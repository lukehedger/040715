(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./source/js/app.coffee":[function(require,module,exports){
require("./module/index");

require("./../../vendor/gsap/src/uncompressed/TweenMax.js");

require("./../../vendor/ractive-events-tap/ractive-events-tap.js");

require("./../../vendor/ractive-touch/index.js");

require("./../../vendor/ractive-transitions-fade/ractive-transitions-fade.js");

require("./../../vendor/ractive-transitions-fly/ractive-transitions-fly.js");

require("./../../vendor/ractive-transitions-slide/ractive-transitions-slide.js");

require('./../../vendor/domready/ready.js')(function() {
  var View;
  if ("development" === "development") {
    require("./app-debug")();
  }
  View = require("./view/main-view");
  return window._view = new View();
});



},{"./../../vendor/domready/ready.js":"/Users/luke/dev/040715/vendor/domready/ready.js","./../../vendor/gsap/src/uncompressed/TweenMax.js":"/Users/luke/dev/040715/vendor/gsap/src/uncompressed/TweenMax.js","./../../vendor/ractive-events-tap/ractive-events-tap.js":"/Users/luke/dev/040715/vendor/ractive-events-tap/ractive-events-tap.js","./../../vendor/ractive-touch/index.js":"/Users/luke/dev/040715/vendor/ractive-touch/index.js","./../../vendor/ractive-transitions-fade/ractive-transitions-fade.js":"/Users/luke/dev/040715/vendor/ractive-transitions-fade/ractive-transitions-fade.js","./../../vendor/ractive-transitions-fly/ractive-transitions-fly.js":"/Users/luke/dev/040715/vendor/ractive-transitions-fly/ractive-transitions-fly.js","./../../vendor/ractive-transitions-slide/ractive-transitions-slide.js":"/Users/luke/dev/040715/vendor/ractive-transitions-slide/ractive-transitions-slide.js","./app-debug":"/Users/luke/dev/040715/source/js/app-debug.coffee","./module/index":"/Users/luke/dev/040715/source/js/module/index.coffee","./view/main-view":"/Users/luke/dev/040715/source/js/view/main-view.coffee"}],"/Users/luke/dev/040715/node_modules/dat-gui/index.js":[function(require,module,exports){
module.exports = require('./vendor/dat.gui')
module.exports.color = require('./vendor/dat.color')
},{"./vendor/dat.color":"/Users/luke/dev/040715/node_modules/dat-gui/vendor/dat.color.js","./vendor/dat.gui":"/Users/luke/dev/040715/node_modules/dat-gui/vendor/dat.gui.js"}],"/Users/luke/dev/040715/node_modules/dat-gui/vendor/dat.color.js":[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.color = dat.color || {};

/** @namespace */
dat.utils = dat.utils || {};

dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.Color = dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common),
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common);
},{}],"/Users/luke/dev/040715/node_modules/dat-gui/vendor/dat.gui.js":[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.gui = dat.gui || {};

/** @namespace */
dat.utils = dat.utils || {};

/** @namespace */
dat.controllers = dat.controllers || {};

/** @namespace */
dat.dom = dat.dom || {};

/** @namespace */
dat.color = dat.color || {};

dat.utils.css = (function () {
  return {
    load: function (url, doc) {
      doc = doc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function(css, doc) {
      doc = doc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = css;
      doc.getElementsByTagName('head')[0].appendChild(injected);
    }
  }
})();


dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.controllers.Controller = (function (common) {

  /**
   * @class An "abstract" class that represents a given property of an object.
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var Controller = function(object, property) {

    this.initialValue = object[property];

    /**
     * Those who extend this class will put their DOM elements in here.
     * @type {DOMElement}
     */
    this.domElement = document.createElement('div');

    /**
     * The object to manipulate
     * @type {Object}
     */
    this.object = object;

    /**
     * The name of the property to manipulate
     * @type {String}
     */
    this.property = property;

    /**
     * The function to be called on change.
     * @type {Function}
     * @ignore
     */
    this.__onChange = undefined;

    /**
     * The function to be called on finishing change.
     * @type {Function}
     * @ignore
     */
    this.__onFinishChange = undefined;

  };

  common.extend(

      Controller.prototype,

      /** @lends dat.controllers.Controller.prototype */
      {

        /**
         * Specify that a function fire every time someone changes the value with
         * this Controller.
         *
         * @param {Function} fnc This function will be called whenever the value
         * is modified via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onChange: function(fnc) {
          this.__onChange = fnc;
          return this;
        },

        /**
         * Specify that a function fire every time someone "finishes" changing
         * the value wih this Controller. Useful for values that change
         * incrementally like numbers or strings.
         *
         * @param {Function} fnc This function will be called whenever
         * someone "finishes" changing the value via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onFinishChange: function(fnc) {
          this.__onFinishChange = fnc;
          return this;
        },

        /**
         * Change the value of <code>object[property]</code>
         *
         * @param {Object} newValue The new value of <code>object[property]</code>
         */
        setValue: function(newValue) {
          this.object[this.property] = newValue;
          if (this.__onChange) {
            this.__onChange.call(this, newValue);
          }
          this.updateDisplay();
          return this;
        },

        /**
         * Gets the value of <code>object[property]</code>
         *
         * @returns {Object} The current value of <code>object[property]</code>
         */
        getValue: function() {
          return this.object[this.property];
        },

        /**
         * Refreshes the visual display of a Controller in order to keep sync
         * with the object's current value.
         * @returns {dat.controllers.Controller} this
         */
        updateDisplay: function() {
          return this;
        },

        /**
         * @returns {Boolean} true if the value has deviated from initialValue
         */
        isModified: function() {
          return this.initialValue !== this.getValue()
        }

      }

  );

  return Controller;


})(dat.utils.common);


dat.dom.dom = (function (common) {

  var EVENT_MAP = {
    'HTMLEvents': ['change'],
    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],
    'KeyboardEvents': ['keydown']
  };

  var EVENT_MAP_INV = {};
  common.each(EVENT_MAP, function(v, k) {
    common.each(v, function(e) {
      EVENT_MAP_INV[e] = k;
    });
  });

  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {

    if (val === '0' || common.isUndefined(val)) return 0;

    var match = val.match(CSS_VALUE_PIXELS);

    if (!common.isNull(match)) {
      return parseFloat(match[1]);
    }

    // TODO ...ems? %?

    return 0;

  }

  /**
   * @namespace
   * @member dat.dom
   */
  var dom = {

    /**
     * 
     * @param elem
     * @param selectable
     */
    makeSelectable: function(elem, selectable) {

      if (elem === undefined || elem.style === undefined) return;

      elem.onselectstart = selectable ? function() {
        return false;
      } : function() {
      };

      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';

    },

    /**
     *
     * @param elem
     * @param horizontal
     * @param vertical
     */
    makeFullscreen: function(elem, horizontal, vertical) {

      if (common.isUndefined(horizontal)) horizontal = true;
      if (common.isUndefined(vertical)) vertical = true;

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }
      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }

    },

    /**
     *
     * @param elem
     * @param eventType
     * @param params
     */
    fakeEvent: function(elem, eventType, params, aux) {
      params = params || {};
      var className = EVENT_MAP_INV[eventType];
      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }
      var evt = document.createEvent(className);
      switch (className) {
        case 'MouseEvents':
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false,
              params.cancelable || true, window, params.clickCount || 1,
              0, //screen X
              0, //screen Y
              clientX, //client X
              clientY, //client Y
              false, false, false, false, 0, null);
          break;
        case 'KeyboardEvents':
          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
          common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false,
              params.cancelable, window,
              params.ctrlKey, params.altKey,
              params.shiftKey, params.metaKey,
              params.keyCode, params.charCode);
          break;
        default:
          evt.initEvent(eventType, params.bubbles || false,
              params.cancelable || true);
          break;
      }
      common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    bind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.addEventListener)
        elem.addEventListener(event, func, bool);
      else if (elem.attachEvent)
        elem.attachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    unbind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.removeEventListener)
        elem.removeEventListener(event, func, bool);
      else if (elem.detachEvent)
        elem.detachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    addClass: function(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);
        if (classes.indexOf(className) == -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    removeClass: function(elem, className) {
      if (className) {
        if (elem.className === undefined) {
          // elem.className = className;
        } else if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);
          if (index != -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }
      return dom;
    },

    hasClass: function(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },

    /**
     *
     * @param elem
     */
    getWidth: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-left-width']) +
          cssValueToPixels(style['border-right-width']) +
          cssValueToPixels(style['padding-left']) +
          cssValueToPixels(style['padding-right']) +
          cssValueToPixels(style['width']);
    },

    /**
     *
     * @param elem
     */
    getHeight: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-top-width']) +
          cssValueToPixels(style['border-bottom-width']) +
          cssValueToPixels(style['padding-top']) +
          cssValueToPixels(style['padding-bottom']) +
          cssValueToPixels(style['height']);
    },

    /**
     *
     * @param elem
     */
    getOffset: function(elem) {
      var offset = {left: 0, top:0};
      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
        } while (elem = elem.offsetParent);
      }
      return offset;
    },

    // http://stackoverflow.com/posts/2684561/revisions
    /**
     * 
     * @param elem
     */
    isActive: function(elem) {
      return elem === document.activeElement && ( elem.type || elem.href );
    }

  };

  return dom;

})(dat.utils.common);


dat.controllers.OptionController = (function (Controller, dom, common) {

  /**
   * @class Provides a select input to alter the property of an object, using a
   * list of accepted values.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object|string[]} options A map of labels to acceptable values, or
   * a list of acceptable string values.
   *
   * @member dat.controllers
   */
  var OptionController = function(object, property, options) {

    OptionController.superclass.call(this, object, property);

    var _this = this;

    /**
     * The drop down menu
     * @ignore
     */
    this.__select = document.createElement('select');

    if (common.isArray(options)) {
      var map = {};
      common.each(options, function(element) {
        map[element] = element;
      });
      options = map;
    }

    common.each(options, function(value, key) {

      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);

    });

    // Acknowledge original value
    this.updateDisplay();

    dom.bind(this.__select, 'change', function() {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });

    this.domElement.appendChild(this.__select);

  };

  OptionController.superclass = Controller;

  common.extend(

      OptionController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          return toReturn;
        },

        updateDisplay: function() {
          this.__select.value = this.getValue();
          return OptionController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return OptionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberController = (function (Controller, common) {

  /**
   * @class Represents a given property of an object that is a number.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberController = function(object, property, params) {

    NumberController.superclass.call(this, object, property);

    params = params || {};

    this.__min = params.min;
    this.__max = params.max;
    this.__step = params.step;

    if (common.isUndefined(this.__step)) {

      if (this.initialValue == 0) {
        this.__impliedStep = 1; // What are we, psychics?
      } else {
        // Hey Doug, check this out.
        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;
      }

    } else {

      this.__impliedStep = this.__step;

    }

    this.__precision = numDecimals(this.__impliedStep);


  };

  NumberController.superclass = Controller;

  common.extend(

      NumberController.prototype,
      Controller.prototype,

      /** @lends dat.controllers.NumberController.prototype */
      {

        setValue: function(v) {

          if (this.__min !== undefined && v < this.__min) {
            v = this.__min;
          } else if (this.__max !== undefined && v > this.__max) {
            v = this.__max;
          }

          if (this.__step !== undefined && v % this.__step != 0) {
            v = Math.round(v / this.__step) * this.__step;
          }

          return NumberController.superclass.prototype.setValue.call(this, v);

        },

        /**
         * Specify a minimum value for <code>object[property]</code>.
         *
         * @param {Number} minValue The minimum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        min: function(v) {
          this.__min = v;
          return this;
        },

        /**
         * Specify a maximum value for <code>object[property]</code>.
         *
         * @param {Number} maxValue The maximum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        max: function(v) {
          this.__max = v;
          return this;
        },

        /**
         * Specify a step value that dat.controllers.NumberController
         * increments by.
         *
         * @param {Number} stepValue The step value for
         * dat.controllers.NumberController
         * @default if minimum and maximum specified increment is 1% of the
         * difference otherwise stepValue is 1
         * @returns {dat.controllers.NumberController} this
         */
        step: function(v) {
          this.__step = v;
          return this;
        }

      }

  );

  function numDecimals(x) {
    x = x.toString();
    if (x.indexOf('.') > -1) {
      return x.length - x.indexOf('.') - 1;
    } else {
      return 0;
    }
  }

  return NumberController;

})(dat.controllers.Controller,
dat.utils.common);


dat.controllers.NumberControllerBox = (function (NumberController, dom, common) {

  /**
   * @class Represents a given property of an object that is a number and
   * provides an input element with which to manipulate it.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerBox = function(object, property, params) {

    this.__truncationSuspended = false;

    NumberControllerBox.superclass.call(this, object, property, params);

    var _this = this;

    /**
     * {Number} Previous mouse y position
     * @ignore
     */
    var prev_y;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    // Makes it so manually specified values are not truncated.

    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'mousedown', onMouseDown);
    dom.bind(this.__input, 'keydown', function(e) {

      // When pressing entire, you can be as precise as you want.
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
      }

    });

    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!common.isNaN(attempted)) _this.setValue(attempted);
    }

    function onBlur() {
      onChange();
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prev_y = e.clientY;
    }

    function onMouseDrag(e) {

      var diff = prev_y - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);

      prev_y = e.clientY;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  NumberControllerBox.superclass = NumberController;

  common.extend(

      NumberControllerBox.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {

          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  return NumberControllerBox;

})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {

  /**
   * @class Represents a given property of an object that is a number, contains
   * a minimum and maximum, and provides a slider element with which to
   * manipulate it. It should be noted that the slider element is made up of
   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
   * <code>&lt;slider&gt;</code> element.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   * 
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Number} minValue Minimum allowed value
   * @param {Number} maxValue Maximum allowed value
   * @param {Number} stepValue Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerSlider = function(object, property, min, max, step) {

    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });

    var _this = this;

    this.__background = document.createElement('div');
    this.__foreground = document.createElement('div');
    


    dom.bind(this.__background, 'mousedown', onMouseDown);
    
    dom.addClass(this.__background, 'slider');
    dom.addClass(this.__foreground, 'slider-fg');

    function onMouseDown(e) {

      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);

      onMouseDrag(e);
    }

    function onMouseDrag(e) {

      e.preventDefault();

      var offset = dom.getOffset(_this.__background);
      var width = dom.getWidth(_this.__background);
      
      _this.setValue(
        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)
      );

      return false;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.__background.appendChild(this.__foreground);
    this.domElement.appendChild(this.__background);

  };

  NumberControllerSlider.superclass = NumberController;

  /**
   * Injects default stylesheet for slider elements.
   */
  NumberControllerSlider.useDefaultStyles = function() {
    css.inject(styleSheet);
  };

  common.extend(

      NumberControllerSlider.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {
          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);
          this.__foreground.style.width = pct*100+'%';
          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);
        }

      }



  );

  function map(v, i1, i2, o1, o2) {
    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
  }

  return NumberControllerSlider;
  
})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.css,
dat.utils.common,
".slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");


dat.controllers.FunctionController = (function (Controller, dom, common) {

  /**
   * @class Provides a GUI interface to fire a specified method, a property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var FunctionController = function(object, property, text) {

    FunctionController.superclass.call(this, object, property);

    var _this = this;

    this.__button = document.createElement('div');
    this.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(this.__button, 'click', function(e) {
      e.preventDefault();
      _this.fire();
      return false;
    });

    dom.addClass(this.__button, 'button');

    this.domElement.appendChild(this.__button);


  };

  FunctionController.superclass = Controller;

  common.extend(

      FunctionController.prototype,
      Controller.prototype,
      {
        
        fire: function() {
          if (this.__onChange) {
            this.__onChange.call(this);
          }
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.getValue().call(this.object);
        }
      }

  );

  return FunctionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.BooleanController = (function (Controller, dom, common) {

  /**
   * @class Provides a checkbox input to alter the boolean property of an object.
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var BooleanController = function(object, property) {

    BooleanController.superclass.call(this, object, property);

    var _this = this;
    this.__prev = this.getValue();

    this.__checkbox = document.createElement('input');
    this.__checkbox.setAttribute('type', 'checkbox');


    dom.bind(this.__checkbox, 'change', onChange, false);

    this.domElement.appendChild(this.__checkbox);

    // Match original value
    this.updateDisplay();

    function onChange() {
      _this.setValue(!_this.__prev);
    }

  };

  BooleanController.superclass = Controller;

  common.extend(

      BooleanController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.__prev = this.getValue();
          return toReturn;
        },

        updateDisplay: function() {
          
          if (this.getValue() === true) {
            this.__checkbox.setAttribute('checked', 'checked');
            this.__checkbox.checked = true;    
          } else {
              this.__checkbox.checked = false;
          }

          return BooleanController.superclass.prototype.updateDisplay.call(this);

        }


      }

  );

  return BooleanController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common);


dat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {

  css.inject(styleSheet);

  /** Outer-most className for GUI's */
  var CSS_NAMESPACE = 'dg';

  var HIDE_KEY_CODE = 72;

  /** The only value shared between the JS and SCSS. Use caution. */
  var CLOSE_BUTTON_HEIGHT = 20;

  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = (function() {
    try {
      return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
      return false;
    }
  })();

  var SAVE_DIALOGUE;

  /** Have we yet to create an autoPlace GUI? */
  var auto_place_virgin = true;

  /** Fixed position div that auto place GUI's go inside */
  var auto_place_container;

  /** Are we hiding the GUI's ? */
  var hide = false;

  /** GUI's which should be hidden */
  var hideable_guis = [];

  /**
   * A lightweight controller library for JavaScript. It allows you to easily
   * manipulate variables and fire functions on the fly.
   * @class
   *
   * @member dat.gui
   *
   * @param {Object} [params]
   * @param {String} [params.name] The name of this GUI.
   * @param {Object} [params.load] JSON object representing the saved state of
   * this GUI.
   * @param {Boolean} [params.auto=true]
   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
   * @param {Boolean} [params.closed] If true, starts closed
   */
  var GUI = function(params) {

    var _this = this;

    /**
     * Outermost DOM Element
     * @type DOMElement
     */
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);

    dom.addClass(this.domElement, CSS_NAMESPACE);

    /**
     * Nested GUI's by name
     * @ignore
     */
    this.__folders = {};

    this.__controllers = [];

    /**
     * List of objects I'm remembering for save, only used in top level GUI
     * @ignore
     */
    this.__rememberedObjects = [];

    /**
     * Maps the index of remembered objects to a map of controllers, only used
     * in top level GUI.
     *
     * @private
     * @ignore
     *
     * @example
     * [
     *  {
     *    propertyName: Controller,
     *    anotherPropertyName: Controller
     *  },
     *  {
     *    propertyName: Controller
     *  }
     * ]
     */
    this.__rememberedObjectIndecesToControllers = [];

    this.__listening = [];

    params = params || {};

    // Default parameters
    params = common.defaults(params, {
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });

    params = common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });


    if (!common.isUndefined(params.load)) {

      // Explicit preset
      if (params.preset) params.load.preset = params.preset;

    } else {

      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };

    }

    if (common.isUndefined(params.parent) && params.hideable) {
      hideable_guis.push(this);
    }

    // Only root level GUI's are resizable.
    params.resizable = common.isUndefined(params.parent) && params.resizable;


    if (params.autoPlace && common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }
//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;

    // Not part of params because I don't want people passing this in via
    // constructor. Should be a 'remembered' value.
    var use_local_storage =
        SUPPORTS_LOCAL_STORAGE &&
            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';

    Object.defineProperties(this,

        /** @lends dat.gui.GUI.prototype */
        {

          /**
           * The parent <code>GUI</code>
           * @type dat.gui.GUI
           */
          parent: {
            get: function() {
              return params.parent;
            }
          },

          scrollable: {
            get: function() {
              return params.scrollable;
            }
          },

          /**
           * Handles <code>GUI</code>'s element placement for you
           * @type Boolean
           */
          autoPlace: {
            get: function() {
              return params.autoPlace;
            }
          },

          /**
           * The identifier for a set of saved values
           * @type String
           */
          preset: {

            get: function() {
              if (_this.parent) {
                return _this.getRoot().preset;
              } else {
                return params.load.preset;
              }
            },

            set: function(v) {
              if (_this.parent) {
                _this.getRoot().preset = v;
              } else {
                params.load.preset = v;
              }
              setPresetSelectIndex(this);
              _this.revert();
            }

          },

          /**
           * The width of <code>GUI</code> element
           * @type Number
           */
          width: {
            get: function() {
              return params.width;
            },
            set: function(v) {
              params.width = v;
              setWidth(_this, v);
            }
          },

          /**
           * The name of <code>GUI</code>. Used for folders. i.e
           * a folder's name
           * @type String
           */
          name: {
            get: function() {
              return params.name;
            },
            set: function(v) {
              // TODO Check for collisions among sibling folders
              params.name = v;
              if (title_row_name) {
                title_row_name.innerHTML = params.name;
              }
            }
          },

          /**
           * Whether the <code>GUI</code> is collapsed or not
           * @type Boolean
           */
          closed: {
            get: function() {
              return params.closed;
            },
            set: function(v) {
              params.closed = v;
              if (params.closed) {
                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
              } else {
                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
              }
              // For browsers that aren't going to respect the CSS transition,
              // Lets just check our height against the window height right off
              // the bat.
              this.onResize();

              if (_this.__closeButton) {
                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
              }
            }
          },

          /**
           * Contains all presets
           * @type Object
           */
          load: {
            get: function() {
              return params.load;
            }
          },

          /**
           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
           * <code>remember</code>ing
           * @type Boolean
           */
          useLocalStorage: {

            get: function() {
              return use_local_storage;
            },
            set: function(bool) {
              if (SUPPORTS_LOCAL_STORAGE) {
                use_local_storage = bool;
                if (bool) {
                  dom.bind(window, 'unload', saveToLocalStorage);
                } else {
                  dom.unbind(window, 'unload', saveToLocalStorage);
                }
                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
              }
            }

          }

        });

    // Are we a root level GUI?
    if (common.isUndefined(params.parent)) {

      params.closed = false;

      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      // Are we supposed to be loading locally?
      if (SUPPORTS_LOCAL_STORAGE) {

        if (use_local_storage) {

          _this.useLocalStorage = true;

          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (saved_gui) {
            params.load = JSON.parse(saved_gui);
          }

        }

      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
      this.domElement.appendChild(this.__closeButton);

      dom.bind(this.__closeButton, 'click', function() {

        _this.closed = !_this.closed;


      });


      // Oh, you're a nested GUI!
    } else {

      if (params.closed === undefined) {
        params.closed = true;
      }

      var title_row_name = document.createTextNode(params.name);
      dom.addClass(title_row_name, 'controller-name');

      var title_row = addRow(_this, title_row_name);

      var on_click_title = function(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);

      dom.addClass(title_row, 'title');
      dom.bind(title_row, 'click', on_click_title);

      if (!params.closed) {
        this.closed = false;
      }

    }

    if (params.autoPlace) {

      if (common.isUndefined(params.parent)) {

        if (auto_place_virgin) {
          auto_place_container = document.createElement('div');
          dom.addClass(auto_place_container, CSS_NAMESPACE);
          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(auto_place_container);
          auto_place_virgin = false;
        }

        // Put it in the dom for you.
        auto_place_container.appendChild(this.domElement);

        // Apply the auto styles
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);

      }


      // Make it not elastic.
      if (!this.parent) setWidth(_this, params.width);

    }

    dom.bind(window, 'resize', function() { _this.onResize() });
    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });
    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });
    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });
    this.onResize();


    if (params.resizable) {
      addResizeHandle(this);
    }

    function saveToLocalStorage() {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }

    var root = _this.getRoot();
    function resetWidth() {
        var root = _this.getRoot();
        root.width += 1;
        common.defer(function() {
          root.width -= 1;
        });
      }

      if (!params.parent) {
        resetWidth();
      }

  };

  GUI.toggleHide = function() {

    hide = !hide;
    common.each(hideable_guis, function(gui) {
      gui.domElement.style.zIndex = hide ? -999 : 999;
      gui.domElement.style.opacity = hide ? 0 : 1;
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_DRAG = 'drag';

  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  dom.bind(window, 'keydown', function(e) {

    if (document.activeElement.type !== 'text' &&
        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }

  }, false);

  common.extend(

      GUI.prototype,

      /** @lends dat.gui.GUI */
      {

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.Controller} The new controller that was added.
         * @instance
         */
        add: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
              }
          );

        },

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.ColorController} The new controller that was added.
         * @instance
         */
        addColor: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                color: true
              }
          );

        },

        /**
         * @param controller
         * @instance
         */
        remove: function(controller) {

          // TODO listening?
          this.__ul.removeChild(controller.__li);
          this.__controllers.slice(this.__controllers.indexOf(controller), 1);
          var _this = this;
          common.defer(function() {
            _this.onResize();
          });

        },

        destroy: function() {

          if (this.autoPlace) {
            auto_place_container.removeChild(this.domElement);
          }

        },

        /**
         * @param name
         * @returns {dat.gui.GUI} The new folder.
         * @throws {Error} if this GUI already has a folder by the specified
         * name
         * @instance
         */
        addFolder: function(name) {

          // We have to prevent collisions on names in order to have a key
          // by which to remember saved values
          if (this.__folders[name] !== undefined) {
            throw new Error('You already have a folder in this GUI by the' +
                ' name "' + name + '"');
          }

          var new_gui_params = { name: name, parent: this };

          // We need to pass down the autoPlace trait so that we can
          // attach event listeners to open/close folder actions to
          // ensure that a scrollbar appears if the window is too short.
          new_gui_params.autoPlace = this.autoPlace;

          // Do we have saved appearance data for this folder?

          if (this.load && // Anything loaded?
              this.load.folders && // Was my parent a dead-end?
              this.load.folders[name]) { // Did daddy remember me?

            // Start me closed if I was closed
            new_gui_params.closed = this.load.folders[name].closed;

            // Pass down the loaded data
            new_gui_params.load = this.load.folders[name];

          }

          var gui = new GUI(new_gui_params);
          this.__folders[name] = gui;

          var li = addRow(this, gui.domElement);
          dom.addClass(li, 'folder');
          return gui;

        },

        open: function() {
          this.closed = false;
        },

        close: function() {
          this.closed = true;
        },

        onResize: function() {

          var root = this.getRoot();

          if (root.scrollable) {

            var top = dom.getOffset(root.__ul).top;
            var h = 0;

            common.each(root.__ul.childNodes, function(node) {
              if (! (root.autoPlace && node === root.__save_row))
                h += dom.getHeight(node);
            });

            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
            } else {
              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = 'auto';
            }

          }

          if (root.__resize_handle) {
            common.defer(function() {
              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
            });
          }

          if (root.__closeButton) {
            root.__closeButton.style.width = root.width + 'px';
          }

        },

        /**
         * Mark objects for saving. The order of these objects cannot change as
         * the GUI grows. When remembering new objects, append them to the end
         * of the list.
         *
         * @param {Object...} objects
         * @throws {Error} if not called on a top level GUI.
         * @instance
         */
        remember: function() {

          if (common.isUndefined(SAVE_DIALOGUE)) {
            SAVE_DIALOGUE = new CenteredDiv();
            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;
          }

          if (this.parent) {
            throw new Error("You can only call remember on a top level GUI.");
          }

          var _this = this;

          common.each(Array.prototype.slice.call(arguments), function(object) {
            if (_this.__rememberedObjects.length == 0) {
              addSaveMenu(_this);
            }
            if (_this.__rememberedObjects.indexOf(object) == -1) {
              _this.__rememberedObjects.push(object);
            }
          });

          if (this.autoPlace) {
            // Set save row width
            setWidth(this, this.width);
          }

        },

        /**
         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
         * @instance
         */
        getRoot: function() {
          var gui = this;
          while (gui.parent) {
            gui = gui.parent;
          }
          return gui;
        },

        /**
         * @returns {Object} a JSON object representing the current state of
         * this GUI as well as its remembered properties.
         * @instance
         */
        getSaveObject: function() {

          var toReturn = this.load;

          toReturn.closed = this.closed;

          // Am I remembering any values?
          if (this.__rememberedObjects.length > 0) {

            toReturn.preset = this.preset;

            if (!toReturn.remembered) {
              toReturn.remembered = {};
            }

            toReturn.remembered[this.preset] = getCurrentPreset(this);

          }

          toReturn.folders = {};
          common.each(this.__folders, function(element, key) {
            toReturn.folders[key] = element.getSaveObject();
          });

          return toReturn;

        },

        save: function() {

          if (!this.load.remembered) {
            this.load.remembered = {};
          }

          this.load.remembered[this.preset] = getCurrentPreset(this);
          markPresetModified(this, false);

        },

        saveAs: function(presetName) {

          if (!this.load.remembered) {

            // Retain default values upon first save
            this.load.remembered = {};
            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);

          }

          this.load.remembered[presetName] = getCurrentPreset(this);
          this.preset = presetName;
          addPresetOption(this, presetName, true);

        },

        revert: function(gui) {

          common.each(this.__controllers, function(controller) {
            // Make revert work on Default.
            if (!this.getRoot().load.remembered) {
              controller.setValue(controller.initialValue);
            } else {
              recallSavedValue(gui || this.getRoot(), controller);
            }
          }, this);

          common.each(this.__folders, function(folder) {
            folder.revert(folder);
          });

          if (!gui) {
            markPresetModified(this.getRoot(), false);
          }


        },

        listen: function(controller) {

          var init = this.__listening.length == 0;
          this.__listening.push(controller);
          if (init) updateDisplays(this.__listening);

        }

      }

  );

  function add(gui, object, property, params) {

    if (object[property] === undefined) {
      throw new Error("Object " + object + " has no property \"" + property + "\"");
    }

    var controller;

    if (params.color) {

      controller = new ColorController(object, property);

    } else {

      var factoryArgs = [object,property].concat(params.factoryArgs);
      controller = controllerFactory.apply(gui, factoryArgs);

    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);

    dom.addClass(controller.domElement, 'c');

    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;

    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);

    var li = addRow(gui, container, params.before);

    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
    dom.addClass(li, typeof controller.getValue());

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;

  }

  /**
   * Add a row to the end of the GUI or before another row.
   *
   * @param gui
   * @param [dom] If specified, inserts the dom content in the new row
   * @param [liBefore] If specified, places the new row before another row
   */
  function addRow(gui, dom, liBefore) {
    var li = document.createElement('li');
    if (dom) li.appendChild(dom);
    if (liBefore) {
      gui.__ul.insertBefore(li, params.before);
    } else {
      gui.__ul.appendChild(li);
    }
    gui.onResize();
    return li;
  }

  function augmentController(gui, li, controller) {

    controller.__li = li;
    controller.__gui = gui;

    common.extend(controller, {

      options: function(options) {

        if (arguments.length > 1) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [common.toArray(arguments)]
              }
          );

        }

        if (common.isArray(options) || common.isObject(options)) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [options]
              }
          );

        }

      },

      name: function(v) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = v;
        return controller;
      },

      listen: function() {
        controller.__gui.listen(controller);
        return controller;
      },

      remove: function() {
        controller.__gui.remove(controller);
        return controller;
      }

    });

    // All sliders should be accompanied by a box.
    if (controller instanceof NumberControllerSlider) {

      var box = new NumberControllerBox(controller.object, controller.property,
          { min: controller.__min, max: controller.__max, step: controller.__step });

      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {
        var pc = controller[method];
        var pb = box[method];
        controller[method] = box[method] = function() {
          var args = Array.prototype.slice.call(arguments);
          pc.apply(controller, args);
          return pb.apply(box, args);
        }
      });

      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);

    }
    else if (controller instanceof NumberControllerBox) {

      var r = function(returned) {

        // Have we defined both boundaries?
        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {

          // Well, then lets just replace this with a slider.
          controller.remove();
          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [controller.__min, controller.__max, controller.__step]
              });

        }

        return returned;

      };

      controller.min = common.compose(r, controller.min);
      controller.max = common.compose(r, controller.max);

    }
    else if (controller instanceof BooleanController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__checkbox, 'click');
      });

      dom.bind(controller.__checkbox, 'click', function(e) {
        e.stopPropagation(); // Prevents double-toggle
      })

    }
    else if (controller instanceof FunctionController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__button, 'click');
      });

      dom.bind(li, 'mouseover', function() {
        dom.addClass(controller.__button, 'hover');
      });

      dom.bind(li, 'mouseout', function() {
        dom.removeClass(controller.__button, 'hover');
      });

    }
    else if (controller instanceof ColorController) {

      dom.addClass(li, 'color');
      controller.updateDisplay = common.compose(function(r) {
        li.style.borderLeftColor = controller.__color.toString();
        return r;
      }, controller.updateDisplay);

      controller.updateDisplay();

    }

    controller.setValue = common.compose(function(r) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }
      return r;
    }, controller.setValue);

  }

  function recallSavedValue(gui, controller) {

    // Find the topmost GUI, that's where remembered objects live.
    var root = gui.getRoot();

    // Does the object we're controlling match anything we've been told to
    // remember?
    var matched_index = root.__rememberedObjects.indexOf(controller.object);

    // Why yes, it does!
    if (matched_index != -1) {

      // Let me fetch a map of controllers for thcommon.isObject.
      var controller_map =
          root.__rememberedObjectIndecesToControllers[matched_index];

      // Ohp, I believe this is the first controller we've created for this
      // object. Lets make the map fresh.
      if (controller_map === undefined) {
        controller_map = {};
        root.__rememberedObjectIndecesToControllers[matched_index] =
            controller_map;
      }

      // Keep track of this controller
      controller_map[controller.property] = controller;

      // Okay, now have we saved any values for this controller?
      if (root.load && root.load.remembered) {

        var preset_map = root.load.remembered;

        // Which preset are we trying to load?
        var preset;

        if (preset_map[gui.preset]) {

          preset = preset_map[gui.preset];

        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {

          // Uhh, you can have the default instead?
          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];

        } else {

          // Nada.

          return;

        }


        // Did the loaded object remember thcommon.isObject?
        if (preset[matched_index] &&

          // Did we remember this particular property?
            preset[matched_index][controller.property] !== undefined) {

          // We did remember something for this guy ...
          var value = preset[matched_index][controller.property];

          // And that's what it is.
          controller.initialValue = value;
          controller.setValue(value);

        }

      }

    }

  }

  function getLocalStorageHash(gui, key) {
    // TODO how does this deal with multiple GUI's?
    return document.location.href + '.' + key;

  }

  function addSaveMenu(gui) {

    var div = gui.__save_row = document.createElement('li');

    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');

    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');

    // TODO replace with FunctionController
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');

    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');

    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');

    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {

      common.each(gui.load.remembered, function(value, key) {
        addPresetOption(gui, key, key == gui.preset);
      });

    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function() {


      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;

    });

    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {

      var saveLocally = document.getElementById('dg-save-locally');
      var explain = document.getElementById('dg-local-explain');

      saveLocally.style.display = 'block';

      var localStorageCheckBox = document.getElementById('dg-local-storage');

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      function showHideExplain() {
        explain.style.display = gui.useLocalStorage ? 'block' : 'none';
      }

      showHideExplain();

      // TODO: Use a boolean controller, fool!
      dom.bind(localStorageCheckBox, 'change', function() {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain();
      });

    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');

    dom.bind(newConstructorTextArea, 'keydown', function(e) {
      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {
        SAVE_DIALOGUE.hide();
      }
    });

    dom.bind(gears, 'click', function() {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });

    dom.bind(button, 'click', function() {
      gui.save();
    });

    dom.bind(button2, 'click', function() {
      var presetName = prompt('Enter a new preset name.');
      if (presetName) gui.saveAs(presetName);
    });

    dom.bind(button3, 'click', function() {
      gui.revert();
    });

//    div.appendChild(button2);

  }

  function addResizeHandle(gui) {

    gui.__resize_handle = document.createElement('div');

    common.extend(gui.__resize_handle.style, {

      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
//      border: '1px solid blue'

    });

    var pmouseX;

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);

    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);

    function dragStart(e) {

      e.preventDefault();

      pmouseX = e.clientX;

      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);

      return false;

    }

    function drag(e) {

      e.preventDefault();

      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;

      return false;

    }

    function dragStop() {

      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);

    }

  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';
    // Auto placed save-rows are position fixed, so we have to
    // set the width manually if we want it to bleed to the edge
    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {

    var toReturn = {};

    // For each object I'm remembering
    common.each(gui.__rememberedObjects, function(val, index) {

      var saved_values = {};

      // The controllers I've made for thcommon.isObject by property
      var controller_map =
          gui.__rememberedObjectIndecesToControllers[index];

      // Remember each value for each property
      common.each(controller_map, function(controller, property) {
        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });

      // Save the values for thcommon.isObject
      toReturn[index] = saved_values;

    });

    return toReturn;

  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;
    gui.__preset_select.appendChild(opt);
    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value == gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
//    console.log('mark', modified, opt);
    if (modified) {
      opt.innerHTML = opt.value + "*";
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function updateDisplays(controllerArray) {


    if (controllerArray.length != 0) {

      requestAnimationFrame(function() {
        updateDisplays(controllerArray);
      });

    }

    common.each(controllerArray, function(c) {
      c.updateDisplay();
    });

  }

  return GUI;

})(dat.utils.css,
"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",
".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
dat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {

      return function(object, property) {

        var initialValue = object[property];

        // Providing options?
        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {
          return new OptionController(object, property, arguments[2]);
        }

        // Providing a map?

        if (common.isNumber(initialValue)) {

          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {

            // Has min and max.
            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);

          } else {

            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });

          }

        }

        if (common.isString(initialValue)) {
          return new StringController(object, property);
        }

        if (common.isFunction(initialValue)) {
          return new FunctionController(object, property, '');
        }

        if (common.isBoolean(initialValue)) {
          return new BooleanController(object, property);
        }

      }

    })(dat.controllers.OptionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.StringController = (function (Controller, dom, common) {

  /**
   * @class Provides a text input to alter the string property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var StringController = function(object, property) {

    StringController.superclass.call(this, object, property);

    var _this = this;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    dom.bind(this.__input, 'keyup', onChange);
    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    

    function onChange() {
      _this.setValue(_this.__input.value);
    }

    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  StringController.superclass = Controller;

  common.extend(

      StringController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {
          // Stops the caret from moving on account of:
          // keyup -> setValue -> updateDisplay
          if (!dom.isActive(this.__input)) {
            this.__input.value = this.getValue();
          }
          return StringController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return StringController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common),
dat.controllers.FunctionController,
dat.controllers.BooleanController,
dat.utils.common),
dat.controllers.Controller,
dat.controllers.BooleanController,
dat.controllers.FunctionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.OptionController,
dat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {

  var ColorController = function(object, property) {

    ColorController.superclass.call(this, object, property);

    this.__color = new Color(this.getValue());
    this.__temp = new Color(0);

    var _this = this;

    this.domElement = document.createElement('div');

    dom.makeSelectable(this.domElement, false);

    this.__selector = document.createElement('div');
    this.__selector.className = 'selector';

    this.__saturation_field = document.createElement('div');
    this.__saturation_field.className = 'saturation-field';

    this.__field_knob = document.createElement('div');
    this.__field_knob.className = 'field-knob';
    this.__field_knob_border = '2px solid ';

    this.__hue_knob = document.createElement('div');
    this.__hue_knob.className = 'hue-knob';

    this.__hue_field = document.createElement('div');
    this.__hue_field.className = 'hue-field';

    this.__input = document.createElement('input');
    this.__input.type = 'text';
    this.__input_textShadow = '0 1px 1px ';

    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) { // on enter
        onBlur.call(this);
      }
    });

    dom.bind(this.__input, 'blur', onBlur);

    dom.bind(this.__selector, 'mousedown', function(e) {

      dom
        .addClass(this, 'drag')
        .bind(window, 'mouseup', function(e) {
          dom.removeClass(_this.__selector, 'drag');
        });

    });

    var value_field = document.createElement('div');

    common.extend(this.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });

    common.extend(this.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    
    common.extend(this.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });

    common.extend(this.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });

    common.extend(value_field.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    
    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');

    common.extend(this.__hue_field.style, {
      width: '15px',
      height: '100px',
      display: 'inline-block',
      border: '1px solid #555',
      cursor: 'ns-resize'
    });

    hueGradient(this.__hue_field);

    common.extend(this.__input.style, {
      outline: 'none',
//      width: '120px',
      textAlign: 'center',
//      padding: '4px',
//      marginBottom: '6px',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'
    });

    dom.bind(this.__saturation_field, 'mousedown', fieldDown);
    dom.bind(this.__field_knob, 'mousedown', fieldDown);

    dom.bind(this.__hue_field, 'mousedown', function(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'mouseup', unbindH);
    });

    function fieldDown(e) {
      setSV(e);
      // document.body.style.cursor = 'none';
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'mouseup', unbindSV);
    }

    function unbindSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'mouseup', unbindSV);
      // document.body.style.cursor = 'default';
    }

    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }

    function unbindH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'mouseup', unbindH);
    }

    this.__saturation_field.appendChild(value_field);
    this.__selector.appendChild(this.__field_knob);
    this.__selector.appendChild(this.__saturation_field);
    this.__selector.appendChild(this.__hue_field);
    this.__hue_field.appendChild(this.__hue_knob);

    this.domElement.appendChild(this.__input);
    this.domElement.appendChild(this.__selector);

    this.updateDisplay();

    function setSV(e) {

      e.preventDefault();

      var w = dom.getWidth(_this.__saturation_field);
      var o = dom.getOffset(_this.__saturation_field);
      var s = (e.clientX - o.left + document.body.scrollLeft) / w;
      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;

      if (v > 1) v = 1;
      else if (v < 0) v = 0;

      if (s > 1) s = 1;
      else if (s < 0) s = 0;

      _this.__color.v = v;
      _this.__color.s = s;

      _this.setValue(_this.__color.toOriginal());


      return false;

    }

    function setH(e) {

      e.preventDefault();

      var s = dom.getHeight(_this.__hue_field);
      var o = dom.getOffset(_this.__hue_field);
      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;

      if (h > 1) h = 1;
      else if (h < 0) h = 0;

      _this.__color.h = h * 360;

      _this.setValue(_this.__color.toOriginal());

      return false;

    }

  };

  ColorController.superclass = Controller;

  common.extend(

      ColorController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {

          var i = interpret(this.getValue());

          if (i !== false) {

            var mismatch = false;

            // Check for mismatch on the interpreted value.

            common.each(Color.COMPONENTS, function(component) {
              if (!common.isUndefined(i[component]) &&
                  !common.isUndefined(this.__color.__state[component]) &&
                  i[component] !== this.__color.__state[component]) {
                mismatch = true;
                return {}; // break
              }
            }, this);

            // If nothing diverges, we keep our previous values
            // for statefulness, otherwise we recalculate fresh
            if (mismatch) {
              common.extend(this.__color.__state, i);
            }

          }

          common.extend(this.__temp.__state, this.__color.__state);

          this.__temp.a = 1;

          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;
          var _flip = 255 - flip;

          common.extend(this.__field_knob.style, {
            marginLeft: 100 * this.__color.s - 7 + 'px',
            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
            backgroundColor: this.__temp.toString(),
            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'
          });

          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'

          this.__temp.s = 1;
          this.__temp.v = 1;

          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());

          common.extend(this.__input.style, {
            backgroundColor: this.__input.value = this.__color.toString(),
            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',
            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'
          });

        }

      }

  );
  
  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];
  
  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    common.each(vendors, function(vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';
    });
  }
  
  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  }


  return ColorController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret,
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common),
dat.color.interpret,
dat.utils.common),
dat.utils.requestAnimationFrame = (function () {

  /**
   * requirejs version of Paul Irish's RequestAnimationFrame
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   */

  return window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback, element) {

        window.setTimeout(callback, 1000 / 60);

      };
})(),
dat.dom.CenteredDiv = (function (dom, common) {


  var CenteredDiv = function() {

    this.backgroundElement = document.createElement('div');
    common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear'
    });

    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';

    this.domElement = document.createElement('div');
    common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'
    });


    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);

    var _this = this;
    dom.bind(this.backgroundElement, 'click', function() {
      _this.hide();
    });


  };

  CenteredDiv.prototype.show = function() {

    var _this = this;
    


    this.backgroundElement.style.display = 'block';

    this.domElement.style.display = 'block';
    this.domElement.style.opacity = 0;
//    this.domElement.style.top = '52%';
    this.domElement.style.webkitTransform = 'scale(1.1)';

    this.layout();

    common.defer(function() {
      _this.backgroundElement.style.opacity = 1;
      _this.domElement.style.opacity = 1;
      _this.domElement.style.webkitTransform = 'scale(1)';
    });

  };

  CenteredDiv.prototype.hide = function() {

    var _this = this;

    var hide = function() {

      _this.domElement.style.display = 'none';
      _this.backgroundElement.style.display = 'none';

      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
      dom.unbind(_this.domElement, 'transitionend', hide);
      dom.unbind(_this.domElement, 'oTransitionEnd', hide);

    };

    dom.bind(this.domElement, 'webkitTransitionEnd', hide);
    dom.bind(this.domElement, 'transitionend', hide);
    dom.bind(this.domElement, 'oTransitionEnd', hide);

    this.backgroundElement.style.opacity = 0;
//    this.domElement.style.top = '48%';
    this.domElement.style.opacity = 0;
    this.domElement.style.webkitTransform = 'scale(1.1)';

  };

  CenteredDiv.prototype.layout = function() {
    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';
    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';
  };
  
  function lockScroll(e) {
    console.log(e);
  }

  return CenteredDiv;

})(dat.dom.dom,
dat.utils.common),
dat.dom.dom,
dat.utils.common);
},{}],"/Users/luke/dev/040715/node_modules/firebase/lib/firebase-web.js":[function(require,module,exports){
/*! @license Firebase v2.2.0 - License: https://www.firebase.com/terms/terms-of-service.html */ (function() {var h,aa=this;function m(a){return void 0!==a}function ba(){}function ca(a){a.Ob=function(){return a.kf?a.kf:a.kf=new a}}
function da(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b}function ea(a){return"array"==da(a)}function fa(a){var b=da(a);return"array"==b||"object"==b&&"number"==typeof a.length}function p(a){return"string"==typeof a}function ga(a){return"number"==typeof a}function ha(a){return"function"==da(a)}function ia(a){var b=typeof a;return"object"==b&&null!=a||"function"==b}function ja(a,b,c){return a.call.apply(a.bind,arguments)}
function ka(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function q(a,b,c){q=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?ja:ka;return q.apply(null,arguments)}var la=Date.now||function(){return+new Date};
function ma(a,b){function c(){}c.prototype=b.prototype;a.Kg=b.prototype;a.prototype=new c;a.Gg=function(a,c,f){return b.prototype[c].apply(a,Array.prototype.slice.call(arguments,2))}};function na(a){a=String(a);if(/^\s*$/.test(a)?0:/^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g,"@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g,"")))try{return eval("("+a+")")}catch(b){}throw Error("Invalid JSON string: "+a);}function oa(){this.Md=void 0}
function pa(a,b,c){switch(typeof b){case "string":qa(b,c);break;case "number":c.push(isFinite(b)&&!isNaN(b)?b:"null");break;case "boolean":c.push(b);break;case "undefined":c.push("null");break;case "object":if(null==b){c.push("null");break}if(ea(b)){var d=b.length;c.push("[");for(var e="",f=0;f<d;f++)c.push(e),e=b[f],pa(a,a.Md?a.Md.call(b,String(f),e):e,c),e=",";c.push("]");break}c.push("{");d="";for(f in b)Object.prototype.hasOwnProperty.call(b,f)&&(e=b[f],"function"!=typeof e&&(c.push(d),qa(f,c),
c.push(":"),pa(a,a.Md?a.Md.call(b,f,e):e,c),d=","));c.push("}");break;case "function":break;default:throw Error("Unknown type: "+typeof b);}}var ra={'"':'\\"',"\\":"\\\\","/":"\\/","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\u000b"},sa=/\uffff/.test("\uffff")?/[\\\"\x00-\x1f\x7f-\uffff]/g:/[\\\"\x00-\x1f\x7f-\xff]/g;
function qa(a,b){b.push('"',a.replace(sa,function(a){if(a in ra)return ra[a];var b=a.charCodeAt(0),e="\\u";16>b?e+="000":256>b?e+="00":4096>b&&(e+="0");return ra[a]=e+b.toString(16)}),'"')};function ta(a){return"undefined"!==typeof JSON&&m(JSON.parse)?JSON.parse(a):na(a)}function r(a){if("undefined"!==typeof JSON&&m(JSON.stringify))a=JSON.stringify(a);else{var b=[];pa(new oa,a,b);a=b.join("")}return a};function s(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function t(a,b){if(Object.prototype.hasOwnProperty.call(a,b))return a[b]}function ua(a,b){for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&b(c,a[c])}function va(a){var b={};ua(a,function(a,d){b[a]=d});return b};function wa(a){this.vc=a;this.Jd="firebase:"}h=wa.prototype;h.set=function(a,b){null==b?this.vc.removeItem(this.Jd+a):this.vc.setItem(this.Jd+a,r(b))};h.get=function(a){a=this.vc.getItem(this.Jd+a);return null==a?null:ta(a)};h.remove=function(a){this.vc.removeItem(this.Jd+a)};h.lf=!1;h.toString=function(){return this.vc.toString()};function xa(){this.pc={}}xa.prototype.set=function(a,b){null==b?delete this.pc[a]:this.pc[a]=b};xa.prototype.get=function(a){return s(this.pc,a)?this.pc[a]:null};xa.prototype.remove=function(a){delete this.pc[a]};xa.prototype.lf=!0;function ya(a){try{if("undefined"!==typeof window&&"undefined"!==typeof window[a]){var b=window[a];b.setItem("firebase:sentinel","cache");b.removeItem("firebase:sentinel");return new wa(b)}}catch(c){}return new xa}var za=ya("localStorage"),v=ya("sessionStorage");function Aa(a,b,c,d,e){this.host=a.toLowerCase();this.domain=this.host.substr(this.host.indexOf(".")+1);this.Bb=b;this.ub=c;this.Eg=d;this.Id=e||"";this.Ma=za.get("host:"+a)||this.host}function Ba(a,b){b!==a.Ma&&(a.Ma=b,"s-"===a.Ma.substr(0,2)&&za.set("host:"+a.host,a.Ma))}Aa.prototype.toString=function(){var a=(this.Bb?"https://":"http://")+this.host;this.Id&&(a+="<"+this.Id+">");return a};function Ca(){this.Sa=-1};function Da(){this.Sa=-1;this.Sa=64;this.R=[];this.ge=[];this.Ef=[];this.Fd=[];this.Fd[0]=128;for(var a=1;a<this.Sa;++a)this.Fd[a]=0;this.Yd=this.Tb=0;this.reset()}ma(Da,Ca);Da.prototype.reset=function(){this.R[0]=1732584193;this.R[1]=4023233417;this.R[2]=2562383102;this.R[3]=271733878;this.R[4]=3285377520;this.Yd=this.Tb=0};
function Ea(a,b,c){c||(c=0);var d=a.Ef;if(p(b))for(var e=0;16>e;e++)d[e]=b.charCodeAt(c)<<24|b.charCodeAt(c+1)<<16|b.charCodeAt(c+2)<<8|b.charCodeAt(c+3),c+=4;else for(e=0;16>e;e++)d[e]=b[c]<<24|b[c+1]<<16|b[c+2]<<8|b[c+3],c+=4;for(e=16;80>e;e++){var f=d[e-3]^d[e-8]^d[e-14]^d[e-16];d[e]=(f<<1|f>>>31)&4294967295}b=a.R[0];c=a.R[1];for(var g=a.R[2],k=a.R[3],l=a.R[4],n,e=0;80>e;e++)40>e?20>e?(f=k^c&(g^k),n=1518500249):(f=c^g^k,n=1859775393):60>e?(f=c&g|k&(c|g),n=2400959708):(f=c^g^k,n=3395469782),f=(b<<
5|b>>>27)+f+l+n+d[e]&4294967295,l=k,k=g,g=(c<<30|c>>>2)&4294967295,c=b,b=f;a.R[0]=a.R[0]+b&4294967295;a.R[1]=a.R[1]+c&4294967295;a.R[2]=a.R[2]+g&4294967295;a.R[3]=a.R[3]+k&4294967295;a.R[4]=a.R[4]+l&4294967295}
Da.prototype.update=function(a,b){m(b)||(b=a.length);for(var c=b-this.Sa,d=0,e=this.ge,f=this.Tb;d<b;){if(0==f)for(;d<=c;)Ea(this,a,d),d+=this.Sa;if(p(a))for(;d<b;){if(e[f]=a.charCodeAt(d),++f,++d,f==this.Sa){Ea(this,e);f=0;break}}else for(;d<b;)if(e[f]=a[d],++f,++d,f==this.Sa){Ea(this,e);f=0;break}}this.Tb=f;this.Yd+=b};function Fa(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^la()).toString(36)};var w=Array.prototype,Ga=w.indexOf?function(a,b,c){return w.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(p(a))return p(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},Ha=w.forEach?function(a,b,c){w.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)},Ia=w.filter?function(a,b,c){return w.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=p(a)?
a.split(""):a,k=0;k<d;k++)if(k in g){var l=g[k];b.call(c,l,k,a)&&(e[f++]=l)}return e},Ja=w.map?function(a,b,c){return w.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=p(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e},Ka=w.reduce?function(a,b,c,d){d&&(b=q(b,d));return w.reduce.call(a,b,c)}:function(a,b,c,d){var e=c;Ha(a,function(c,g){e=b.call(d,e,c,g,a)});return e},La=w.every?function(a,b,c){return w.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=
p(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return!1;return!0};function Ma(a,b){var c=Na(a,b,void 0);return 0>c?null:p(a)?a.charAt(c):a[c]}function Na(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return-1}function Oa(a,b){var c=Ga(a,b);0<=c&&w.splice.call(a,c,1)}function Pa(a,b,c){return 2>=arguments.length?w.slice.call(a,b):w.slice.call(a,b,c)}function Qa(a,b){a.sort(b||Ra)}function Ra(a,b){return a>b?1:a<b?-1:0};var Sa;a:{var Ta=aa.navigator;if(Ta){var Ua=Ta.userAgent;if(Ua){Sa=Ua;break a}}Sa=""}function Va(a){return-1!=Sa.indexOf(a)};var Wa=Va("Opera")||Va("OPR"),Xa=Va("Trident")||Va("MSIE"),Ya=Va("Gecko")&&-1==Sa.toLowerCase().indexOf("webkit")&&!(Va("Trident")||Va("MSIE")),Za=-1!=Sa.toLowerCase().indexOf("webkit");(function(){var a="",b;if(Wa&&aa.opera)return a=aa.opera.version,ha(a)?a():a;Ya?b=/rv\:([^\);]+)(\)|;)/:Xa?b=/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/:Za&&(b=/WebKit\/(\S+)/);b&&(a=(a=b.exec(Sa))?a[1]:"");return Xa&&(b=(b=aa.document)?b.documentMode:void 0,b>parseFloat(a))?String(b):a})();var $a=null,ab=null,bb=null;function cb(a,b){if(!fa(a))throw Error("encodeByteArray takes an array as a parameter");db();for(var c=b?ab:$a,d=[],e=0;e<a.length;e+=3){var f=a[e],g=e+1<a.length,k=g?a[e+1]:0,l=e+2<a.length,n=l?a[e+2]:0,u=f>>2,f=(f&3)<<4|k>>4,k=(k&15)<<2|n>>6,n=n&63;l||(n=64,g||(k=64));d.push(c[u],c[f],c[k],c[n])}return d.join("")}
function db(){if(!$a){$a={};ab={};bb={};for(var a=0;65>a;a++)$a[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a),ab[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a),bb[ab[a]]=a}};var eb=function(){var a=1;return function(){return a++}}();function y(a,b){if(!a)throw fb(b);}function fb(a){return Error("Firebase INTERNAL ASSERT FAILED:"+a)}
function gb(a){try{var b;if("undefined"!==typeof atob)b=atob(a);else{db();for(var c=bb,d=[],e=0;e<a.length;){var f=c[a.charAt(e++)],g=e<a.length?c[a.charAt(e)]:0;++e;var k=e<a.length?c[a.charAt(e)]:64;++e;var l=e<a.length?c[a.charAt(e)]:64;++e;if(null==f||null==g||null==k||null==l)throw Error();d.push(f<<2|g>>4);64!=k&&(d.push(g<<4&240|k>>2),64!=l&&d.push(k<<6&192|l))}if(8192>d.length)b=String.fromCharCode.apply(null,d);else{a="";for(c=0;c<d.length;c+=8192)a+=String.fromCharCode.apply(null,Pa(d,c,
c+8192));b=a}}return b}catch(n){hb("base64Decode failed: ",n)}return null}function ib(a){var b=jb(a);a=new Da;a.update(b);var b=[],c=8*a.Yd;56>a.Tb?a.update(a.Fd,56-a.Tb):a.update(a.Fd,a.Sa-(a.Tb-56));for(var d=a.Sa-1;56<=d;d--)a.ge[d]=c&255,c/=256;Ea(a,a.ge);for(d=c=0;5>d;d++)for(var e=24;0<=e;e-=8)b[c]=a.R[d]>>e&255,++c;return cb(b)}
function kb(a){for(var b="",c=0;c<arguments.length;c++)b=fa(arguments[c])?b+kb.apply(null,arguments[c]):"object"===typeof arguments[c]?b+r(arguments[c]):b+arguments[c],b+=" ";return b}var lb=null,mb=!0;function hb(a){!0===mb&&(mb=!1,null===lb&&!0===v.get("logging_enabled")&&nb(!0));if(lb){var b=kb.apply(null,arguments);lb(b)}}function ob(a){return function(){hb(a,arguments)}}
function pb(a){if("undefined"!==typeof console){var b="FIREBASE INTERNAL ERROR: "+kb.apply(null,arguments);"undefined"!==typeof console.error?console.error(b):console.log(b)}}function qb(a){var b=kb.apply(null,arguments);throw Error("FIREBASE FATAL ERROR: "+b);}function z(a){if("undefined"!==typeof console){var b="FIREBASE WARNING: "+kb.apply(null,arguments);"undefined"!==typeof console.warn?console.warn(b):console.log(b)}}
function rb(a){var b="",c="",d="",e="",f=!0,g="https",k=443;if(p(a)){var l=a.indexOf("//");0<=l&&(g=a.substring(0,l-1),a=a.substring(l+2));l=a.indexOf("/");-1===l&&(l=a.length);b=a.substring(0,l);e="";a=a.substring(l).split("/");for(l=0;l<a.length;l++)if(0<a[l].length){var n=a[l];try{n=decodeURIComponent(n.replace(/\+/g," "))}catch(u){}e+="/"+n}a=b.split(".");3===a.length?(c=a[1],d=a[0].toLowerCase()):2===a.length&&(c=a[0]);l=b.indexOf(":");0<=l&&(f="https"===g||"wss"===g,k=b.substring(l+1),isFinite(k)&&
(k=String(k)),k=p(k)?/^\s*-?0x/i.test(k)?parseInt(k,16):parseInt(k,10):NaN)}return{host:b,port:k,domain:c,Bg:d,Bb:f,scheme:g,Pc:e}}function sb(a){return ga(a)&&(a!=a||a==Number.POSITIVE_INFINITY||a==Number.NEGATIVE_INFINITY)}
function tb(a){if("complete"===document.readyState)a();else{var b=!1,c=function(){document.body?b||(b=!0,a()):setTimeout(c,Math.floor(10))};document.addEventListener?(document.addEventListener("DOMContentLoaded",c,!1),window.addEventListener("load",c,!1)):document.attachEvent&&(document.attachEvent("onreadystatechange",function(){"complete"===document.readyState&&c()}),window.attachEvent("onload",c))}}
function ub(a,b){if(a===b)return 0;if("[MIN_NAME]"===a||"[MAX_NAME]"===b)return-1;if("[MIN_NAME]"===b||"[MAX_NAME]"===a)return 1;var c=vb(a),d=vb(b);return null!==c?null!==d?0==c-d?a.length-b.length:c-d:-1:null!==d?1:a<b?-1:1}function wb(a,b){if(b&&a in b)return b[a];throw Error("Missing required key ("+a+") in object: "+r(b));}
function xb(a){if("object"!==typeof a||null===a)return r(a);var b=[],c;for(c in a)b.push(c);b.sort();c="{";for(var d=0;d<b.length;d++)0!==d&&(c+=","),c+=r(b[d]),c+=":",c+=xb(a[b[d]]);return c+"}"}function yb(a,b){if(a.length<=b)return[a];for(var c=[],d=0;d<a.length;d+=b)d+b>a?c.push(a.substring(d,a.length)):c.push(a.substring(d,d+b));return c}function zb(a,b){if(ea(a))for(var c=0;c<a.length;++c)b(c,a[c]);else A(a,b)}
function Ab(a){y(!sb(a),"Invalid JSON number");var b,c,d,e;0===a?(d=c=0,b=-Infinity===1/a?1:0):(b=0>a,a=Math.abs(a),a>=Math.pow(2,-1022)?(d=Math.min(Math.floor(Math.log(a)/Math.LN2),1023),c=d+1023,d=Math.round(a*Math.pow(2,52-d)-Math.pow(2,52))):(c=0,d=Math.round(a/Math.pow(2,-1074))));e=[];for(a=52;a;a-=1)e.push(d%2?1:0),d=Math.floor(d/2);for(a=11;a;a-=1)e.push(c%2?1:0),c=Math.floor(c/2);e.push(b?1:0);e.reverse();b=e.join("");c="";for(a=0;64>a;a+=8)d=parseInt(b.substr(a,8),2).toString(16),1===d.length&&
(d="0"+d),c+=d;return c.toLowerCase()}var Bb=/^-?\d{1,10}$/;function vb(a){return Bb.test(a)&&(a=Number(a),-2147483648<=a&&2147483647>=a)?a:null}function Cb(a){try{a()}catch(b){setTimeout(function(){z("Exception was thrown by user callback.",b.stack||"");throw b;},Math.floor(0))}}function B(a,b){if(ha(a)){var c=Array.prototype.slice.call(arguments,1).slice();Cb(function(){a.apply(null,c)})}};function Db(a,b,c,d){this.pe=b;this.Sd=c;this.Kd=d;this.kd=a}Db.prototype.Rb=function(){var a=this.Sd.dc();return"value"===this.kd?a.path:a.parent().path};Db.prototype.te=function(){return this.kd};Db.prototype.Mb=function(){return this.pe.Mb(this)};Db.prototype.toString=function(){return this.Rb().toString()+":"+this.kd+":"+r(this.Sd.cf())};function Eb(a,b,c){this.pe=a;this.error=b;this.path=c}Eb.prototype.Rb=function(){return this.path};Eb.prototype.te=function(){return"cancel"};
Eb.prototype.Mb=function(){return this.pe.Mb(this)};Eb.prototype.toString=function(){return this.path.toString()+":cancel"};function C(a,b,c,d){this.type=a;this.Ha=b;this.Ua=c;this.Ee=d;this.Kd=void 0}function Fb(a){return new C(Gb,a)}var Gb="value";function Hb(a,b,c){this.Hb=a;this.lb=b;this.nb=c||null}h=Hb.prototype;h.wf=function(a){return"value"===a};h.createEvent=function(a,b){var c=b.n.g;return new Db("value",this,new D(a.Ha,b.dc(),c))};h.Mb=function(a){var b=this.nb;if("cancel"===a.te()){y(this.lb,"Raising a cancel event on a listener with no cancel callback");var c=this.lb;return function(){c.call(b,a.error)}}var d=this.Hb;return function(){d.call(b,a.Sd)}};h.Ze=function(a,b){return this.lb?new Eb(this,a,b):null};
h.matches=function(a){return a instanceof Hb?a.Hb&&this.Hb?a.Hb===this.Hb&&a.nb===this.nb:!0:!1};h.jf=function(){return null!==this.Hb};function Ib(a,b,c){this.ea=a;this.lb=b;this.nb=c}h=Ib.prototype;h.wf=function(a){a="children_added"===a?"child_added":a;return("children_removed"===a?"child_removed":a)in this.ea};h.Ze=function(a,b){return this.lb?new Eb(this,a,b):null};
h.createEvent=function(a,b){y(null!=a.Ua,"Child events should have a childName.");var c=b.dc().u(a.Ua);return new Db(a.type,this,new D(a.Ha,c,b.n.g),a.Kd)};h.Mb=function(a){var b=this.nb;if("cancel"===a.te()){y(this.lb,"Raising a cancel event on a listener with no cancel callback");var c=this.lb;return function(){c.call(b,a.error)}}var d=this.ea[a.kd];return function(){d.call(b,a.Sd,a.Kd)}};
h.matches=function(a){if(a instanceof Ib){if(!this.ea||!a.ea)return!0;if(this.nb===a.nb){var b=Jb(a.ea);if(b===Jb(this.ea)){if(1===b){var b=Kb(a.ea),c=Kb(this.ea);return c===b&&(!a.ea[b]||!this.ea[c]||a.ea[b]===this.ea[c])}return Lb(this.ea,function(b,c){return a.ea[c]===b})}}}return!1};h.jf=function(){return null!==this.ea};function jb(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);55296<=e&&56319>=e&&(e-=55296,d++,y(d<a.length,"Surrogate pair missing trail surrogate."),e=65536+(e<<10)+(a.charCodeAt(d)-56320));128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(65536>e?b[c++]=e>>12|224:(b[c++]=e>>18|240,b[c++]=e>>12&63|128),b[c++]=e>>6&63|128),b[c++]=e&63|128)}return b};function E(a,b,c,d){var e;d<b?e="at least "+b:d>c&&(e=0===c?"none":"no more than "+c);if(e)throw Error(a+" failed: Was called with "+d+(1===d?" argument.":" arguments.")+" Expects "+e+".");}function G(a,b,c){var d="";switch(b){case 1:d=c?"first":"First";break;case 2:d=c?"second":"Second";break;case 3:d=c?"third":"Third";break;case 4:d=c?"fourth":"Fourth";break;default:throw Error("errorPrefix called with argumentNumber > 4.  Need to update it?");}return a=a+" failed: "+(d+" argument ")}
function H(a,b,c,d){if((!d||m(c))&&!ha(c))throw Error(G(a,b,d)+"must be a valid function.");}function Mb(a,b,c){if(m(c)&&(!ia(c)||null===c))throw Error(G(a,b,!0)+"must be a valid context object.");};var Nb=/[\[\].#$\/\u0000-\u001F\u007F]/,Ob=/[\[\].#$\u0000-\u001F\u007F]/;function Pb(a){return p(a)&&0!==a.length&&!Nb.test(a)}function Qb(a){return null===a||p(a)||ga(a)&&!sb(a)||ia(a)&&s(a,".sv")}function Rb(a,b,c){c&&!m(b)||Sb(G(a,1,c),b)}
function Sb(a,b,c,d){c||(c=0);var e=d||[];if(!m(b))throw Error(a+"contains undefined"+Tb(e));if(ha(b))throw Error(a+"contains a function"+Tb(e)+" with contents: "+b.toString());if(sb(b))throw Error(a+"contains "+b.toString()+Tb(e));if(1E3<c)throw new TypeError(a+"contains a cyclic object value ("+e.slice(0,100).join(".")+"...)");if(p(b)&&b.length>10485760/3&&10485760<jb(b).length)throw Error(a+"contains a string greater than 10485760 utf8 bytes"+Tb(e)+" ('"+b.substring(0,50)+"...')");if(ia(b)){var f=
!1,g=!1;ua(b,function(b,d){if(".value"===b)f=!0;else if(".priority"!==b&&".sv"!==b&&(g=!0,!Pb(b)))throw Error(a+" contains an invalid key ("+b+")"+Tb(e)+'.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');e.push(b);Sb(a,d,c+1,e);e.pop()});if(f&&g)throw Error(a+' contains ".value" child'+Tb(e)+" in addition to actual children.");}}function Tb(a){return 0==a.length?"":" in property '"+a.join(".")+"'"}
function Ub(a,b){if(!ia(b)||ea(b))throw Error(G(a,1,!1)+" must be an Object containing the children to replace.");if(s(b,".value"))throw Error(G(a,1,!1)+' must not contain ".value".  To overwrite with a leaf value, just use .set() instead.');Rb(a,b,!1)}
function Vb(a,b,c){if(sb(c))throw Error(G(a,b,!1)+"is "+c.toString()+", but must be a valid Firebase priority (a string, finite number, server value, or null).");if(!Qb(c))throw Error(G(a,b,!1)+"must be a valid Firebase priority (a string, finite number, server value, or null).");}
function Wb(a,b,c){if(!c||m(b))switch(b){case "value":case "child_added":case "child_removed":case "child_changed":case "child_moved":break;default:throw Error(G(a,1,c)+'must be a valid event type: "value", "child_added", "child_removed", "child_changed", or "child_moved".');}}function Xb(a,b,c,d){if((!d||m(c))&&!Pb(c))throw Error(G(a,b,d)+'was an invalid key: "'+c+'".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").');}
function Yb(a,b){if(!p(b)||0===b.length||Ob.test(b))throw Error(G(a,1,!1)+'was an invalid path: "'+b+'". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"');}function Zb(a,b){if(".info"===I(b))throw Error(a+" failed: Can't modify data under /.info/");}function $b(a,b){if(!p(b))throw Error(G(a,1,!1)+"must be a valid credential (a string).");}function ac(a,b,c){if(!p(c))throw Error(G(a,b,!1)+"must be a valid string.");}
function J(a,b,c,d){if(!d||m(c))if(!ia(c)||null===c)throw Error(G(a,b,d)+"must be a valid object.");}function K(a,b,c){if(!ia(b)||null===b||!s(b,c))throw Error(G(a,1,!1)+'must contain the key "'+c+'"');if(!p(t(b,c)))throw Error(G(a,1,!1)+'must contain the key "'+c+'" with type "string"');};function bc(a){this.g=a}h=bc.prototype;h.D=function(a,b,c,d,e){y(a.Bc(this.g),"A node must be indexed if only a child is updated");d=a.K(b);if(d.aa(c))return a;null!=e&&(c.e()?a.Da(b)?cc(e,new C("child_removed",d,b)):y(a.M(),"A child remove without an old child only makes sense on a leaf node"):d.e()?cc(e,new C("child_added",c,b)):cc(e,new C("child_changed",c,b,d)));return a.M()&&c.e()?a:a.P(b,c).hb(this.g)};
h.oa=function(a,b,c){null!=c&&(a.M()||a.U(L,function(a,e){b.Da(a)||cc(c,new C("child_removed",e,a))}),b.M()||b.U(L,function(b,e){if(a.Da(b)){var f=a.K(b);f.aa(e)||cc(c,new C("child_changed",e,b,f))}else cc(c,new C("child_added",e,b))}));return b.hb(this.g)};h.$=function(a,b){return a.e()?M:a.$(b)};h.Ca=function(){return!1};h.Nb=function(){return this};function dc(a){this.ve=new bc(a.g);this.g=a.g;var b;a.ia?(b=ec(a),b=a.g.ud(fc(a),b)):b=a.g.yd();this.Vc=b;a.qa?(b=gc(a),a=a.g.ud(hc(a),b)):a=a.g.wd();this.xc=a}h=dc.prototype;h.matches=function(a){return 0>=this.g.compare(this.Vc,a)&&0>=this.g.compare(a,this.xc)};h.D=function(a,b,c,d,e){this.matches(new N(b,c))||(c=M);return this.ve.D(a,b,c,d,e)};h.oa=function(a,b,c){b.M()&&(b=M);var d=b.hb(this.g),d=d.$(M),e=this;b.U(L,function(a,b){e.matches(new N(a,b))||(d=d.P(a,M))});return this.ve.oa(a,d,c)};
h.$=function(a){return a};h.Ca=function(){return!0};h.Nb=function(){return this.ve};function ic(a,b){return ub(a.name,b.name)}function jc(a,b){return ub(a,b)};function kc(){}var lc={};function mc(a){return q(a.compare,a)}kc.prototype.we=function(a,b){return 0!==this.compare(new N("[MIN_NAME]",a),new N("[MIN_NAME]",b))};kc.prototype.yd=function(){return nc};function oc(a){this.Vb=a}ma(oc,kc);h=oc.prototype;h.sd=function(a){return!a.K(this.Vb).e()};h.compare=function(a,b){var c=a.V.K(this.Vb),d=b.V.K(this.Vb),c=c.dd(d);return 0===c?ub(a.name,b.name):c};h.ud=function(a,b){var c=O(a),c=M.P(this.Vb,c);return new N(b,c)};
h.wd=function(){var a=M.P(this.Vb,pc);return new N("[MAX_NAME]",a)};h.toString=function(){return this.Vb};var L=new oc(".priority");function qc(){}ma(qc,kc);h=qc.prototype;h.compare=function(a,b){return ub(a.name,b.name)};h.sd=function(){throw fb("KeyIndex.isDefinedOn not expected to be called.");};h.we=function(){return!1};h.yd=function(){return nc};h.wd=function(){return new N("[MAX_NAME]",M)};h.ud=function(a){y(p(a),"KeyIndex indexValue must always be a string.");return new N(a,M)};
h.toString=function(){return".key"};var rc=new qc;function sc(){}ma(sc,kc);h=sc.prototype;h.compare=function(a,b){var c=a.V.dd(b.V);return 0===c?ub(a.name,b.name):c};h.sd=function(){return!0};h.we=function(a,b){return!a.aa(b)};h.yd=function(){return nc};h.wd=function(){return tc};h.ud=function(a,b){var c=O(a);return new N(b,c)};h.toString=function(){return".value"};var uc=new sc;function vc(){}vc.prototype.ff=function(){return null};vc.prototype.se=function(){return null};var wc=new vc;function xc(a,b,c){this.Bf=a;this.Ia=b;this.Ed=c}xc.prototype.ff=function(a){var b=this.Ia.B;if(yc(b,a))return b.j().K(a);b=null!=this.Ed?new zc(this.Ed,!0,!1):this.Ia.o();return this.Bf.Ta(a,b)};xc.prototype.se=function(a,b,c){var d=null!=this.Ed?this.Ed:Ac(this.Ia);a=this.Bf.he(d,b,1,c,a);return 0===a.length?null:a[0]};function Bc(){this.Za={}}
function cc(a,b){var c=b.type,d=b.Ua;y("child_added"==c||"child_changed"==c||"child_removed"==c,"Only child changes supported for tracking");y(".priority"!==d,"Only non-priority child changes can be tracked.");var e=t(a.Za,d);if(e){var f=e.type;if("child_added"==c&&"child_removed"==f)a.Za[d]=new C("child_changed",b.Ha,d,e.Ha);else if("child_removed"==c&&"child_added"==f)delete a.Za[d];else if("child_removed"==c&&"child_changed"==f)a.Za[d]=new C("child_removed",e.Ee,d);else if("child_changed"==c&&
"child_added"==f)a.Za[d]=new C("child_added",b.Ha,d);else if("child_changed"==c&&"child_changed"==f)a.Za[d]=new C("child_changed",b.Ha,d,e.Ee);else throw fb("Illegal combination of changes: "+b+" occurred after "+e);}else a.Za[d]=b};function N(a,b){this.name=a;this.V=b}function Cc(a,b){return new N(a,b)};function Dc(a){this.ma=new dc(a);this.g=a.g;y(a.ka,"Only valid if limit has been set");this.sa=a.sa;this.Ab=!(""===a.Fb?a.ia:"l"===a.Fb)}h=Dc.prototype;h.D=function(a,b,c,d,e){this.ma.matches(new N(b,c))||(c=M);return a.K(b).aa(c)?a:a.vb()<this.sa?this.ma.Nb().D(a,b,c,d,e):Ec(this,a,b,c,d,e)};
h.oa=function(a,b,c){var d;if(b.M()||b.e())d=M.hb(this.g);else if(2*this.sa<b.vb()&&b.Bc(this.g)){d=M.hb(this.g);b=this.Ab?b.Sb(this.ma.xc,this.g):b.Qb(this.ma.Vc,this.g);for(var e=0;0<b.Na.length&&e<this.sa;){var f=P(b),g;if(g=this.Ab?0>=this.g.compare(this.ma.Vc,f):0>=this.g.compare(f,this.ma.xc))d=d.P(f.name,f.V),e++;else break}}else{d=b.hb(this.g);d=d.$(M);var k,l,n;if(this.Ab){b=d.hf(this.g);k=this.ma.xc;l=this.ma.Vc;var u=mc(this.g);n=function(a,b){return u(b,a)}}else b=d.Pb(this.g),k=this.ma.Vc,
l=this.ma.xc,n=mc(this.g);for(var e=0,x=!1;0<b.Na.length;)f=P(b),!x&&0>=n(k,f)&&(x=!0),(g=x&&e<this.sa&&0>=n(f,l))?e++:d=d.P(f.name,M)}return this.ma.Nb().oa(a,d,c)};h.$=function(a){return a};h.Ca=function(){return!0};h.Nb=function(){return this.ma.Nb()};
function Ec(a,b,c,d,e,f){var g;if(a.Ab){var k=mc(a.g);g=function(a,b){return k(b,a)}}else g=mc(a.g);y(b.vb()==a.sa,"");var l=new N(c,d),n=a.Ab?Fc(b,a.g):Gc(b,a.g),u=a.ma.matches(l);if(b.Da(c)){var x=b.K(c),n=e.se(a.g,n,a.Ab);null!=n&&n.name==c&&(n=e.se(a.g,n,a.Ab));e=null==n?1:g(n,l);if(u&&!d.e()&&0<=e)return null!=f&&cc(f,new C("child_changed",d,c,x)),b.P(c,d);null!=f&&cc(f,new C("child_removed",x,c));b=b.P(c,M);return null!=n&&a.ma.matches(n)?(null!=f&&cc(f,new C("child_added",n.V,n.name)),b.P(n.name,
n.V)):b}return d.e()?b:u&&0<=g(n,l)?(null!=f&&(cc(f,new C("child_removed",n.V,n.name)),cc(f,new C("child_added",d,c))),b.P(c,d).P(n.name,M)):b};function Hc(){this.wc=this.qa=this.lc=this.ia=this.ka=!1;this.sa=0;this.Fb="";this.Ac=null;this.Xb="";this.zc=null;this.Ub="";this.g=L}var Ic=new Hc;function fc(a){y(a.ia,"Only valid if start has been set");return a.Ac}function ec(a){y(a.ia,"Only valid if start has been set");return a.lc?a.Xb:"[MIN_NAME]"}function hc(a){y(a.qa,"Only valid if end has been set");return a.zc}function gc(a){y(a.qa,"Only valid if end has been set");return a.wc?a.Ub:"[MAX_NAME]"}
function Jc(a){var b=new Hc;b.ka=a.ka;b.sa=a.sa;b.ia=a.ia;b.Ac=a.Ac;b.lc=a.lc;b.Xb=a.Xb;b.qa=a.qa;b.zc=a.zc;b.wc=a.wc;b.Ub=a.Ub;b.g=a.g;return b}h=Hc.prototype;h.Be=function(a){var b=Jc(this);b.ka=!0;b.sa=a;b.Fb="";return b};h.Ce=function(a){var b=Jc(this);b.ka=!0;b.sa=a;b.Fb="l";return b};h.De=function(a){var b=Jc(this);b.ka=!0;b.sa=a;b.Fb="r";return b};h.Td=function(a,b){var c=Jc(this);c.ia=!0;m(a)||(a=null);c.Ac=a;null!=b?(c.lc=!0,c.Xb=b):(c.lc=!1,c.Xb="");return c};
h.jd=function(a,b){var c=Jc(this);c.qa=!0;m(a)||(a=null);c.zc=a;m(b)?(c.wc=!0,c.Ub=b):(c.Jg=!1,c.Ub="");return c};function Kc(a,b){var c=Jc(a);c.g=b;return c}function Lc(a){var b={};a.ia&&(b.sp=a.Ac,a.lc&&(b.sn=a.Xb));a.qa&&(b.ep=a.zc,a.wc&&(b.en=a.Ub));if(a.ka){b.l=a.sa;var c=a.Fb;""===c&&(c=a.ia?"l":"r");b.vf=c}a.g!==L&&(b.i=a.g.toString());return b}function Mc(a){return!(a.ia||a.qa||a.ka)}h.toString=function(){return r(Lc(this))};function Q(a,b,c,d){this.k=a;this.path=b;this.n=c;this.bc=d}
function Nc(a){var b=null,c=null;a.ia&&(b=fc(a));a.qa&&(c=hc(a));if(a.g===rc){if(a.ia){if("[MIN_NAME]"!=ec(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if("string"!==typeof b)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}if(a.qa){if("[MAX_NAME]"!=gc(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if("string"!==
typeof c)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}}else if(a.g===L){if(null!=b&&!Qb(b)||null!=c&&!Qb(c))throw Error("Query: When ordering by priority, the first argument passed to startAt(), endAt(), or equalTo() must be a valid priority value (null, a number, or a string).");}else if(y(a.g instanceof oc||a.g===uc,"unknown index type."),null!=b&&"object"===typeof b||null!=c&&"object"===typeof c)throw Error("Query: First argument passed to startAt(), endAt(), or equalTo() cannot be an object.");
}function Oc(a){if(a.ia&&a.qa&&a.ka&&(!a.ka||""===a.Fb))throw Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");}function Pc(a,b){if(!0===a.bc)throw Error(b+": You can't combine multiple orderBy calls.");}Q.prototype.dc=function(){E("Query.ref",0,0,arguments.length);return new R(this.k,this.path)};Q.prototype.ref=Q.prototype.dc;
Q.prototype.wb=function(a,b,c,d){E("Query.on",2,4,arguments.length);Wb("Query.on",a,!1);H("Query.on",2,b,!1);var e=Qc("Query.on",c,d);if("value"===a)Rc(this.k,this,new Hb(b,e.cancel||null,e.Ka||null));else{var f={};f[a]=b;Rc(this.k,this,new Ib(f,e.cancel,e.Ka))}return b};Q.prototype.on=Q.prototype.wb;
Q.prototype.$b=function(a,b,c){E("Query.off",0,3,arguments.length);Wb("Query.off",a,!0);H("Query.off",2,b,!0);Mb("Query.off",3,c);var d=null,e=null;"value"===a?d=new Hb(b||null,null,c||null):a&&(b&&(e={},e[a]=b),d=new Ib(e,null,c||null));e=this.k;d=".info"===I(this.path)?e.rd.gb(this,d):e.N.gb(this,d);Sc(e.ba,this.path,d)};Q.prototype.off=Q.prototype.$b;
Q.prototype.lg=function(a,b){function c(g){f&&(f=!1,e.$b(a,c),b.call(d.Ka,g))}E("Query.once",2,4,arguments.length);Wb("Query.once",a,!1);H("Query.once",2,b,!1);var d=Qc("Query.once",arguments[2],arguments[3]),e=this,f=!0;this.wb(a,c,function(b){e.$b(a,c);d.cancel&&d.cancel.call(d.Ka,b)})};Q.prototype.once=Q.prototype.lg;
Q.prototype.Be=function(a){z("Query.limit() being deprecated. Please use Query.limitToFirst() or Query.limitToLast() instead.");E("Query.limit",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limit: First argument must be a positive integer.");if(this.n.ka)throw Error("Query.limit: Limit was already set (by another call to limit, limitToFirst, orlimitToLast.");var b=this.n.Be(a);Oc(b);return new Q(this.k,this.path,b,this.bc)};Q.prototype.limit=Q.prototype.Be;
Q.prototype.Ce=function(a){E("Query.limitToFirst",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToFirst: First argument must be a positive integer.");if(this.n.ka)throw Error("Query.limitToFirst: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new Q(this.k,this.path,this.n.Ce(a),this.bc)};Q.prototype.limitToFirst=Q.prototype.Ce;
Q.prototype.De=function(a){E("Query.limitToLast",1,1,arguments.length);if(!ga(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToLast: First argument must be a positive integer.");if(this.n.ka)throw Error("Query.limitToLast: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new Q(this.k,this.path,this.n.De(a),this.bc)};Q.prototype.limitToLast=Q.prototype.De;
Q.prototype.mg=function(a){E("Query.orderByChild",1,1,arguments.length);if("$key"===a)throw Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');if("$priority"===a)throw Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');if("$value"===a)throw Error('Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.');Xb("Query.orderByChild",1,a,!1);Pc(this,"Query.orderByChild");var b=Kc(this.n,new oc(a));Nc(b);return new Q(this.k,
this.path,b,!0)};Q.prototype.orderByChild=Q.prototype.mg;Q.prototype.ng=function(){E("Query.orderByKey",0,0,arguments.length);Pc(this,"Query.orderByKey");var a=Kc(this.n,rc);Nc(a);return new Q(this.k,this.path,a,!0)};Q.prototype.orderByKey=Q.prototype.ng;Q.prototype.og=function(){E("Query.orderByPriority",0,0,arguments.length);Pc(this,"Query.orderByPriority");var a=Kc(this.n,L);Nc(a);return new Q(this.k,this.path,a,!0)};Q.prototype.orderByPriority=Q.prototype.og;
Q.prototype.pg=function(){E("Query.orderByValue",0,0,arguments.length);Pc(this,"Query.orderByValue");var a=Kc(this.n,uc);Nc(a);return new Q(this.k,this.path,a,!0)};Q.prototype.orderByValue=Q.prototype.pg;
Q.prototype.Td=function(a,b){E("Query.startAt",0,2,arguments.length);Rb("Query.startAt",a,!0);Xb("Query.startAt",2,b,!0);var c=this.n.Td(a,b);Oc(c);Nc(c);if(this.n.ia)throw Error("Query.startAt: Starting point was already set (by another call to startAt or equalTo).");m(a)||(b=a=null);return new Q(this.k,this.path,c,this.bc)};Q.prototype.startAt=Q.prototype.Td;
Q.prototype.jd=function(a,b){E("Query.endAt",0,2,arguments.length);Rb("Query.endAt",a,!0);Xb("Query.endAt",2,b,!0);var c=this.n.jd(a,b);Oc(c);Nc(c);if(this.n.qa)throw Error("Query.endAt: Ending point was already set (by another call to endAt or equalTo).");return new Q(this.k,this.path,c,this.bc)};Q.prototype.endAt=Q.prototype.jd;
Q.prototype.Tf=function(a,b){E("Query.equalTo",1,2,arguments.length);Rb("Query.equalTo",a,!1);Xb("Query.equalTo",2,b,!0);if(this.n.ia)throw Error("Query.equalTo: Starting point was already set (by another call to endAt or equalTo).");if(this.n.qa)throw Error("Query.equalTo: Ending point was already set (by another call to endAt or equalTo).");return this.Td(a,b).jd(a,b)};Q.prototype.equalTo=Q.prototype.Tf;Q.prototype.Fa=function(){var a=xb(Lc(this.n));return"{}"===a?"default":a};
function Qc(a,b,c){var d={cancel:null,Ka:null};if(b&&c)d.cancel=b,H(a,3,d.cancel,!0),d.Ka=c,Mb(a,4,d.Ka);else if(b)if("object"===typeof b&&null!==b)d.Ka=b;else if("function"===typeof b)d.cancel=b;else throw Error(G(a,3,!0)+" must either be a cancel callback or a context object.");return d};function S(a,b){if(1==arguments.length){this.w=a.split("/");for(var c=0,d=0;d<this.w.length;d++)0<this.w[d].length&&(this.w[c]=this.w[d],c++);this.w.length=c;this.da=0}else this.w=a,this.da=b}function I(a){return a.da>=a.w.length?null:a.w[a.da]}function Tc(a){return a.w.length-a.da}function T(a){var b=a.da;b<a.w.length&&b++;return new S(a.w,b)}function Uc(a){return a.da<a.w.length?a.w[a.w.length-1]:null}
S.prototype.toString=function(){for(var a="",b=this.da;b<this.w.length;b++)""!==this.w[b]&&(a+="/"+this.w[b]);return a||"/"};S.prototype.parent=function(){if(this.da>=this.w.length)return null;for(var a=[],b=this.da;b<this.w.length-1;b++)a.push(this.w[b]);return new S(a,0)};
S.prototype.u=function(a){for(var b=[],c=this.da;c<this.w.length;c++)b.push(this.w[c]);if(a instanceof S)for(c=a.da;c<a.w.length;c++)b.push(a.w[c]);else for(a=a.split("/"),c=0;c<a.length;c++)0<a[c].length&&b.push(a[c]);return new S(b,0)};S.prototype.e=function(){return this.da>=this.w.length};var U=new S("");function V(a,b){var c=I(a);if(null===c)return b;if(c===I(b))return V(T(a),T(b));throw Error("INTERNAL ERROR: innerPath ("+b+") is not within outerPath ("+a+")");}
S.prototype.aa=function(a){if(Tc(this)!==Tc(a))return!1;for(var b=this.da,c=a.da;b<=this.w.length;b++,c++)if(this.w[b]!==a.w[c])return!1;return!0};S.prototype.contains=function(a){var b=this.da,c=a.da;if(Tc(this)>Tc(a))return!1;for(;b<this.w.length;){if(this.w[b]!==a.w[c])return!1;++b;++c}return!0};function Vc(){this.children={};this.bd=0;this.value=null}function Wc(a,b,c){this.zd=a?a:"";this.Oc=b?b:null;this.A=c?c:new Vc}function Xc(a,b){for(var c=b instanceof S?b:new S(b),d=a,e;null!==(e=I(c));)d=new Wc(e,d,t(d.A.children,e)||new Vc),c=T(c);return d}h=Wc.prototype;h.za=function(){return this.A.value};function Yc(a,b){y("undefined"!==typeof b,"Cannot set value to undefined");a.A.value=b;Zc(a)}h.clear=function(){this.A.value=null;this.A.children={};this.A.bd=0;Zc(this)};
h.md=function(){return 0<this.A.bd};h.e=function(){return null===this.za()&&!this.md()};h.U=function(a){var b=this;A(this.A.children,function(c,d){a(new Wc(d,b,c))})};function $c(a,b,c,d){c&&!d&&b(a);a.U(function(a){$c(a,b,!0,d)});c&&d&&b(a)}function ad(a,b){for(var c=a.parent();null!==c&&!b(c);)c=c.parent()}h.path=function(){return new S(null===this.Oc?this.zd:this.Oc.path()+"/"+this.zd)};h.name=function(){return this.zd};h.parent=function(){return this.Oc};
function Zc(a){if(null!==a.Oc){var b=a.Oc,c=a.zd,d=a.e(),e=s(b.A.children,c);d&&e?(delete b.A.children[c],b.A.bd--,Zc(b)):d||e||(b.A.children[c]=a.A,b.A.bd++,Zc(b))}};function bd(a,b){this.Ja=a;this.va=b?b:cd}h=bd.prototype;h.La=function(a,b){return new bd(this.Ja,this.va.La(a,b,this.Ja).Y(null,null,!1,null,null))};h.remove=function(a){return new bd(this.Ja,this.va.remove(a,this.Ja).Y(null,null,!1,null,null))};h.get=function(a){for(var b,c=this.va;!c.e();){b=this.Ja(a,c.key);if(0===b)return c.value;0>b?c=c.left:0<b&&(c=c.right)}return null};
function dd(a,b){for(var c,d=a.va,e=null;!d.e();){c=a.Ja(b,d.key);if(0===c){if(d.left.e())return e?e.key:null;for(d=d.left;!d.right.e();)d=d.right;return d.key}0>c?d=d.left:0<c&&(e=d,d=d.right)}throw Error("Attempted to find predecessor key for a nonexistent key.  What gives?");}h.e=function(){return this.va.e()};h.count=function(){return this.va.count()};h.Ic=function(){return this.va.Ic()};h.Yb=function(){return this.va.Yb()};h.fa=function(a){return this.va.fa(a)};
h.Pb=function(a){return new ed(this.va,null,this.Ja,!1,a)};h.Qb=function(a,b){return new ed(this.va,a,this.Ja,!1,b)};h.Sb=function(a,b){return new ed(this.va,a,this.Ja,!0,b)};h.hf=function(a){return new ed(this.va,null,this.Ja,!0,a)};function ed(a,b,c,d,e){this.Nd=e||null;this.ze=d;this.Na=[];for(e=1;!a.e();)if(e=b?c(a.key,b):1,d&&(e*=-1),0>e)a=this.ze?a.left:a.right;else if(0===e){this.Na.push(a);break}else this.Na.push(a),a=this.ze?a.right:a.left}
function P(a){if(0===a.Na.length)return null;var b=a.Na.pop(),c;c=a.Nd?a.Nd(b.key,b.value):{key:b.key,value:b.value};if(a.ze)for(b=b.left;!b.e();)a.Na.push(b),b=b.right;else for(b=b.right;!b.e();)a.Na.push(b),b=b.left;return c}function fd(a){if(0===a.Na.length)return null;var b;b=a.Na;b=b[b.length-1];return a.Nd?a.Nd(b.key,b.value):{key:b.key,value:b.value}}function gd(a,b,c,d,e){this.key=a;this.value=b;this.color=null!=c?c:!0;this.left=null!=d?d:cd;this.right=null!=e?e:cd}h=gd.prototype;
h.Y=function(a,b,c,d,e){return new gd(null!=a?a:this.key,null!=b?b:this.value,null!=c?c:this.color,null!=d?d:this.left,null!=e?e:this.right)};h.count=function(){return this.left.count()+1+this.right.count()};h.e=function(){return!1};h.fa=function(a){return this.left.fa(a)||a(this.key,this.value)||this.right.fa(a)};function hd(a){return a.left.e()?a:hd(a.left)}h.Ic=function(){return hd(this).key};h.Yb=function(){return this.right.e()?this.key:this.right.Yb()};
h.La=function(a,b,c){var d,e;e=this;d=c(a,e.key);e=0>d?e.Y(null,null,null,e.left.La(a,b,c),null):0===d?e.Y(null,b,null,null,null):e.Y(null,null,null,null,e.right.La(a,b,c));return id(e)};function jd(a){if(a.left.e())return cd;a.left.ca()||a.left.left.ca()||(a=kd(a));a=a.Y(null,null,null,jd(a.left),null);return id(a)}
h.remove=function(a,b){var c,d;c=this;if(0>b(a,c.key))c.left.e()||c.left.ca()||c.left.left.ca()||(c=kd(c)),c=c.Y(null,null,null,c.left.remove(a,b),null);else{c.left.ca()&&(c=md(c));c.right.e()||c.right.ca()||c.right.left.ca()||(c=nd(c),c.left.left.ca()&&(c=md(c),c=nd(c)));if(0===b(a,c.key)){if(c.right.e())return cd;d=hd(c.right);c=c.Y(d.key,d.value,null,null,jd(c.right))}c=c.Y(null,null,null,null,c.right.remove(a,b))}return id(c)};h.ca=function(){return this.color};
function id(a){a.right.ca()&&!a.left.ca()&&(a=od(a));a.left.ca()&&a.left.left.ca()&&(a=md(a));a.left.ca()&&a.right.ca()&&(a=nd(a));return a}function kd(a){a=nd(a);a.right.left.ca()&&(a=a.Y(null,null,null,null,md(a.right)),a=od(a),a=nd(a));return a}function od(a){return a.right.Y(null,null,a.color,a.Y(null,null,!0,null,a.right.left),null)}function md(a){return a.left.Y(null,null,a.color,null,a.Y(null,null,!0,a.left.right,null))}
function nd(a){return a.Y(null,null,!a.color,a.left.Y(null,null,!a.left.color,null,null),a.right.Y(null,null,!a.right.color,null,null))}function pd(){}h=pd.prototype;h.Y=function(){return this};h.La=function(a,b){return new gd(a,b,null)};h.remove=function(){return this};h.count=function(){return 0};h.e=function(){return!0};h.fa=function(){return!1};h.Ic=function(){return null};h.Yb=function(){return null};h.ca=function(){return!1};var cd=new pd;function qd(a,b){this.F=a;y(m(this.F)&&null!==this.F,"LeafNode shouldn't be created with null/undefined value.");this.ha=b||M;rd(this.ha);this.tb=null}h=qd.prototype;h.M=function(){return!0};h.L=function(){return this.ha};h.$=function(a){return new qd(this.F,a)};h.K=function(a){return".priority"===a?this.ha:M};h.ra=function(a){return a.e()?this:".priority"===I(a)?this.ha:M};h.Da=function(){return!1};h.gf=function(){return null};
h.P=function(a,b){return".priority"===a?this.$(b):b.e()&&".priority"!==a?this:M.P(a,b).$(this.ha)};h.D=function(a,b){var c=I(a);if(null===c)return b;if(b.e()&&".priority"!==c)return this;y(".priority"!==c||1===Tc(a),".priority must be the last token in a path");return this.P(c,M.D(T(a),b))};h.e=function(){return!1};h.vb=function(){return 0};h.I=function(a){return a&&!this.L().e()?{".value":this.za(),".priority":this.L().I()}:this.za()};
h.hash=function(){if(null===this.tb){var a="";this.ha.e()||(a+="priority:"+sd(this.ha.I())+":");var b=typeof this.F,a=a+(b+":"),a="number"===b?a+Ab(this.F):a+this.F;this.tb=ib(a)}return this.tb};h.za=function(){return this.F};h.dd=function(a){if(a===M)return 1;if(a instanceof W)return-1;y(a.M(),"Unknown node type");var b=typeof a.F,c=typeof this.F,d=Ga(td,b),e=Ga(td,c);y(0<=d,"Unknown leaf type: "+b);y(0<=e,"Unknown leaf type: "+c);return d===e?"object"===c?0:this.F<a.F?-1:this.F===a.F?0:1:e-d};
var td=["object","boolean","number","string"];qd.prototype.hb=function(){return this};qd.prototype.Bc=function(){return!0};qd.prototype.aa=function(a){return a===this?!0:a.M()?this.F===a.F&&this.ha.aa(a.ha):!1};qd.prototype.toString=function(){return r(this.I(!0))};function ud(a,b){this.qd=a;this.Wb=b}ud.prototype.get=function(a){var b=t(this.qd,a);if(!b)throw Error("No index defined for "+a);return b===lc?null:b};function vd(a,b,c){var d=wd(a.qd,function(d,f){var g=t(a.Wb,f);y(g,"Missing index implementation for "+f);if(d===lc){if(g.sd(b.V)){for(var k=[],l=c.Pb(Cc),n=P(l);n;)n.name!=b.name&&k.push(n),n=P(l);k.push(b);return xd(k,mc(g))}return lc}g=c.get(b.name);k=d;g&&(k=k.remove(new N(b.name,g)));return k.La(b,b.V)});return new ud(d,a.Wb)}
function yd(a,b,c){var d=wd(a.qd,function(a){if(a===lc)return a;var d=c.get(b.name);return d?a.remove(new N(b.name,d)):a});return new ud(d,a.Wb)}var zd=new ud({".priority":lc},{".priority":L});function W(a,b,c){this.m=a;(this.ha=b)&&rd(this.ha);this.pb=c;this.tb=null}h=W.prototype;h.M=function(){return!1};h.L=function(){return this.ha||M};h.$=function(a){return new W(this.m,a,this.pb)};h.K=function(a){if(".priority"===a)return this.L();a=this.m.get(a);return null===a?M:a};h.ra=function(a){var b=I(a);return null===b?this:this.K(b).ra(T(a))};h.Da=function(a){return null!==this.m.get(a)};
h.P=function(a,b){y(b,"We should always be passing snapshot nodes");if(".priority"===a)return this.$(b);var c=new N(a,b),d;b.e()?(d=this.m.remove(a),c=yd(this.pb,c,this.m)):(d=this.m.La(a,b),c=vd(this.pb,c,this.m));return new W(d,this.ha,c)};h.D=function(a,b){var c=I(a);if(null===c)return b;y(".priority"!==I(a)||1===Tc(a),".priority must be the last token in a path");var d=this.K(c).D(T(a),b);return this.P(c,d)};h.e=function(){return this.m.e()};h.vb=function(){return this.m.count()};var Ad=/^(0|[1-9]\d*)$/;
h=W.prototype;h.I=function(a){if(this.e())return null;var b={},c=0,d=0,e=!0;this.U(L,function(f,g){b[f]=g.I(a);c++;e&&Ad.test(f)?d=Math.max(d,Number(f)):e=!1});if(!a&&e&&d<2*c){var f=[],g;for(g in b)f[g]=b[g];return f}a&&!this.L().e()&&(b[".priority"]=this.L().I());return b};h.hash=function(){if(null===this.tb){var a="";this.L().e()||(a+="priority:"+sd(this.L().I())+":");this.U(L,function(b,c){var d=c.hash();""!==d&&(a+=":"+b+":"+d)});this.tb=""===a?"":ib(a)}return this.tb};
h.gf=function(a,b,c){return(c=Bd(this,c))?(a=dd(c,new N(a,b)))?a.name:null:dd(this.m,a)};function Fc(a,b){var c;c=(c=Bd(a,b))?(c=c.Ic())&&c.name:a.m.Ic();return c?new N(c,a.m.get(c)):null}function Gc(a,b){var c;c=(c=Bd(a,b))?(c=c.Yb())&&c.name:a.m.Yb();return c?new N(c,a.m.get(c)):null}h.U=function(a,b){var c=Bd(this,a);return c?c.fa(function(a){return b(a.name,a.V)}):this.m.fa(b)};h.Pb=function(a){return this.Qb(a.yd(),a)};
h.Qb=function(a,b){var c=Bd(this,b);if(c)return c.Qb(a,function(a){return a});for(var c=this.m.Qb(a.name,Cc),d=fd(c);null!=d&&0>b.compare(d,a);)P(c),d=fd(c);return c};h.hf=function(a){return this.Sb(a.wd(),a)};h.Sb=function(a,b){var c=Bd(this,b);if(c)return c.Sb(a,function(a){return a});for(var c=this.m.Sb(a.name,Cc),d=fd(c);null!=d&&0<b.compare(d,a);)P(c),d=fd(c);return c};h.dd=function(a){return this.e()?a.e()?0:-1:a.M()||a.e()?1:a===pc?-1:0};
h.hb=function(a){if(a===rc||Cd(this.pb.Wb,a.toString()))return this;var b=this.pb,c=this.m;y(a!==rc,"KeyIndex always exists and isn't meant to be added to the IndexMap.");for(var d=[],e=!1,c=c.Pb(Cc),f=P(c);f;)e=e||a.sd(f.V),d.push(f),f=P(c);d=e?xd(d,mc(a)):lc;e=a.toString();c=Dd(b.Wb);c[e]=a;a=Dd(b.qd);a[e]=d;return new W(this.m,this.ha,new ud(a,c))};h.Bc=function(a){return a===rc||Cd(this.pb.Wb,a.toString())};
h.aa=function(a){if(a===this)return!0;if(a.M())return!1;if(this.L().aa(a.L())&&this.m.count()===a.m.count()){var b=this.Pb(L);a=a.Pb(L);for(var c=P(b),d=P(a);c&&d;){if(c.name!==d.name||!c.V.aa(d.V))return!1;c=P(b);d=P(a)}return null===c&&null===d}return!1};function Bd(a,b){return b===rc?null:a.pb.get(b.toString())}h.toString=function(){return r(this.I(!0))};function O(a,b){if(null===a)return M;var c=null;"object"===typeof a&&".priority"in a?c=a[".priority"]:"undefined"!==typeof b&&(c=b);y(null===c||"string"===typeof c||"number"===typeof c||"object"===typeof c&&".sv"in c,"Invalid priority type found: "+typeof c);"object"===typeof a&&".value"in a&&null!==a[".value"]&&(a=a[".value"]);if("object"!==typeof a||".sv"in a)return new qd(a,O(c));if(a instanceof Array){var d=M,e=a;A(e,function(a,b){if(s(e,b)&&"."!==b.substring(0,1)){var c=O(a);if(c.M()||!c.e())d=
d.P(b,c)}});return d.$(O(c))}var f=[],g=!1,k=a;ua(k,function(a){if("string"!==typeof a||"."!==a.substring(0,1)){var b=O(k[a]);b.e()||(g=g||!b.L().e(),f.push(new N(a,b)))}});var l=xd(f,ic,function(a){return a.name},jc);if(g){var n=xd(f,mc(L));return new W(l,O(c),new ud({".priority":n},{".priority":L}))}return new W(l,O(c),zd)}var Ed=Math.log(2);function Fd(a){this.count=parseInt(Math.log(a+1)/Ed,10);this.af=this.count-1;this.Nf=a+1&parseInt(Array(this.count+1).join("1"),2)}
function Gd(a){var b=!(a.Nf&1<<a.af);a.af--;return b}
function xd(a,b,c,d){function e(b,d){var f=d-b;if(0==f)return null;if(1==f){var n=a[b],u=c?c(n):n;return new gd(u,n.V,!1,null,null)}var n=parseInt(f/2,10)+b,f=e(b,n),x=e(n+1,d),n=a[n],u=c?c(n):n;return new gd(u,n.V,!1,f,x)}a.sort(b);var f=function(b){function d(b,g){var k=u-b,x=u;u-=b;var x=e(k+1,x),k=a[k],F=c?c(k):k,x=new gd(F,k.V,g,null,x);f?f.left=x:n=x;f=x}for(var f=null,n=null,u=a.length,x=0;x<b.count;++x){var F=Gd(b),ld=Math.pow(2,b.count-(x+1));F?d(ld,!1):(d(ld,!1),d(ld,!0))}return n}(new Fd(a.length));
return null!==f?new bd(d||b,f):new bd(d||b)}function sd(a){return"number"===typeof a?"number:"+Ab(a):"string:"+a}function rd(a){if(a.M()){var b=a.I();y("string"===typeof b||"number"===typeof b||"object"===typeof b&&s(b,".sv"),"Priority must be a string or number.")}else y(a===pc||a.e(),"priority of unexpected type.");y(a===pc||a.L().e(),"Priority nodes can't have a priority of their own.")}var M=new W(new bd(jc),null,zd);function Hd(){W.call(this,new bd(jc),M,zd)}ma(Hd,W);h=Hd.prototype;
h.dd=function(a){return a===this?0:1};h.aa=function(a){return a===this};h.L=function(){throw fb("Why is this called?");};h.K=function(){return M};h.e=function(){return!1};var pc=new Hd,nc=new N("[MIN_NAME]",M),tc=new N("[MAX_NAME]",pc);function D(a,b,c){this.A=a;this.W=b;this.g=c}D.prototype.I=function(){E("Firebase.DataSnapshot.val",0,0,arguments.length);return this.A.I()};D.prototype.val=D.prototype.I;D.prototype.cf=function(){E("Firebase.DataSnapshot.exportVal",0,0,arguments.length);return this.A.I(!0)};D.prototype.exportVal=D.prototype.cf;D.prototype.Wf=function(){E("Firebase.DataSnapshot.exists",0,0,arguments.length);return!this.A.e()};D.prototype.exists=D.prototype.Wf;
D.prototype.u=function(a){E("Firebase.DataSnapshot.child",0,1,arguments.length);ga(a)&&(a=String(a));Yb("Firebase.DataSnapshot.child",a);var b=new S(a),c=this.W.u(b);return new D(this.A.ra(b),c,L)};D.prototype.child=D.prototype.u;D.prototype.Da=function(a){E("Firebase.DataSnapshot.hasChild",1,1,arguments.length);Yb("Firebase.DataSnapshot.hasChild",a);var b=new S(a);return!this.A.ra(b).e()};D.prototype.hasChild=D.prototype.Da;
D.prototype.L=function(){E("Firebase.DataSnapshot.getPriority",0,0,arguments.length);return this.A.L().I()};D.prototype.getPriority=D.prototype.L;D.prototype.forEach=function(a){E("Firebase.DataSnapshot.forEach",1,1,arguments.length);H("Firebase.DataSnapshot.forEach",1,a,!1);if(this.A.M())return!1;var b=this;return!!this.A.U(this.g,function(c,d){return a(new D(d,b.W.u(c),L))})};D.prototype.forEach=D.prototype.forEach;
D.prototype.md=function(){E("Firebase.DataSnapshot.hasChildren",0,0,arguments.length);return this.A.M()?!1:!this.A.e()};D.prototype.hasChildren=D.prototype.md;D.prototype.name=function(){z("Firebase.DataSnapshot.name() being deprecated. Please use Firebase.DataSnapshot.key() instead.");E("Firebase.DataSnapshot.name",0,0,arguments.length);return this.key()};D.prototype.name=D.prototype.name;D.prototype.key=function(){E("Firebase.DataSnapshot.key",0,0,arguments.length);return this.W.key()};
D.prototype.key=D.prototype.key;D.prototype.vb=function(){E("Firebase.DataSnapshot.numChildren",0,0,arguments.length);return this.A.vb()};D.prototype.numChildren=D.prototype.vb;D.prototype.dc=function(){E("Firebase.DataSnapshot.ref",0,0,arguments.length);return this.W};D.prototype.ref=D.prototype.dc;function Id(a){y(ea(a)&&0<a.length,"Requires a non-empty array");this.Ff=a;this.Gc={}}Id.prototype.$d=function(a,b){for(var c=this.Gc[a]||[],d=0;d<c.length;d++)c[d].rc.apply(c[d].Ka,Array.prototype.slice.call(arguments,1))};Id.prototype.wb=function(a,b,c){Jd(this,a);this.Gc[a]=this.Gc[a]||[];this.Gc[a].push({rc:b,Ka:c});(a=this.ue(a))&&b.apply(c,a)};Id.prototype.$b=function(a,b,c){Jd(this,a);a=this.Gc[a]||[];for(var d=0;d<a.length;d++)if(a[d].rc===b&&(!c||c===a[d].Ka)){a.splice(d,1);break}};
function Jd(a,b){y(Ma(a.Ff,function(a){return a===b}),"Unknown event: "+b)};function Kd(){Id.call(this,["visible"]);var a,b;"undefined"!==typeof document&&"undefined"!==typeof document.addEventListener&&("undefined"!==typeof document.hidden?(b="visibilitychange",a="hidden"):"undefined"!==typeof document.mozHidden?(b="mozvisibilitychange",a="mozHidden"):"undefined"!==typeof document.msHidden?(b="msvisibilitychange",a="msHidden"):"undefined"!==typeof document.webkitHidden&&(b="webkitvisibilitychange",a="webkitHidden"));this.nc=!0;if(b){var c=this;document.addEventListener(b,
function(){var b=!document[a];b!==c.nc&&(c.nc=b,c.$d("visible",b))},!1)}}ma(Kd,Id);ca(Kd);Kd.prototype.ue=function(a){y("visible"===a,"Unknown event type: "+a);return[this.nc]};function A(a,b){for(var c in a)b.call(void 0,a[c],c,a)}function wd(a,b){var c={},d;for(d in a)c[d]=b.call(void 0,a[d],d,a);return c}function Lb(a,b){for(var c in a)if(!b.call(void 0,a[c],c,a))return!1;return!0}function Jb(a){var b=0,c;for(c in a)b++;return b}function Kb(a){for(var b in a)return b}function Ld(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b}function Md(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b}function Cd(a,b){for(var c in a)if(a[c]==b)return!0;return!1}
function Nd(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d}function Od(a,b){var c=Nd(a,b,void 0);return c&&a[c]}function Pd(a){for(var b in a)return!1;return!0}function Qd(a,b){return b in a?a[b]:void 0}function Dd(a){var b={},c;for(c in a)b[c]=a[c];return b}var Rd="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Sd(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<Rd.length;f++)c=Rd[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};function Td(){this.uc={}}function Ud(a,b,c){m(c)||(c=1);s(a.uc,b)||(a.uc[b]=0);a.uc[b]+=c}Td.prototype.get=function(){return Dd(this.uc)};function Vd(a){this.Pf=a;this.td=null}Vd.prototype.get=function(){var a=this.Pf.get(),b=Dd(a);if(this.td)for(var c in this.td)b[c]-=this.td[c];this.td=a;return b};function Wd(a,b){this.zf={};this.Ud=new Vd(a);this.S=b;var c=1E4+2E4*Math.random();setTimeout(q(this.tf,this),Math.floor(c))}Wd.prototype.tf=function(){var a=this.Ud.get(),b={},c=!1,d;for(d in a)0<a[d]&&s(this.zf,d)&&(b[d]=a[d],c=!0);c&&(a=this.S,a.ja&&(b={c:b},a.f("reportStats",b),a.Ba("s",b)));setTimeout(q(this.tf,this),Math.floor(6E5*Math.random()))};var Xd={},Yd={};function Zd(a){a=a.toString();Xd[a]||(Xd[a]=new Td);return Xd[a]}function $d(a,b){var c=a.toString();Yd[c]||(Yd[c]=b());return Yd[c]};var ae=null;"undefined"!==typeof MozWebSocket?ae=MozWebSocket:"undefined"!==typeof WebSocket&&(ae=WebSocket);function be(a,b,c){this.me=a;this.f=ob(this.me);this.frames=this.Cc=null;this.jb=this.kb=this.Ue=0;this.Ra=Zd(b);this.$a=(b.Bb?"wss://":"ws://")+b.Ma+"/.ws?v=5";"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(this.$a+="&r=f");b.host!==b.Ma&&(this.$a=this.$a+"&ns="+b.ub);c&&(this.$a=this.$a+"&s="+c)}var ce;
be.prototype.open=function(a,b){this.fb=b;this.hg=a;this.f("Websocket connecting to "+this.$a);this.yc=!1;za.set("previous_websocket_failure",!0);try{this.ua=new ae(this.$a)}catch(c){this.f("Error instantiating WebSocket.");var d=c.message||c.data;d&&this.f(d);this.eb();return}var e=this;this.ua.onopen=function(){e.f("Websocket connected.");e.yc=!0};this.ua.onclose=function(){e.f("Websocket connection was disconnected.");e.ua=null;e.eb()};this.ua.onmessage=function(a){if(null!==e.ua)if(a=a.data,e.jb+=
a.length,Ud(e.Ra,"bytes_received",a.length),de(e),null!==e.frames)ee(e,a);else{a:{y(null===e.frames,"We already have a frame buffer");if(6>=a.length){var b=Number(a);if(!isNaN(b)){e.Ue=b;e.frames=[];a=null;break a}}e.Ue=1;e.frames=[]}null!==a&&ee(e,a)}};this.ua.onerror=function(a){e.f("WebSocket error.  Closing connection.");(a=a.message||a.data)&&e.f(a);e.eb()}};be.prototype.start=function(){};
be.isAvailable=function(){var a=!1;if("undefined"!==typeof navigator&&navigator.userAgent){var b=navigator.userAgent.match(/Android ([0-9]{0,}\.[0-9]{0,})/);b&&1<b.length&&4.4>parseFloat(b[1])&&(a=!0)}return!a&&null!==ae&&!ce};be.responsesRequiredToBeHealthy=2;be.healthyTimeout=3E4;h=be.prototype;h.vd=function(){za.remove("previous_websocket_failure")};function ee(a,b){a.frames.push(b);if(a.frames.length==a.Ue){var c=a.frames.join("");a.frames=null;c=ta(c);a.hg(c)}}
h.send=function(a){de(this);a=r(a);this.kb+=a.length;Ud(this.Ra,"bytes_sent",a.length);a=yb(a,16384);1<a.length&&this.ua.send(String(a.length));for(var b=0;b<a.length;b++)this.ua.send(a[b])};h.Uc=function(){this.rb=!0;this.Cc&&(clearInterval(this.Cc),this.Cc=null);this.ua&&(this.ua.close(),this.ua=null)};h.eb=function(){this.rb||(this.f("WebSocket is closing itself"),this.Uc(),this.fb&&(this.fb(this.yc),this.fb=null))};h.close=function(){this.rb||(this.f("WebSocket is being closed"),this.Uc())};
function de(a){clearInterval(a.Cc);a.Cc=setInterval(function(){a.ua&&a.ua.send("0");de(a)},Math.floor(45E3))};function fe(a){this.ac=a;this.Hd=[];this.Jb=0;this.le=-1;this.xb=null}function ge(a,b,c){a.le=b;a.xb=c;a.le<a.Jb&&(a.xb(),a.xb=null)}function he(a,b,c){for(a.Hd[b]=c;a.Hd[a.Jb];){var d=a.Hd[a.Jb];delete a.Hd[a.Jb];for(var e=0;e<d.length;++e)if(d[e]){var f=a;Cb(function(){f.ac(d[e])})}if(a.Jb===a.le){a.xb&&(clearTimeout(a.xb),a.xb(),a.xb=null);break}a.Jb++}};function ie(){this.set={}}h=ie.prototype;h.add=function(a,b){this.set[a]=null!==b?b:!0};h.contains=function(a){return s(this.set,a)};h.get=function(a){return this.contains(a)?this.set[a]:void 0};h.remove=function(a){delete this.set[a]};h.clear=function(){this.set={}};h.e=function(){return Pd(this.set)};h.count=function(){return Jb(this.set)};function je(a,b){A(a.set,function(a,d){b(d,a)})};function ke(a,b,c){this.me=a;this.f=ob(a);this.jb=this.kb=0;this.Ra=Zd(b);this.Rd=c;this.yc=!1;this.Zc=function(a){b.host!==b.Ma&&(a.ns=b.ub);var c=[],f;for(f in a)a.hasOwnProperty(f)&&c.push(f+"="+a[f]);return(b.Bb?"https://":"http://")+b.Ma+"/.lp?"+c.join("&")}}var le,me;
ke.prototype.open=function(a,b){this.$e=0;this.ga=b;this.mf=new fe(a);this.rb=!1;var c=this;this.mb=setTimeout(function(){c.f("Timed out trying to connect.");c.eb();c.mb=null},Math.floor(3E4));tb(function(){if(!c.rb){c.Pa=new ne(function(a,b,d,k,l){oe(c,arguments);if(c.Pa)if(c.mb&&(clearTimeout(c.mb),c.mb=null),c.yc=!0,"start"==a)c.id=b,c.rf=d;else if("close"===a)b?(c.Pa.Pd=!1,ge(c.mf,b,function(){c.eb()})):c.eb();else throw Error("Unrecognized command received: "+a);},function(a,b){oe(c,arguments);
he(c.mf,a,b)},function(){c.eb()},c.Zc);var a={start:"t"};a.ser=Math.floor(1E8*Math.random());c.Pa.ae&&(a.cb=c.Pa.ae);a.v="5";c.Rd&&(a.s=c.Rd);"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(a.r="f");a=c.Zc(a);c.f("Connecting via long-poll to "+a);pe(c.Pa,a,function(){})}})};
ke.prototype.start=function(){var a=this.Pa,b=this.rf;a.cg=this.id;a.dg=b;for(a.fe=!0;qe(a););a=this.id;b=this.rf;this.Zb=document.createElement("iframe");var c={dframe:"t"};c.id=a;c.pw=b;this.Zb.src=this.Zc(c);this.Zb.style.display="none";document.body.appendChild(this.Zb)};ke.isAvailable=function(){return!me&&!("object"===typeof window&&window.chrome&&window.chrome.extension&&!/^chrome/.test(window.location.href))&&!("object"===typeof Windows&&"object"===typeof Windows.Fg)&&(le||!0)};h=ke.prototype;
h.vd=function(){};h.Uc=function(){this.rb=!0;this.Pa&&(this.Pa.close(),this.Pa=null);this.Zb&&(document.body.removeChild(this.Zb),this.Zb=null);this.mb&&(clearTimeout(this.mb),this.mb=null)};h.eb=function(){this.rb||(this.f("Longpoll is closing itself"),this.Uc(),this.ga&&(this.ga(this.yc),this.ga=null))};h.close=function(){this.rb||(this.f("Longpoll is being closed."),this.Uc())};
h.send=function(a){a=r(a);this.kb+=a.length;Ud(this.Ra,"bytes_sent",a.length);a=jb(a);a=cb(a,!0);a=yb(a,1840);for(var b=0;b<a.length;b++){var c=this.Pa;c.Qc.push({ug:this.$e,Cg:a.length,bf:a[b]});c.fe&&qe(c);this.$e++}};function oe(a,b){var c=r(b).length;a.jb+=c;Ud(a.Ra,"bytes_received",c)}
function ne(a,b,c,d){this.Zc=d;this.fb=c;this.Je=new ie;this.Qc=[];this.oe=Math.floor(1E8*Math.random());this.Pd=!0;this.ae=eb();window["pLPCommand"+this.ae]=a;window["pRTLPCB"+this.ae]=b;a=document.createElement("iframe");a.style.display="none";if(document.body){document.body.appendChild(a);try{a.contentWindow.document||hb("No IE domain setting required")}catch(e){a.src="javascript:void((function(){document.open();document.domain='"+document.domain+"';document.close();})())"}}else throw"Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
a.contentDocument?a.ab=a.contentDocument:a.contentWindow?a.ab=a.contentWindow.document:a.document&&(a.ab=a.document);this.Aa=a;a="";this.Aa.src&&"javascript:"===this.Aa.src.substr(0,11)&&(a='<script>document.domain="'+document.domain+'";\x3c/script>');a="<html><body>"+a+"</body></html>";try{this.Aa.ab.open(),this.Aa.ab.write(a),this.Aa.ab.close()}catch(f){hb("frame writing exception"),f.stack&&hb(f.stack),hb(f)}}
ne.prototype.close=function(){this.fe=!1;if(this.Aa){this.Aa.ab.body.innerHTML="";var a=this;setTimeout(function(){null!==a.Aa&&(document.body.removeChild(a.Aa),a.Aa=null)},Math.floor(0))}var b=this.fb;b&&(this.fb=null,b())};
function qe(a){if(a.fe&&a.Pd&&a.Je.count()<(0<a.Qc.length?2:1)){a.oe++;var b={};b.id=a.cg;b.pw=a.dg;b.ser=a.oe;for(var b=a.Zc(b),c="",d=0;0<a.Qc.length;)if(1870>=a.Qc[0].bf.length+30+c.length){var e=a.Qc.shift(),c=c+"&seg"+d+"="+e.ug+"&ts"+d+"="+e.Cg+"&d"+d+"="+e.bf;d++}else break;re(a,b+c,a.oe);return!0}return!1}function re(a,b,c){function d(){a.Je.remove(c);qe(a)}a.Je.add(c);var e=setTimeout(d,Math.floor(25E3));pe(a,b,function(){clearTimeout(e);d()})}
function pe(a,b,c){setTimeout(function(){try{if(a.Pd){var d=a.Aa.ab.createElement("script");d.type="text/javascript";d.async=!0;d.src=b;d.onload=d.onreadystatechange=function(){var a=d.readyState;a&&"loaded"!==a&&"complete"!==a||(d.onload=d.onreadystatechange=null,d.parentNode&&d.parentNode.removeChild(d),c())};d.onerror=function(){hb("Long-poll script failed to load: "+b);a.Pd=!1;a.close()};a.Aa.ab.body.appendChild(d)}}catch(e){}},Math.floor(1))};function se(a){te(this,a)}var ue=[ke,be];function te(a,b){var c=be&&be.isAvailable(),d=c&&!(za.lf||!0===za.get("previous_websocket_failure"));b.Eg&&(c||z("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."),d=!0);if(d)a.Xc=[be];else{var e=a.Xc=[];zb(ue,function(a,b){b&&b.isAvailable()&&e.push(b)})}}function ve(a){if(0<a.Xc.length)return a.Xc[0];throw Error("No transports available");};function we(a,b,c,d,e,f){this.id=a;this.f=ob("c:"+this.id+":");this.ac=c;this.Kc=d;this.ga=e;this.He=f;this.O=b;this.Gd=[];this.Ye=0;this.Af=new se(b);this.Qa=0;this.f("Connection created");xe(this)}
function xe(a){var b=ve(a.Af);a.J=new b("c:"+a.id+":"+a.Ye++,a.O);a.Le=b.responsesRequiredToBeHealthy||0;var c=ye(a,a.J),d=ze(a,a.J);a.Yc=a.J;a.Tc=a.J;a.C=null;a.sb=!1;setTimeout(function(){a.J&&a.J.open(c,d)},Math.floor(0));b=b.healthyTimeout||0;0<b&&(a.od=setTimeout(function(){a.od=null;a.sb||(a.J&&102400<a.J.jb?(a.f("Connection exceeded healthy timeout but has received "+a.J.jb+" bytes.  Marking connection healthy."),a.sb=!0,a.J.vd()):a.J&&10240<a.J.kb?a.f("Connection exceeded healthy timeout but has sent "+
a.J.kb+" bytes.  Leaving connection alive."):(a.f("Closing unhealthy connection after timeout."),a.close()))},Math.floor(b)))}function ze(a,b){return function(c){b===a.J?(a.J=null,c||0!==a.Qa?1===a.Qa&&a.f("Realtime connection lost."):(a.f("Realtime connection failed."),"s-"===a.O.Ma.substr(0,2)&&(za.remove("host:"+a.O.host),a.O.Ma=a.O.host)),a.close()):b===a.C?(a.f("Secondary connection lost."),c=a.C,a.C=null,a.Yc!==c&&a.Tc!==c||a.close()):a.f("closing an old connection")}}
function ye(a,b){return function(c){if(2!=a.Qa)if(b===a.Tc){var d=wb("t",c);c=wb("d",c);if("c"==d){if(d=wb("t",c),"d"in c)if(c=c.d,"h"===d){var d=c.ts,e=c.v,f=c.h;a.Rd=c.s;Ba(a.O,f);0==a.Qa&&(a.J.start(),Ae(a,a.J,d),"5"!==e&&z("Protocol version mismatch detected"),c=a.Af,(c=1<c.Xc.length?c.Xc[1]:null)&&Be(a,c))}else if("n"===d){a.f("recvd end transmission on primary");a.Tc=a.C;for(c=0;c<a.Gd.length;++c)a.Cd(a.Gd[c]);a.Gd=[];Ce(a)}else"s"===d?(a.f("Connection shutdown command received. Shutting down..."),
a.He&&(a.He(c),a.He=null),a.ga=null,a.close()):"r"===d?(a.f("Reset packet received.  New host: "+c),Ba(a.O,c),1===a.Qa?a.close():(De(a),xe(a))):"e"===d?pb("Server Error: "+c):"o"===d?(a.f("got pong on primary."),Ee(a),Fe(a)):pb("Unknown control packet command: "+d)}else"d"==d&&a.Cd(c)}else if(b===a.C)if(d=wb("t",c),c=wb("d",c),"c"==d)"t"in c&&(c=c.t,"a"===c?Ge(a):"r"===c?(a.f("Got a reset on secondary, closing it"),a.C.close(),a.Yc!==a.C&&a.Tc!==a.C||a.close()):"o"===c&&(a.f("got pong on secondary."),
a.yf--,Ge(a)));else if("d"==d)a.Gd.push(c);else throw Error("Unknown protocol layer: "+d);else a.f("message on old connection")}}we.prototype.Ba=function(a){He(this,{t:"d",d:a})};function Ce(a){a.Yc===a.C&&a.Tc===a.C&&(a.f("cleaning up and promoting a connection: "+a.C.me),a.J=a.C,a.C=null)}
function Ge(a){0>=a.yf?(a.f("Secondary connection is healthy."),a.sb=!0,a.C.vd(),a.C.start(),a.f("sending client ack on secondary"),a.C.send({t:"c",d:{t:"a",d:{}}}),a.f("Ending transmission on primary"),a.J.send({t:"c",d:{t:"n",d:{}}}),a.Yc=a.C,Ce(a)):(a.f("sending ping on secondary."),a.C.send({t:"c",d:{t:"p",d:{}}}))}we.prototype.Cd=function(a){Ee(this);this.ac(a)};function Ee(a){a.sb||(a.Le--,0>=a.Le&&(a.f("Primary connection is healthy."),a.sb=!0,a.J.vd()))}
function Be(a,b){a.C=new b("c:"+a.id+":"+a.Ye++,a.O,a.Rd);a.yf=b.responsesRequiredToBeHealthy||0;a.C.open(ye(a,a.C),ze(a,a.C));setTimeout(function(){a.C&&(a.f("Timed out trying to upgrade."),a.C.close())},Math.floor(6E4))}function Ae(a,b,c){a.f("Realtime connection established.");a.J=b;a.Qa=1;a.Kc&&(a.Kc(c),a.Kc=null);0===a.Le?(a.f("Primary connection is healthy."),a.sb=!0):setTimeout(function(){Fe(a)},Math.floor(5E3))}
function Fe(a){a.sb||1!==a.Qa||(a.f("sending ping on primary."),He(a,{t:"c",d:{t:"p",d:{}}}))}function He(a,b){if(1!==a.Qa)throw"Connection is not connected";a.Yc.send(b)}we.prototype.close=function(){2!==this.Qa&&(this.f("Closing realtime connection."),this.Qa=2,De(this),this.ga&&(this.ga(),this.ga=null))};function De(a){a.f("Shutting down all connections");a.J&&(a.J.close(),a.J=null);a.C&&(a.C.close(),a.C=null);a.od&&(clearTimeout(a.od),a.od=null)};function Ie(){Id.call(this,["online"]);this.Lc=!0;if("undefined"!==typeof window&&"undefined"!==typeof window.addEventListener){var a=this;window.addEventListener("online",function(){a.Lc||a.$d("online",!0);a.Lc=!0},!1);window.addEventListener("offline",function(){a.Lc&&a.$d("online",!1);a.Lc=!1},!1)}}ma(Ie,Id);ca(Ie);Ie.prototype.ue=function(a){y("online"===a,"Unknown event type: "+a);return[this.Lc]};function Je(a){var b={},c={},d={},e="";try{var f=a.split("."),b=ta(gb(f[0])||""),c=ta(gb(f[1])||""),e=f[2],d=c.d||{};delete c.d}catch(g){}return{Hg:b,ke:c,data:d,yg:e}}function Ke(a){a=Je(a).ke;return"object"===typeof a&&a.hasOwnProperty("iat")?t(a,"iat"):null}function Le(a){a=Je(a);var b=a.ke;return!!a.yg&&!!b&&"object"===typeof b&&b.hasOwnProperty("iat")};function Me(a,b,c,d){this.id=Ne++;this.f=ob("p:"+this.id+":");this.Db=!0;this.ta={};this.la=[];this.Nc=0;this.Jc=[];this.ja=!1;this.Wa=1E3;this.xd=3E5;this.Dd=b;this.Bd=c;this.Ie=d;this.O=a;this.Pe=null;this.Sc={};this.tg=0;this.Dc=this.Ae=null;Oe(this,0);Kd.Ob().wb("visible",this.kg,this);-1===a.host.indexOf("fblocal")&&Ie.Ob().wb("online",this.ig,this)}var Ne=0,Pe=0;h=Me.prototype;
h.Ba=function(a,b,c){var d=++this.tg;a={r:d,a:a,b:b};this.f(r(a));y(this.ja,"sendRequest call when we're not connected not allowed.");this.Oa.Ba(a);c&&(this.Sc[d]=c)};function Qe(a,b,c,d,e){var f=b.Fa(),g=b.path.toString();a.f("Listen called for "+g+" "+f);a.ta[g]=a.ta[g]||{};y(!a.ta[g][f],"listen() called twice for same path/queryId.");b={H:e,nd:c,qg:Lc(b.n),tag:d};a.ta[g][f]=b;a.ja&&Re(a,g,f,b)}
function Re(a,b,c,d){a.f("Listen on "+b+" for "+c);var e={p:b};d.tag&&(e.q=d.qg,e.t=d.tag);e.h=d.nd();a.Ba("q",e,function(e){if((a.ta[b]&&a.ta[b][c])===d){a.f("listen response",e);var g=e.s;"ok"!==g&&Se(a,b,c);e=e.d;d.H&&d.H(g,e)}})}h.Q=function(a,b,c){this.Ib={Rf:a,df:!1,rc:b,ad:c};this.f("Authenticating using credential: "+a);Te(this);(b=40==a.length)||(a=Je(a).ke,b="object"===typeof a&&!0===t(a,"admin"));b&&(this.f("Admin auth credential detected.  Reducing max reconnect time."),this.xd=3E4)};
h.Ve=function(a){delete this.Ib;this.ja&&this.Ba("unauth",{},function(b){a(b.s,b.d)})};function Te(a){var b=a.Ib;a.ja&&b&&a.Ba("auth",{cred:b.Rf},function(c){var d=c.s;c=c.d||"error";"ok"!==d&&a.Ib===b&&delete a.Ib;b.df?"ok"!==d&&b.ad&&b.ad(d,c):(b.df=!0,b.rc&&b.rc(d,c))})}function Ue(a,b,c,d){a.ja?Ve(a,"o",b,c,d):a.Jc.push({Pc:b,action:"o",data:c,H:d})}function We(a,b,c,d){a.ja?Ve(a,"om",b,c,d):a.Jc.push({Pc:b,action:"om",data:c,H:d})}
h.Ge=function(a,b){this.ja?Ve(this,"oc",a,null,b):this.Jc.push({Pc:a,action:"oc",data:null,H:b})};function Ve(a,b,c,d,e){c={p:c,d:d};a.f("onDisconnect "+b,c);a.Ba(b,c,function(a){e&&setTimeout(function(){e(a.s,a.d)},Math.floor(0))})}h.put=function(a,b,c,d){Xe(this,"p",a,b,c,d)};function Ye(a,b,c,d){Xe(a,"m",b,c,d,void 0)}function Xe(a,b,c,d,e,f){d={p:c,d:d};m(f)&&(d.h=f);a.la.push({action:b,uf:d,H:e});a.Nc++;b=a.la.length-1;a.ja?Ze(a,b):a.f("Buffering put: "+c)}
function Ze(a,b){var c=a.la[b].action,d=a.la[b].uf,e=a.la[b].H;a.la[b].rg=a.ja;a.Ba(c,d,function(d){a.f(c+" response",d);delete a.la[b];a.Nc--;0===a.Nc&&(a.la=[]);e&&e(d.s,d.d)})}
h.Cd=function(a){if("r"in a){this.f("from server: "+r(a));var b=a.r,c=this.Sc[b];c&&(delete this.Sc[b],c(a.b))}else{if("error"in a)throw"A server-side error has occurred: "+a.error;"a"in a&&(b=a.a,c=a.b,this.f("handleServerMessage",b,c),"d"===b?this.Dd(c.p,c.d,!1,c.t):"m"===b?this.Dd(c.p,c.d,!0,c.t):"c"===b?$e(this,c.p,c.q):"ac"===b?(a=c.s,b=c.d,c=this.Ib,delete this.Ib,c&&c.ad&&c.ad(a,b)):"sd"===b?this.Pe?this.Pe(c):"msg"in c&&"undefined"!==typeof console&&console.log("FIREBASE: "+c.msg.replace("\n",
"\nFIREBASE: ")):pb("Unrecognized action received from server: "+r(b)+"\nAre you using the latest client?"))}};h.Kc=function(a){this.f("connection ready");this.ja=!0;this.Dc=(new Date).getTime();this.Ie({serverTimeOffset:a-(new Date).getTime()});af(this);this.Bd(!0)};function Oe(a,b){y(!a.Oa,"Scheduling a connect when we're already connected/ing?");a.Kb&&clearTimeout(a.Kb);a.Kb=setTimeout(function(){a.Kb=null;bf(a)},Math.floor(b))}
h.kg=function(a){a&&!this.nc&&this.Wa===this.xd&&(this.f("Window became visible.  Reducing delay."),this.Wa=1E3,this.Oa||Oe(this,0));this.nc=a};h.ig=function(a){a?(this.f("Browser went online.  Reconnecting."),this.Wa=1E3,this.Db=!0,this.Oa||Oe(this,0)):(this.f("Browser went offline.  Killing connection; don't reconnect."),this.Db=!1,this.Oa&&this.Oa.close())};
h.of=function(){this.f("data client disconnected");this.ja=!1;this.Oa=null;for(var a=0;a<this.la.length;a++){var b=this.la[a];b&&"h"in b.uf&&b.rg&&(b.H&&b.H("disconnect"),delete this.la[a],this.Nc--)}0===this.Nc&&(this.la=[]);if(this.Db)this.nc?this.Dc&&(3E4<(new Date).getTime()-this.Dc&&(this.Wa=1E3),this.Dc=null):(this.f("Window isn't visible.  Delaying reconnect."),this.Wa=this.xd,this.Ae=(new Date).getTime()),a=Math.max(0,this.Wa-((new Date).getTime()-this.Ae)),a*=Math.random(),this.f("Trying to reconnect in "+
a+"ms"),Oe(this,a),this.Wa=Math.min(this.xd,1.3*this.Wa);else for(var c in this.Sc)delete this.Sc[c];this.Bd(!1)};function bf(a){if(a.Db){a.f("Making a connection attempt");a.Ae=(new Date).getTime();a.Dc=null;var b=q(a.Cd,a),c=q(a.Kc,a),d=q(a.of,a),e=a.id+":"+Pe++;a.Oa=new we(e,a.O,b,c,d,function(b){z(b+" ("+a.O.toString()+")");a.Db=!1})}}h.qb=function(){this.Db=!1;this.Oa?this.Oa.close():(this.Kb&&(clearTimeout(this.Kb),this.Kb=null),this.ja&&this.of())};
h.ic=function(){this.Db=!0;this.Wa=1E3;this.Oa||Oe(this,0)};function $e(a,b,c){c=c?Ja(c,function(a){return xb(a)}).join("$"):"default";(a=Se(a,b,c))&&a.H&&a.H("permission_denied")}function Se(a,b,c){b=(new S(b)).toString();var d;m(a.ta[b])?(d=a.ta[b][c],delete a.ta[b][c],0===Jb(a.ta[b])&&delete a.ta[b]):d=void 0;return d}
function af(a){Te(a);A(a.ta,function(b,d){A(b,function(b,c){Re(a,d,c,b)})});for(var b=0;b<a.la.length;b++)a.la[b]&&Ze(a,b);for(;a.Jc.length;)b=a.Jc.shift(),Ve(a,b.action,b.Pc,b.data,b.H)};function cf(){this.m=this.F=null}cf.prototype.ec=function(a,b){if(a.e())this.F=b,this.m=null;else if(null!==this.F)this.F=this.F.D(a,b);else{null==this.m&&(this.m=new ie);var c=I(a);this.m.contains(c)||this.m.add(c,new cf);c=this.m.get(c);a=T(a);c.ec(a,b)}};
function df(a,b){if(b.e())return a.F=null,a.m=null,!0;if(null!==a.F){if(a.F.M())return!1;var c=a.F;a.F=null;c.U(L,function(b,c){a.ec(new S(b),c)});return df(a,b)}return null!==a.m?(c=I(b),b=T(b),a.m.contains(c)&&df(a.m.get(c),b)&&a.m.remove(c),a.m.e()?(a.m=null,!0):!1):!0}function ef(a,b,c){null!==a.F?c(b,a.F):a.U(function(a,e){var f=new S(b.toString()+"/"+a);ef(e,f,c)})}cf.prototype.U=function(a){null!==this.m&&je(this.m,function(b,c){a(b,c)})};function ff(){this.Od=M}ff.prototype.j=function(a){return this.Od.ra(a)};ff.prototype.toString=function(){return this.Od.toString()};function gf(){this.ob=[]}function hf(a,b){for(var c=null,d=0;d<b.length;d++){var e=b[d],f=e.Rb();null===c||f.aa(c.Rb())||(a.ob.push(c),c=null);null===c&&(c=new jf(f));c.add(e)}c&&a.ob.push(c)}function Sc(a,b,c){hf(a,c);kf(a,function(a){return a.aa(b)})}function lf(a,b,c){hf(a,c);kf(a,function(a){return a.contains(b)||b.contains(a)})}
function kf(a,b){for(var c=!0,d=0;d<a.ob.length;d++){var e=a.ob[d];if(e)if(e=e.Rb(),b(e)){for(var e=a.ob[d],f=0;f<e.ld.length;f++){var g=e.ld[f];if(null!==g){e.ld[f]=null;var k=g.Mb();lb&&hb("event: "+g.toString());Cb(k)}}a.ob[d]=null}else c=!1}c&&(a.ob=[])}function jf(a){this.Ea=a;this.ld=[]}jf.prototype.add=function(a){this.ld.push(a)};jf.prototype.Rb=function(){return this.Ea};var mf="auth.firebase.com";function nf(a,b,c){this.cd=a||{};this.Zd=b||{};this.Xa=c||{};this.cd.remember||(this.cd.remember="default")}var of=["remember","redirectTo"];function pf(a){var b={},c={};ua(a||{},function(a,e){0<=Ga(of,a)?b[a]=e:c[a]=e});return new nf(b,{},c)};var qf={NETWORK_ERROR:"Unable to contact the Firebase server.",SERVER_ERROR:"An unknown server error occurred.",TRANSPORT_UNAVAILABLE:"There are no login transports available for the requested method.",REQUEST_INTERRUPTED:"The browser redirected the page before the login request could complete.",USER_CANCELLED:"The user cancelled authentication."};function X(a){var b=Error(t(qf,a),a);b.code=a;return b};function rf(){var a=window.opener.frames,b;for(b=a.length-1;0<=b;b--)try{if(a[b].location.protocol===window.location.protocol&&a[b].location.host===window.location.host&&"__winchan_relay_frame"===a[b].name)return a[b]}catch(c){}return null}function sf(a,b,c){a.attachEvent?a.attachEvent("on"+b,c):a.addEventListener&&a.addEventListener(b,c,!1)}function tf(a,b,c){a.detachEvent?a.detachEvent("on"+b,c):a.removeEventListener&&a.removeEventListener(b,c,!1)}
function uf(a){/^https?:\/\//.test(a)||(a=window.location.href);var b=/^(https?:\/\/[\-_a-zA-Z\.0-9:]+)/.exec(a);return b?b[1]:a}function vf(a){var b="";try{a=a.replace("#","");var c={},d=a.replace(/^\?/,"").split("&");for(a=0;a<d.length;a++)if(d[a]){var e=d[a].split("=");c[e[0]]=e[1]}c&&s(c,"__firebase_request_key")&&(b=t(c,"__firebase_request_key"))}catch(f){}return b}
function wf(a){var b=[],c;for(c in a)if(s(a,c)){var d=t(a,c);if(ea(d))for(var e=0;e<d.length;e++)b.push(encodeURIComponent(c)+"="+encodeURIComponent(d[e]));else b.push(encodeURIComponent(c)+"="+encodeURIComponent(t(a,c)))}return b?"&"+b.join("&"):""}function xf(){var a=rb(mf);return a.scheme+"://"+a.host+"/v2"}function yf(a){return xf()+"/"+a+"/auth/channel"};function zf(){return!!(window.cordova||window.phonegap||window.PhoneGap)&&/ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(navigator.userAgent)}function Af(){var a=navigator.userAgent;if("Microsoft Internet Explorer"===navigator.appName){if((a=a.match(/MSIE ([0-9]{1,}[\.0-9]{0,})/))&&1<a.length)return 8<=parseFloat(a[1])}else if(-1<a.indexOf("Trident")&&(a=a.match(/rv:([0-9]{2,2}[\.0-9]{0,})/))&&1<a.length)return 8<=parseFloat(a[1]);return!1};function Bf(a){a.method||(a.method="GET");a.headers||(a.headers={});a.headers.content_type||(a.headers.content_type="application/json");a.headers.content_type=a.headers.content_type.toLowerCase();this.options=a}
Bf.prototype.open=function(a,b,c){function d(){c&&(c(X("REQUEST_INTERRUPTED")),c=null)}var e=new XMLHttpRequest,f=this.options.method.toUpperCase(),g;sf(window,"beforeunload",d);e.onreadystatechange=function(){if(c&&4===e.readyState){var a;if(200<=e.status&&300>e.status){try{a=ta(e.responseText)}catch(b){}c(null,a)}else 500<=e.status&&600>e.status?c(X("SERVER_ERROR")):c(X("NETWORK_ERROR"));c=null;tf(window,"beforeunload",d)}};if("GET"===f)a+=(/\?/.test(a)?"":"?")+wf(b),g=null;else{var k=this.options.headers.content_type;
"application/json"===k&&(g=r(b));"application/x-www-form-urlencoded"===k&&(g=wf(b))}e.open(f,a,!0);a={"X-Requested-With":"XMLHttpRequest",Accept:"application/json;text/plain"};Sd(a,this.options.headers);for(var l in a)e.setRequestHeader(l,a[l]);e.send(g)};Bf.isAvailable=function(){return!!window.XMLHttpRequest&&"string"===typeof(new XMLHttpRequest).responseType&&(!(navigator.userAgent.match(/MSIE/)||navigator.userAgent.match(/Trident/))||Af())};Bf.prototype.tc=function(){return"json"};function Cf(a){this.gc=Fa()+Fa()+Fa();this.pf=a}
Cf.prototype.open=function(a,b,c){function d(){c&&(c(X("USER_CANCELLED")),c=null)}var e=this,f=rb(mf),g;b.requestId=this.gc;b.redirectTo=f.scheme+"://"+f.host+"/blank/page.html";a+=/\?/.test(a)?"":"?";a+=wf(b);(g=window.open(a,"_blank","location=no"))&&ha(g.addEventListener)?(g.addEventListener("loadstart",function(a){var b;if(b=a&&a.url)a:{var n=a.url;try{var u=document.createElement("a");u.href=n;b=u.host===f.host&&"/blank/page.html"===u.pathname;break a}catch(x){}b=!1}b&&(a=vf(a.url),g.removeEventListener("exit",
d),g.close(),a=new nf(null,null,{requestId:e.gc,requestKey:a}),e.pf.requestWithCredential("/auth/session",a,c),c=null)}),g.addEventListener("exit",d)):c(X("TRANSPORT_UNAVAILABLE"))};Cf.isAvailable=function(){return zf()};Cf.prototype.tc=function(){return"redirect"};function Df(a){if(!a.window_features||-1!==navigator.userAgent.indexOf("Fennec/")||-1!==navigator.userAgent.indexOf("Firefox/")&&-1!==navigator.userAgent.indexOf("Android"))a.window_features=void 0;a.window_name||(a.window_name="_blank");this.options=a}
Df.prototype.open=function(a,b,c){function d(a){g&&(document.body.removeChild(g),g=void 0);u&&(u=clearInterval(u));tf(window,"message",e);tf(window,"unload",d);if(n&&!a)try{n.close()}catch(b){k.postMessage("die",l)}n=k=void 0}function e(a){if(a.origin===l)try{var b=ta(a.data);"ready"===b.a?k.postMessage(x,l):"error"===b.a?(d(!1),c&&(c(b.d),c=null)):"response"===b.a&&(d(b.forceKeepWindowOpen),c&&(c(null,b.d),c=null))}catch(e){}}var f=Af(),g,k;if(!this.options.relay_url)return c(Error("invalid arguments: origin of url and relay_url must match"));
var l=uf(a);if(l!==uf(this.options.relay_url))c&&setTimeout(function(){c(Error("invalid arguments: origin of url and relay_url must match"))},0);else{f&&(g=document.createElement("iframe"),g.setAttribute("src",this.options.relay_url),g.style.display="none",g.setAttribute("name","__winchan_relay_frame"),document.body.appendChild(g),k=g.contentWindow);a+=(/\?/.test(a)?"":"?")+wf(b);var n=window.open(a,this.options.window_name,this.options.window_features);k||(k=n);var u=setInterval(function(){n&&n.closed&&
(d(!1),c&&(c(X("USER_CANCELLED")),c=null))},500),x=r({a:"request",d:b});sf(window,"unload",d);sf(window,"message",e)}};
Df.isAvailable=function(){return"postMessage"in window&&!/^file:\//.test(location.href)&&!(zf()||navigator.userAgent.match(/Windows Phone/)||window.Windows&&/^ms-appx:/.test(location.href)||navigator.userAgent.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i)||navigator.userAgent.match(/CriOS/)||navigator.userAgent.match(/Twitter for iPhone/)||navigator.userAgent.match(/FBAN\/FBIOS/)||window.navigator.standalone)&&!navigator.userAgent.match(/PhantomJS/)};Df.prototype.tc=function(){return"popup"};function Ef(a){a.callback_parameter||(a.callback_parameter="callback");this.options=a;window.__firebase_auth_jsonp=window.__firebase_auth_jsonp||{}}
Ef.prototype.open=function(a,b,c){function d(){c&&(c(X("REQUEST_INTERRUPTED")),c=null)}function e(){setTimeout(function(){window.__firebase_auth_jsonp[f]=void 0;Pd(window.__firebase_auth_jsonp)&&(window.__firebase_auth_jsonp=void 0);try{var a=document.getElementById(f);a&&a.parentNode.removeChild(a)}catch(b){}},1);tf(window,"beforeunload",d)}var f="fn"+(new Date).getTime()+Math.floor(99999*Math.random());b[this.options.callback_parameter]="__firebase_auth_jsonp."+f;a+=(/\?/.test(a)?"":"?")+wf(b);
sf(window,"beforeunload",d);window.__firebase_auth_jsonp[f]=function(a){c&&(c(null,a),c=null);e()};Ff(f,a,c)};
function Ff(a,b,c){setTimeout(function(){try{var d=document.createElement("script");d.type="text/javascript";d.id=a;d.async=!0;d.src=b;d.onerror=function(){var b=document.getElementById(a);null!==b&&b.parentNode.removeChild(b);c&&c(X("NETWORK_ERROR"))};var e=document.getElementsByTagName("head");(e&&0!=e.length?e[0]:document.documentElement).appendChild(d)}catch(f){c&&c(X("NETWORK_ERROR"))}},0)}Ef.isAvailable=function(){return!zf()};Ef.prototype.tc=function(){return"json"};function Gf(a,b){this.Ke=["session",a.Id,a.ub].join(":");this.Wd=b}Gf.prototype.set=function(a,b){if(!b)if(this.Wd.length)b=this.Wd[0];else throw Error("fb.login.SessionManager : No storage options available!");b.set(this.Ke,a)};Gf.prototype.get=function(){var a=Ja(this.Wd,q(this.Zf,this)),a=Ia(a,function(a){return null!==a});Qa(a,function(a,c){return Ke(c.token)-Ke(a.token)});return 0<a.length?a.shift():null};Gf.prototype.Zf=function(a){try{var b=a.get(this.Ke);if(b&&b.token)return b}catch(c){}return null};
Gf.prototype.clear=function(){var a=this;Ha(this.Wd,function(b){b.remove(a.Ke)})};function Hf(a){this.gc=Fa()+Fa()+Fa();this.pf=a}Hf.prototype.open=function(a,b){v.set("redirect_request_id",this.gc);v.set("redirect_request_id",this.gc);b.requestId=this.gc;b.redirectTo=b.redirectTo||window.location.href;a+=(/\?/.test(a)?"":"?")+wf(b);window.location=a};Hf.isAvailable=function(){return!/^file:\//.test(location.href)&&!zf()};Hf.prototype.tc=function(){return"redirect"};function If(a,b,c,d){Id.call(this,["auth_status"]);this.O=a;this.Xe=b;this.Dg=c;this.Fe=d;this.jc=new Gf(a,[za,v]);this.ib=null;Jf(this)}ma(If,Id);h=If.prototype;h.re=function(){return this.ib||null};function Jf(a){v.get("redirect_request_id")&&Kf(a);var b=a.jc.get();b&&b.token?(Lf(a,b),a.Xe(b.token,function(c,d){Mf(a,c,d,!1,b.token,b)},function(b,d){Nf(a,"resumeSession()",b,d)})):Lf(a,null)}
function Of(a,b,c,d,e,f){"firebaseio-demo.com"===a.O.domain&&z("Firebase authentication is not supported on demo Firebases (*.firebaseio-demo.com). To secure your Firebase, create a production Firebase at https://www.firebase.com.");a.Xe(b,function(f,k){Mf(a,f,k,!0,b,c,d||{},e)},function(b,c){Nf(a,"auth()",b,c,f)})}function Pf(a,b){a.jc.clear();Lf(a,null);a.Dg(function(a,d){if("ok"===a)B(b,null);else{var e=(a||"error").toUpperCase(),f=e;d&&(f+=": "+d);f=Error(f);f.code=e;B(b,f)}})}
function Mf(a,b,c,d,e,f,g,k){"ok"===b?(d&&(b=c.auth,f.auth=b,f.expires=c.expires,f.token=Le(e)?e:"",c=null,b&&s(b,"uid")?c=t(b,"uid"):s(f,"uid")&&(c=t(f,"uid")),f.uid=c,c="custom",b&&s(b,"provider")?c=t(b,"provider"):s(f,"provider")&&(c=t(f,"provider")),f.provider=c,a.jc.clear(),Le(e)&&(g=g||{},c=za,"sessionOnly"===g.remember&&(c=v),"none"!==g.remember&&a.jc.set(f,c)),Lf(a,f)),B(k,null,f)):(a.jc.clear(),Lf(a,null),f=a=(b||"error").toUpperCase(),c&&(f+=": "+c),f=Error(f),f.code=a,B(k,f))}
function Nf(a,b,c,d,e){z(b+" was canceled: "+d);a.jc.clear();Lf(a,null);a=Error(d);a.code=c.toUpperCase();B(e,a)}function Qf(a,b,c,d,e){Rf(a);c=new nf(d||{},{},c||{});Sf(a,[Bf,Ef],"/auth/"+b,c,e)}
function Tf(a,b,c,d){Rf(a);var e=[Df,Cf];c=pf(c);"anonymous"===b||"password"===b?setTimeout(function(){B(d,X("TRANSPORT_UNAVAILABLE"))},0):(c.Zd.window_features="menubar=yes,modal=yes,alwaysRaised=yeslocation=yes,resizable=yes,scrollbars=yes,status=yes,height=625,width=625,top="+("object"===typeof screen?.5*(screen.height-625):0)+",left="+("object"===typeof screen?.5*(screen.width-625):0),c.Zd.relay_url=yf(a.O.ub),c.Zd.requestWithCredential=q(a.hc,a),Sf(a,e,"/auth/"+b,c,d))}
function Kf(a){var b=v.get("redirect_request_id");if(b){var c=v.get("redirect_client_options");v.remove("redirect_request_id");v.remove("redirect_client_options");var d=[Bf,Ef],b={requestId:b,requestKey:vf(document.location.hash)},c=new nf(c,{},b);try{document.location.hash=document.location.hash.replace(/&__firebase_request_key=([a-zA-z0-9]*)/,"")}catch(e){}Sf(a,d,"/auth/session",c)}}h.ne=function(a,b){Rf(this);var c=pf(a);c.Xa._method="POST";this.hc("/users",c,function(a,c){a?B(b,a):B(b,a,c)})};
h.Me=function(a,b){var c=this;Rf(this);var d="/users/"+encodeURIComponent(a.email),e=pf(a);e.Xa._method="DELETE";this.hc(d,e,function(a,d){!a&&d&&d.uid&&c.ib&&c.ib.uid&&c.ib.uid===d.uid&&Pf(c);B(b,a)})};h.je=function(a,b){Rf(this);var c="/users/"+encodeURIComponent(a.email)+"/password",d=pf(a);d.Xa._method="PUT";d.Xa.password=a.newPassword;this.hc(c,d,function(a){B(b,a)})};
h.ie=function(a,b){Rf(this);var c="/users/"+encodeURIComponent(a.oldEmail)+"/email",d=pf(a);d.Xa._method="PUT";d.Xa.email=a.newEmail;d.Xa.password=a.password;this.hc(c,d,function(a){B(b,a)})};h.Ne=function(a,b){Rf(this);var c="/users/"+encodeURIComponent(a.email)+"/password",d=pf(a);d.Xa._method="POST";this.hc(c,d,function(a){B(b,a)})};h.hc=function(a,b,c){Uf(this,[Bf,Ef],a,b,c)};
function Sf(a,b,c,d,e){Uf(a,b,c,d,function(b,c){!b&&c&&c.token&&c.uid?Of(a,c.token,c,d.cd,function(a,b){a?B(e,a):B(e,null,b)}):B(e,b||X("UNKNOWN_ERROR"))})}
function Uf(a,b,c,d,e){b=Ia(b,function(a){return"function"===typeof a.isAvailable&&a.isAvailable()});0===b.length?setTimeout(function(){B(e,X("TRANSPORT_UNAVAILABLE"))},0):(b=new (b.shift())(d.Zd),d=va(d.Xa),d.v="js-2.2.0",d.transport=b.tc(),d.suppress_status_codes=!0,a=xf()+"/"+a.O.ub+c,b.open(a,d,function(a,b){if(a)B(e,a);else if(b&&b.error){var c=Error(b.error.message);c.code=b.error.code;c.details=b.error.details;B(e,c)}else B(e,null,b)}))}
function Lf(a,b){var c=null!==a.ib||null!==b;a.ib=b;c&&a.$d("auth_status",b);a.Fe(null!==b)}h.ue=function(a){y("auth_status"===a,'initial event must be of type "auth_status"');return[this.ib]};function Rf(a){var b=a.O;if("firebaseio.com"!==b.domain&&"firebaseio-demo.com"!==b.domain&&"auth.firebase.com"===mf)throw Error("This custom Firebase server ('"+a.O.domain+"') does not support delegated login.");};function Vf(a,b){return a&&"object"===typeof a?(y(".sv"in a,"Unexpected leaf node or priority contents"),b[a[".sv"]]):a}function Wf(a,b){var c=new cf;ef(a,new S(""),function(a,e){c.ec(a,Xf(e,b))});return c}function Xf(a,b){var c=a.L().I(),c=Vf(c,b),d;if(a.M()){var e=Vf(a.za(),b);return e!==a.za()||c!==a.L().I()?new qd(e,O(c)):a}d=a;c!==a.L().I()&&(d=d.$(new qd(c)));a.U(L,function(a,c){var e=Xf(c,b);e!==c&&(d=d.P(a,e))});return d};function Yf(a,b){this.value=a;this.children=b||Zf}var Zf=new bd(function(a,b){return a===b?0:a<b?-1:1}),$f=new Yf(null);function ag(a){var b=$f;A(a,function(a,d){b=b.set(new S(d),a)});return b}h=Yf.prototype;h.e=function(){return null===this.value&&this.children.e()};function bg(a,b,c){if(null!=a.value&&c(a.value))return{path:U,value:a.value};if(b.e())return null;var d=I(b);a=a.children.get(d);return null!==a?(b=bg(a,T(b),c),null!=b?{path:(new S(d)).u(b.path),value:b.value}:null):null}
function cg(a,b){return bg(a,b,function(){return!0})}h.subtree=function(a){if(a.e())return this;var b=this.children.get(I(a));return null!==b?b.subtree(T(a)):$f};h.set=function(a,b){if(a.e())return new Yf(b,this.children);var c=I(a),d=(this.children.get(c)||$f).set(T(a),b),c=this.children.La(c,d);return new Yf(this.value,c)};
h.remove=function(a){if(a.e())return this.children.e()?$f:new Yf(null,this.children);var b=I(a),c=this.children.get(b);return c?(a=c.remove(T(a)),b=a.e()?this.children.remove(b):this.children.La(b,a),null===this.value&&b.e()?$f:new Yf(this.value,b)):this};h.get=function(a){if(a.e())return this.value;var b=this.children.get(I(a));return b?b.get(T(a)):null};
function dg(a,b,c){if(b.e())return c;var d=I(b);b=dg(a.children.get(d)||$f,T(b),c);d=b.e()?a.children.remove(d):a.children.La(d,b);return new Yf(a.value,d)}function eg(a,b){return fg(a,U,b)}function fg(a,b,c){var d={};a.children.fa(function(a,f){d[a]=fg(f,b.u(a),c)});return c(b,a.value,d)}function gg(a,b,c){return hg(a,b,U,c)}function hg(a,b,c,d){var e=a.value?d(c,a.value):!1;if(e)return e;if(b.e())return null;e=I(b);return(a=a.children.get(e))?hg(a,T(b),c.u(e),d):null}
function ig(a,b,c){if(!b.e()){var d=!0;a.value&&(d=c(U,a.value));!0===d&&(d=I(b),(a=a.children.get(d))&&jg(a,T(b),U.u(d),c))}}function jg(a,b,c,d){if(b.e())return a;a.value&&d(c,a.value);var e=I(b);return(a=a.children.get(e))?jg(a,T(b),c.u(e),d):$f}function kg(a,b){lg(a,U,b)}function lg(a,b,c){a.children.fa(function(a,e){lg(e,b.u(a),c)});a.value&&c(b,a.value)}function mg(a,b){a.children.fa(function(a,d){d.value&&b(a,d.value)})}
h.toString=function(){var a={};kg(this,function(b,c){a[b.toString()]=c.toString()});return r(a)};function ng(a,b){this.ce=a;this.Of=b}function og(a){this.G=a}
og.prototype.Ya=function(a,b,c,d){var e=new Bc,f;if(b.type===pg)b.source.qe?c=qg(this,a,b.path,b.Ga,c,d,e):(y(b.source.ef,"Unknown source."),f=b.source.Te,c=rg(this,a,b.path,b.Ga,c,d,f,e));else if(b.type===sg)b.source.qe?c=tg(this,a,b.path,b.children,c,d,e):(y(b.source.ef,"Unknown source."),f=b.source.Te,c=ug(this,a,b.path,b.children,c,d,f,e));else if(b.type===vg)if(b.Oe)if(f=b.path,null!=c.kc(f))c=a;else{b=new xc(c,a,d);d=a.B.j();if(f.e()||".priority"===I(f))wg(a.o())?b=c.pa(Ac(a)):(b=a.o().j(),
y(b instanceof W,"serverChildren would be complete if leaf node"),b=c.qc(b)),b=this.G.oa(d,b,e);else{f=I(f);var g=c.Ta(f,a.o());null==g&&yc(a.o(),f)&&(g=d.K(f));b=null!=g?this.G.D(d,f,g,b,e):a.B.j().Da(f)?this.G.D(d,f,M,b,e):d;b.e()&&wg(a.o())&&(d=c.pa(Ac(a)),d.M()&&(b=this.G.oa(b,d,e)))}d=wg(a.o())||null!=c.kc(U);c=xg(a,b,d,this.G.Ca())}else c=yg(this,a,b.path,c,d,e);else if(b.type===zg)d=b.path,b=a.o(),f=b.j(),g=b.Z||d.e(),c=Ag(this,new Bg(a.B,new zc(f,g,b.Lb)),d,c,wc,e);else throw fb("Unknown operation type: "+
b.type);e=Ld(e.Za);d=c;b=d.B;b.Z&&(f=b.j().M()||b.j().e(),g=Cg(a),(0<e.length||!a.B.Z||f&&!b.j().aa(g)||!b.j().L().aa(g.L()))&&e.push(Fb(Cg(d))));return new ng(c,e)};
function Ag(a,b,c,d,e,f){var g=b.B;if(null!=d.kc(c))return b;var k;if(c.e())y(wg(b.o()),"If change path is empty, we must have complete server data"),b.o().Lb?(e=Ac(b),d=d.qc(e instanceof W?e:M)):d=d.pa(Ac(b)),f=a.G.oa(b.B.j(),d,f);else{var l=I(c);if(".priority"==l)y(1==Tc(c),"Can't have a priority with additional path components"),f=g.j(),k=b.o().j(),d=d.$c(c,f,k),f=null!=d?a.G.$(f,d):g.j();else{var n=T(c);yc(g,l)?(k=b.o().j(),d=d.$c(c,g.j(),k),d=null!=d?g.j().K(l).D(n,d):g.j().K(l)):d=d.Ta(l,b.o());
f=null!=d?a.G.D(g.j(),l,d,e,f):g.j()}}return xg(b,f,g.Z||c.e(),a.G.Ca())}function rg(a,b,c,d,e,f,g,k){var l=b.o();g=g?a.G:a.G.Nb();if(c.e())d=g.oa(l.j(),d,null);else if(g.Ca()&&!l.Lb)d=l.j().D(c,d),d=g.oa(l.j(),d,null);else{var n=I(c);if((c.e()?!l.Z||l.Lb:!yc(l,I(c)))&&1<Tc(c))return b;d=l.j().K(n).D(T(c),d);d=".priority"==n?g.$(l.j(),d):g.D(l.j(),n,d,wc,null)}l=l.Z||c.e();b=new Bg(b.B,new zc(d,l,g.Ca()));return Ag(a,b,c,e,new xc(e,b,f),k)}
function qg(a,b,c,d,e,f,g){var k=b.B;e=new xc(e,b,f);if(c.e())g=a.G.oa(b.B.j(),d,g),a=xg(b,g,!0,a.G.Ca());else if(f=I(c),".priority"===f)g=a.G.$(b.B.j(),d),a=xg(b,g,k.Z,k.Lb);else{var l=T(c);c=k.j().K(f);if(!l.e()){var n=e.ff(f);d=null!=n?".priority"===Uc(l)&&n.ra(l.parent()).e()?n:n.D(l,d):M}c.aa(d)?a=b:(g=a.G.D(k.j(),f,d,e,g),a=xg(b,g,k.Z,a.G.Ca()))}return a}
function tg(a,b,c,d,e,f,g){var k=b;kg(d,function(d,n){var u=c.u(d);yc(b.B,I(u))&&(k=qg(a,k,u,n,e,f,g))});kg(d,function(d,n){var u=c.u(d);yc(b.B,I(u))||(k=qg(a,k,u,n,e,f,g))});return k}function Dg(a,b){kg(b,function(b,d){a=a.D(b,d)});return a}
function ug(a,b,c,d,e,f,g,k){if(b.o().j().e()&&!wg(b.o()))return b;var l=b;c=c.e()?d:dg($f,c,d);var n=b.o().j();c.children.fa(function(c,d){if(n.Da(c)){var F=b.o().j().K(c),F=Dg(F,d);l=rg(a,l,new S(c),F,e,f,g,k)}});c.children.fa(function(c,d){var F=!wg(b.o())&&null==d.value;n.Da(c)||F||(F=b.o().j().K(c),F=Dg(F,d),l=rg(a,l,new S(c),F,e,f,g,k))});return l}
function yg(a,b,c,d,e,f){if(null!=d.kc(c))return b;var g=new xc(d,b,e),k=e=b.B.j();if(wg(b.o())){if(c.e())e=d.pa(Ac(b)),k=a.G.oa(b.B.j(),e,f);else if(".priority"===I(c)){var l=d.Ta(I(c),b.o());null==l||e.e()||e.L().aa(l)||(k=a.G.$(e,l))}else l=I(c),e=d.Ta(l,b.o()),null!=e&&(k=a.G.D(b.B.j(),l,e,g,f));e=!0}else if(b.B.Z||c.e())k=e,e=b.B.j(),e.M()||e.U(L,function(c){var e=d.Ta(c,b.o());null!=e&&(k=a.G.D(k,c,e,g,f))}),e=b.B.Z;else{l=I(c);if(1==Tc(c)||yc(b.B,l))c=d.Ta(l,b.o()),null!=c&&(k=a.G.D(e,l,c,
g,f));e=!1}return xg(b,k,e,a.G.Ca())};function Eg(a){this.W=a;this.g=a.n.g}function Fg(a,b,c,d){var e=[],f=[];Ha(b,function(b){"child_changed"===b.type&&a.g.we(b.Ee,b.Ha)&&f.push(new C("child_moved",b.Ha,b.Ua))});Gg(a,e,"child_removed",b,d,c);Gg(a,e,"child_added",b,d,c);Gg(a,e,"child_moved",f,d,c);Gg(a,e,"child_changed",b,d,c);Gg(a,e,Gb,b,d,c);return e}function Gg(a,b,c,d,e,f){d=Ia(d,function(a){return a.type===c});Qa(d,q(a.Qf,a));Ha(d,function(c){var d=Hg(a,c,f);Ha(e,function(e){e.wf(c.type)&&b.push(e.createEvent(d,a.W))})})}
function Hg(a,b,c){"value"!==b.type&&"child_removed"!==b.type&&(b.Kd=c.gf(b.Ua,b.Ha,a.g));return b}Eg.prototype.Qf=function(a,b){if(null==a.Ua||null==b.Ua)throw fb("Should only compare child_ events.");return this.g.compare(new N(a.Ua,a.Ha),new N(b.Ua,b.Ha))};function zc(a,b,c){this.A=a;this.Z=b;this.Lb=c}function wg(a){return a.Z}function yc(a,b){return a.Z&&!a.Lb||a.A.Da(b)}zc.prototype.j=function(){return this.A};function Bg(a,b){this.B=a;this.Qd=b}function xg(a,b,c,d){return new Bg(new zc(b,c,d),a.Qd)}function Cg(a){return a.B.Z?a.B.j():null}Bg.prototype.o=function(){return this.Qd};function Ac(a){return a.Qd.Z?a.Qd.j():null};function Ig(a,b){this.W=a;var c=a.n,d=new bc(c.g),c=Mc(c)?new bc(c.g):c.ka?new Dc(c):new dc(c);this.sf=new og(c);var e=b.o(),f=b.B,g=d.oa(M,e.j(),null),k=c.oa(M,f.j(),null);this.Ia=new Bg(new zc(k,f.Z,c.Ca()),new zc(g,e.Z,d.Ca()));this.Va=[];this.Uf=new Eg(a)}function Jg(a){return a.W}h=Ig.prototype;h.o=function(){return this.Ia.o().j()};h.bb=function(a){var b=Ac(this.Ia);return b&&(Mc(this.W.n)||!a.e()&&!b.K(I(a)).e())?b.ra(a):null};h.e=function(){return 0===this.Va.length};h.Gb=function(a){this.Va.push(a)};
h.gb=function(a,b){var c=[];if(b){y(null==a,"A cancel should cancel all event registrations.");var d=this.W.path;Ha(this.Va,function(a){(a=a.Ze(b,d))&&c.push(a)})}if(a){for(var e=[],f=0;f<this.Va.length;++f){var g=this.Va[f];if(!g.matches(a))e.push(g);else if(a.jf()){e=e.concat(this.Va.slice(f+1));break}}this.Va=e}else this.Va=[];return c};
h.Ya=function(a,b,c){a.type===sg&&null!==a.source.zb&&(y(Ac(this.Ia),"We should always have a full cache before handling merges"),y(Cg(this.Ia),"Missing event cache, even though we have a server cache"));var d=this.Ia;a=this.sf.Ya(d,a,b,c);b=this.sf;c=a.ce;y(c.B.j().Bc(b.G.g),"Event snap not indexed");y(c.o().j().Bc(b.G.g),"Server snap not indexed");y(wg(a.ce.o())||!wg(d.o()),"Once a server snap is complete, it should never go back");this.Ia=a.ce;return Kg(this,a.Of,a.ce.B.j(),null)};
function Lg(a,b){var c=a.Ia.B,d=[];c.j().M()||c.j().U(L,function(a,b){d.push(new C("child_added",b,a))});c.Z&&d.push(Fb(c.j()));return Kg(a,d,c.j(),b)}function Kg(a,b,c,d){return Fg(a.Uf,b,c,d?[d]:a.Va)};function Mg(){this.wa={}}h=Mg.prototype;h.e=function(){return Pd(this.wa)};h.Ya=function(a,b,c){var d=a.source.zb;if(null!==d)return d=t(this.wa,d),y(null!=d,"SyncTree gave us an op for an invalid query."),d.Ya(a,b,c);var e=[];A(this.wa,function(d){e=e.concat(d.Ya(a,b,c))});return e};h.Gb=function(a,b,c,d,e){var f=a.Fa(),g=t(this.wa,f);if(!g){var g=c.pa(e?d:null),k=!1;g?k=!0:(g=d instanceof W?c.qc(d):M,k=!1);g=new Ig(a,new Bg(new zc(g,k,!1),new zc(d,e,!1)));this.wa[f]=g}g.Gb(b);return Lg(g,b)};
h.gb=function(a,b,c){var d=a.Fa(),e=[],f=[],g=null!=Ng(this);if("default"===d){var k=this;A(this.wa,function(a,d){f=f.concat(a.gb(b,c));a.e()&&(delete k.wa[d],Mc(a.W.n)||e.push(a.W))})}else{var l=t(this.wa,d);l&&(f=f.concat(l.gb(b,c)),l.e()&&(delete this.wa[d],Mc(l.W.n)||e.push(l.W)))}g&&null==Ng(this)&&e.push(new R(a.k,a.path));return{sg:e,Vf:f}};function Og(a){return Ia(Ld(a.wa),function(a){return!Mc(a.W.n)})}h.bb=function(a){var b=null;A(this.wa,function(c){b=b||c.bb(a)});return b};
function Pg(a,b){if(Mc(b.n))return Ng(a);var c=b.Fa();return t(a.wa,c)}function Ng(a){return Od(a.wa,function(a){return Mc(a.W.n)})||null};function Qg(a){this.X=a}var Rg=new Qg(new Yf(null));function Sg(a,b,c){if(b.e())return new Qg(new Yf(c));var d=cg(a.X,b);if(null!=d){var e=d.path,d=d.value;b=V(e,b);d=d.D(b,c);return new Qg(a.X.set(e,d))}a=dg(a.X,b,new Yf(c));return new Qg(a)}function Tg(a,b,c){var d=a;ua(c,function(a,c){d=Sg(d,b.u(a),c)});return d}Qg.prototype.Ld=function(a){if(a.e())return Rg;a=dg(this.X,a,$f);return new Qg(a)};function Ug(a,b){var c=cg(a.X,b);return null!=c?a.X.get(c.path).ra(V(c.path,b)):null}
function Vg(a){var b=[],c=a.X.value;null!=c?c.M()||c.U(L,function(a,c){b.push(new N(a,c))}):a.X.children.fa(function(a,c){null!=c.value&&b.push(new N(a,c.value))});return b}function Wg(a,b){if(b.e())return a;var c=Ug(a,b);return null!=c?new Qg(new Yf(c)):new Qg(a.X.subtree(b))}Qg.prototype.e=function(){return this.X.e()};Qg.prototype.apply=function(a){return Xg(U,this.X,a)};
function Xg(a,b,c){if(null!=b.value)return c.D(a,b.value);var d=null;b.children.fa(function(b,f){".priority"===b?(y(null!==f.value,"Priority writes must always be leaf nodes"),d=f.value):c=Xg(a.u(b),f,c)});c.ra(a).e()||null===d||(c=c.D(a.u(".priority"),d));return c};function Yg(){this.T=Rg;this.xa=[];this.Ec=-1}h=Yg.prototype;
h.Ld=function(a){var b=Na(this.xa,function(b){return b.de===a});y(0<=b,"removeWrite called with nonexistent writeId.");var c=this.xa[b];this.xa.splice(b,1);for(var d=c.visible,e=!1,f=this.xa.length-1;d&&0<=f;){var g=this.xa[f];g.visible&&(f>=b&&Zg(g,c.path)?d=!1:c.path.contains(g.path)&&(e=!0));f--}if(d){if(e)this.T=$g(this.xa,ah,U),this.Ec=0<this.xa.length?this.xa[this.xa.length-1].de:-1;else if(c.Ga)this.T=this.T.Ld(c.path);else{var k=this;A(c.children,function(a,b){k.T=k.T.Ld(c.path.u(b))})}return c.path}return null};
h.pa=function(a,b,c,d){if(c||d){var e=Wg(this.T,a);return!d&&e.e()?b:d||null!=b||null!=Ug(e,U)?(e=$g(this.xa,function(b){return(b.visible||d)&&(!c||!(0<=Ga(c,b.de)))&&(b.path.contains(a)||a.contains(b.path))},a),b=b||M,e.apply(b)):null}e=Ug(this.T,a);if(null!=e)return e;e=Wg(this.T,a);return e.e()?b:null!=b||null!=Ug(e,U)?(b=b||M,e.apply(b)):null};
h.qc=function(a,b){var c=M,d=Ug(this.T,a);if(d)d.M()||d.U(L,function(a,b){c=c.P(a,b)});else if(b){var e=Wg(this.T,a);b.U(L,function(a,b){var d=Wg(e,new S(a)).apply(b);c=c.P(a,d)});Ha(Vg(e),function(a){c=c.P(a.name,a.V)})}else e=Wg(this.T,a),Ha(Vg(e),function(a){c=c.P(a.name,a.V)});return c};h.$c=function(a,b,c,d){y(c||d,"Either existingEventSnap or existingServerSnap must exist");a=a.u(b);if(null!=Ug(this.T,a))return null;a=Wg(this.T,a);return a.e()?d.ra(b):a.apply(d.ra(b))};
h.Ta=function(a,b,c){a=a.u(b);var d=Ug(this.T,a);return null!=d?d:yc(c,b)?Wg(this.T,a).apply(c.j().K(b)):null};h.kc=function(a){return Ug(this.T,a)};h.he=function(a,b,c,d,e,f){var g;a=Wg(this.T,a);g=Ug(a,U);if(null==g)if(null!=b)g=a.apply(b);else return[];g=g.hb(f);if(g.e()||g.M())return[];b=[];a=mc(f);e=e?g.Sb(c,f):g.Qb(c,f);for(f=P(e);f&&b.length<d;)0!==a(f,c)&&b.push(f),f=P(e);return b};
function Zg(a,b){return a.Ga?a.path.contains(b):!!Nd(a.children,function(c,d){return a.path.u(d).contains(b)})}function ah(a){return a.visible}
function $g(a,b,c){for(var d=Rg,e=0;e<a.length;++e){var f=a[e];if(b(f)){var g=f.path;if(f.Ga)c.contains(g)?(g=V(c,g),d=Sg(d,g,f.Ga)):g.contains(c)&&(g=V(g,c),d=Sg(d,U,f.Ga.ra(g)));else if(f.children)if(c.contains(g))g=V(c,g),d=Tg(d,g,f.children);else{if(g.contains(c))if(g=V(g,c),g.e())d=Tg(d,U,f.children);else if(f=t(f.children,I(g)))f=f.ra(T(g)),d=Sg(d,U,f)}else throw fb("WriteRecord should have .snap or .children");}}return d}function bh(a,b){this.Eb=a;this.X=b}h=bh.prototype;
h.pa=function(a,b,c){return this.X.pa(this.Eb,a,b,c)};h.qc=function(a){return this.X.qc(this.Eb,a)};h.$c=function(a,b,c){return this.X.$c(this.Eb,a,b,c)};h.kc=function(a){return this.X.kc(this.Eb.u(a))};h.he=function(a,b,c,d,e){return this.X.he(this.Eb,a,b,c,d,e)};h.Ta=function(a,b){return this.X.Ta(this.Eb,a,b)};h.u=function(a){return new bh(this.Eb.u(a),this.X)};function ch(a,b,c){this.type=pg;this.source=a;this.path=b;this.Ga=c}ch.prototype.Mc=function(a){return this.path.e()?new ch(this.source,U,this.Ga.K(a)):new ch(this.source,T(this.path),this.Ga)};ch.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" overwrite: "+this.Ga.toString()+")"};function dh(a,b){this.type=vg;this.source=eh;this.path=a;this.Oe=b}dh.prototype.Mc=function(){return this.path.e()?this:new dh(T(this.path),this.Oe)};dh.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" ack write revert="+this.Oe+")"};function fh(a,b){this.type=zg;this.source=a;this.path=b}fh.prototype.Mc=function(){return this.path.e()?new fh(this.source,U):new fh(this.source,T(this.path))};fh.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" listen_complete)"};function gh(a,b,c){this.type=sg;this.source=a;this.path=b;this.children=c}gh.prototype.Mc=function(a){if(this.path.e())return a=this.children.subtree(new S(a)),a.e()?null:a.value?new ch(this.source,U,a.value):new gh(this.source,U,a);y(I(this.path)===a,"Can't get a merge for a child not on the path of the operation");return new gh(this.source,T(this.path),this.children)};gh.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" merge: "+this.children.toString()+")"};var pg=0,sg=1,vg=2,zg=3;function hh(a,b,c,d){this.qe=a;this.ef=b;this.zb=c;this.Te=d;y(!d||b,"Tagged queries must be from server.")}var eh=new hh(!0,!1,null,!1),ih=new hh(!1,!0,null,!1);hh.prototype.toString=function(){return this.qe?"user":this.Te?"server(queryID="+this.zb+")":"server"};function jh(a){this.na=$f;this.yb=new Yg;this.Wc={};this.cc={};this.Fc=a}function kh(a,b,c,d,e){var f=a.yb,g=e;y(d>f.Ec,"Stacking an older write on top of newer ones");m(g)||(g=!0);f.xa.push({path:b,Ga:c,de:d,visible:g});g&&(f.T=Sg(f.T,b,c));f.Ec=d;return e?lh(a,new ch(eh,b,c)):[]}function mh(a,b,c,d){var e=a.yb;y(d>e.Ec,"Stacking an older merge on top of newer ones");e.xa.push({path:b,children:c,de:d,visible:!0});e.T=Tg(e.T,b,c);e.Ec=d;c=ag(c);return lh(a,new gh(eh,b,c))}
function nh(a,b,c){c=c||!1;b=a.yb.Ld(b);return null==b?[]:lh(a,new dh(b,c))}function oh(a,b,c){c=ag(c);return lh(a,new gh(ih,b,c))}function ph(a,b,c,d){d=Qd(a.Wc,"_"+d);if(null!=d){var e=qh(d);d=e.path;e=e.zb;b=V(d,b);c=new ch(new hh(!1,!0,e,!0),b,c);return rh(a,d,c)}return[]}function sh(a,b,c,d){if(d=Qd(a.Wc,"_"+d)){var e=qh(d);d=e.path;e=e.zb;b=V(d,b);c=ag(c);c=new gh(new hh(!1,!0,e,!0),b,c);return rh(a,d,c)}return[]}
jh.prototype.Gb=function(a,b){var c=a.path,d=null,e=!1;ig(this.na,c,function(a,b){var f=V(a,c);d=b.bb(f);e=e||null!=Ng(b);return!d});var f=this.na.get(c);f?(e=e||null!=Ng(f),d=d||f.bb(U)):(f=new Mg,this.na=this.na.set(c,f));var g;null!=d?g=!0:(g=!1,d=M,mg(this.na.subtree(c),function(a,b){var c=b.bb(U);c&&(d=d.P(a,c))}));var k=null!=Pg(f,a);if(!k&&!Mc(a.n)){var l=th(a);y(!(l in this.cc),"View does not exist, but we have a tag");var n=uh++;this.cc[l]=n;this.Wc["_"+n]=l}g=f.Gb(a,b,new bh(c,this.yb),
d,g);k||e||(f=Pg(f,a),g=g.concat(vh(this,a,f)));return g};
jh.prototype.gb=function(a,b,c){var d=a.path,e=this.na.get(d),f=[];if(e&&("default"===a.Fa()||null!=Pg(e,a))){f=e.gb(a,b,c);e.e()&&(this.na=this.na.remove(d));e=f.sg;f=f.Vf;b=-1!==Na(e,function(a){return Mc(a.n)});var g=gg(this.na,d,function(a,b){return null!=Ng(b)});if(b&&!g&&(d=this.na.subtree(d),!d.e()))for(var d=wh(d),k=0;k<d.length;++k){var l=d[k],n=l.W,l=xh(this,l);this.Fc.Qe(n,yh(this,n),l.nd,l.H)}if(!g&&0<e.length&&!c)if(b)this.Fc.Vd(a,null);else{var u=this;Ha(e,function(a){a.Fa();var b=u.cc[th(a)];
u.Fc.Vd(a,b)})}zh(this,e)}return f};jh.prototype.pa=function(a,b){var c=this.yb,d=gg(this.na,a,function(b,c){var d=V(b,a);if(d=c.bb(d))return d});return c.pa(a,d,b,!0)};function wh(a){return eg(a,function(a,c,d){if(c&&null!=Ng(c))return[Ng(c)];var e=[];c&&(e=Og(c));A(d,function(a){e=e.concat(a)});return e})}function zh(a,b){for(var c=0;c<b.length;++c){var d=b[c];if(!Mc(d.n)){var d=th(d),e=a.cc[d];delete a.cc[d];delete a.Wc["_"+e]}}}
function vh(a,b,c){var d=b.path,e=yh(a,b);c=xh(a,c);b=a.Fc.Qe(b,e,c.nd,c.H);d=a.na.subtree(d);if(e)y(null==Ng(d.value),"If we're adding a query, it shouldn't be shadowed");else for(e=eg(d,function(a,b,c){if(!a.e()&&b&&null!=Ng(b))return[Jg(Ng(b))];var d=[];b&&(d=d.concat(Ja(Og(b),function(a){return a.W})));A(c,function(a){d=d.concat(a)});return d}),d=0;d<e.length;++d)c=e[d],a.Fc.Vd(c,yh(a,c));return b}
function xh(a,b){var c=b.W,d=yh(a,c);return{nd:function(){return(b.o()||M).hash()},H:function(b,f){if("ok"===b){if(f&&"object"===typeof f&&s(f,"w")){var g=t(f,"w");ea(g)&&0<=Ga(g,"no_index")&&z("Using an unspecified index. Consider adding "+('".indexOn": "'+c.n.g.toString()+'"')+" at "+c.path.toString()+" to your security rules for better performance")}if(d){var k=c.path;if(g=Qd(a.Wc,"_"+d))var l=qh(g),g=l.path,l=l.zb,k=V(g,k),k=new fh(new hh(!1,!0,l,!0),k),g=rh(a,g,k);else g=[]}else g=lh(a,new fh(ih,
c.path));return g}g="Unknown Error";"too_big"===b?g="The data requested exceeds the maximum size that can be accessed with a single request.":"permission_denied"==b?g="Client doesn't have permission to access the desired data.":"unavailable"==b&&(g="The service is unavailable");g=Error(b+": "+g);g.code=b.toUpperCase();return a.gb(c,null,g)}}}function th(a){return a.path.toString()+"$"+a.Fa()}
function qh(a){var b=a.indexOf("$");y(-1!==b&&b<a.length-1,"Bad queryKey.");return{zb:a.substr(b+1),path:new S(a.substr(0,b))}}function yh(a,b){var c=th(b);return t(a.cc,c)}var uh=1;function rh(a,b,c){var d=a.na.get(b);y(d,"Missing sync point for query tag that we're tracking");return d.Ya(c,new bh(b,a.yb),null)}function lh(a,b){return Ah(a,b,a.na,null,new bh(U,a.yb))}
function Ah(a,b,c,d,e){if(b.path.e())return Bh(a,b,c,d,e);var f=c.get(U);null==d&&null!=f&&(d=f.bb(U));var g=[],k=I(b.path),l=b.Mc(k);if((c=c.children.get(k))&&l)var n=d?d.K(k):null,k=e.u(k),g=g.concat(Ah(a,l,c,n,k));f&&(g=g.concat(f.Ya(b,e,d)));return g}function Bh(a,b,c,d,e){var f=c.get(U);null==d&&null!=f&&(d=f.bb(U));var g=[];c.children.fa(function(c,f){var n=d?d.K(c):null,u=e.u(c),x=b.Mc(c);x&&(g=g.concat(Bh(a,x,f,n,u)))});f&&(g=g.concat(f.Ya(b,e,d)));return g};function Ch(a){this.O=a;this.Ra=Zd(a);this.ba=new gf;this.Ad=1;this.S=new Me(this.O,q(this.Dd,this),q(this.Bd,this),q(this.Ie,this));this.Ag=$d(a,q(function(){return new Wd(this.Ra,this.S)},this));this.mc=new Wc;this.xe=new ff;var b=this;this.rd=new jh({Qe:function(a,d,e,f){d=[];e=b.xe.j(a.path);e.e()||(d=lh(b.rd,new ch(ih,a.path,e)),setTimeout(function(){f("ok")},0));return d},Vd:ba});Dh(this,"connected",!1);this.ga=new cf;this.Q=new If(a,q(this.S.Q,this.S),q(this.S.Ve,this.S),q(this.Fe,this));this.hd=
0;this.ye=null;this.N=new jh({Qe:function(a,d,e,f){Qe(b.S,a,e,d,function(d,e){var l=f(d,e);lf(b.ba,a.path,l)});return[]},Vd:function(a,d){var e=b.S,f=a.path.toString(),g=a.Fa();e.f("Unlisten called for "+f+" "+g);if(Se(e,f,g)&&e.ja){var k=Lc(a.n);e.f("Unlisten on "+f+" for "+g);f={p:f};d&&(f.q=k,f.t=d);e.Ba("n",f)}}})}h=Ch.prototype;h.toString=function(){return(this.O.Bb?"https://":"http://")+this.O.host};h.name=function(){return this.O.ub};
function Eh(a){a=a.xe.j(new S(".info/serverTimeOffset")).I()||0;return(new Date).getTime()+a}function Fh(a){a=a={timestamp:Eh(a)};a.timestamp=a.timestamp||(new Date).getTime();return a}h.Dd=function(a,b,c,d){this.hd++;var e=new S(a);b=this.ye?this.ye(a,b):b;a=[];d?c?(b=wd(b,function(a){return O(a)}),a=sh(this.N,e,b,d)):(b=O(b),a=ph(this.N,e,b,d)):c?(d=wd(b,function(a){return O(a)}),a=oh(this.N,e,d)):(d=O(b),a=lh(this.N,new ch(ih,e,d)));d=e;0<a.length&&(d=Gh(this,e));lf(this.ba,d,a)};
h.Bd=function(a){Dh(this,"connected",a);!1===a&&Hh(this)};h.Ie=function(a){var b=this;zb(a,function(a,d){Dh(b,d,a)})};h.Fe=function(a){Dh(this,"authenticated",a)};function Dh(a,b,c){b=new S("/.info/"+b);c=O(c);var d=a.xe;d.Od=d.Od.D(b,c);c=lh(a.rd,new ch(ih,b,c));lf(a.ba,b,c)}
h.Cb=function(a,b,c,d){this.f("set",{path:a.toString(),value:b,Ig:c});var e=Fh(this);b=O(b,c);var e=Xf(b,e),f=this.Ad++,e=kh(this.N,a,e,f,!0);hf(this.ba,e);var g=this;this.S.put(a.toString(),b.I(!0),function(b,c){var e="ok"===b;e||z("set at "+a+" failed: "+b);e=nh(g.N,f,!e);lf(g.ba,a,e);Ih(d,b,c)});e=Jh(this,a);Gh(this,e);lf(this.ba,e,[])};
h.update=function(a,b,c){this.f("update",{path:a.toString(),value:b});var d=!0,e=Fh(this),f={};A(b,function(a,b){d=!1;var c=O(a);f[b]=Xf(c,e)});if(d)hb("update() called with empty data.  Don't do anything."),Ih(c,"ok");else{var g=this.Ad++,k=mh(this.N,a,f,g);hf(this.ba,k);var l=this;Ye(this.S,a.toString(),b,function(b,d){y("ok"===b||"permission_denied"===b,"merge at "+a+" failed.");var e="ok"===b;e||z("update at "+a+" failed: "+b);var e=nh(l.N,g,!e),f=a;0<e.length&&(f=Gh(l,a));lf(l.ba,f,e);Ih(c,b,
d)});b=Jh(this,a);Gh(this,b);lf(this.ba,a,[])}};function Hh(a){a.f("onDisconnectEvents");var b=Fh(a),c=[];ef(Wf(a.ga,b),U,function(b,e){c=c.concat(lh(a.N,new ch(ih,b,e)));var f=Jh(a,b);Gh(a,f)});a.ga=new cf;lf(a.ba,U,c)}h.Ge=function(a,b){var c=this;this.S.Ge(a.toString(),function(d,e){"ok"===d&&df(c.ga,a);Ih(b,d,e)})};function Kh(a,b,c,d){var e=O(c);Ue(a.S,b.toString(),e.I(!0),function(c,g){"ok"===c&&a.ga.ec(b,e);Ih(d,c,g)})}
function Lh(a,b,c,d,e){var f=O(c,d);Ue(a.S,b.toString(),f.I(!0),function(c,d){"ok"===c&&a.ga.ec(b,f);Ih(e,c,d)})}function Mh(a,b,c,d){var e=!0,f;for(f in c)e=!1;e?(hb("onDisconnect().update() called with empty data.  Don't do anything."),Ih(d,"ok")):We(a.S,b.toString(),c,function(e,f){if("ok"===e)for(var l in c){var n=O(c[l]);a.ga.ec(b.u(l),n)}Ih(d,e,f)})}function Rc(a,b,c){c=".info"===I(b.path)?a.rd.Gb(b,c):a.N.Gb(b,c);Sc(a.ba,b.path,c)}h.qb=function(){this.S.qb()};h.ic=function(){this.S.ic()};
h.Re=function(a){if("undefined"!==typeof console){a?(this.Ud||(this.Ud=new Vd(this.Ra)),a=this.Ud.get()):a=this.Ra.get();var b=Ka(Md(a),function(a,b){return Math.max(b.length,a)},0),c;for(c in a){for(var d=a[c],e=c.length;e<b+2;e++)c+=" ";console.log(c+d)}}};h.Se=function(a){Ud(this.Ra,a);this.Ag.zf[a]=!0};h.f=function(a){hb("r:"+this.S.id+":",arguments)};function Ih(a,b,c){a&&Cb(function(){if("ok"==b)a(null);else{var d=(b||"error").toUpperCase(),e=d;c&&(e+=": "+c);e=Error(e);e.code=d;a(e)}})};function Nh(a,b,c,d,e){function f(){}a.f("transaction on "+b);var g=new R(a,b);g.wb("value",f);c={path:b,update:c,H:d,status:null,qf:eb(),We:e,xf:0,be:function(){g.$b("value",f)},ee:null,ya:null,ed:null,fd:null,gd:null};d=a.N.pa(b,void 0)||M;c.ed=d;d=c.update(d.I());if(m(d)){Sb("transaction failed: Data returned ",d);c.status=1;e=Xc(a.mc,b);var k=e.za()||[];k.push(c);Yc(e,k);"object"===typeof d&&null!==d&&s(d,".priority")?(k=t(d,".priority"),y(Qb(k),"Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.")):
k=(a.N.pa(b)||M).L().I();e=Fh(a);d=O(d,k);e=Xf(d,e);c.fd=d;c.gd=e;c.ya=a.Ad++;c=kh(a.N,b,e,c.ya,c.We);lf(a.ba,b,c);Oh(a)}else c.be(),c.fd=null,c.gd=null,c.H&&(a=new D(c.ed,new R(a,c.path),L),c.H(null,!1,a))}function Oh(a,b){var c=b||a.mc;b||Ph(a,c);if(null!==c.za()){var d=Qh(a,c);y(0<d.length,"Sending zero length transaction queue");La(d,function(a){return 1===a.status})&&Rh(a,c.path(),d)}else c.md()&&c.U(function(b){Oh(a,b)})}
function Rh(a,b,c){for(var d=Ja(c,function(a){return a.ya}),e=a.N.pa(b,d)||M,d=e,e=e.hash(),f=0;f<c.length;f++){var g=c[f];y(1===g.status,"tryToSendTransactionQueue_: items in queue should all be run.");g.status=2;g.xf++;var k=V(b,g.path),d=d.D(k,g.fd)}d=d.I(!0);a.S.put(b.toString(),d,function(d){a.f("transaction put response",{path:b.toString(),status:d});var e=[];if("ok"===d){d=[];for(f=0;f<c.length;f++){c[f].status=3;e=e.concat(nh(a.N,c[f].ya));if(c[f].H){var g=c[f].gd,k=new R(a,c[f].path);d.push(q(c[f].H,
null,null,!0,new D(g,k,L)))}c[f].be()}Ph(a,Xc(a.mc,b));Oh(a);lf(a.ba,b,e);for(f=0;f<d.length;f++)Cb(d[f])}else{if("datastale"===d)for(f=0;f<c.length;f++)c[f].status=4===c[f].status?5:1;else for(z("transaction at "+b.toString()+" failed: "+d),f=0;f<c.length;f++)c[f].status=5,c[f].ee=d;Gh(a,b)}},e)}function Gh(a,b){var c=Sh(a,b),d=c.path(),c=Qh(a,c);Th(a,c,d);return d}
function Th(a,b,c){if(0!==b.length){for(var d=[],e=[],f=Ja(b,function(a){return a.ya}),g=0;g<b.length;g++){var k=b[g],l=V(c,k.path),n=!1,u;y(null!==l,"rerunTransactionsUnderNode_: relativePath should not be null.");if(5===k.status)n=!0,u=k.ee,e=e.concat(nh(a.N,k.ya,!0));else if(1===k.status)if(25<=k.xf)n=!0,u="maxretry",e=e.concat(nh(a.N,k.ya,!0));else{var x=a.N.pa(k.path,f)||M;k.ed=x;var F=b[g].update(x.I());m(F)?(Sb("transaction failed: Data returned ",F),l=O(F),"object"===typeof F&&null!=F&&s(F,
".priority")||(l=l.$(x.L())),x=k.ya,F=Fh(a),F=Xf(l,F),k.fd=l,k.gd=F,k.ya=a.Ad++,Oa(f,x),e=e.concat(kh(a.N,k.path,F,k.ya,k.We)),e=e.concat(nh(a.N,x,!0))):(n=!0,u="nodata",e=e.concat(nh(a.N,k.ya,!0)))}lf(a.ba,c,e);e=[];n&&(b[g].status=3,setTimeout(b[g].be,Math.floor(0)),b[g].H&&("nodata"===u?(k=new R(a,b[g].path),d.push(q(b[g].H,null,null,!1,new D(b[g].ed,k,L)))):d.push(q(b[g].H,null,Error(u),!1,null))))}Ph(a,a.mc);for(g=0;g<d.length;g++)Cb(d[g]);Oh(a)}}
function Sh(a,b){for(var c,d=a.mc;null!==(c=I(b))&&null===d.za();)d=Xc(d,c),b=T(b);return d}function Qh(a,b){var c=[];Uh(a,b,c);c.sort(function(a,b){return a.qf-b.qf});return c}function Uh(a,b,c){var d=b.za();if(null!==d)for(var e=0;e<d.length;e++)c.push(d[e]);b.U(function(b){Uh(a,b,c)})}function Ph(a,b){var c=b.za();if(c){for(var d=0,e=0;e<c.length;e++)3!==c[e].status&&(c[d]=c[e],d++);c.length=d;Yc(b,0<c.length?c:null)}b.U(function(b){Ph(a,b)})}
function Jh(a,b){var c=Sh(a,b).path(),d=Xc(a.mc,b);ad(d,function(b){Vh(a,b)});Vh(a,d);$c(d,function(b){Vh(a,b)});return c}
function Vh(a,b){var c=b.za();if(null!==c){for(var d=[],e=[],f=-1,g=0;g<c.length;g++)4!==c[g].status&&(2===c[g].status?(y(f===g-1,"All SENT items should be at beginning of queue."),f=g,c[g].status=4,c[g].ee="set"):(y(1===c[g].status,"Unexpected transaction status in abort"),c[g].be(),e=e.concat(nh(a.N,c[g].ya,!0)),c[g].H&&d.push(q(c[g].H,null,Error("set"),!1,null))));-1===f?Yc(b,null):c.length=f+1;lf(a.ba,b.path(),e);for(g=0;g<d.length;g++)Cb(d[g])}};function Wh(){this.fc={}}ca(Wh);Wh.prototype.qb=function(){for(var a in this.fc)this.fc[a].qb()};Wh.prototype.interrupt=Wh.prototype.qb;Wh.prototype.ic=function(){for(var a in this.fc)this.fc[a].ic()};Wh.prototype.resume=Wh.prototype.ic;function Xh(a){var b=this;this.sc=a;this.Xd="*";Af()?this.Hc=this.pd=rf():(this.Hc=window.opener,this.pd=window);if(!b.Hc)throw"Unable to find relay frame";sf(this.pd,"message",q(this.ac,this));sf(this.pd,"message",q(this.nf,this));try{Yh(this,{a:"ready"})}catch(c){sf(this.Hc,"load",function(){Yh(b,{a:"ready"})})}sf(window,"unload",q(this.jg,this))}function Yh(a,b){b=r(b);Af()?a.Hc.doPost(b,a.Xd):a.Hc.postMessage(b,a.Xd)}
Xh.prototype.ac=function(a){var b=this,c;try{c=ta(a.data)}catch(d){}c&&"request"===c.a&&(tf(window,"message",this.ac),this.Xd=a.origin,this.sc&&setTimeout(function(){b.sc(b.Xd,c.d,function(a,c){b.Mf=!c;b.sc=void 0;Yh(b,{a:"response",d:a,forceKeepWindowOpen:c})})},0))};Xh.prototype.jg=function(){try{tf(this.pd,"message",this.nf)}catch(a){}this.sc&&(Yh(this,{a:"error",d:"unknown closed window"}),this.sc=void 0);try{window.close()}catch(b){}};Xh.prototype.nf=function(a){if(this.Mf&&"die"===a.data)try{window.close()}catch(b){}};var Y={Xf:function(){le=ce=!0}};Y.forceLongPolling=Y.Xf;Y.Yf=function(){me=!0};Y.forceWebSockets=Y.Yf;Y.xg=function(a,b){a.k.S.Pe=b};Y.setSecurityDebugCallback=Y.xg;Y.Re=function(a,b){a.k.Re(b)};Y.stats=Y.Re;Y.Se=function(a,b){a.k.Se(b)};Y.statsIncrementCounter=Y.Se;Y.hd=function(a){return a.k.hd};Y.dataUpdateCount=Y.hd;Y.ag=function(a,b){a.k.ye=b};Y.interceptServerData=Y.ag;Y.gg=function(a){new Xh(a)};Y.onPopupOpen=Y.gg;Y.vg=function(a){mf=a};Y.setAuthenticationServer=Y.vg;function Z(a,b){this.Rc=a;this.Ea=b}Z.prototype.cancel=function(a){E("Firebase.onDisconnect().cancel",0,1,arguments.length);H("Firebase.onDisconnect().cancel",1,a,!0);this.Rc.Ge(this.Ea,a||null)};Z.prototype.cancel=Z.prototype.cancel;Z.prototype.remove=function(a){E("Firebase.onDisconnect().remove",0,1,arguments.length);Zb("Firebase.onDisconnect().remove",this.Ea);H("Firebase.onDisconnect().remove",1,a,!0);Kh(this.Rc,this.Ea,null,a)};Z.prototype.remove=Z.prototype.remove;
Z.prototype.set=function(a,b){E("Firebase.onDisconnect().set",1,2,arguments.length);Zb("Firebase.onDisconnect().set",this.Ea);Rb("Firebase.onDisconnect().set",a,!1);H("Firebase.onDisconnect().set",2,b,!0);Kh(this.Rc,this.Ea,a,b)};Z.prototype.set=Z.prototype.set;
Z.prototype.Cb=function(a,b,c){E("Firebase.onDisconnect().setWithPriority",2,3,arguments.length);Zb("Firebase.onDisconnect().setWithPriority",this.Ea);Rb("Firebase.onDisconnect().setWithPriority",a,!1);Vb("Firebase.onDisconnect().setWithPriority",2,b);H("Firebase.onDisconnect().setWithPriority",3,c,!0);Lh(this.Rc,this.Ea,a,b,c)};Z.prototype.setWithPriority=Z.prototype.Cb;
Z.prototype.update=function(a,b){E("Firebase.onDisconnect().update",1,2,arguments.length);Zb("Firebase.onDisconnect().update",this.Ea);if(ea(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;z("Passing an Array to Firebase.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}Ub("Firebase.onDisconnect().update",a);H("Firebase.onDisconnect().update",2,b,!0);Mh(this.Rc,
this.Ea,a,b)};Z.prototype.update=Z.prototype.update;var $={};$.oc=Me;$.DataConnection=$.oc;Me.prototype.zg=function(a,b){this.Ba("q",{p:a},b)};$.oc.prototype.simpleListen=$.oc.prototype.zg;Me.prototype.Sf=function(a,b){this.Ba("echo",{d:a},b)};$.oc.prototype.echo=$.oc.prototype.Sf;Me.prototype.interrupt=Me.prototype.qb;$.Df=we;$.RealTimeConnection=$.Df;we.prototype.sendRequest=we.prototype.Ba;we.prototype.close=we.prototype.close;
$.$f=function(a){var b=Me.prototype.put;Me.prototype.put=function(c,d,e,f){m(f)&&(f=a());b.call(this,c,d,e,f)};return function(){Me.prototype.put=b}};$.hijackHash=$.$f;$.Cf=Aa;$.ConnectionTarget=$.Cf;$.Fa=function(a){return a.Fa()};$.queryIdentifier=$.Fa;$.bg=function(a){return a.k.S.ta};$.listens=$.bg;var Zh=function(){var a=0,b=[];return function(c){var d=c===a;a=c;for(var e=Array(8),f=7;0<=f;f--)e[f]="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(c%64),c=Math.floor(c/64);y(0===c,"Cannot push at time == 0");c=e.join("");if(d){for(f=11;0<=f&&63===b[f];f--)b[f]=0;b[f]++}else for(f=0;12>f;f++)b[f]=Math.floor(64*Math.random());for(f=0;12>f;f++)c+="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(b[f]);y(20===c.length,"NextPushId: Length should be 20.");
return c}}();function R(a,b){var c,d,e;if(a instanceof Ch)c=a,d=b;else{E("new Firebase",1,2,arguments.length);d=rb(arguments[0]);c=d.Bg;"firebase"===d.domain&&qb(d.host+" is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");c||qb("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");d.Bb||"undefined"!==typeof window&&window.location&&window.location.protocol&&-1!==window.location.protocol.indexOf("https:")&&z("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
c=new Aa(d.host,d.Bb,c,"ws"===d.scheme||"wss"===d.scheme);d=new S(d.Pc);e=d.toString();var f;!(f=!p(c.host)||0===c.host.length||!Pb(c.ub))&&(f=0!==e.length)&&(e&&(e=e.replace(/^\/*\.info(\/|$)/,"/")),f=!(p(e)&&0!==e.length&&!Ob.test(e)));if(f)throw Error(G("new Firebase",1,!1)+'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".');if(b)if(b instanceof Wh)e=b;else if(p(b))e=Wh.Ob(),c.Id=b;else throw Error("Expected a valid Firebase.Context for second argument to new Firebase()");
else e=Wh.Ob();f=c.toString();var g=t(e.fc,f);g||(g=new Ch(c),e.fc[f]=g);c=g}Q.call(this,c,d,Ic,!1)}ma(R,Q);var $h=R,ai=["Firebase"],bi=aa;ai[0]in bi||!bi.execScript||bi.execScript("var "+ai[0]);for(var ci;ai.length&&(ci=ai.shift());)!ai.length&&m($h)?bi[ci]=$h:bi=bi[ci]?bi[ci]:bi[ci]={};R.prototype.name=function(){z("Firebase.name() being deprecated. Please use Firebase.key() instead.");E("Firebase.name",0,0,arguments.length);return this.key()};R.prototype.name=R.prototype.name;
R.prototype.key=function(){E("Firebase.key",0,0,arguments.length);return this.path.e()?null:Uc(this.path)};R.prototype.key=R.prototype.key;R.prototype.u=function(a){E("Firebase.child",1,1,arguments.length);if(ga(a))a=String(a);else if(!(a instanceof S))if(null===I(this.path)){var b=a;b&&(b=b.replace(/^\/*\.info(\/|$)/,"/"));Yb("Firebase.child",b)}else Yb("Firebase.child",a);return new R(this.k,this.path.u(a))};R.prototype.child=R.prototype.u;
R.prototype.parent=function(){E("Firebase.parent",0,0,arguments.length);var a=this.path.parent();return null===a?null:new R(this.k,a)};R.prototype.parent=R.prototype.parent;R.prototype.root=function(){E("Firebase.ref",0,0,arguments.length);for(var a=this;null!==a.parent();)a=a.parent();return a};R.prototype.root=R.prototype.root;
R.prototype.toString=function(){E("Firebase.toString",0,0,arguments.length);var a;if(null===this.parent())a=this.k.toString();else{a=this.parent().toString()+"/";var b=this.key();a+=encodeURIComponent(String(b))}return a};R.prototype.toString=R.prototype.toString;R.prototype.set=function(a,b){E("Firebase.set",1,2,arguments.length);Zb("Firebase.set",this.path);Rb("Firebase.set",a,!1);H("Firebase.set",2,b,!0);this.k.Cb(this.path,a,null,b||null)};R.prototype.set=R.prototype.set;
R.prototype.update=function(a,b){E("Firebase.update",1,2,arguments.length);Zb("Firebase.update",this.path);if(ea(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;z("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}Ub("Firebase.update",a);H("Firebase.update",2,b,!0);this.k.update(this.path,a,b||null)};R.prototype.update=R.prototype.update;
R.prototype.Cb=function(a,b,c){E("Firebase.setWithPriority",2,3,arguments.length);Zb("Firebase.setWithPriority",this.path);Rb("Firebase.setWithPriority",a,!1);Vb("Firebase.setWithPriority",2,b);H("Firebase.setWithPriority",3,c,!0);if(".length"===this.key()||".keys"===this.key())throw"Firebase.setWithPriority failed: "+this.key()+" is a read-only object.";this.k.Cb(this.path,a,b,c||null)};R.prototype.setWithPriority=R.prototype.Cb;
R.prototype.remove=function(a){E("Firebase.remove",0,1,arguments.length);Zb("Firebase.remove",this.path);H("Firebase.remove",1,a,!0);this.set(null,a)};R.prototype.remove=R.prototype.remove;
R.prototype.transaction=function(a,b,c){E("Firebase.transaction",1,3,arguments.length);Zb("Firebase.transaction",this.path);H("Firebase.transaction",1,a,!1);H("Firebase.transaction",2,b,!0);if(m(c)&&"boolean"!=typeof c)throw Error(G("Firebase.transaction",3,!0)+"must be a boolean.");if(".length"===this.key()||".keys"===this.key())throw"Firebase.transaction failed: "+this.key()+" is a read-only object.";"undefined"===typeof c&&(c=!0);Nh(this.k,this.path,a,b||null,c)};R.prototype.transaction=R.prototype.transaction;
R.prototype.wg=function(a,b){E("Firebase.setPriority",1,2,arguments.length);Zb("Firebase.setPriority",this.path);Vb("Firebase.setPriority",1,a);H("Firebase.setPriority",2,b,!0);this.k.Cb(this.path.u(".priority"),a,null,b)};R.prototype.setPriority=R.prototype.wg;R.prototype.push=function(a,b){E("Firebase.push",0,2,arguments.length);Zb("Firebase.push",this.path);Rb("Firebase.push",a,!0);H("Firebase.push",2,b,!0);var c=Eh(this.k),c=Zh(c),c=this.u(c);"undefined"!==typeof a&&null!==a&&c.set(a,b);return c};
R.prototype.push=R.prototype.push;R.prototype.fb=function(){Zb("Firebase.onDisconnect",this.path);return new Z(this.k,this.path)};R.prototype.onDisconnect=R.prototype.fb;R.prototype.Q=function(a,b,c){z("FirebaseRef.auth() being deprecated. Please use FirebaseRef.authWithCustomToken() instead.");E("Firebase.auth",1,3,arguments.length);$b("Firebase.auth",a);H("Firebase.auth",2,b,!0);H("Firebase.auth",3,b,!0);Of(this.k.Q,a,{},{remember:"none"},b,c)};R.prototype.auth=R.prototype.Q;
R.prototype.Ve=function(a){E("Firebase.unauth",0,1,arguments.length);H("Firebase.unauth",1,a,!0);Pf(this.k.Q,a)};R.prototype.unauth=R.prototype.Ve;R.prototype.re=function(){E("Firebase.getAuth",0,0,arguments.length);return this.k.Q.re()};R.prototype.getAuth=R.prototype.re;R.prototype.fg=function(a,b){E("Firebase.onAuth",1,2,arguments.length);H("Firebase.onAuth",1,a,!1);Mb("Firebase.onAuth",2,b);this.k.Q.wb("auth_status",a,b)};R.prototype.onAuth=R.prototype.fg;
R.prototype.eg=function(a,b){E("Firebase.offAuth",1,2,arguments.length);H("Firebase.offAuth",1,a,!1);Mb("Firebase.offAuth",2,b);this.k.Q.$b("auth_status",a,b)};R.prototype.offAuth=R.prototype.eg;R.prototype.Hf=function(a,b,c){E("Firebase.authWithCustomToken",2,3,arguments.length);$b("Firebase.authWithCustomToken",a);H("Firebase.authWithCustomToken",2,b,!1);J("Firebase.authWithCustomToken",3,c,!0);Of(this.k.Q,a,{},c||{},b)};R.prototype.authWithCustomToken=R.prototype.Hf;
R.prototype.If=function(a,b,c){E("Firebase.authWithOAuthPopup",2,3,arguments.length);ac("Firebase.authWithOAuthPopup",1,a);H("Firebase.authWithOAuthPopup",2,b,!1);J("Firebase.authWithOAuthPopup",3,c,!0);Tf(this.k.Q,a,c,b)};R.prototype.authWithOAuthPopup=R.prototype.If;
R.prototype.Jf=function(a,b,c){E("Firebase.authWithOAuthRedirect",2,3,arguments.length);ac("Firebase.authWithOAuthRedirect",1,a);H("Firebase.authWithOAuthRedirect",2,b,!1);J("Firebase.authWithOAuthRedirect",3,c,!0);var d=this.k.Q;Rf(d);var e=[Hf],f=pf(c);"anonymous"===a||"firebase"===a?B(b,X("TRANSPORT_UNAVAILABLE")):(v.set("redirect_client_options",f.cd),Sf(d,e,"/auth/"+a,f,b))};R.prototype.authWithOAuthRedirect=R.prototype.Jf;
R.prototype.Kf=function(a,b,c,d){E("Firebase.authWithOAuthToken",3,4,arguments.length);ac("Firebase.authWithOAuthToken",1,a);H("Firebase.authWithOAuthToken",3,c,!1);J("Firebase.authWithOAuthToken",4,d,!0);p(b)?(ac("Firebase.authWithOAuthToken",2,b),Qf(this.k.Q,a+"/token",{access_token:b},d,c)):(J("Firebase.authWithOAuthToken",2,b,!1),Qf(this.k.Q,a+"/token",b,d,c))};R.prototype.authWithOAuthToken=R.prototype.Kf;
R.prototype.Gf=function(a,b){E("Firebase.authAnonymously",1,2,arguments.length);H("Firebase.authAnonymously",1,a,!1);J("Firebase.authAnonymously",2,b,!0);Qf(this.k.Q,"anonymous",{},b,a)};R.prototype.authAnonymously=R.prototype.Gf;
R.prototype.Lf=function(a,b,c){E("Firebase.authWithPassword",2,3,arguments.length);J("Firebase.authWithPassword",1,a,!1);K("Firebase.authWithPassword",a,"email");K("Firebase.authWithPassword",a,"password");H("Firebase.authAnonymously",2,b,!1);J("Firebase.authAnonymously",3,c,!0);Qf(this.k.Q,"password",a,c,b)};R.prototype.authWithPassword=R.prototype.Lf;
R.prototype.ne=function(a,b){E("Firebase.createUser",2,2,arguments.length);J("Firebase.createUser",1,a,!1);K("Firebase.createUser",a,"email");K("Firebase.createUser",a,"password");H("Firebase.createUser",2,b,!1);this.k.Q.ne(a,b)};R.prototype.createUser=R.prototype.ne;R.prototype.Me=function(a,b){E("Firebase.removeUser",2,2,arguments.length);J("Firebase.removeUser",1,a,!1);K("Firebase.removeUser",a,"email");K("Firebase.removeUser",a,"password");H("Firebase.removeUser",2,b,!1);this.k.Q.Me(a,b)};
R.prototype.removeUser=R.prototype.Me;R.prototype.je=function(a,b){E("Firebase.changePassword",2,2,arguments.length);J("Firebase.changePassword",1,a,!1);K("Firebase.changePassword",a,"email");K("Firebase.changePassword",a,"oldPassword");K("Firebase.changePassword",a,"newPassword");H("Firebase.changePassword",2,b,!1);this.k.Q.je(a,b)};R.prototype.changePassword=R.prototype.je;
R.prototype.ie=function(a,b){E("Firebase.changeEmail",2,2,arguments.length);J("Firebase.changeEmail",1,a,!1);K("Firebase.changeEmail",a,"oldEmail");K("Firebase.changeEmail",a,"newEmail");K("Firebase.changeEmail",a,"password");H("Firebase.changeEmail",2,b,!1);this.k.Q.ie(a,b)};R.prototype.changeEmail=R.prototype.ie;
R.prototype.Ne=function(a,b){E("Firebase.resetPassword",2,2,arguments.length);J("Firebase.resetPassword",1,a,!1);K("Firebase.resetPassword",a,"email");H("Firebase.resetPassword",2,b,!1);this.k.Q.Ne(a,b)};R.prototype.resetPassword=R.prototype.Ne;R.goOffline=function(){E("Firebase.goOffline",0,0,arguments.length);Wh.Ob().qb()};R.goOnline=function(){E("Firebase.goOnline",0,0,arguments.length);Wh.Ob().ic()};
function nb(a,b){y(!b||!0===a||!1===a,"Can't turn on custom loggers persistently.");!0===a?("undefined"!==typeof console&&("function"===typeof console.log?lb=q(console.log,console):"object"===typeof console.log&&(lb=function(a){console.log(a)})),b&&v.set("logging_enabled",!0)):a?lb=a:(lb=null,v.remove("logging_enabled"))}R.enableLogging=nb;R.ServerValue={TIMESTAMP:{".sv":"timestamp"}};R.SDK_VERSION="2.2.0";R.INTERNAL=Y;R.Context=Wh;R.TEST_ACCESS=$;})();
module.exports = Firebase;

},{}],"/Users/luke/dev/040715/node_modules/mout/array.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'append' : require('./array/append'),
    'collect' : require('./array/collect'),
    'combine' : require('./array/combine'),
    'compact' : require('./array/compact'),
    'contains' : require('./array/contains'),
    'difference' : require('./array/difference'),
    'equals' : require('./array/equals'),
    'every' : require('./array/every'),
    'filter' : require('./array/filter'),
    'find' : require('./array/find'),
    'findIndex' : require('./array/findIndex'),
    'findLast' : require('./array/findLast'),
    'findLastIndex' : require('./array/findLastIndex'),
    'flatten' : require('./array/flatten'),
    'forEach' : require('./array/forEach'),
    'groupBy' : require('./array/groupBy'),
    'indexOf' : require('./array/indexOf'),
    'insert' : require('./array/insert'),
    'intersection' : require('./array/intersection'),
    'invoke' : require('./array/invoke'),
    'join' : require('./array/join'),
    'last' : require('./array/last'),
    'lastIndexOf' : require('./array/lastIndexOf'),
    'map' : require('./array/map'),
    'max' : require('./array/max'),
    'min' : require('./array/min'),
    'pick' : require('./array/pick'),
    'pluck' : require('./array/pluck'),
    'range' : require('./array/range'),
    'reduce' : require('./array/reduce'),
    'reduceRight' : require('./array/reduceRight'),
    'reject' : require('./array/reject'),
    'remove' : require('./array/remove'),
    'removeAll' : require('./array/removeAll'),
    'shuffle' : require('./array/shuffle'),
    'slice' : require('./array/slice'),
    'some' : require('./array/some'),
    'sort' : require('./array/sort'),
    'sortBy' : require('./array/sortBy'),
    'split' : require('./array/split'),
    'take' : require('./array/take'),
    'toLookup' : require('./array/toLookup'),
    'union' : require('./array/union'),
    'unique' : require('./array/unique'),
    'xor' : require('./array/xor'),
    'zip' : require('./array/zip')
};



},{"./array/append":"/Users/luke/dev/040715/node_modules/mout/array/append.js","./array/collect":"/Users/luke/dev/040715/node_modules/mout/array/collect.js","./array/combine":"/Users/luke/dev/040715/node_modules/mout/array/combine.js","./array/compact":"/Users/luke/dev/040715/node_modules/mout/array/compact.js","./array/contains":"/Users/luke/dev/040715/node_modules/mout/array/contains.js","./array/difference":"/Users/luke/dev/040715/node_modules/mout/array/difference.js","./array/equals":"/Users/luke/dev/040715/node_modules/mout/array/equals.js","./array/every":"/Users/luke/dev/040715/node_modules/mout/array/every.js","./array/filter":"/Users/luke/dev/040715/node_modules/mout/array/filter.js","./array/find":"/Users/luke/dev/040715/node_modules/mout/array/find.js","./array/findIndex":"/Users/luke/dev/040715/node_modules/mout/array/findIndex.js","./array/findLast":"/Users/luke/dev/040715/node_modules/mout/array/findLast.js","./array/findLastIndex":"/Users/luke/dev/040715/node_modules/mout/array/findLastIndex.js","./array/flatten":"/Users/luke/dev/040715/node_modules/mout/array/flatten.js","./array/forEach":"/Users/luke/dev/040715/node_modules/mout/array/forEach.js","./array/groupBy":"/Users/luke/dev/040715/node_modules/mout/array/groupBy.js","./array/indexOf":"/Users/luke/dev/040715/node_modules/mout/array/indexOf.js","./array/insert":"/Users/luke/dev/040715/node_modules/mout/array/insert.js","./array/intersection":"/Users/luke/dev/040715/node_modules/mout/array/intersection.js","./array/invoke":"/Users/luke/dev/040715/node_modules/mout/array/invoke.js","./array/join":"/Users/luke/dev/040715/node_modules/mout/array/join.js","./array/last":"/Users/luke/dev/040715/node_modules/mout/array/last.js","./array/lastIndexOf":"/Users/luke/dev/040715/node_modules/mout/array/lastIndexOf.js","./array/map":"/Users/luke/dev/040715/node_modules/mout/array/map.js","./array/max":"/Users/luke/dev/040715/node_modules/mout/array/max.js","./array/min":"/Users/luke/dev/040715/node_modules/mout/array/min.js","./array/pick":"/Users/luke/dev/040715/node_modules/mout/array/pick.js","./array/pluck":"/Users/luke/dev/040715/node_modules/mout/array/pluck.js","./array/range":"/Users/luke/dev/040715/node_modules/mout/array/range.js","./array/reduce":"/Users/luke/dev/040715/node_modules/mout/array/reduce.js","./array/reduceRight":"/Users/luke/dev/040715/node_modules/mout/array/reduceRight.js","./array/reject":"/Users/luke/dev/040715/node_modules/mout/array/reject.js","./array/remove":"/Users/luke/dev/040715/node_modules/mout/array/remove.js","./array/removeAll":"/Users/luke/dev/040715/node_modules/mout/array/removeAll.js","./array/shuffle":"/Users/luke/dev/040715/node_modules/mout/array/shuffle.js","./array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js","./array/some":"/Users/luke/dev/040715/node_modules/mout/array/some.js","./array/sort":"/Users/luke/dev/040715/node_modules/mout/array/sort.js","./array/sortBy":"/Users/luke/dev/040715/node_modules/mout/array/sortBy.js","./array/split":"/Users/luke/dev/040715/node_modules/mout/array/split.js","./array/take":"/Users/luke/dev/040715/node_modules/mout/array/take.js","./array/toLookup":"/Users/luke/dev/040715/node_modules/mout/array/toLookup.js","./array/union":"/Users/luke/dev/040715/node_modules/mout/array/union.js","./array/unique":"/Users/luke/dev/040715/node_modules/mout/array/unique.js","./array/xor":"/Users/luke/dev/040715/node_modules/mout/array/xor.js","./array/zip":"/Users/luke/dev/040715/node_modules/mout/array/zip.js"}],"/Users/luke/dev/040715/node_modules/mout/array/append.js":[function(require,module,exports){


    /**
     * Appends an array to the end of another.
     * The first array will be modified.
     */
    function append(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var pad = arr1.length,
            i = -1,
            len = arr2.length;
        while (++i < len) {
            arr1[pad + i] = arr2[i];
        }
        return arr1;
    }
    module.exports = append;


},{}],"/Users/luke/dev/040715/node_modules/mout/array/collect.js":[function(require,module,exports){
var append = require('./append');
var makeIterator = require('../function/makeIterator_');

    /**
     * Maps the items in the array and concatenates the result arrays.
     */
    function collect(arr, callback, thisObj){
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            var value = callback(arr[i], i, arr);
            if (value != null) {
                append(results, value);
            }
        }

        return results;
    }

    module.exports = collect;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./append":"/Users/luke/dev/040715/node_modules/mout/array/append.js"}],"/Users/luke/dev/040715/node_modules/mout/array/combine.js":[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Combines an array with all the items of another.
     * Does not allow duplicates and is case and type sensitive.
     */
    function combine(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var i = -1, len = arr2.length;
        while (++i < len) {
            if (indexOf(arr1, arr2[i]) === -1) {
                arr1.push(arr2[i]);
            }
        }

        return arr1;
    }
    module.exports = combine;


},{"./indexOf":"/Users/luke/dev/040715/node_modules/mout/array/indexOf.js"}],"/Users/luke/dev/040715/node_modules/mout/array/compact.js":[function(require,module,exports){
var filter = require('./filter');

    /**
     * Remove all null/undefined items from array.
     */
    function compact(arr) {
        return filter(arr, function(val){
            return (val != null);
        });
    }

    module.exports = compact;


},{"./filter":"/Users/luke/dev/040715/node_modules/mout/array/filter.js"}],"/Users/luke/dev/040715/node_modules/mout/array/contains.js":[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * If array contains values.
     */
    function contains(arr, val) {
        return indexOf(arr, val) !== -1;
    }
    module.exports = contains;


},{"./indexOf":"/Users/luke/dev/040715/node_modules/mout/array/indexOf.js"}],"/Users/luke/dev/040715/node_modules/mout/array/difference.js":[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var some = require('./some');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements that aren't present in the other Arrays.
     */
    function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return !some(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = difference;



},{"./contains":"/Users/luke/dev/040715/node_modules/mout/array/contains.js","./filter":"/Users/luke/dev/040715/node_modules/mout/array/filter.js","./slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js","./some":"/Users/luke/dev/040715/node_modules/mout/array/some.js","./unique":"/Users/luke/dev/040715/node_modules/mout/array/unique.js"}],"/Users/luke/dev/040715/node_modules/mout/array/equals.js":[function(require,module,exports){
var is = require('../lang/is');
var isArray = require('../lang/isArray');
var every = require('./every');

    /**
     * Compares if both arrays have the same elements
     */
    function equals(a, b, callback){
        callback = callback || is;

        if (!isArray(a) || !isArray(b)) {
            return callback(a, b);
        }

        if (a.length !== b.length) {
            return false;
        }

        return every(a, makeCompare(callback), b);
    }

    function makeCompare(callback) {
        return function(value, i) {
            return i in this && callback(value, this[i]);
        };
    }

    module.exports = equals;



},{"../lang/is":"/Users/luke/dev/040715/node_modules/mout/lang/is.js","../lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","./every":"/Users/luke/dev/040715/node_modules/mout/array/every.js"}],"/Users/luke/dev/040715/node_modules/mout/array/every.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array every
     */
    function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (!callback(arr[i], i, arr) ) {
                result = false;
                break;
            }
        }

        return result;
    }

    module.exports = every;


},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/filter.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/find.js":[function(require,module,exports){
var findIndex = require('./findIndex');

    /**
     * Returns first item that matches criteria
     */
    function find(arr, iterator, thisObj){
        var idx = findIndex(arr, iterator, thisObj);
        return idx >= 0? arr[idx] : void(0);
    }

    module.exports = find;



},{"./findIndex":"/Users/luke/dev/040715/node_modules/mout/array/findIndex.js"}],"/Users/luke/dev/040715/node_modules/mout/array/findIndex.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns the index of the first item that matches criteria
     */
    function findIndex(arr, iterator, thisObj){
        iterator = makeIterator(iterator, thisObj);
        if (arr == null) {
            return -1;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (iterator(arr[i], i, arr)) {
                return i;
            }
        }

        return -1;
    }

    module.exports = findIndex;


},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/findLast.js":[function(require,module,exports){
var findLastIndex = require('./findLastIndex');

    /**
     * Returns last item that matches criteria
     */
    function findLast(arr, iterator, thisObj){
        var idx = findLastIndex(arr, iterator, thisObj);
        return idx >= 0? arr[idx] : void(0);
    }

    module.exports = findLast;



},{"./findLastIndex":"/Users/luke/dev/040715/node_modules/mout/array/findLastIndex.js"}],"/Users/luke/dev/040715/node_modules/mout/array/findLastIndex.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns the index of the last item that matches criteria
     */
    function findLastIndex(arr, iterator, thisObj){
        iterator = makeIterator(iterator, thisObj);
        if (arr == null) {
            return -1;
        }

        var n = arr.length;
        while (--n >= 0) {
            if (iterator(arr[n], n, arr)) {
                return n;
            }
        }

        return -1;
    }

    module.exports = findLastIndex;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/flatten.js":[function(require,module,exports){
var isArray = require('../lang/isArray');
var append = require('./append');

    /*
     * Helper function to flatten to a destination array.
     * Used to remove the need to create intermediate arrays while flattening.
     */
    function flattenTo(arr, result, level) {
        if (arr == null) {
            return result;
        } else if (level === 0) {
            append(result, arr);
            return result;
        }

        var value,
            i = -1,
            len = arr.length;
        while (++i < len) {
            value = arr[i];
            if (isArray(value)) {
                flattenTo(value, result, level - 1);
            } else {
                result.push(value);
            }
        }
        return result;
    }

    /**
     * Recursively flattens an array.
     * A new array containing all the elements is returned.
     * If `shallow` is true, it will only flatten one level.
     */
    function flatten(arr, level) {
        level = level == null? -1 : level;
        return flattenTo(arr, [], level);
    }

    module.exports = flatten;




},{"../lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","./append":"/Users/luke/dev/040715/node_modules/mout/array/append.js"}],"/Users/luke/dev/040715/node_modules/mout/array/forEach.js":[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],"/Users/luke/dev/040715/node_modules/mout/array/groupBy.js":[function(require,module,exports){
var forEach = require('../array/forEach');
var identity = require('../function/identity');
var makeIterator = require('../function/makeIterator_');

    /**
     * Bucket the array values.
     */
    function groupBy(arr, categorize, thisObj) {
        if (categorize) {
            categorize = makeIterator(categorize, thisObj);
        } else {
            // Default to identity function.
            categorize = identity;
        }

        var buckets = {};
        forEach(arr, function(element) {
            var bucket = categorize(element);
            if (!(bucket in buckets)) {
                buckets[bucket] = [];
            }

            buckets[bucket].push(element);
        });

        return buckets;
    }

    module.exports = groupBy;


},{"../array/forEach":"/Users/luke/dev/040715/node_modules/mout/array/forEach.js","../function/identity":"/Users/luke/dev/040715/node_modules/mout/function/identity.js","../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/indexOf.js":[function(require,module,exports){


    /**
     * Array.indexOf
     */
    function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
            return -1;
        }

        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[i] === item) {
                return i;
            }

            i++;
        }

        return -1;
    }

    module.exports = indexOf;


},{}],"/Users/luke/dev/040715/node_modules/mout/array/insert.js":[function(require,module,exports){
var difference = require('./difference');
var slice = require('./slice');

    /**
     * Insert item into array if not already present.
     */
    function insert(arr, rest_items) {
        var diff = difference(slice(arguments, 1), arr);
        if (diff.length) {
            Array.prototype.push.apply(arr, diff);
        }
        return arr.length;
    }
    module.exports = insert;


},{"./difference":"/Users/luke/dev/040715/node_modules/mout/array/difference.js","./slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/array/intersection.js":[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var every = require('./every');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements common to all Arrays.
     * - based on underscore.js implementation
     */
    function intersection(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return every(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = intersection;



},{"./contains":"/Users/luke/dev/040715/node_modules/mout/array/contains.js","./every":"/Users/luke/dev/040715/node_modules/mout/array/every.js","./filter":"/Users/luke/dev/040715/node_modules/mout/array/filter.js","./slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js","./unique":"/Users/luke/dev/040715/node_modules/mout/array/unique.js"}],"/Users/luke/dev/040715/node_modules/mout/array/invoke.js":[function(require,module,exports){
var slice = require('./slice');

    /**
     * Call `methodName` on each item of the array passing custom arguments if
     * needed.
     */
    function invoke(arr, methodName, var_args){
        if (arr == null) {
            return arr;
        }

        var args = slice(arguments, 2);
        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            value[methodName].apply(value, args);
        }

        return arr;
    }

    module.exports = invoke;


},{"./slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/array/join.js":[function(require,module,exports){
var filter = require('./filter');

    function isValidString(val) {
        return (val != null && val !== '');
    }

    /**
     * Joins strings with the specified separator inserted between each value.
     * Null values and empty strings will be excluded.
     */
    function join(items, separator) {
        separator = separator || '';
        return filter(items, isValidString).join(separator);
    }

    module.exports = join;


},{"./filter":"/Users/luke/dev/040715/node_modules/mout/array/filter.js"}],"/Users/luke/dev/040715/node_modules/mout/array/last.js":[function(require,module,exports){


    /**
     * Returns last element of array.
     */
    function last(arr){
        if (arr == null || arr.length < 1) {
            return undefined;
        }

        return arr[arr.length - 1];
    }

    module.exports = last;



},{}],"/Users/luke/dev/040715/node_modules/mout/array/lastIndexOf.js":[function(require,module,exports){


    /**
     * Array lastIndexOf
     */
    function lastIndexOf(arr, item, fromIndex) {
        if (arr == null) {
            return -1;
        }

        var len = arr.length;
        fromIndex = (fromIndex == null || fromIndex >= len)? len - 1 : fromIndex;
        fromIndex = (fromIndex < 0)? len + fromIndex : fromIndex;

        while (fromIndex >= 0) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[fromIndex] === item) {
                return fromIndex;
            }
            fromIndex--;
        }

        return -1;
    }

    module.exports = lastIndexOf;


},{}],"/Users/luke/dev/040715/node_modules/mout/array/map.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/max.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Return maximum value inside array
     */
    function max(arr, iterator, thisObj){
        if (arr == null || !arr.length) {
            return Infinity;
        } else if (arr.length && !iterator) {
            return Math.max.apply(Math, arr);
        } else {
            iterator = makeIterator(iterator, thisObj);
            var result,
                compare = -Infinity,
                value,
                temp;

            var i = -1, len = arr.length;
            while (++i < len) {
                value = arr[i];
                temp = iterator(value, i, arr);
                if (temp > compare) {
                    compare = temp;
                    result = value;
                }
            }

            return result;
        }
    }

    module.exports = max;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/min.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Return minimum value inside array
     */
    function min(arr, iterator, thisObj){
        if (arr == null || !arr.length) {
            return -Infinity;
        } else if (arr.length && !iterator) {
            return Math.min.apply(Math, arr);
        } else {
            iterator = makeIterator(iterator, thisObj);
            var result,
                compare = Infinity,
                value,
                temp;

            var i = -1, len = arr.length;
            while (++i < len) {
                value = arr[i];
                temp = iterator(value, i, arr);
                if (temp < compare) {
                    compare = temp;
                    result = value;
                }
            }

            return result;
        }
    }

    module.exports = min;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/pick.js":[function(require,module,exports){
var randInt = require('../random/randInt');

    /**
     * Remove random item(s) from the Array and return it.
     * Returns an Array of items if [nItems] is provided or a single item if
     * it isn't specified.
     */
    function pick(arr, nItems){
        if (nItems != null) {
            var result = [];
            if (nItems > 0 && arr && arr.length) {
                nItems = nItems > arr.length? arr.length : nItems;
                while (nItems--) {
                    result.push( pickOne(arr) );
                }
            }
            return result;
        }
        return (arr && arr.length)? pickOne(arr) : void(0);
    }


    function pickOne(arr){
        var idx = randInt(0, arr.length - 1);
        return arr.splice(idx, 1)[0];
    }


    module.exports = pick;



},{"../random/randInt":"/Users/luke/dev/040715/node_modules/mout/random/randInt.js"}],"/Users/luke/dev/040715/node_modules/mout/array/pluck.js":[function(require,module,exports){
var map = require('./map');

    /**
     * Extract a list of property values.
     */
    function pluck(arr, propName){
        return map(arr, propName);
    }

    module.exports = pluck;



},{"./map":"/Users/luke/dev/040715/node_modules/mout/array/map.js"}],"/Users/luke/dev/040715/node_modules/mout/array/range.js":[function(require,module,exports){
var countSteps = require('../math/countSteps');

    /**
     * Returns an Array of numbers inside range.
     */
    function range(start, stop, step) {
        if (stop == null) {
            stop = start;
            start = 0;
        }
        step = step || 1;

        var result = [],
            nSteps = countSteps(stop - start, step),
            i = start;

        while (i <= stop) {
            result.push(i);
            i += step;
        }

        return result;
    }

    module.exports = range;



},{"../math/countSteps":"/Users/luke/dev/040715/node_modules/mout/math/countSteps.js"}],"/Users/luke/dev/040715/node_modules/mout/array/reduce.js":[function(require,module,exports){


    /**
     * Array reduce
     */
    function reduce(arr, fn, initVal) {
        // check for args.length since initVal might be "undefined" see #gh-57
        var hasInit = arguments.length > 2,
            result = initVal;

        if (arr == null || !arr.length) {
            if (!hasInit) {
                throw new Error('reduce of empty array with no initial value');
            } else {
                return initVal;
            }
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (!hasInit) {
                result = arr[i];
                hasInit = true;
            } else {
                result = fn(result, arr[i], i, arr);
            }
        }

        return result;
    }

    module.exports = reduce;


},{}],"/Users/luke/dev/040715/node_modules/mout/array/reduceRight.js":[function(require,module,exports){


    /**
     * Array reduceRight
     */
    function reduceRight(arr, fn, initVal) {
        // check for args.length since initVal might be "undefined" see #gh-57
        var hasInit = arguments.length > 2;

        if (arr == null || !arr.length) {
            if (hasInit) {
                return initVal;
            } else {
                throw new Error('reduce of empty array with no initial value');
            }
        }

        var i = arr.length, result = initVal, value;
        while (--i >= 0) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            value = arr[i];
            if (!hasInit) {
                result = value;
                hasInit = true;
            } else {
                result = fn(result, value, i, arr);
            }
        }
        return result;
    }

    module.exports = reduceRight;


},{}],"/Users/luke/dev/040715/node_modules/mout/array/reject.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array reject
     */
    function reject(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (!callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = reject;


},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/remove.js":[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Remove a single item from the array.
     * (it won't remove duplicates, just a single item)
     */
    function remove(arr, item){
        var idx = indexOf(arr, item);
        if (idx !== -1) arr.splice(idx, 1);
    }

    module.exports = remove;


},{"./indexOf":"/Users/luke/dev/040715/node_modules/mout/array/indexOf.js"}],"/Users/luke/dev/040715/node_modules/mout/array/removeAll.js":[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Remove all instances of an item from array.
     */
    function removeAll(arr, item){
        var idx = indexOf(arr, item);
        while (idx !== -1) {
            arr.splice(idx, 1);
            idx = indexOf(arr, item, idx);
        }
    }

    module.exports = removeAll;


},{"./indexOf":"/Users/luke/dev/040715/node_modules/mout/array/indexOf.js"}],"/Users/luke/dev/040715/node_modules/mout/array/shuffle.js":[function(require,module,exports){
var randInt = require('../random/randInt');

    /**
     * Shuffle array items.
     */
    function shuffle(arr) {
        var results = [],
            rnd;
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            if (!i) {
                results[0] = arr[0];
            } else {
                rnd = randInt(0, i);
                results[i] = results[rnd];
                results[rnd] = arr[i];
            }
        }

        return results;
    }

    module.exports = shuffle;


},{"../random/randInt":"/Users/luke/dev/040715/node_modules/mout/random/randInt.js"}],"/Users/luke/dev/040715/node_modules/mout/array/slice.js":[function(require,module,exports){


    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    module.exports = slice;



},{}],"/Users/luke/dev/040715/node_modules/mout/array/some.js":[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    module.exports = some;


},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js"}],"/Users/luke/dev/040715/node_modules/mout/array/sort.js":[function(require,module,exports){


    /**
     * Merge sort (http://en.wikipedia.org/wiki/Merge_sort)
     */
    function mergeSort(arr, compareFn) {
        if (arr == null) {
            return [];
        } else if (arr.length < 2) {
            return arr;
        }

        if (compareFn == null) {
            compareFn = defaultCompare;
        }

        var mid, left, right;

        mid   = ~~(arr.length / 2);
        left  = mergeSort( arr.slice(0, mid), compareFn );
        right = mergeSort( arr.slice(mid, arr.length), compareFn );

        return merge(left, right, compareFn);
    }

    function defaultCompare(a, b) {
        return a < b ? -1 : (a > b? 1 : 0);
    }

    function merge(left, right, compareFn) {
        var result = [];

        while (left.length && right.length) {
            if (compareFn(left[0], right[0]) <= 0) {
                // if 0 it should preserve same order (stable)
                result.push(left.shift());
            } else {
                result.push(right.shift());
            }
        }

        if (left.length) {
            result.push.apply(result, left);
        }

        if (right.length) {
            result.push.apply(result, right);
        }

        return result;
    }

    module.exports = mergeSort;



},{}],"/Users/luke/dev/040715/node_modules/mout/array/sortBy.js":[function(require,module,exports){
var sort = require('./sort');
var makeIterator = require('../function/makeIterator_');

    /*
     * Sort array by the result of the callback
     */
    function sortBy(arr, callback, context){
        callback = makeIterator(callback, context);

        return sort(arr, function(a, b) {
            a = callback(a);
            b = callback(b);
            return (a < b) ? -1 : ((a > b) ? 1 : 0);
        });
    }

    module.exports = sortBy;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./sort":"/Users/luke/dev/040715/node_modules/mout/array/sort.js"}],"/Users/luke/dev/040715/node_modules/mout/array/split.js":[function(require,module,exports){


    /**
     * Split array into a fixed number of segments.
     */
    function split(array, segments) {
        segments = segments || 2;
        var results = [];
        if (array == null) {
            return results;
        }

        var minLength = Math.floor(array.length / segments),
            remainder = array.length % segments,
            i = 0,
            len = array.length,
            segmentIndex = 0,
            segmentLength;

        while (i < len) {
            segmentLength = minLength;
            if (segmentIndex < remainder) {
                segmentLength++;
            }

            results.push(array.slice(i, i + segmentLength));

            segmentIndex++;
            i += segmentLength;
        }

        return results;
    }
    module.exports = split;


},{}],"/Users/luke/dev/040715/node_modules/mout/array/take.js":[function(require,module,exports){


    /**
     * Iterates over a callback a set amount of times
     * returning the results
     */
    function take(n, callback, thisObj){
        var i = -1;
        var arr = [];
        if( !thisObj ){
            while(++i < n){
                arr[i] = callback(i, n);
            }
        } else {
            while(++i < n){
                arr[i] = callback.call(thisObj, i, n);
            }
        }
        return arr;
    }

    module.exports = take;



},{}],"/Users/luke/dev/040715/node_modules/mout/array/toLookup.js":[function(require,module,exports){
var isFunction = require('../lang/isFunction');

    /**
     * Creates an object that holds a lookup for the objects in the array.
     */
    function toLookup(arr, key) {
        var result = {};
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length, value;
        if (isFunction(key)) {
            while (++i < len) {
                value = arr[i];
                result[key(value)] = value;
            }
        } else {
            while (++i < len) {
                value = arr[i];
                result[value[key]] = value;
            }
        }

        return result;
    }
    module.exports = toLookup;


},{"../lang/isFunction":"/Users/luke/dev/040715/node_modules/mout/lang/isFunction.js"}],"/Users/luke/dev/040715/node_modules/mout/array/union.js":[function(require,module,exports){
var unique = require('./unique');
var append = require('./append');

    /**
     * Concat multiple arrays and remove duplicates
     */
    function union(arrs) {
        var results = [];
        var i = -1, len = arguments.length;
        while (++i < len) {
            append(results, arguments[i]);
        }

        return unique(results);
    }

    module.exports = union;



},{"./append":"/Users/luke/dev/040715/node_modules/mout/array/append.js","./unique":"/Users/luke/dev/040715/node_modules/mout/array/unique.js"}],"/Users/luke/dev/040715/node_modules/mout/array/unique.js":[function(require,module,exports){
var filter = require('./filter');

    /**
     * @return {array} Array of unique items
     */
    function unique(arr, compare){
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr){
            var n = arr.length;
            while (++i < n) {
                if ( compare(item, arr[i]) ) {
                    return false;
                }
            }
            return true;
        });
    }

    function isEqual(a, b){
        return a === b;
    }

    module.exports = unique;



},{"./filter":"/Users/luke/dev/040715/node_modules/mout/array/filter.js"}],"/Users/luke/dev/040715/node_modules/mout/array/xor.js":[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var contains = require('./contains');


    /**
     * Exclusive OR. Returns items that are present in a single array.
     * - like ptyhon's `symmetric_difference`
     */
    function xor(arr1, arr2) {
        arr1 = unique(arr1);
        arr2 = unique(arr2);

        var a1 = filter(arr1, function(item){
                return !contains(arr2, item);
            }),
            a2 = filter(arr2, function(item){
                return !contains(arr1, item);
            });

        return a1.concat(a2);
    }

    module.exports = xor;



},{"./contains":"/Users/luke/dev/040715/node_modules/mout/array/contains.js","./filter":"/Users/luke/dev/040715/node_modules/mout/array/filter.js","./unique":"/Users/luke/dev/040715/node_modules/mout/array/unique.js"}],"/Users/luke/dev/040715/node_modules/mout/array/zip.js":[function(require,module,exports){
var max = require('./max');
var map = require('./map');

    function getLength(arr) {
        return arr == null ? 0 : arr.length;
    }

    /**
     * Merges together the values of each of the arrays with the values at the
     * corresponding position.
     */
    function zip(arr){
        var len = arr ? max(map(arguments, getLength)) : 0,
            results = [],
            i = -1;
        while (++i < len) {
            // jshint loopfunc: true
            results.push(map(arguments, function(item) {
                return item == null ? undefined : item[i];
            }));
        }

        return results;
    }

    module.exports = zip;



},{"./map":"/Users/luke/dev/040715/node_modules/mout/array/map.js","./max":"/Users/luke/dev/040715/node_modules/mout/array/max.js"}],"/Users/luke/dev/040715/node_modules/mout/collection.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'contains' : require('./collection/contains'),
    'every' : require('./collection/every'),
    'filter' : require('./collection/filter'),
    'find' : require('./collection/find'),
    'forEach' : require('./collection/forEach'),
    'make_' : require('./collection/make_'),
    'map' : require('./collection/map'),
    'max' : require('./collection/max'),
    'min' : require('./collection/min'),
    'pluck' : require('./collection/pluck'),
    'reduce' : require('./collection/reduce'),
    'reject' : require('./collection/reject'),
    'size' : require('./collection/size'),
    'some' : require('./collection/some')
};



},{"./collection/contains":"/Users/luke/dev/040715/node_modules/mout/collection/contains.js","./collection/every":"/Users/luke/dev/040715/node_modules/mout/collection/every.js","./collection/filter":"/Users/luke/dev/040715/node_modules/mout/collection/filter.js","./collection/find":"/Users/luke/dev/040715/node_modules/mout/collection/find.js","./collection/forEach":"/Users/luke/dev/040715/node_modules/mout/collection/forEach.js","./collection/make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js","./collection/map":"/Users/luke/dev/040715/node_modules/mout/collection/map.js","./collection/max":"/Users/luke/dev/040715/node_modules/mout/collection/max.js","./collection/min":"/Users/luke/dev/040715/node_modules/mout/collection/min.js","./collection/pluck":"/Users/luke/dev/040715/node_modules/mout/collection/pluck.js","./collection/reduce":"/Users/luke/dev/040715/node_modules/mout/collection/reduce.js","./collection/reject":"/Users/luke/dev/040715/node_modules/mout/collection/reject.js","./collection/size":"/Users/luke/dev/040715/node_modules/mout/collection/size.js","./collection/some":"/Users/luke/dev/040715/node_modules/mout/collection/some.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/contains.js":[function(require,module,exports){
var make = require('./make_');
var arrContains = require('../array/contains');
var objContains = require('../object/contains');

    /**
     */
    module.exports = make(arrContains, objContains);



},{"../array/contains":"/Users/luke/dev/040715/node_modules/mout/array/contains.js","../object/contains":"/Users/luke/dev/040715/node_modules/mout/object/contains.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/every.js":[function(require,module,exports){
var make = require('./make_');
var arrEvery = require('../array/every');
var objEvery = require('../object/every');

    /**
     */
    module.exports = make(arrEvery, objEvery);



},{"../array/every":"/Users/luke/dev/040715/node_modules/mout/array/every.js","../object/every":"/Users/luke/dev/040715/node_modules/mout/object/every.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/filter.js":[function(require,module,exports){
var forEach = require('./forEach');
var makeIterator = require('../function/makeIterator_');

    /**
     * filter collection values, returns array.
     */
    function filter(list, iterator, thisObj) {
        iterator = makeIterator(iterator, thisObj);
        var results = [];
        if (!list) {
            return results;
        }
        forEach(list, function(value, index, list) {
            if (iterator(value, index, list)) {
                results[results.length] = value;
            }
        });
        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./forEach":"/Users/luke/dev/040715/node_modules/mout/collection/forEach.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/find.js":[function(require,module,exports){
var make = require('./make_');
var arrFind = require('../array/find');
var objFind = require('../object/find');

    /**
     * Find value that returns true on iterator check.
     */
    module.exports = make(arrFind, objFind);



},{"../array/find":"/Users/luke/dev/040715/node_modules/mout/array/find.js","../object/find":"/Users/luke/dev/040715/node_modules/mout/object/find.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/forEach.js":[function(require,module,exports){
var make = require('./make_');
var arrForEach = require('../array/forEach');
var objForEach = require('../object/forOwn');

    /**
     */
    module.exports = make(arrForEach, objForEach);



},{"../array/forEach":"/Users/luke/dev/040715/node_modules/mout/array/forEach.js","../object/forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/make_.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * internal method used to create other collection modules.
     */
    function makeCollectionMethod(arrMethod, objMethod, defaultReturn) {
        return function(){
            var args = slice(arguments);
            if (args[0] == null) {
                return defaultReturn;
            }
            // array-like is treated as array
            return (typeof args[0].length === 'number')? arrMethod.apply(null, args) : objMethod.apply(null, args);
        };
    }

    module.exports = makeCollectionMethod;



},{"../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/map.js":[function(require,module,exports){
var isObject = require('../lang/isObject');
var values = require('../object/values');
var arrMap = require('../array/map');
var makeIterator = require('../function/makeIterator_');

    /**
     * Map collection values, returns Array.
     */
    function map(list, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        // list.length to check array-like object, if not array-like
        // we simply map all the object values
        if( isObject(list) && list.length == null ){
            list = values(list);
        }
        return arrMap(list, function (val, key, list) {
            return callback(val, key, list);
        });
    }

    module.exports = map;



},{"../array/map":"/Users/luke/dev/040715/node_modules/mout/array/map.js","../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","../lang/isObject":"/Users/luke/dev/040715/node_modules/mout/lang/isObject.js","../object/values":"/Users/luke/dev/040715/node_modules/mout/object/values.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/max.js":[function(require,module,exports){
var make = require('./make_');
var arrMax = require('../array/max');
var objMax = require('../object/max');

    /**
     * Get maximum value inside collection
     */
    module.exports = make(arrMax, objMax);



},{"../array/max":"/Users/luke/dev/040715/node_modules/mout/array/max.js","../object/max":"/Users/luke/dev/040715/node_modules/mout/object/max.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/min.js":[function(require,module,exports){
var make = require('./make_');
var arrMin = require('../array/min');
var objMin = require('../object/min');

    /**
     * Get minimum value inside collection.
     */
    module.exports = make(arrMin, objMin);



},{"../array/min":"/Users/luke/dev/040715/node_modules/mout/array/min.js","../object/min":"/Users/luke/dev/040715/node_modules/mout/object/min.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/pluck.js":[function(require,module,exports){
var map = require('./map');

    /**
     * Extract a list of property values.
     */
    function pluck(list, key) {
        return map(list, function(value) {
            return value[key];
        });
    }

    module.exports = pluck;



},{"./map":"/Users/luke/dev/040715/node_modules/mout/collection/map.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/reduce.js":[function(require,module,exports){
var make = require('./make_');
var arrReduce = require('../array/reduce');
var objReduce = require('../object/reduce');

    /**
     */
    module.exports = make(arrReduce, objReduce);



},{"../array/reduce":"/Users/luke/dev/040715/node_modules/mout/array/reduce.js","../object/reduce":"/Users/luke/dev/040715/node_modules/mout/object/reduce.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/reject.js":[function(require,module,exports){
var filter = require('./filter');
var makeIterator = require('../function/makeIterator_');

    /**
     * Inverse or collection/filter
     */
    function reject(list, iterator, thisObj) {
        iterator = makeIterator(iterator, thisObj);
        return filter(list, function(value, index, list) {
            return !iterator(value, index, list);
        }, thisObj);
    }

    module.exports = reject;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./filter":"/Users/luke/dev/040715/node_modules/mout/collection/filter.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/size.js":[function(require,module,exports){
var isArray = require('../lang/isArray');
var objSize = require('../object/size');

    /**
     * Get collection size
     */
    function size(list) {
        if (!list) {
            return 0;
        }
        if (isArray(list)) {
            return list.length;
        }
        return objSize(list);
    }

    module.exports = size;



},{"../lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","../object/size":"/Users/luke/dev/040715/node_modules/mout/object/size.js"}],"/Users/luke/dev/040715/node_modules/mout/collection/some.js":[function(require,module,exports){
var make = require('./make_');
var arrSome = require('../array/some');
var objSome = require('../object/some');

    /**
     */
    module.exports = make(arrSome, objSome);



},{"../array/some":"/Users/luke/dev/040715/node_modules/mout/array/some.js","../object/some":"/Users/luke/dev/040715/node_modules/mout/object/some.js","./make_":"/Users/luke/dev/040715/node_modules/mout/collection/make_.js"}],"/Users/luke/dev/040715/node_modules/mout/date.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'dayOfTheYear' : require('./date/dayOfTheYear'),
    'diff' : require('./date/diff'),
    'i18n_' : require('./date/i18n_'),
    'isLeapYear' : require('./date/isLeapYear'),
    'isSame' : require('./date/isSame'),
    'parseIso' : require('./date/parseIso'),
    'quarter' : require('./date/quarter'),
    'startOf' : require('./date/startOf'),
    'strftime' : require('./date/strftime'),
    'timezoneAbbr' : require('./date/timezoneAbbr'),
    'timezoneOffset' : require('./date/timezoneOffset'),
    'totalDaysInMonth' : require('./date/totalDaysInMonth'),
    'totalDaysInYear' : require('./date/totalDaysInYear'),
    'weekOfTheYear' : require('./date/weekOfTheYear')
};



},{"./date/dayOfTheYear":"/Users/luke/dev/040715/node_modules/mout/date/dayOfTheYear.js","./date/diff":"/Users/luke/dev/040715/node_modules/mout/date/diff.js","./date/i18n_":"/Users/luke/dev/040715/node_modules/mout/date/i18n_.js","./date/isLeapYear":"/Users/luke/dev/040715/node_modules/mout/date/isLeapYear.js","./date/isSame":"/Users/luke/dev/040715/node_modules/mout/date/isSame.js","./date/parseIso":"/Users/luke/dev/040715/node_modules/mout/date/parseIso.js","./date/quarter":"/Users/luke/dev/040715/node_modules/mout/date/quarter.js","./date/startOf":"/Users/luke/dev/040715/node_modules/mout/date/startOf.js","./date/strftime":"/Users/luke/dev/040715/node_modules/mout/date/strftime.js","./date/timezoneAbbr":"/Users/luke/dev/040715/node_modules/mout/date/timezoneAbbr.js","./date/timezoneOffset":"/Users/luke/dev/040715/node_modules/mout/date/timezoneOffset.js","./date/totalDaysInMonth":"/Users/luke/dev/040715/node_modules/mout/date/totalDaysInMonth.js","./date/totalDaysInYear":"/Users/luke/dev/040715/node_modules/mout/date/totalDaysInYear.js","./date/weekOfTheYear":"/Users/luke/dev/040715/node_modules/mout/date/weekOfTheYear.js"}],"/Users/luke/dev/040715/node_modules/mout/date/dayOfTheYear.js":[function(require,module,exports){
var isDate = require('../lang/isDate');

    /**
     * return the day of the year (1..366)
     */
    function dayOfTheYear(date){
        return (Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) -
                Date.UTC(date.getFullYear(), 0, 1)) / 86400000 + 1;
    }

    module.exports = dayOfTheYear;



},{"../lang/isDate":"/Users/luke/dev/040715/node_modules/mout/lang/isDate.js"}],"/Users/luke/dev/040715/node_modules/mout/date/diff.js":[function(require,module,exports){
var totalDaysInMonth = require('./totalDaysInMonth');
var totalDaysInYear = require('./totalDaysInYear');
var convert = require('../time/convert');

    /**
     * calculate the difference between dates (range)
     */
    function diff(start, end, unitName){
        // sort the dates to make it easier to process (specially year/month)
        if (start > end) {
            var swap = start;
            start = end;
            end = swap;
        }

        var output;

        if (unitName === 'month') {
            output = getMonthsDiff(start, end);
        } else if (unitName === 'year'){
            output = getYearsDiff(start, end);
        } else if (unitName != null) {
            if (unitName === 'day') {
                // ignore timezone difference because of daylight savings time
                start = toUtc(start);
                end = toUtc(end);
            }
            output = convert(end - start, 'ms', unitName);
        } else {
            output = end - start;
        }

        return output;
    }


    function toUtc(d){
        // we ignore timezone differences on purpose because of daylight
        // savings time, otherwise it would return fractional days/weeks even
        // if a full day elapsed. eg:
        // Wed Feb 12 2014 00:00:00 GMT-0200 (BRST)
        // Sun Feb 16 2014 00:00:00 GMT-0300 (BRT)
        // diff should be 4 days and not 4.041666666666667
        return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(),
                        d.getHours(), d.getMinutes(), d.getSeconds(),
                        d.getMilliseconds());
    }


    function getMonthsDiff(start, end){
        return getElapsedMonths(start, end) +
               getElapsedYears(start, end) * 12 +
               getFractionalMonth(start, end);
    }


    function getYearsDiff(start, end){
        var elapsedYears = getElapsedYears(start, end);
        return elapsedYears + getFractionalYear(start, end, elapsedYears);
    }


    function getElapsedMonths(start, end){
        var monthDiff = end.getMonth() - start.getMonth();
        if (monthDiff < 0) {
            monthDiff += 12;
        }
        // less than a full month
        if (start.getDate() > end.getDate()) {
            monthDiff -= 1;
        }
        return monthDiff;
    }


    function getElapsedYears(start, end){
        var yearDiff = end.getFullYear() - start.getFullYear();
        // less than a full year
        if (start.getMonth() > end.getMonth()) {
            yearDiff -= 1;
        }
        return yearDiff;
    }


    function getFractionalMonth(start, end){
        var fractionalDiff = 0;
        var startDay = start.getDate();
        var endDay = end.getDate();

        if (startDay !== endDay) {
            var startTotalDays = totalDaysInMonth(start);
            var endTotalDays = totalDaysInMonth(end);
            var totalDays;
            var daysElapsed;

            if (startDay > endDay) {
                // eg: Jan 29 - Feb 27 (29 days elapsed but not a full month)
                var baseDay = startTotalDays - startDay;
                daysElapsed = endDay + baseDay;
                // total days should be relative to 1st day of next month if
                // startDay > endTotalDays
                totalDays = (startDay > endTotalDays)?
                    endTotalDays + baseDay + 1 : startDay + baseDay;
            } else {
                // fractional is only based on endMonth eg: Jan 12 - Feb 18
                // (6 fractional days, 28 days until next full month)
                daysElapsed = endDay - startDay;
                totalDays = endTotalDays;
            }

            fractionalDiff = daysElapsed / totalDays;
        }

        return fractionalDiff;
    }


    function getFractionalYear(start, end, elapsedYears){
        var base = elapsedYears?
            new Date(end.getFullYear(), start.getMonth(), start.getDate()) :
            start;
        var elapsedDays = diff(base, end, 'day');
        return elapsedDays / totalDaysInYear(end);
    }


    module.exports = diff;



},{"../time/convert":"/Users/luke/dev/040715/node_modules/mout/time/convert.js","./totalDaysInMonth":"/Users/luke/dev/040715/node_modules/mout/date/totalDaysInMonth.js","./totalDaysInYear":"/Users/luke/dev/040715/node_modules/mout/date/totalDaysInYear.js"}],"/Users/luke/dev/040715/node_modules/mout/date/i18n/en-US.js":[function(require,module,exports){

    // en-US (English, United States)
    module.exports = {
        "am" : "AM",
        "pm" : "PM",

        "x": "%m/%d/%y",
        "X": "%H:%M:%S",
        "c": "%a %d %b %Y %I:%M:%S %p %Z",

        "months" : [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
        ],

        "months_abbr" : [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
        ],

        "days" : [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
        ],

        "days_abbr" : [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
        ]
    };


},{}],"/Users/luke/dev/040715/node_modules/mout/date/i18n_.js":[function(require,module,exports){
var mixIn = require('../object/mixIn');
var enUS = require('./i18n/en-US');

    // we also use mixIn to make sure we don't affect the original locale
    var activeLocale = mixIn({}, enUS, {
        // we expose a "set" method to allow overriding the global locale
        set : function(localeData){
            mixIn(activeLocale, localeData);
        }
    });

    module.exports = activeLocale;



},{"../object/mixIn":"/Users/luke/dev/040715/node_modules/mout/object/mixIn.js","./i18n/en-US":"/Users/luke/dev/040715/node_modules/mout/date/i18n/en-US.js"}],"/Users/luke/dev/040715/node_modules/mout/date/isLeapYear.js":[function(require,module,exports){
var isDate = require('../lang/isDate');

    /**
     * checks if it's a leap year
     */
    function isLeapYear(fullYear){
        if (isDate(fullYear)) {
            fullYear = fullYear.getFullYear();
        }
        return fullYear % 400 === 0 || (fullYear % 100 !== 0 && fullYear % 4 === 0);
    }

    module.exports = isLeapYear;



},{"../lang/isDate":"/Users/luke/dev/040715/node_modules/mout/lang/isDate.js"}],"/Users/luke/dev/040715/node_modules/mout/date/isSame.js":[function(require,module,exports){
var startOf = require('./startOf');

    /**
     * Check if date is "same" with optional period
     */
    function isSame(date1, date2, period){
        if (period) {
            date1 = startOf(date1, period);
            date2 = startOf(date2, period);
        }
        return Number(date1) === Number(date2);
    }

    module.exports = isSame;



},{"./startOf":"/Users/luke/dev/040715/node_modules/mout/date/startOf.js"}],"/Users/luke/dev/040715/node_modules/mout/date/parseIso.js":[function(require,module,exports){
var some = require('../array/some');

    var datePatterns = [
        /^([0-9]{4})$/,                        // YYYY
        /^([0-9]{4})-([0-9]{2})$/,             // YYYY-MM (YYYYMM not allowed)
        /^([0-9]{4})-?([0-9]{2})-?([0-9]{2})$/ // YYYY-MM-DD or YYYYMMDD
    ];
    var ORD_DATE = /^([0-9]{4})-?([0-9]{3})$/; // YYYY-DDD

    var timePatterns = [
        /^([0-9]{2}(?:\.[0-9]*)?)$/,                      // HH.hh
        /^([0-9]{2}):?([0-9]{2}(?:\.[0-9]*)?)$/,          // HH:MM.mm
        /^([0-9]{2}):?([0-9]{2}):?([0-9]{2}(\.[0-9]*)?)$/ // HH:MM:SS.ss
    ];

    var DATE_TIME = /^(.+)T(.+)$/;
    var TIME_ZONE = /^(.+)([+\-])([0-9]{2}):?([0-9]{2})$/;

    function matchAll(str, patterns) {
        var match;
        var found = some(patterns, function(pattern) {
            return !!(match = pattern.exec(str));
        });

        return found ? match : null;
    }

    function getDate(year, month, day) {
        var date = new Date(Date.UTC(year, month, day));

        // Explicitly set year to avoid Date.UTC making dates < 100 relative to
        // 1900
        date.setUTCFullYear(year);

        var valid =
            date.getUTCFullYear() === year &&
            date.getUTCMonth() === month &&
            date.getUTCDate() === day;
        return valid ? +date : NaN;
    }

    function parseOrdinalDate(str) {
        var match = ORD_DATE.exec(str);
        if (match ) {
            var year = +match[1],
                day = +match[2],
                date = new Date(Date.UTC(year, 0, day));

            if (date.getUTCFullYear() === year) {
                return +date;
            }
        }

        return NaN;
    }

    function parseDate(str) {
        var match, year, month, day;

        match = matchAll(str, datePatterns);
        if (match === null) {
            // Ordinal dates are verified differently.
            return parseOrdinalDate(str);
        }

        year = (match[1] === void 0) ? 0 : +match[1];
        month = (match[2] === void 0) ? 0 : +match[2] - 1;
        day = (match[3] === void 0) ? 1 : +match[3];

        return getDate(year, month, day);
    }

    function getTime(hr, min, sec) {
        var valid =
            (hr < 24 && hr >= 0 &&
             min < 60 && min >= 0 &&
             sec < 60 && min >= 0) ||
            (hr === 24 && min === 0 && sec === 0);
        if (!valid) {
            return NaN;
        }

        return ((hr * 60 + min) * 60 + sec) * 1000;
    }

    function parseOffset(str) {
        var match;
        if (str.charAt(str.length - 1) === 'Z') {
            str = str.substring(0, str.length - 1);
        } else {
            match = TIME_ZONE.exec(str);
            if (match) {
                var hours = +match[3],
                    minutes = (match[4] === void 0) ? 0 : +match[4],
                    offset = getTime(hours, minutes, 0);

                if (match[2] === '-') {
                    offset *= -1;
                }

                return { offset: offset, time: match[1] };
            }
        }

        // No time zone specified, assume UTC
        return { offset: 0, time: str };
    }

    function parseTime(str) {
        var match;
        var offset = parseOffset(str);

        str = offset.time;
        offset = offset.offset;
        if (isNaN(offset)) {
            return NaN;
        }

        match = matchAll(str, timePatterns);
        if (match === null) {
            return NaN;
        }

        var hours = (match[1] === void 0) ? 0 : +match[1],
            minutes = (match[2] === void 0) ? 0 : +match[2],
            seconds = (match[3] === void 0) ? 0 : +match[3];

        return getTime(hours, minutes, seconds) - offset;
    }

    /**
     * Parse an ISO8601 formatted date string, and return a Date object.
     */
    function parseISO8601(str){
        var match = DATE_TIME.exec(str);
        if (!match) {
            // No time specified
            return parseDate(str);
        }

        return parseDate(match[1]) + parseTime(match[2]);
    }

    module.exports = parseISO8601;



},{"../array/some":"/Users/luke/dev/040715/node_modules/mout/array/some.js"}],"/Users/luke/dev/040715/node_modules/mout/date/quarter.js":[function(require,module,exports){


    /**
     * gets date quarter
     */
    function quarter(date){
        var month = date.getMonth();
        if (month < 3) return 1;
        if (month < 6) return 2;
        if (month < 9) return 3;
        return 4;
    }

    module.exports = quarter;



},{}],"/Users/luke/dev/040715/node_modules/mout/date/startOf.js":[function(require,module,exports){
var clone = require('../lang/clone');

    /**
     * get a new Date object representing start of period
     */
    function startOf(date, period){
        date = clone(date);

        // intentionally removed "break" from switch since start of
        // month/year/etc should also reset the following periods
        switch (period) {
            case 'year':
                date.setMonth(0);
            /* falls through */
            case 'month':
                date.setDate(1);
            /* falls through */
            case 'week':
            case 'day':
                date.setHours(0);
            /* falls through */
            case 'hour':
                date.setMinutes(0);
            /* falls through */
            case 'minute':
                date.setSeconds(0);
            /* falls through */
            case 'second':
                date.setMilliseconds(0);
                break;
            default:
                throw new Error('"'+ period +'" is not a valid period');
        }

        // week is the only case that should reset the weekDay and maybe even
        // overflow to previous month
        if (period === 'week') {
            var weekDay = date.getDay();
            var baseDate = date.getDate();
            if (weekDay) {
                if (weekDay >= baseDate) {
                    //start of the week is on previous month
                    date.setDate(0);
                }
                date.setDate(date.getDate() - date.getDay());
            }
        }

        return date;
    }

    module.exports = startOf;



},{"../lang/clone":"/Users/luke/dev/040715/node_modules/mout/lang/clone.js"}],"/Users/luke/dev/040715/node_modules/mout/date/strftime.js":[function(require,module,exports){
var pad = require('../number/pad');
var lpad = require('../string/lpad');
var i18n = require('./i18n_');
var dayOfTheYear = require('./dayOfTheYear');
var timezoneOffset = require('./timezoneOffset');
var timezoneAbbr = require('./timezoneAbbr');
var weekOfTheYear = require('./weekOfTheYear');

    var _combinations = {
        'D': '%m/%d/%y',
        'F': '%Y-%m-%d',
        'r': '%I:%M:%S %p',
        'R': '%H:%M',
        'T': '%H:%M:%S',
        'x': 'locale',
        'X': 'locale',
        'c': 'locale'
    };


    /**
     * format date based on strftime format
     */
    function strftime(date, format, localeData){
        localeData = localeData  || i18n;
        var reToken = /%([a-z%])/gi;

        function makeIterator(fn) {
            return function(match, token){
                return fn(date, token, localeData);
            };
        }

        return format
            .replace(reToken, makeIterator(expandCombinations))
            .replace(reToken, makeIterator(convertToken));
    }


    function expandCombinations(date, token, l10n){
        if (token in _combinations) {
            var expanded = _combinations[token];
            return expanded === 'locale'? l10n[token] : expanded;
        } else {
            return '%'+ token;
        }
    }


    function convertToken(date, token, l10n){
        switch (token){
            case 'a':
                return l10n.days_abbr[date.getDay()];
            case 'A':
                return l10n.days[date.getDay()];
            case 'h':
            case 'b':
                return l10n.months_abbr[date.getMonth()];
            case 'B':
                return l10n.months[date.getMonth()];
            case 'C':
                return pad(Math.floor(date.getFullYear() / 100), 2);
            case 'd':
                return pad(date.getDate(), 2);
            case 'e':
                return pad(date.getDate(), 2, ' ');
            case 'H':
                return pad(date.getHours(), 2);
            case 'I':
                return pad(date.getHours() % 12, 2);
            case 'j':
                return pad(dayOfTheYear(date), 3);
            case 'l':
                return lpad(date.getHours() % 12, 2);
            case 'L':
                return pad(date.getMilliseconds(), 3);
            case 'm':
                return pad(date.getMonth() + 1, 2);
            case 'M':
                return pad(date.getMinutes(), 2);
            case 'n':
                return '\n';
            case 'p':
                return date.getHours() >= 12? l10n.pm : l10n.am;
            case 'P':
                return convertToken(date, 'p', l10n).toLowerCase();
            case 's':
                return date.getTime() / 1000;
            case 'S':
                return pad(date.getSeconds(), 2);
            case 't':
                return '\t';
            case 'u':
                var day = date.getDay();
                return day === 0? 7 : day;
            case 'U':
                return pad(weekOfTheYear(date), 2);
            case 'w':
                return date.getDay();
            case 'W':
                return pad(weekOfTheYear(date, 1), 2);
            case 'y':
                return pad(date.getFullYear() % 100, 2);
            case 'Y':
                return pad(date.getFullYear(), 4);
            case 'z':
                return timezoneOffset(date);
            case 'Z':
                return timezoneAbbr(date);
            case '%':
                return '%';
            default:
                // keep unrecognized tokens
                return '%'+ token;
        }
    }


    module.exports = strftime;



},{"../number/pad":"/Users/luke/dev/040715/node_modules/mout/number/pad.js","../string/lpad":"/Users/luke/dev/040715/node_modules/mout/string/lpad.js","./dayOfTheYear":"/Users/luke/dev/040715/node_modules/mout/date/dayOfTheYear.js","./i18n_":"/Users/luke/dev/040715/node_modules/mout/date/i18n_.js","./timezoneAbbr":"/Users/luke/dev/040715/node_modules/mout/date/timezoneAbbr.js","./timezoneOffset":"/Users/luke/dev/040715/node_modules/mout/date/timezoneOffset.js","./weekOfTheYear":"/Users/luke/dev/040715/node_modules/mout/date/weekOfTheYear.js"}],"/Users/luke/dev/040715/node_modules/mout/date/timezoneAbbr.js":[function(require,module,exports){
var timezoneOffset = require('./timezoneOffset');

    /**
     * Abbreviated time zone name or similar information.
     */
    function timezoneAbbr(date){
        // Date.toString gives different results depending on the
        // browser/system so we fallback to timezone offset
        // chrome: 'Mon Apr 08 2013 09:02:04 GMT-0300 (BRT)'
        // IE: 'Mon Apr 8 09:02:04 UTC-0300 2013'
        var tz = /\(([A-Z]{3,4})\)/.exec(date.toString());
        return tz? tz[1] : timezoneOffset(date);
    }

    module.exports = timezoneAbbr;



},{"./timezoneOffset":"/Users/luke/dev/040715/node_modules/mout/date/timezoneOffset.js"}],"/Users/luke/dev/040715/node_modules/mout/date/timezoneOffset.js":[function(require,module,exports){
var pad = require('../number/pad');

    /**
     * time zone as hour and minute offset from UTC (e.g. +0900)
     */
    function timezoneOffset(date){
        var offset = date.getTimezoneOffset();
        var abs = Math.abs(offset);
        var h = pad(Math.floor(abs / 60), 2);
        var m = pad(abs % 60, 2);
        return (offset > 0? '-' : '+') + h + m;
    }

    module.exports = timezoneOffset;



},{"../number/pad":"/Users/luke/dev/040715/node_modules/mout/number/pad.js"}],"/Users/luke/dev/040715/node_modules/mout/date/totalDaysInMonth.js":[function(require,module,exports){
var isDate = require('../lang/isDate');
var isLeapYear = require('./isLeapYear');

    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

    /**
     * returns the total amount of days in the month (considering leap years)
     */
    function totalDaysInMonth(fullYear, monthIndex){
        if (isDate(fullYear)) {
            monthIndex = fullYear.getMonth();
        }

        if (monthIndex === 1 && isLeapYear(fullYear)) {
            return 29;
        } else {
            return DAYS_IN_MONTH[monthIndex];
        }
    }

    module.exports = totalDaysInMonth;



},{"../lang/isDate":"/Users/luke/dev/040715/node_modules/mout/lang/isDate.js","./isLeapYear":"/Users/luke/dev/040715/node_modules/mout/date/isLeapYear.js"}],"/Users/luke/dev/040715/node_modules/mout/date/totalDaysInYear.js":[function(require,module,exports){
var isLeapYear = require('./isLeapYear');

    /**
     * return the amount of days in the year following the gregorian calendar
     * and leap years
     */
    function totalDaysInYear(fullYear){
        return isLeapYear(fullYear)? 366 : 365;
    }

    module.exports = totalDaysInYear;



},{"./isLeapYear":"/Users/luke/dev/040715/node_modules/mout/date/isLeapYear.js"}],"/Users/luke/dev/040715/node_modules/mout/date/weekOfTheYear.js":[function(require,module,exports){
var dayOfTheYear = require('./dayOfTheYear');

    /**
     * Return the week of the year based on given firstDayOfWeek
     */
    function weekOfTheYear(date, firstDayOfWeek){
        firstDayOfWeek = firstDayOfWeek == null? 0 : firstDayOfWeek;
        var doy = dayOfTheYear(date);
        var dow = (7 + date.getDay() - firstDayOfWeek) % 7;
        var relativeWeekDay = 6 - firstDayOfWeek - dow;
        return Math.floor((doy + relativeWeekDay) / 7);
    }

    module.exports = weekOfTheYear;



},{"./dayOfTheYear":"/Users/luke/dev/040715/node_modules/mout/date/dayOfTheYear.js"}],"/Users/luke/dev/040715/node_modules/mout/function.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'awaitDelay' : require('./function/awaitDelay'),
    'bind' : require('./function/bind'),
    'compose' : require('./function/compose'),
    'constant' : require('./function/constant'),
    'debounce' : require('./function/debounce'),
    'func' : require('./function/func'),
    'identity' : require('./function/identity'),
    'makeIterator_' : require('./function/makeIterator_'),
    'partial' : require('./function/partial'),
    'prop' : require('./function/prop'),
    'series' : require('./function/series'),
    'throttle' : require('./function/throttle'),
    'timeout' : require('./function/timeout'),
    'times' : require('./function/times'),
    'wrap' : require('./function/wrap')
};



},{"./function/awaitDelay":"/Users/luke/dev/040715/node_modules/mout/function/awaitDelay.js","./function/bind":"/Users/luke/dev/040715/node_modules/mout/function/bind.js","./function/compose":"/Users/luke/dev/040715/node_modules/mout/function/compose.js","./function/constant":"/Users/luke/dev/040715/node_modules/mout/function/constant.js","./function/debounce":"/Users/luke/dev/040715/node_modules/mout/function/debounce.js","./function/func":"/Users/luke/dev/040715/node_modules/mout/function/func.js","./function/identity":"/Users/luke/dev/040715/node_modules/mout/function/identity.js","./function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./function/partial":"/Users/luke/dev/040715/node_modules/mout/function/partial.js","./function/prop":"/Users/luke/dev/040715/node_modules/mout/function/prop.js","./function/series":"/Users/luke/dev/040715/node_modules/mout/function/series.js","./function/throttle":"/Users/luke/dev/040715/node_modules/mout/function/throttle.js","./function/timeout":"/Users/luke/dev/040715/node_modules/mout/function/timeout.js","./function/times":"/Users/luke/dev/040715/node_modules/mout/function/times.js","./function/wrap":"/Users/luke/dev/040715/node_modules/mout/function/wrap.js"}],"/Users/luke/dev/040715/node_modules/mout/function/awaitDelay.js":[function(require,module,exports){
var now = require('../time/now');
var timeout = require('./timeout');
var append = require('../array/append');

    /**
     * Ensure a minimum delay for callbacks
     */
    function awaitDelay( callback, delay ){
        var baseTime = now() + delay;
        return function() {
            // ensure all browsers will execute it asynchronously (avoid hard
            // to catch errors) not using "0" because of old browsers and also
            // since new browsers increase the value to be at least "4"
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout
            var ms = Math.max(baseTime - now(), 4);
            return timeout.apply(this, append([callback, ms, this], arguments));
        };
    }

    module.exports = awaitDelay;



},{"../array/append":"/Users/luke/dev/040715/node_modules/mout/array/append.js","../time/now":"/Users/luke/dev/040715/node_modules/mout/time/now.js","./timeout":"/Users/luke/dev/040715/node_modules/mout/function/timeout.js"}],"/Users/luke/dev/040715/node_modules/mout/function/bind.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a function that will execute in the given context, optionally adding any additional supplied parameters to the beginning of the arguments collection.
     * @param {Function} fn  Function.
     * @param {object} context   Execution context.
     * @param {rest} args    Arguments (0...n arguments).
     * @return {Function} Wrapped Function.
     */
    function bind(fn, context, args){
        var argsArr = slice(arguments, 2); //curried args
        return function(){
            return fn.apply(context, argsArr.concat(slice(arguments)));
        };
    }

    module.exports = bind;



},{"../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/function/compose.js":[function(require,module,exports){


    /**
     * Returns a function that composes multiple functions, passing results to
     * each other.
     */
    function compose() {
        var fns = arguments;
        return function(arg){
            // only cares about the first argument since the chain can only
            // deal with a single return value anyway. It should start from
            // the last fn.
            var n = fns.length;
            while (n--) {
                arg = fns[n].call(this, arg);
            }
            return arg;
         };
     }

     module.exports = compose;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/constant.js":[function(require,module,exports){


    /**
     * Returns a new function that will return the value
     */
    function constant(value){
        return function() {
            return value;
        };
    }

    module.exports = constant;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/debounce.js":[function(require,module,exports){


    /**
     * Debounce callback execution
     */
    function debounce(fn, threshold, isAsap){
        var timeout, result;
        function debounced(){
            var args = arguments, context = this;
            function delayed(){
                if (! isAsap) {
                    result = fn.apply(context, args);
                }
                timeout = null;
            }
            if (timeout) {
                clearTimeout(timeout);
            } else if (isAsap) {
                result = fn.apply(context, args);
            }
            timeout = setTimeout(delayed, threshold);
            return result;
        }
        debounced.cancel = function(){
            clearTimeout(timeout);
        };
        return debounced;
    }

    module.exports = debounce;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/func.js":[function(require,module,exports){


    /**
     * Returns a function that call a method on the passed object
     */
    function func(name){
        return function(obj){
            return obj[name]();
        };
    }

    module.exports = func;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/identity.js":[function(require,module,exports){


    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    module.exports = identity;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js":[function(require,module,exports){
var identity = require('./identity');
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":"/Users/luke/dev/040715/node_modules/mout/object/deepMatches.js","./identity":"/Users/luke/dev/040715/node_modules/mout/function/identity.js","./prop":"/Users/luke/dev/040715/node_modules/mout/function/prop.js"}],"/Users/luke/dev/040715/node_modules/mout/function/partial.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Creates a partially applied function.
     */
    function partial(f) {
        var as = slice(arguments, 1);
        return function() {
            var args = as.concat(slice(arguments));
            for (var i = args.length; i--;) {
                if (args[i] === partial._) {
                    args[i] = args.splice(-1)[0];
                }
            }
            return f.apply(this, args);
        };
    }

    partial._ = {};

    module.exports = partial;



},{"../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/function/prop.js":[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/series.js":[function(require,module,exports){


    /**
     * Returns a function that will execute a list of functions in sequence
     * passing the same arguments to each one. (useful for batch processing
     * items during a forEach loop)
     */
    function series(){
        var fns = arguments;
        return function(){
            var i = 0,
                n = fns.length;
            while (i < n) {
                fns[i].apply(this, arguments);
                i += 1;
            }
        };
    }

    module.exports = series;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/throttle.js":[function(require,module,exports){
var now = require('../time/now');

    /**
     */
    function throttle(fn, delay){
        var context, timeout, result, args,
            diff, prevCall = 0;
        function delayed(){
            prevCall = now();
            timeout = null;
            result = fn.apply(context, args);
        }
        function throttled(){
            context = this;
            args = arguments;
            diff = delay - (now() - prevCall);
            if (diff <= 0) {
                clearTimeout(timeout);
                delayed();
            } else if (! timeout) {
                timeout = setTimeout(delayed, diff);
            }
            return result;
        }
        throttled.cancel = function(){
            clearTimeout(timeout);
        };
        return throttled;
    }

    module.exports = throttle;



},{"../time/now":"/Users/luke/dev/040715/node_modules/mout/time/now.js"}],"/Users/luke/dev/040715/node_modules/mout/function/timeout.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Delays the call of a function within a given context.
     */
    function timeout(fn, millis, context){

        var args = slice(arguments, 3);

        return setTimeout(function() {
            fn.apply(context, args);
        }, millis);
    }

    module.exports = timeout;



},{"../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/function/times.js":[function(require,module,exports){


    /**
     * Iterates over a callback a set amount of times
     */
    function times(n, callback, thisObj){
        var i = -1;
        while (++i < n) {
            if ( callback.call(thisObj, i) === false ) {
                break;
            }
        }
    }

    module.exports = times;



},{}],"/Users/luke/dev/040715/node_modules/mout/function/wrap.js":[function(require,module,exports){
var partial = require('./partial');

    /**
     * Returns the first function passed as an argument to the second,
     * allowing you to adjust arguments, run code before and after, and
     * conditionally execute the original function.
     */
    function wrap(fn, wrapper){
        return partial(wrapper, fn);
    }

    module.exports = wrap;



},{"./partial":"/Users/luke/dev/040715/node_modules/mout/function/partial.js"}],"/Users/luke/dev/040715/node_modules/mout/index.js":[function(require,module,exports){
/**@license
 * mout v0.11.0 | http://moutjs.com | MIT license
 */


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'VERSION' : '0.11.0',
    'array' : require('./array'),
    'collection' : require('./collection'),
    'date' : require('./date'),
    'function' : require('./function'),
    'lang' : require('./lang'),
    'math' : require('./math'),
    'number' : require('./number'),
    'object' : require('./object'),
    'queryString' : require('./queryString'),
    'random' : require('./random'),
    'string' : require('./string'),
    'time' : require('./time'),
    'fn' : require('./function')
};



},{"./array":"/Users/luke/dev/040715/node_modules/mout/array.js","./collection":"/Users/luke/dev/040715/node_modules/mout/collection.js","./date":"/Users/luke/dev/040715/node_modules/mout/date.js","./function":"/Users/luke/dev/040715/node_modules/mout/function.js","./lang":"/Users/luke/dev/040715/node_modules/mout/lang.js","./math":"/Users/luke/dev/040715/node_modules/mout/math.js","./number":"/Users/luke/dev/040715/node_modules/mout/number.js","./object":"/Users/luke/dev/040715/node_modules/mout/object.js","./queryString":"/Users/luke/dev/040715/node_modules/mout/queryString.js","./random":"/Users/luke/dev/040715/node_modules/mout/random.js","./string":"/Users/luke/dev/040715/node_modules/mout/string.js","./time":"/Users/luke/dev/040715/node_modules/mout/time.js"}],"/Users/luke/dev/040715/node_modules/mout/lang.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'GLOBAL' : require('./lang/GLOBAL'),
    'clone' : require('./lang/clone'),
    'createObject' : require('./lang/createObject'),
    'ctorApply' : require('./lang/ctorApply'),
    'deepClone' : require('./lang/deepClone'),
    'deepEquals' : require('./lang/deepEquals'),
    'defaults' : require('./lang/defaults'),
    'inheritPrototype' : require('./lang/inheritPrototype'),
    'is' : require('./lang/is'),
    'isArguments' : require('./lang/isArguments'),
    'isArray' : require('./lang/isArray'),
    'isBoolean' : require('./lang/isBoolean'),
    'isDate' : require('./lang/isDate'),
    'isEmpty' : require('./lang/isEmpty'),
    'isFinite' : require('./lang/isFinite'),
    'isFunction' : require('./lang/isFunction'),
    'isInteger' : require('./lang/isInteger'),
    'isKind' : require('./lang/isKind'),
    'isNaN' : require('./lang/isNaN'),
    'isNull' : require('./lang/isNull'),
    'isNumber' : require('./lang/isNumber'),
    'isObject' : require('./lang/isObject'),
    'isPlainObject' : require('./lang/isPlainObject'),
    'isPrimitive' : require('./lang/isPrimitive'),
    'isRegExp' : require('./lang/isRegExp'),
    'isString' : require('./lang/isString'),
    'isUndefined' : require('./lang/isUndefined'),
    'isnt' : require('./lang/isnt'),
    'kindOf' : require('./lang/kindOf'),
    'toArray' : require('./lang/toArray'),
    'toNumber' : require('./lang/toNumber'),
    'toString' : require('./lang/toString')
};



},{"./lang/GLOBAL":"/Users/luke/dev/040715/node_modules/mout/lang/GLOBAL.js","./lang/clone":"/Users/luke/dev/040715/node_modules/mout/lang/clone.js","./lang/createObject":"/Users/luke/dev/040715/node_modules/mout/lang/createObject.js","./lang/ctorApply":"/Users/luke/dev/040715/node_modules/mout/lang/ctorApply.js","./lang/deepClone":"/Users/luke/dev/040715/node_modules/mout/lang/deepClone.js","./lang/deepEquals":"/Users/luke/dev/040715/node_modules/mout/lang/deepEquals.js","./lang/defaults":"/Users/luke/dev/040715/node_modules/mout/lang/defaults.js","./lang/inheritPrototype":"/Users/luke/dev/040715/node_modules/mout/lang/inheritPrototype.js","./lang/is":"/Users/luke/dev/040715/node_modules/mout/lang/is.js","./lang/isArguments":"/Users/luke/dev/040715/node_modules/mout/lang/isArguments.js","./lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","./lang/isBoolean":"/Users/luke/dev/040715/node_modules/mout/lang/isBoolean.js","./lang/isDate":"/Users/luke/dev/040715/node_modules/mout/lang/isDate.js","./lang/isEmpty":"/Users/luke/dev/040715/node_modules/mout/lang/isEmpty.js","./lang/isFinite":"/Users/luke/dev/040715/node_modules/mout/lang/isFinite.js","./lang/isFunction":"/Users/luke/dev/040715/node_modules/mout/lang/isFunction.js","./lang/isInteger":"/Users/luke/dev/040715/node_modules/mout/lang/isInteger.js","./lang/isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js","./lang/isNaN":"/Users/luke/dev/040715/node_modules/mout/lang/isNaN.js","./lang/isNull":"/Users/luke/dev/040715/node_modules/mout/lang/isNull.js","./lang/isNumber":"/Users/luke/dev/040715/node_modules/mout/lang/isNumber.js","./lang/isObject":"/Users/luke/dev/040715/node_modules/mout/lang/isObject.js","./lang/isPlainObject":"/Users/luke/dev/040715/node_modules/mout/lang/isPlainObject.js","./lang/isPrimitive":"/Users/luke/dev/040715/node_modules/mout/lang/isPrimitive.js","./lang/isRegExp":"/Users/luke/dev/040715/node_modules/mout/lang/isRegExp.js","./lang/isString":"/Users/luke/dev/040715/node_modules/mout/lang/isString.js","./lang/isUndefined":"/Users/luke/dev/040715/node_modules/mout/lang/isUndefined.js","./lang/isnt":"/Users/luke/dev/040715/node_modules/mout/lang/isnt.js","./lang/kindOf":"/Users/luke/dev/040715/node_modules/mout/lang/kindOf.js","./lang/toArray":"/Users/luke/dev/040715/node_modules/mout/lang/toArray.js","./lang/toNumber":"/Users/luke/dev/040715/node_modules/mout/lang/toNumber.js","./lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/GLOBAL.js":[function(require,module,exports){


    // Reference to the global context (works on ES3 and ES5-strict mode)
    //jshint -W061, -W064
    module.exports = Function('return this')();



},{}],"/Users/luke/dev/040715/node_modules/mout/lang/clone.js":[function(require,module,exports){
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');
var mixIn = require('../object/mixIn');

    /**
     * Clone native types.
     */
    function clone(val){
        switch (kindOf(val)) {
            case 'Object':
                return cloneObject(val);
            case 'Array':
                return cloneArray(val);
            case 'RegExp':
                return cloneRegExp(val);
            case 'Date':
                return cloneDate(val);
            default:
                return val;
        }
    }

    function cloneObject(source) {
        if (isPlainObject(source)) {
            return mixIn({}, source);
        } else {
            return source;
        }
    }

    function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignoreCase ? 'i' : '';
        return new RegExp(r.source, flags);
    }

    function cloneDate(date) {
        return new Date(+date);
    }

    function cloneArray(arr) {
        return arr.slice();
    }

    module.exports = clone;



},{"../object/mixIn":"/Users/luke/dev/040715/node_modules/mout/object/mixIn.js","./isPlainObject":"/Users/luke/dev/040715/node_modules/mout/lang/isPlainObject.js","./kindOf":"/Users/luke/dev/040715/node_modules/mout/lang/kindOf.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/createObject.js":[function(require,module,exports){
var mixIn = require('../object/mixIn');

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;



},{"../object/mixIn":"/Users/luke/dev/040715/node_modules/mout/object/mixIn.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/ctorApply.js":[function(require,module,exports){


    function F(){}

    /**
     * Do fn.apply on a constructor.
     */
    function ctorApply(ctor, args) {
        F.prototype = ctor.prototype;
        var instance = new F();
        ctor.apply(instance, args);
        return instance;
    }

    module.exports = ctorApply;



},{}],"/Users/luke/dev/040715/node_modules/mout/lang/deepClone.js":[function(require,module,exports){
var clone = require('./clone');
var forOwn = require('../object/forOwn');
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');

    /**
     * Recursively clone native types.
     */
    function deepClone(val, instanceClone) {
        switch ( kindOf(val) ) {
            case 'Object':
                return cloneObject(val, instanceClone);
            case 'Array':
                return cloneArray(val, instanceClone);
            default:
                return clone(val);
        }
    }

    function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
            var out = {};
            forOwn(source, function(val, key) {
                this[key] = deepClone(val, instanceClone);
            }, out);
            return out;
        } else if (instanceClone) {
            return instanceClone(source);
        } else {
            return source;
        }
    }

    function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
            out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
    }

    module.exports = deepClone;




},{"../object/forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js","./clone":"/Users/luke/dev/040715/node_modules/mout/lang/clone.js","./isPlainObject":"/Users/luke/dev/040715/node_modules/mout/lang/isPlainObject.js","./kindOf":"/Users/luke/dev/040715/node_modules/mout/lang/kindOf.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/deepEquals.js":[function(require,module,exports){
var is = require('./is');
var isObject = require('./isObject');
var isArray = require('./isArray');
var objEquals = require('../object/equals');
var arrEquals = require('../array/equals');

    /**
     * Recursively checks for same properties and values.
     */
    function deepEquals(a, b, callback){
        callback = callback || is;

        var bothObjects = isObject(a) && isObject(b);
        var bothArrays = !bothObjects && isArray(a) && isArray(b);

        if (!bothObjects && !bothArrays) {
            return callback(a, b);
        }

        function compare(a, b){
            return deepEquals(a, b, callback);
        }

        var method = bothObjects ? objEquals : arrEquals;
        return method(a, b, compare);
    }

    module.exports = deepEquals;



},{"../array/equals":"/Users/luke/dev/040715/node_modules/mout/array/equals.js","../object/equals":"/Users/luke/dev/040715/node_modules/mout/object/equals.js","./is":"/Users/luke/dev/040715/node_modules/mout/lang/is.js","./isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","./isObject":"/Users/luke/dev/040715/node_modules/mout/lang/isObject.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/defaults.js":[function(require,module,exports){
var toArray = require('./toArray');
var find = require('../array/find');

    /**
     * Return first non void argument
     */
    function defaults(var_args){
        return find(toArray(arguments), nonVoid);
    }

    function nonVoid(val){
        return val != null;
    }

    module.exports = defaults;



},{"../array/find":"/Users/luke/dev/040715/node_modules/mout/array/find.js","./toArray":"/Users/luke/dev/040715/node_modules/mout/lang/toArray.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/inheritPrototype.js":[function(require,module,exports){
var createObject = require('./createObject');

    /**
    * Inherit prototype from another Object.
    * - inspired by Nicholas Zackas <http://nczonline.net> Solution
    * @param {object} child Child object
    * @param {object} parent    Parent Object
    */
    function inheritPrototype(child, parent){
        var p = createObject(parent.prototype);
        p.constructor = child;
        child.prototype = p;
        child.super_ = parent;
        return p;
    }

    module.exports = inheritPrototype;


},{"./createObject":"/Users/luke/dev/040715/node_modules/mout/lang/createObject.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/is.js":[function(require,module,exports){


    /**
     * Check if both arguments are egal.
     */
    function is(x, y){
        // implementation borrowed from harmony:egal spec
        if (x === y) {
          // 0 === -0, but they are not identical
          return x !== 0 || 1 / x === 1 / y;
        }

        // NaN !== NaN, but they are identical.
        // NaNs are the only non-reflexive value, i.e., if x !== x,
        // then x is a NaN.
        // isNaN is broken: it converts its argument to number, so
        // isNaN("foo") => true
        return x !== x && y !== y;
    }

    module.exports = is;



},{}],"/Users/luke/dev/040715/node_modules/mout/lang/isArguments.js":[function(require,module,exports){
var isKind = require('./isKind');

    /**
     */
    var isArgs = isKind(arguments, 'Arguments')?
            function(val){
                return isKind(val, 'Arguments');
            } :
            function(val){
                // Arguments is an Object on IE7
                return !!(val && Object.prototype.hasOwnProperty.call(val, 'callee'));
            };

    module.exports = isArgs;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isBoolean.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isBoolean(val) {
        return isKind(val, 'Boolean');
    }
    module.exports = isBoolean;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isDate.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isDate(val) {
        return isKind(val, 'Date');
    }
    module.exports = isDate;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isEmpty.js":[function(require,module,exports){
var forOwn = require('../object/forOwn');
var isArray = require('./isArray');

    function isEmpty(val){
        if (val == null) {
            // typeof null == 'object' so we check it first
            return true;
        } else if ( typeof val === 'string' || isArray(val) ) {
            return !val.length;
        } else if ( typeof val === 'object' ) {
            var result = true;
            forOwn(val, function(){
                result = false;
                return false; // break loop
            });
            return result;
        } else {
            return true;
        }
    }

    module.exports = isEmpty;



},{"../object/forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js","./isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isFinite.js":[function(require,module,exports){
var isNumber = require('./isNumber');
var GLOBAL = require('./GLOBAL');

    /**
     * Check if value is finite
     */
    function isFinite(val){
        var is = false;
        if (typeof val === 'string' && val !== '') {
            is = GLOBAL.isFinite( parseFloat(val) );
        } else if (isNumber(val)){
            // need to use isNumber because of Number constructor
            is = GLOBAL.isFinite( val );
        }
        return is;
    }

    module.exports = isFinite;



},{"./GLOBAL":"/Users/luke/dev/040715/node_modules/mout/lang/GLOBAL.js","./isNumber":"/Users/luke/dev/040715/node_modules/mout/lang/isNumber.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isFunction.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isFunction(val) {
        return isKind(val, 'Function');
    }
    module.exports = isFunction;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isInteger.js":[function(require,module,exports){
var isNumber = require('./isNumber');

    /**
     * Check if value is an integer
     */
    function isInteger(val){
        return isNumber(val) && (val % 1 === 0);
    }

    module.exports = isInteger;



},{"./isNumber":"/Users/luke/dev/040715/node_modules/mout/lang/isNumber.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js":[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":"/Users/luke/dev/040715/node_modules/mout/lang/kindOf.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isNaN.js":[function(require,module,exports){
var isNumber = require('./isNumber');
var $isNaN = require('../number/isNaN');

    /**
     * Check if value is NaN for realz
     */
    function isNaN(val){
        // based on the fact that NaN !== NaN
        // need to check if it's a number to avoid conflicts with host objects
        // also need to coerce ToNumber to avoid edge case `new Number(NaN)`
        return !isNumber(val) || $isNaN(Number(val));
    }

    module.exports = isNaN;



},{"../number/isNaN":"/Users/luke/dev/040715/node_modules/mout/number/isNaN.js","./isNumber":"/Users/luke/dev/040715/node_modules/mout/lang/isNumber.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isNull.js":[function(require,module,exports){

    /**
     */
    function isNull(val){
        return val === null;
    }
    module.exports = isNull;



},{}],"/Users/luke/dev/040715/node_modules/mout/lang/isNumber.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isNumber(val) {
        return isKind(val, 'Number');
    }
    module.exports = isNumber;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isObject.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isPlainObject.js":[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],"/Users/luke/dev/040715/node_modules/mout/lang/isPrimitive.js":[function(require,module,exports){


    /**
     * Checks if the object is a primitive
     */
    function isPrimitive(value) {
        // Using switch fallthrough because it's simple to read and is
        // generally fast: http://jsperf.com/testing-value-is-primitive/5
        switch (typeof value) {
            case "string":
            case "number":
            case "boolean":
                return true;
        }

        return value == null;
    }

    module.exports = isPrimitive;



},{}],"/Users/luke/dev/040715/node_modules/mout/lang/isRegExp.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }
    module.exports = isRegExp;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isString.js":[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isString(val) {
        return isKind(val, 'String');
    }
    module.exports = isString;


},{"./isKind":"/Users/luke/dev/040715/node_modules/mout/lang/isKind.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/isUndefined.js":[function(require,module,exports){

    var UNDEF;

    /**
     */
    function isUndef(val){
        return val === UNDEF;
    }
    module.exports = isUndef;


},{}],"/Users/luke/dev/040715/node_modules/mout/lang/isnt.js":[function(require,module,exports){
var is = require('./is');

    /**
     * Check if both values are not identical/egal
     */
    function isnt(x, y){
        return !is(x, y);
    }

    module.exports = isnt;



},{"./is":"/Users/luke/dev/040715/node_modules/mout/lang/is.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/kindOf.js":[function(require,module,exports){


    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    module.exports = kindOf;


},{}],"/Users/luke/dev/040715/node_modules/mout/lang/toArray.js":[function(require,module,exports){
var kindOf = require('./kindOf');
var GLOBAL = require('./GLOBAL');

    /**
     * Convert array-like object into array
     */
    function toArray(val){
        var ret = [],
            kind = kindOf(val),
            n;

        if (val != null) {
            if ( val.length == null || kind === 'String' || kind === 'Function' || kind === 'RegExp' || val === GLOBAL ) {
                //string, regexp, function have .length but user probably just want
                //to wrap value into an array..
                ret[ret.length] = val;
            } else {
                //window returns true on isObject in IE7 and may have length
                //property. `typeof NodeList` returns `function` on Safari so
                //we can't use it (#58)
                n = val.length;
                while (n--) {
                    ret[n] = val[n];
                }
            }
        }
        return ret;
    }
    module.exports = toArray;


},{"./GLOBAL":"/Users/luke/dev/040715/node_modules/mout/lang/GLOBAL.js","./kindOf":"/Users/luke/dev/040715/node_modules/mout/lang/kindOf.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/toNumber.js":[function(require,module,exports){
var isArray = require('./isArray');

    /**
     * covert value into number if numeric
     */
    function toNumber(val){
        // numberic values should come first because of -0
        if (typeof val === 'number') return val;
        // we want all falsy values (besides -0) to return zero to avoid
        // headaches
        if (!val) return 0;
        if (typeof val === 'string') return parseFloat(val);
        // arrays are edge cases. `Number([4]) === 4`
        if (isArray(val)) return NaN;
        return Number(val);
    }

    module.exports = toNumber;



},{"./isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js"}],"/Users/luke/dev/040715/node_modules/mout/lang/toString.js":[function(require,module,exports){


    /**
     * Typecast a value to a String, using an empty string value for null or
     * undefined.
     */
    function toString(val){
        return val == null ? '' : val.toString();
    }

    module.exports = toString;



},{}],"/Users/luke/dev/040715/node_modules/mout/math.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'ceil' : require('./math/ceil'),
    'clamp' : require('./math/clamp'),
    'countSteps' : require('./math/countSteps'),
    'floor' : require('./math/floor'),
    'inRange' : require('./math/inRange'),
    'isNear' : require('./math/isNear'),
    'lerp' : require('./math/lerp'),
    'loop' : require('./math/loop'),
    'map' : require('./math/map'),
    'norm' : require('./math/norm'),
    'round' : require('./math/round')
};



},{"./math/ceil":"/Users/luke/dev/040715/node_modules/mout/math/ceil.js","./math/clamp":"/Users/luke/dev/040715/node_modules/mout/math/clamp.js","./math/countSteps":"/Users/luke/dev/040715/node_modules/mout/math/countSteps.js","./math/floor":"/Users/luke/dev/040715/node_modules/mout/math/floor.js","./math/inRange":"/Users/luke/dev/040715/node_modules/mout/math/inRange.js","./math/isNear":"/Users/luke/dev/040715/node_modules/mout/math/isNear.js","./math/lerp":"/Users/luke/dev/040715/node_modules/mout/math/lerp.js","./math/loop":"/Users/luke/dev/040715/node_modules/mout/math/loop.js","./math/map":"/Users/luke/dev/040715/node_modules/mout/math/map.js","./math/norm":"/Users/luke/dev/040715/node_modules/mout/math/norm.js","./math/round":"/Users/luke/dev/040715/node_modules/mout/math/round.js"}],"/Users/luke/dev/040715/node_modules/mout/math/ceil.js":[function(require,module,exports){

    /**
     * Round value up with a custom radix.
     */
    function ceil(val, step){
        step = Math.abs(step || 1);
        return Math.ceil(val / step) * step;
    }

    module.exports = ceil;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/clamp.js":[function(require,module,exports){

    /**
     * Clamps value inside range.
     */
    function clamp(val, min, max){
        return val < min? min : (val > max? max : val);
    }
    module.exports = clamp;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/countSteps.js":[function(require,module,exports){

    /**
    * Count number of full steps.
    */
    function countSteps(val, step, overflow){
        val = Math.floor(val / step);

        if (overflow) {
            return val % overflow;
        }

        return val;
    }

    module.exports = countSteps;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/floor.js":[function(require,module,exports){

    /**
    * Floor value to full steps.
    */
    function floor(val, step){
        step = Math.abs(step || 1);
        return Math.floor(val / step) * step;
    }
    module.exports = floor;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/inRange.js":[function(require,module,exports){

    /**
    * Checks if value is inside the range.
    */
    function inRange(val, min, max, threshold){
        threshold = threshold || 0;
        return (val + threshold >= min && val - threshold <= max);
    }

    module.exports = inRange;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/isNear.js":[function(require,module,exports){

    /**
    * Check if value is close to target.
    */
    function isNear(val, target, threshold){
        return (Math.abs(val - target) <= threshold);
    }
    module.exports = isNear;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/lerp.js":[function(require,module,exports){

    /**
    * Linear interpolation.
    * IMPORTANT:will return `Infinity` if numbers overflow Number.MAX_VALUE
    */
    function lerp(ratio, start, end){
        return start + (end - start) * ratio;
    }

    module.exports = lerp;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/loop.js":[function(require,module,exports){

    /**
    * Loops value inside range.
    */
    function loop(val, min, max){
        return val < min? max : (val > max? min : val);
    }

    module.exports = loop;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/map.js":[function(require,module,exports){
var lerp = require('./lerp');
var norm = require('./norm');
    /**
    * Maps a number from one scale to another.
    * @example map(3, 0, 4, -1, 1) -> 0.5
    */
    function map(val, min1, max1, min2, max2){
        return lerp( norm(val, min1, max1), min2, max2 );
    }
    module.exports = map;


},{"./lerp":"/Users/luke/dev/040715/node_modules/mout/math/lerp.js","./norm":"/Users/luke/dev/040715/node_modules/mout/math/norm.js"}],"/Users/luke/dev/040715/node_modules/mout/math/norm.js":[function(require,module,exports){

    /**
    * Gets normalized ratio of value inside range.
    */
    function norm(val, min, max){
        if (val < min || val > max) {
            throw new RangeError('value (' + val + ') must be between ' + min + ' and ' + max);
        }

        return val === max ? 1 : (val - min) / (max - min);
    }
    module.exports = norm;


},{}],"/Users/luke/dev/040715/node_modules/mout/math/round.js":[function(require,module,exports){

    /**
     * Round number to a specific radix
     */
    function round(value, radix){
        radix = radix || 1; // default round 1
        return Math.round(value / radix) * radix;
    }

    module.exports = round;



},{}],"/Users/luke/dev/040715/node_modules/mout/number.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'MAX_INT' : require('./number/MAX_INT'),
    'MAX_SAFE_INTEGER' : require('./number/MAX_SAFE_INTEGER'),
    'MAX_UINT' : require('./number/MAX_UINT'),
    'MIN_INT' : require('./number/MIN_INT'),
    'abbreviate' : require('./number/abbreviate'),
    'currencyFormat' : require('./number/currencyFormat'),
    'enforcePrecision' : require('./number/enforcePrecision'),
    'isNaN' : require('./number/isNaN'),
    'nth' : require('./number/nth'),
    'ordinal' : require('./number/ordinal'),
    'pad' : require('./number/pad'),
    'rol' : require('./number/rol'),
    'ror' : require('./number/ror'),
    'sign' : require('./number/sign'),
    'toInt' : require('./number/toInt'),
    'toUInt' : require('./number/toUInt'),
    'toUInt31' : require('./number/toUInt31')
};



},{"./number/MAX_INT":"/Users/luke/dev/040715/node_modules/mout/number/MAX_INT.js","./number/MAX_SAFE_INTEGER":"/Users/luke/dev/040715/node_modules/mout/number/MAX_SAFE_INTEGER.js","./number/MAX_UINT":"/Users/luke/dev/040715/node_modules/mout/number/MAX_UINT.js","./number/MIN_INT":"/Users/luke/dev/040715/node_modules/mout/number/MIN_INT.js","./number/abbreviate":"/Users/luke/dev/040715/node_modules/mout/number/abbreviate.js","./number/currencyFormat":"/Users/luke/dev/040715/node_modules/mout/number/currencyFormat.js","./number/enforcePrecision":"/Users/luke/dev/040715/node_modules/mout/number/enforcePrecision.js","./number/isNaN":"/Users/luke/dev/040715/node_modules/mout/number/isNaN.js","./number/nth":"/Users/luke/dev/040715/node_modules/mout/number/nth.js","./number/ordinal":"/Users/luke/dev/040715/node_modules/mout/number/ordinal.js","./number/pad":"/Users/luke/dev/040715/node_modules/mout/number/pad.js","./number/rol":"/Users/luke/dev/040715/node_modules/mout/number/rol.js","./number/ror":"/Users/luke/dev/040715/node_modules/mout/number/ror.js","./number/sign":"/Users/luke/dev/040715/node_modules/mout/number/sign.js","./number/toInt":"/Users/luke/dev/040715/node_modules/mout/number/toInt.js","./number/toUInt":"/Users/luke/dev/040715/node_modules/mout/number/toUInt.js","./number/toUInt31":"/Users/luke/dev/040715/node_modules/mout/number/toUInt31.js"}],"/Users/luke/dev/040715/node_modules/mout/number/MAX_INT.js":[function(require,module,exports){
/**
 * @constant Maximum 32-bit signed integer value. (2^31 - 1)
 */

    module.exports = 2147483647;


},{}],"/Users/luke/dev/040715/node_modules/mout/number/MAX_SAFE_INTEGER.js":[function(require,module,exports){


    // maximum safe integer (Math.pow(2, 53) - 1)
    // see: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer
    module.exports = 9007199254740991;



},{}],"/Users/luke/dev/040715/node_modules/mout/number/MAX_UINT.js":[function(require,module,exports){
/**
 * @constant Maximum 32-bit unsigned integet value (2^32 - 1)
 */

    module.exports = 4294967295;


},{}],"/Users/luke/dev/040715/node_modules/mout/number/MIN_INT.js":[function(require,module,exports){
/**
 * @constant Minimum 32-bit signed integer value (-2^31).
 */

    module.exports = -2147483648;


},{}],"/Users/luke/dev/040715/node_modules/mout/number/abbreviate.js":[function(require,module,exports){
var enforcePrecision = require('./enforcePrecision');

    var _defaultDict = {
        thousand : 'K',
        million : 'M',
        billion : 'B'
    };

    /**
     * Abbreviate number if bigger than 1000. (eg: 2.5K, 17.5M, 3.4B, ...)
     */
    function abbreviateNumber(val, nDecimals, dict){
        nDecimals = nDecimals != null? nDecimals : 1;
        dict = dict || _defaultDict;
        val = enforcePrecision(val, nDecimals);

        var str, mod;

        if (val < 1000000) {
            mod = enforcePrecision(val / 1000, nDecimals);
            // might overflow to next scale during rounding
            str = mod < 1000? mod + dict.thousand : 1 + dict.million;
        } else if (val < 1000000000) {
            mod = enforcePrecision(val / 1000000, nDecimals);
            str = mod < 1000? mod + dict.million : 1 + dict.billion;
        } else {
            str = enforcePrecision(val / 1000000000, nDecimals) + dict.billion;
        }

        return str;
    }

    module.exports = abbreviateNumber;



},{"./enforcePrecision":"/Users/luke/dev/040715/node_modules/mout/number/enforcePrecision.js"}],"/Users/luke/dev/040715/node_modules/mout/number/currencyFormat.js":[function(require,module,exports){
var toNumber = require('../lang/toNumber');

    /**
     * Converts number into currency format
     */
    function currencyFormat(val, nDecimalDigits, decimalSeparator, thousandsSeparator) {
        val = toNumber(val);
        nDecimalDigits = nDecimalDigits == null? 2 : nDecimalDigits;
        decimalSeparator = decimalSeparator == null? '.' : decimalSeparator;
        thousandsSeparator = thousandsSeparator == null? ',' : thousandsSeparator;

        //can't use enforce precision since it returns a number and we are
        //doing a RegExp over the string
        var fixed = val.toFixed(nDecimalDigits),
            //separate begin [$1], middle [$2] and decimal digits [$4]
            parts = new RegExp('^(-?\\d{1,3})((?:\\d{3})+)(\\.(\\d{'+ nDecimalDigits +'}))?$').exec( fixed );

        if(parts){ //val >= 1000 || val <= -1000
            return parts[1] + parts[2].replace(/\d{3}/g, thousandsSeparator + '$&') + (parts[4] ? decimalSeparator + parts[4] : '');
        }else{
            return fixed.replace('.', decimalSeparator);
        }
    }

    module.exports = currencyFormat;



},{"../lang/toNumber":"/Users/luke/dev/040715/node_modules/mout/lang/toNumber.js"}],"/Users/luke/dev/040715/node_modules/mout/number/enforcePrecision.js":[function(require,module,exports){
var toNumber = require('../lang/toNumber');
    /**
     * Enforce a specific amount of decimal digits and also fix floating
     * point rounding issues.
     */
    function enforcePrecision(val, nDecimalDigits){
        val = toNumber(val);
        var pow = Math.pow(10, nDecimalDigits);
        return +(Math.round(val * pow) / pow).toFixed(nDecimalDigits);
    }
    module.exports = enforcePrecision;


},{"../lang/toNumber":"/Users/luke/dev/040715/node_modules/mout/lang/toNumber.js"}],"/Users/luke/dev/040715/node_modules/mout/number/isNaN.js":[function(require,module,exports){


    /**
     * ES6 Number.isNaN
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
     */
    function isNaN(val){
        // jshint eqeqeq:false
        return typeof val === 'number' && val != val;
    }

    module.exports = isNaN;



},{}],"/Users/luke/dev/040715/node_modules/mout/number/nth.js":[function(require,module,exports){


    /**
     * Returns "nth" of number (1 = "st", 2 = "nd", 3 = "rd", 4..10 = "th", ...)
     */
    function nth(i) {
        var t = (i % 100);
        if (t >= 10 && t <= 20) {
            return 'th';
        }
        switch(i % 10) {
            case 1:
                return 'st';
            case 2:
                return 'nd';
            case 3:
                return 'rd';
            default:
                return 'th';
        }
    }

    module.exports = nth;



},{}],"/Users/luke/dev/040715/node_modules/mout/number/ordinal.js":[function(require,module,exports){
var toInt = require('./toInt');
var nth = require('./nth');

    /**
     * converts number into ordinal form (1st, 2nd, 3rd, 4th, ...)
     */
    function ordinal(n){
       n = toInt(n);
       return n + nth(n);
    }

    module.exports = ordinal;



},{"./nth":"/Users/luke/dev/040715/node_modules/mout/number/nth.js","./toInt":"/Users/luke/dev/040715/node_modules/mout/number/toInt.js"}],"/Users/luke/dev/040715/node_modules/mout/number/pad.js":[function(require,module,exports){
var lpad = require('../string/lpad');
var toNumber = require('../lang/toNumber');

    /**
     * Add padding zeros if n.length < minLength.
     */
    function pad(n, minLength, char){
        n = toNumber(n);
        return lpad(''+ n, minLength, char || '0');
    }

    module.exports = pad;



},{"../lang/toNumber":"/Users/luke/dev/040715/node_modules/mout/lang/toNumber.js","../string/lpad":"/Users/luke/dev/040715/node_modules/mout/string/lpad.js"}],"/Users/luke/dev/040715/node_modules/mout/number/rol.js":[function(require,module,exports){

    /**
     * Bitwise circular shift left
     * http://en.wikipedia.org/wiki/Circular_shift
     */
    function rol(val, shift){
        return (val << shift) | (val >> (32 - shift));
    }
    module.exports = rol;


},{}],"/Users/luke/dev/040715/node_modules/mout/number/ror.js":[function(require,module,exports){

    /**
     * Bitwise circular shift right
     * http://en.wikipedia.org/wiki/Circular_shift
     */
    function ror(val, shift){
        return (val >> shift) | (val << (32 - shift));
    }
    module.exports = ror;


},{}],"/Users/luke/dev/040715/node_modules/mout/number/sign.js":[function(require,module,exports){
var toNumber = require('../lang/toNumber');

    /**
     * Get sign of the value.
     */
    function sign(val) {
        var num = toNumber(val);
        if (num === 0) return num; // +0 and +0 === 0
        if (isNaN(num)) return num; // NaN
        return num < 0? -1 : 1;
    }

    module.exports = sign;



},{"../lang/toNumber":"/Users/luke/dev/040715/node_modules/mout/lang/toNumber.js"}],"/Users/luke/dev/040715/node_modules/mout/number/toInt.js":[function(require,module,exports){


    /**
     * "Convert" value into an 32-bit integer.
     * Works like `Math.floor` if val > 0 and `Math.ceil` if val < 0.
     * IMPORTANT: val will wrap at 2^31 and -2^31.
     * Perf tests: http://jsperf.com/vs-vs-parseint-bitwise-operators/7
     */
    function toInt(val){
        // we do not use lang/toNumber because of perf and also because it
        // doesn't break the functionality
        return ~~val;
    }

    module.exports = toInt;



},{}],"/Users/luke/dev/040715/node_modules/mout/number/toUInt.js":[function(require,module,exports){


    /**
     * "Convert" value into a 32-bit unsigned integer.
     * IMPORTANT: Value will wrap at 2^32.
     */
    function toUInt(val){
        // we do not use lang/toNumber because of perf and also because it
        // doesn't break the functionality
        return val >>> 0;
    }

    module.exports = toUInt;



},{}],"/Users/luke/dev/040715/node_modules/mout/number/toUInt31.js":[function(require,module,exports){
var MAX_INT = require('./MAX_INT');

    /**
     * "Convert" value into an 31-bit unsigned integer (since 1 bit is used for sign).
     * IMPORTANT: value wil wrap at 2^31, if negative will return 0.
     */
    function toUInt31(val){
        // we do not use lang/toNumber because of perf and also because it
        // doesn't break the functionality
        return (val <= 0)? 0 : (val > MAX_INT? ~~(val % (MAX_INT + 1)) : ~~val);
    }

    module.exports = toUInt31;



},{"./MAX_INT":"/Users/luke/dev/040715/node_modules/mout/number/MAX_INT.js"}],"/Users/luke/dev/040715/node_modules/mout/object.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'bindAll' : require('./object/bindAll'),
    'contains' : require('./object/contains'),
    'deepFillIn' : require('./object/deepFillIn'),
    'deepMatches' : require('./object/deepMatches'),
    'deepMixIn' : require('./object/deepMixIn'),
    'equals' : require('./object/equals'),
    'every' : require('./object/every'),
    'fillIn' : require('./object/fillIn'),
    'filter' : require('./object/filter'),
    'find' : require('./object/find'),
    'forIn' : require('./object/forIn'),
    'forOwn' : require('./object/forOwn'),
    'functions' : require('./object/functions'),
    'get' : require('./object/get'),
    'has' : require('./object/has'),
    'hasOwn' : require('./object/hasOwn'),
    'keys' : require('./object/keys'),
    'map' : require('./object/map'),
    'matches' : require('./object/matches'),
    'max' : require('./object/max'),
    'merge' : require('./object/merge'),
    'min' : require('./object/min'),
    'mixIn' : require('./object/mixIn'),
    'namespace' : require('./object/namespace'),
    'omit' : require('./object/omit'),
    'pick' : require('./object/pick'),
    'pluck' : require('./object/pluck'),
    'reduce' : require('./object/reduce'),
    'reject' : require('./object/reject'),
    'result' : require('./object/result'),
    'set' : require('./object/set'),
    'size' : require('./object/size'),
    'some' : require('./object/some'),
    'unset' : require('./object/unset'),
    'values' : require('./object/values')
};



},{"./object/bindAll":"/Users/luke/dev/040715/node_modules/mout/object/bindAll.js","./object/contains":"/Users/luke/dev/040715/node_modules/mout/object/contains.js","./object/deepFillIn":"/Users/luke/dev/040715/node_modules/mout/object/deepFillIn.js","./object/deepMatches":"/Users/luke/dev/040715/node_modules/mout/object/deepMatches.js","./object/deepMixIn":"/Users/luke/dev/040715/node_modules/mout/object/deepMixIn.js","./object/equals":"/Users/luke/dev/040715/node_modules/mout/object/equals.js","./object/every":"/Users/luke/dev/040715/node_modules/mout/object/every.js","./object/fillIn":"/Users/luke/dev/040715/node_modules/mout/object/fillIn.js","./object/filter":"/Users/luke/dev/040715/node_modules/mout/object/filter.js","./object/find":"/Users/luke/dev/040715/node_modules/mout/object/find.js","./object/forIn":"/Users/luke/dev/040715/node_modules/mout/object/forIn.js","./object/forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js","./object/functions":"/Users/luke/dev/040715/node_modules/mout/object/functions.js","./object/get":"/Users/luke/dev/040715/node_modules/mout/object/get.js","./object/has":"/Users/luke/dev/040715/node_modules/mout/object/has.js","./object/hasOwn":"/Users/luke/dev/040715/node_modules/mout/object/hasOwn.js","./object/keys":"/Users/luke/dev/040715/node_modules/mout/object/keys.js","./object/map":"/Users/luke/dev/040715/node_modules/mout/object/map.js","./object/matches":"/Users/luke/dev/040715/node_modules/mout/object/matches.js","./object/max":"/Users/luke/dev/040715/node_modules/mout/object/max.js","./object/merge":"/Users/luke/dev/040715/node_modules/mout/object/merge.js","./object/min":"/Users/luke/dev/040715/node_modules/mout/object/min.js","./object/mixIn":"/Users/luke/dev/040715/node_modules/mout/object/mixIn.js","./object/namespace":"/Users/luke/dev/040715/node_modules/mout/object/namespace.js","./object/omit":"/Users/luke/dev/040715/node_modules/mout/object/omit.js","./object/pick":"/Users/luke/dev/040715/node_modules/mout/object/pick.js","./object/pluck":"/Users/luke/dev/040715/node_modules/mout/object/pluck.js","./object/reduce":"/Users/luke/dev/040715/node_modules/mout/object/reduce.js","./object/reject":"/Users/luke/dev/040715/node_modules/mout/object/reject.js","./object/result":"/Users/luke/dev/040715/node_modules/mout/object/result.js","./object/set":"/Users/luke/dev/040715/node_modules/mout/object/set.js","./object/size":"/Users/luke/dev/040715/node_modules/mout/object/size.js","./object/some":"/Users/luke/dev/040715/node_modules/mout/object/some.js","./object/unset":"/Users/luke/dev/040715/node_modules/mout/object/unset.js","./object/values":"/Users/luke/dev/040715/node_modules/mout/object/values.js"}],"/Users/luke/dev/040715/node_modules/mout/object/bindAll.js":[function(require,module,exports){
var functions = require('./functions');
var bind = require('../function/bind');
var forEach = require('../array/forEach');
var slice = require('../array/slice');

    /**
     * Binds methods of the object to be run in it's own context.
     */
    function bindAll(obj, rest_methodNames){
        var keys = arguments.length > 1?
                    slice(arguments, 1) : functions(obj);
        forEach(keys, function(key){
            obj[key] = bind(obj[key], obj);
        });
    }

    module.exports = bindAll;



},{"../array/forEach":"/Users/luke/dev/040715/node_modules/mout/array/forEach.js","../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js","../function/bind":"/Users/luke/dev/040715/node_modules/mout/function/bind.js","./functions":"/Users/luke/dev/040715/node_modules/mout/object/functions.js"}],"/Users/luke/dev/040715/node_modules/mout/object/contains.js":[function(require,module,exports){
var some = require('./some');

    /**
     * Check if object contains value
     */
    function contains(obj, needle) {
        return some(obj, function(val) {
            return (val === needle);
        });
    }
    module.exports = contains;



},{"./some":"/Users/luke/dev/040715/node_modules/mout/object/some.js"}],"/Users/luke/dev/040715/node_modules/mout/object/deepFillIn.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Deeply copy missing properties in the target from the defaults.
     */
    function deepFillIn(target, defaults){
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n) {
            obj = arguments[i];
            if (obj) {
                // jshint loopfunc: true
                forOwn(obj, function(newValue, key) {
                    var curValue = target[key];
                    if (curValue == null) {
                        target[key] = newValue;
                    } else if (isPlainObject(curValue) &&
                               isPlainObject(newValue)) {
                        deepFillIn(curValue, newValue);
                    }
                });
            }
        }

        return target;
    }

    module.exports = deepFillIn;



},{"../lang/isPlainObject":"/Users/luke/dev/040715/node_modules/mout/lang/isPlainObject.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/deepMatches.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/deepMixIn.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Mixes objects into the target object, recursively mixing existing child
     * objects.
     */
    function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n){
            obj = arguments[i];
            if (obj) {
                forOwn(obj, copyProp, target);
            }
        }

        return target;
    }

    function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
            deepMixIn(existing, val);
        } else {
            this[key] = val;
        }
    }

    module.exports = deepMixIn;



},{"../lang/isPlainObject":"/Users/luke/dev/040715/node_modules/mout/lang/isPlainObject.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/equals.js":[function(require,module,exports){
var hasOwn = require('./hasOwn');
var every = require('./every');
var isObject = require('../lang/isObject');
var is = require('../lang/is');

    // Makes a function to compare the object values from the specified compare
    // operation callback.
    function makeCompare(callback) {
        return function(value, key) {
            return hasOwn(this, key) && callback(value, this[key]);
        };
    }

    function checkProperties(value, key) {
        return hasOwn(this, key);
    }

    /**
     * Checks if two objects have the same keys and values.
     */
    function equals(a, b, callback) {
        callback = callback || is;

        if (!isObject(a) || !isObject(b)) {
            return callback(a, b);
        }

        return (every(a, makeCompare(callback), b) &&
                every(b, checkProperties, a));
    }

    module.exports = equals;


},{"../lang/is":"/Users/luke/dev/040715/node_modules/mout/lang/is.js","../lang/isObject":"/Users/luke/dev/040715/node_modules/mout/lang/isObject.js","./every":"/Users/luke/dev/040715/node_modules/mout/object/every.js","./hasOwn":"/Users/luke/dev/040715/node_modules/mout/object/hasOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/every.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object every
     */
    function every(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        forOwn(obj, function(val, key) {
            // we consider any falsy values as "false" on purpose so shorthand
            // syntax can be used to check property existence
            if (!callback(val, key, obj)) {
                result = false;
                return false; // break
            }
        });
        return result;
    }

    module.exports = every;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/fillIn.js":[function(require,module,exports){
var forEach = require('../array/forEach');
var slice = require('../array/slice');
var forOwn = require('./forOwn');

    /**
     * Copy missing properties in the obj from the defaults.
     */
    function fillIn(obj, var_defaults){
        forEach(slice(arguments, 1), function(base){
            forOwn(base, function(val, key){
                if (obj[key] == null) {
                    obj[key] = val;
                }
            });
        });
        return obj;
    }

    module.exports = fillIn;



},{"../array/forEach":"/Users/luke/dev/040715/node_modules/mout/array/forEach.js","../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/filter.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Creates a new object with all the properties where the callback returns
     * true.
     */
    function filterValues(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var output = {};
        forOwn(obj, function(value, key, obj) {
            if (callback(value, key, obj)) {
                output[key] = value;
            }
        });

        return output;
    }
    module.exports = filterValues;


},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/find.js":[function(require,module,exports){
var some = require('./some');
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns first item that matches criteria
     */
    function find(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result;
        some(obj, function(value, key, obj) {
            if (callback(value, key, obj)) {
                result = value;
                return true; //break
            }
        });
        return result;
    }

    module.exports = find;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./some":"/Users/luke/dev/040715/node_modules/mout/object/some.js"}],"/Users/luke/dev/040715/node_modules/mout/object/forIn.js":[function(require,module,exports){
var hasOwn = require('./hasOwn');

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{"./hasOwn":"/Users/luke/dev/040715/node_modules/mout/object/hasOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js":[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":"/Users/luke/dev/040715/node_modules/mout/object/forIn.js","./hasOwn":"/Users/luke/dev/040715/node_modules/mout/object/hasOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/functions.js":[function(require,module,exports){
var forIn = require('./forIn');

    /**
     * return a list of all enumerable properties that have function values
     */
    function functions(obj){
        var keys = [];
        forIn(obj, function(val, key){
            if (typeof val === 'function'){
                keys.push(key);
            }
        });
        return keys.sort();
    }

    module.exports = functions;



},{"./forIn":"/Users/luke/dev/040715/node_modules/mout/object/forIn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/get.js":[function(require,module,exports){
var isPrimitive = require('../lang/isPrimitive');

    /**
     * get "nested" object property
     */
    function get(obj, prop){
        var parts = prop.split('.'),
            last = parts.pop();

        while (prop = parts.shift()) {
            obj = obj[prop];
            if (obj == null) return;
        }

        return obj[last];
    }

    module.exports = get;



},{"../lang/isPrimitive":"/Users/luke/dev/040715/node_modules/mout/lang/isPrimitive.js"}],"/Users/luke/dev/040715/node_modules/mout/object/has.js":[function(require,module,exports){
var get = require('./get');

    var UNDEF;

    /**
     * Check if object has nested property.
     */
    function has(obj, prop){
        return get(obj, prop) !== UNDEF;
    }

    module.exports = has;




},{"./get":"/Users/luke/dev/040715/node_modules/mout/object/get.js"}],"/Users/luke/dev/040715/node_modules/mout/object/hasOwn.js":[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],"/Users/luke/dev/040715/node_modules/mout/object/keys.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object keys
     */
     var keys = Object.keys || function (obj) {
            var keys = [];
            forOwn(obj, function(val, key){
                keys.push(key);
            });
            return keys;
        };

    module.exports = keys;



},{"./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/map.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Creates a new object where all the values are the result of calling
     * `callback`.
     */
    function mapValues(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var output = {};
        forOwn(obj, function(val, key, obj) {
            output[key] = callback(val, key, obj);
        });

        return output;
    }
    module.exports = mapValues;


},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/matches.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * checks if a object contains all given properties/values
     */
    function matches(target, props){
        // can't use "object/every" because of circular dependency
        var result = true;
        forOwn(props, function(val, key){
            if (target[key] !== val) {
                // break loop at first difference
                return (result = false);
            }
        });
        return result;
    }

    module.exports = matches;



},{"./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/max.js":[function(require,module,exports){
var arrMax = require('../array/max');
var values = require('./values');

    /**
     * Returns maximum value inside object.
     */
    function max(obj, compareFn) {
        return arrMax(values(obj), compareFn);
    }

    module.exports = max;


},{"../array/max":"/Users/luke/dev/040715/node_modules/mout/array/max.js","./values":"/Users/luke/dev/040715/node_modules/mout/object/values.js"}],"/Users/luke/dev/040715/node_modules/mout/object/merge.js":[function(require,module,exports){
var hasOwn = require('./hasOwn');
var deepClone = require('../lang/deepClone');
var isObject = require('../lang/isObject');

    /**
     * Deep merge objects.
     */
    function merge() {
        var i = 1,
            key, val, obj, target;

        // make sure we don't modify source element and it's properties
        // objects are passed by reference
        target = deepClone( arguments[0] );

        while (obj = arguments[i++]) {
            for (key in obj) {
                if ( ! hasOwn(obj, key) ) {
                    continue;
                }

                val = obj[key];

                if ( isObject(val) && isObject(target[key]) ){
                    // inception, deep merge objects
                    target[key] = merge(target[key], val);
                } else {
                    // make sure arrays, regexp, date, objects are cloned
                    target[key] = deepClone(val);
                }

            }
        }

        return target;
    }

    module.exports = merge;



},{"../lang/deepClone":"/Users/luke/dev/040715/node_modules/mout/lang/deepClone.js","../lang/isObject":"/Users/luke/dev/040715/node_modules/mout/lang/isObject.js","./hasOwn":"/Users/luke/dev/040715/node_modules/mout/object/hasOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/min.js":[function(require,module,exports){
var arrMin = require('../array/min');
var values = require('./values');

    /**
     * Returns minimum value inside object.
     */
    function min(obj, iterator) {
        return arrMin(values(obj), iterator);
    }

    module.exports = min;


},{"../array/min":"/Users/luke/dev/040715/node_modules/mout/array/min.js","./values":"/Users/luke/dev/040715/node_modules/mout/object/values.js"}],"/Users/luke/dev/040715/node_modules/mout/object/mixIn.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/namespace.js":[function(require,module,exports){
var forEach = require('../array/forEach');

    /**
     * Create nested object if non-existent
     */
    function namespace(obj, path){
        if (!path) return obj;
        forEach(path.split('.'), function(key){
            if (!obj[key]) {
                obj[key] = {};
            }
            obj = obj[key];
        });
        return obj;
    }

    module.exports = namespace;



},{"../array/forEach":"/Users/luke/dev/040715/node_modules/mout/array/forEach.js"}],"/Users/luke/dev/040715/node_modules/mout/object/omit.js":[function(require,module,exports){
var slice = require('../array/slice');
var contains = require('../array/contains');

    /**
     * Return a copy of the object, filtered to only contain properties except the blacklisted keys.
     */
    function omit(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {};

        for (var property in obj) {
            if (obj.hasOwnProperty(property) && !contains(keys, property)) {
                out[property] = obj[property];
            }
        }
        return out;
    }

    module.exports = omit;



},{"../array/contains":"/Users/luke/dev/040715/node_modules/mout/array/contains.js","../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/object/pick.js":[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     */
    function pick(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0, key;
        while (key = keys[i++]) {
            out[key] = obj[key];
        }
        return out;
    }

    module.exports = pick;



},{"../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/object/pluck.js":[function(require,module,exports){
var map = require('./map');
var prop = require('../function/prop');

    /**
     * Extract a list of property values.
     */
    function pluck(obj, propName){
        return map(obj, prop(propName));
    }

    module.exports = pluck;



},{"../function/prop":"/Users/luke/dev/040715/node_modules/mout/function/prop.js","./map":"/Users/luke/dev/040715/node_modules/mout/object/map.js"}],"/Users/luke/dev/040715/node_modules/mout/object/reduce.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var size = require('./size');

    /**
     * Object reduce
     */
    function reduce(obj, callback, memo, thisObj) {
        var initial = arguments.length > 2;

        if (!size(obj) && !initial) {
            throw new Error('reduce of empty object with no initial value');
        }

        forOwn(obj, function(value, key, list) {
            if (!initial) {
                memo = value;
                initial = true;
            }
            else {
                memo = callback.call(thisObj, memo, value, key, list);
            }
        });

        return memo;
    }

    module.exports = reduce;



},{"./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js","./size":"/Users/luke/dev/040715/node_modules/mout/object/size.js"}],"/Users/luke/dev/040715/node_modules/mout/object/reject.js":[function(require,module,exports){
var filter = require('./filter');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object reject
     */
    function reject(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        return filter(obj, function(value, index, obj) {
            return !callback(value, index, obj);
        }, thisObj);
    }

    module.exports = reject;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./filter":"/Users/luke/dev/040715/node_modules/mout/object/filter.js"}],"/Users/luke/dev/040715/node_modules/mout/object/result.js":[function(require,module,exports){
var isFunction = require('../lang/isFunction');

    function result(obj, prop) {
        var property = obj[prop];

        if(property === undefined) {
            return;
        }

        return isFunction(property) ? property.call(obj) : property;
    }

    module.exports = result;


},{"../lang/isFunction":"/Users/luke/dev/040715/node_modules/mout/lang/isFunction.js"}],"/Users/luke/dev/040715/node_modules/mout/object/set.js":[function(require,module,exports){
var namespace = require('./namespace');

    /**
     * set "nested" object property
     */
    function set(obj, prop, val){
        var parts = (/^(.+)\.(.+)$/).exec(prop);
        if (parts){
            namespace(obj, parts[1])[parts[2]] = val;
        } else {
            obj[prop] = val;
        }
    }

    module.exports = set;



},{"./namespace":"/Users/luke/dev/040715/node_modules/mout/object/namespace.js"}],"/Users/luke/dev/040715/node_modules/mout/object/size.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object size
     */
    function size(obj) {
        var count = 0;
        forOwn(obj, function(){
            count++;
        });
        return count;
    }

    module.exports = size;



},{"./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/some.js":[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object some
     */
    function some(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        forOwn(obj, function(val, key) {
            if (callback(val, key, obj)) {
                result = true;
                return false; // break
            }
        });
        return result;
    }

    module.exports = some;



},{"../function/makeIterator_":"/Users/luke/dev/040715/node_modules/mout/function/makeIterator_.js","./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/object/unset.js":[function(require,module,exports){
var has = require('./has');

    /**
     * Unset object property.
     */
    function unset(obj, prop){
        if (has(obj, prop)) {
            var parts = prop.split('.'),
                last = parts.pop();
            while (prop = parts.shift()) {
                obj = obj[prop];
            }
            return (delete obj[last]);

        } else {
            // if property doesn't exist treat as deleted
            return true;
        }
    }

    module.exports = unset;



},{"./has":"/Users/luke/dev/040715/node_modules/mout/object/has.js"}],"/Users/luke/dev/040715/node_modules/mout/object/values.js":[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object values
     */
    function values(obj) {
        var vals = [];
        forOwn(obj, function(val, key){
            vals.push(val);
        });
        return vals;
    }

    module.exports = values;



},{"./forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/queryString.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'contains' : require('./queryString/contains'),
    'decode' : require('./queryString/decode'),
    'encode' : require('./queryString/encode'),
    'getParam' : require('./queryString/getParam'),
    'getQuery' : require('./queryString/getQuery'),
    'parse' : require('./queryString/parse'),
    'setParam' : require('./queryString/setParam')
};



},{"./queryString/contains":"/Users/luke/dev/040715/node_modules/mout/queryString/contains.js","./queryString/decode":"/Users/luke/dev/040715/node_modules/mout/queryString/decode.js","./queryString/encode":"/Users/luke/dev/040715/node_modules/mout/queryString/encode.js","./queryString/getParam":"/Users/luke/dev/040715/node_modules/mout/queryString/getParam.js","./queryString/getQuery":"/Users/luke/dev/040715/node_modules/mout/queryString/getQuery.js","./queryString/parse":"/Users/luke/dev/040715/node_modules/mout/queryString/parse.js","./queryString/setParam":"/Users/luke/dev/040715/node_modules/mout/queryString/setParam.js"}],"/Users/luke/dev/040715/node_modules/mout/queryString/contains.js":[function(require,module,exports){
var getQuery = require('./getQuery');

    /**
     * Checks if query string contains parameter.
     */
    function contains(url, paramName) {
        var regex = new RegExp('(\\?|&)'+ paramName +'=', 'g'); //matches `?param=` or `&param=`
        return regex.test(getQuery(url));
    }

    module.exports = contains;


},{"./getQuery":"/Users/luke/dev/040715/node_modules/mout/queryString/getQuery.js"}],"/Users/luke/dev/040715/node_modules/mout/queryString/decode.js":[function(require,module,exports){
var typecast = require('../string/typecast');
var isString = require('../lang/isString');
var isArray = require('../lang/isArray');
var hasOwn = require('../object/hasOwn');

    /**
     * Decode query string into an object of keys => vals.
     */
    function decode(queryStr, shouldTypecast) {
        var queryArr = (queryStr || '').replace('?', '').split('&'),
            count = -1,
            length = queryArr.length,
            obj = {},
            item, pValue, pName, toSet;

        while (++count < length) {
            item = queryArr[count].split('=');
            pName = item[0];
            if (!pName || !pName.length){
                continue;
            }
            pValue = shouldTypecast === false ? item[1] : typecast(item[1]);
            toSet = isString(pValue) ? decodeURIComponent(pValue) : pValue;
            if (hasOwn(obj,pName)){
                if(isArray(obj[pName])){
                    obj[pName].push(toSet);
                } else {
                    obj[pName] = [obj[pName],toSet];
                }
            } else {
                obj[pName] = toSet;
           }
        }
        return obj;
    }

    module.exports = decode;


},{"../lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","../lang/isString":"/Users/luke/dev/040715/node_modules/mout/lang/isString.js","../object/hasOwn":"/Users/luke/dev/040715/node_modules/mout/object/hasOwn.js","../string/typecast":"/Users/luke/dev/040715/node_modules/mout/string/typecast.js"}],"/Users/luke/dev/040715/node_modules/mout/queryString/encode.js":[function(require,module,exports){
var forOwn = require('../object/forOwn');
var isArray = require('../lang/isArray');
var forEach = require('../array/forEach');

    /**
     * Encode object into a query string.
     */
    function encode(obj){
        var query = [],
            arrValues, reg;
        forOwn(obj, function (val, key) {
            if (isArray(val)) {
                arrValues = key + '=';
                reg = new RegExp('&'+key+'+=$');
                forEach(val, function (aValue) {
                    arrValues += encodeURIComponent(aValue) + '&' + key + '=';
                });
                query.push(arrValues.replace(reg, ''));
            } else {
               query.push(key + '=' + encodeURIComponent(val));
            }
        });
        return (query.length) ? '?' + query.join('&') : '';
    }

    module.exports = encode;


},{"../array/forEach":"/Users/luke/dev/040715/node_modules/mout/array/forEach.js","../lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","../object/forOwn":"/Users/luke/dev/040715/node_modules/mout/object/forOwn.js"}],"/Users/luke/dev/040715/node_modules/mout/queryString/getParam.js":[function(require,module,exports){
var typecast = require('../string/typecast');
var getQuery = require('./getQuery');

    /**
     * Get query parameter value.
     */
    function getParam(url, param, shouldTypecast){
        var regexp = new RegExp('(\\?|&)'+ param + '=([^&]*)'), //matches `?param=value` or `&param=value`, value = $2
            result = regexp.exec( getQuery(url) ),
            val = (result && result[2])? result[2] : null;
        return shouldTypecast === false? val : typecast(val);
    }

    module.exports = getParam;


},{"../string/typecast":"/Users/luke/dev/040715/node_modules/mout/string/typecast.js","./getQuery":"/Users/luke/dev/040715/node_modules/mout/queryString/getQuery.js"}],"/Users/luke/dev/040715/node_modules/mout/queryString/getQuery.js":[function(require,module,exports){


    /**
     * Gets full query as string with all special chars decoded.
     */
    function getQuery(url) {
        url = url.replace(/#.*/, ''); //removes hash (to avoid getting hash query)
        var queryString = /\?[a-zA-Z0-9\=\&\%\$\-\_\.\+\!\*\'\(\)\,]+/.exec(url); //valid chars according to: http://www.ietf.org/rfc/rfc1738.txt
        return (queryString)? decodeURIComponent(queryString[0]) : '';
    }

    module.exports = getQuery;


},{}],"/Users/luke/dev/040715/node_modules/mout/queryString/parse.js":[function(require,module,exports){
var decode = require('./decode');
var getQuery = require('./getQuery');

    /**
     * Get query string, parses and decodes it.
     */
    function parse(url, shouldTypecast) {
        return decode(getQuery(url), shouldTypecast);
    }

    module.exports = parse;



},{"./decode":"/Users/luke/dev/040715/node_modules/mout/queryString/decode.js","./getQuery":"/Users/luke/dev/040715/node_modules/mout/queryString/getQuery.js"}],"/Users/luke/dev/040715/node_modules/mout/queryString/setParam.js":[function(require,module,exports){


    /**
     * Set query string parameter value
     */
    function setParam(url, paramName, value){
        url = url || '';

        var re = new RegExp('(\\?|&)'+ paramName +'=[^&]*' );
        var param = paramName +'='+ encodeURIComponent( value );

        if ( re.test(url) ) {
            return url.replace(re, '$1'+ param);
        } else {
            if (url.indexOf('?') === -1) {
                url += '?';
            }
            if (url.indexOf('=') !== -1) {
                url += '&';
            }
            return url + param;
        }

    }

    module.exports = setParam;



},{}],"/Users/luke/dev/040715/node_modules/mout/random.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'choice' : require('./random/choice'),
    'guid' : require('./random/guid'),
    'rand' : require('./random/rand'),
    'randBit' : require('./random/randBit'),
    'randBool' : require('./random/randBool'),
    'randHex' : require('./random/randHex'),
    'randInt' : require('./random/randInt'),
    'randSign' : require('./random/randSign'),
    'randString' : require('./random/randString'),
    'random' : require('./random/random')
};



},{"./random/choice":"/Users/luke/dev/040715/node_modules/mout/random/choice.js","./random/guid":"/Users/luke/dev/040715/node_modules/mout/random/guid.js","./random/rand":"/Users/luke/dev/040715/node_modules/mout/random/rand.js","./random/randBit":"/Users/luke/dev/040715/node_modules/mout/random/randBit.js","./random/randBool":"/Users/luke/dev/040715/node_modules/mout/random/randBool.js","./random/randHex":"/Users/luke/dev/040715/node_modules/mout/random/randHex.js","./random/randInt":"/Users/luke/dev/040715/node_modules/mout/random/randInt.js","./random/randSign":"/Users/luke/dev/040715/node_modules/mout/random/randSign.js","./random/randString":"/Users/luke/dev/040715/node_modules/mout/random/randString.js","./random/random":"/Users/luke/dev/040715/node_modules/mout/random/random.js"}],"/Users/luke/dev/040715/node_modules/mout/random/choice.js":[function(require,module,exports){
var randInt = require('./randInt');
var isArray = require('../lang/isArray');

    /**
     * Returns a random element from the supplied arguments
     * or from the array (if single argument is an array).
     */
    function choice(items) {
        var target = (arguments.length === 1 && isArray(items))? items : arguments;
        return target[ randInt(0, target.length - 1) ];
    }

    module.exports = choice;



},{"../lang/isArray":"/Users/luke/dev/040715/node_modules/mout/lang/isArray.js","./randInt":"/Users/luke/dev/040715/node_modules/mout/random/randInt.js"}],"/Users/luke/dev/040715/node_modules/mout/random/guid.js":[function(require,module,exports){
var randHex = require('./randHex');
var choice = require('./choice');

  /**
   * Returns pseudo-random guid (UUID v4)
   * IMPORTANT: it's not totally "safe" since randHex/choice uses Math.random
   * by default and sequences can be predicted in some cases. See the
   * "random/random" documentation for more info about it and how to replace
   * the default PRNG.
   */
  function guid() {
    return (
        randHex(8)+'-'+
        randHex(4)+'-'+
        // v4 UUID always contain "4" at this position to specify it was
        // randomly generated
        '4' + randHex(3) +'-'+
        // v4 UUID always contain chars [a,b,8,9] at this position
        choice(8, 9, 'a', 'b') + randHex(3)+'-'+
        randHex(12)
    );
  }
  module.exports = guid;


},{"./choice":"/Users/luke/dev/040715/node_modules/mout/random/choice.js","./randHex":"/Users/luke/dev/040715/node_modules/mout/random/randHex.js"}],"/Users/luke/dev/040715/node_modules/mout/random/rand.js":[function(require,module,exports){
var random = require('./random');
var MIN_INT = require('../number/MIN_INT');
var MAX_INT = require('../number/MAX_INT');

    /**
     * Returns random number inside range
     */
    function rand(min, max){
        min = min == null? MIN_INT : min;
        max = max == null? MAX_INT : max;
        return min + (max - min) * random();
    }

    module.exports = rand;


},{"../number/MAX_INT":"/Users/luke/dev/040715/node_modules/mout/number/MAX_INT.js","../number/MIN_INT":"/Users/luke/dev/040715/node_modules/mout/number/MIN_INT.js","./random":"/Users/luke/dev/040715/node_modules/mout/random/random.js"}],"/Users/luke/dev/040715/node_modules/mout/random/randBit.js":[function(require,module,exports){
var randBool = require('./randBool');

    /**
     * Returns random bit (0 or 1)
     */
    function randomBit() {
        return randBool()? 1 : 0;
    }

    module.exports = randomBit;


},{"./randBool":"/Users/luke/dev/040715/node_modules/mout/random/randBool.js"}],"/Users/luke/dev/040715/node_modules/mout/random/randBool.js":[function(require,module,exports){
var random = require('./random');

    /**
     * returns a random boolean value (true or false)
     */
    function randBool(){
        return random() >= 0.5;
    }

    module.exports = randBool;



},{"./random":"/Users/luke/dev/040715/node_modules/mout/random/random.js"}],"/Users/luke/dev/040715/node_modules/mout/random/randHex.js":[function(require,module,exports){
var choice = require('./choice');

    var _chars = '0123456789abcdef'.split('');

    /**
     * Returns a random hexadecimal string
     */
    function randHex(size){
        size = size && size > 0? size : 6;
        var str = '';
        while (size--) {
            str += choice(_chars);
        }
        return str;
    }

    module.exports = randHex;



},{"./choice":"/Users/luke/dev/040715/node_modules/mout/random/choice.js"}],"/Users/luke/dev/040715/node_modules/mout/random/randInt.js":[function(require,module,exports){
var MIN_INT = require('../number/MIN_INT');
var MAX_INT = require('../number/MAX_INT');
var rand = require('./rand');

    /**
     * Gets random integer inside range or snap to min/max values.
     */
    function randInt(min, max){
        min = min == null? MIN_INT : ~~min;
        max = max == null? MAX_INT : ~~max;
        // can't be max + 0.5 otherwise it will round up if `rand`
        // returns `max` causing it to overflow range.
        // -0.5 and + 0.49 are required to avoid bias caused by rounding
        return Math.round( rand(min - 0.5, max + 0.499999999999) );
    }

    module.exports = randInt;


},{"../number/MAX_INT":"/Users/luke/dev/040715/node_modules/mout/number/MAX_INT.js","../number/MIN_INT":"/Users/luke/dev/040715/node_modules/mout/number/MIN_INT.js","./rand":"/Users/luke/dev/040715/node_modules/mout/random/rand.js"}],"/Users/luke/dev/040715/node_modules/mout/random/randSign.js":[function(require,module,exports){
var randBool = require('./randBool');

    /**
     * Returns random sign (-1 or 1)
     */
    function randomSign() {
        return randBool()? 1 : -1;
    }

    module.exports = randomSign;


},{"./randBool":"/Users/luke/dev/040715/node_modules/mout/random/randBool.js"}],"/Users/luke/dev/040715/node_modules/mout/random/randString.js":[function(require,module,exports){
var isNumber = require('../lang/isNumber');
var isString = require('../lang/isString');
var randInt = require('./randInt');

    var defaultDictionary = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

    function randomString(length, dictionary) {
        if(!isNumber(length) || length <= 0) {
          length = 8;
        }

        if(!isString(dictionary) || dictionary.length < 1) {
          dictionary = defaultDictionary;
        }

        var result = '',
            domain = dictionary.length - 1;

        while(length--) {
          result += dictionary[randInt(0, domain)];
        }
        
        return result;
    }

    module.exports = randomString;


},{"../lang/isNumber":"/Users/luke/dev/040715/node_modules/mout/lang/isNumber.js","../lang/isString":"/Users/luke/dev/040715/node_modules/mout/lang/isString.js","./randInt":"/Users/luke/dev/040715/node_modules/mout/random/randInt.js"}],"/Users/luke/dev/040715/node_modules/mout/random/random.js":[function(require,module,exports){


    /**
     * Just a wrapper to Math.random. No methods inside mout/random should call
     * Math.random() directly so we can inject the pseudo-random number
     * generator if needed (ie. in case we need a seeded random or a better
     * algorithm than the native one)
     */
    function random(){
        return random.get();
    }

    // we expose the method so it can be swapped if needed
    random.get = Math.random;

    module.exports = random;



},{}],"/Users/luke/dev/040715/node_modules/mout/string.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'WHITE_SPACES' : require('./string/WHITE_SPACES'),
    'camelCase' : require('./string/camelCase'),
    'contains' : require('./string/contains'),
    'crop' : require('./string/crop'),
    'endsWith' : require('./string/endsWith'),
    'escapeHtml' : require('./string/escapeHtml'),
    'escapeRegExp' : require('./string/escapeRegExp'),
    'escapeUnicode' : require('./string/escapeUnicode'),
    'hyphenate' : require('./string/hyphenate'),
    'insert' : require('./string/insert'),
    'interpolate' : require('./string/interpolate'),
    'lowerCase' : require('./string/lowerCase'),
    'lpad' : require('./string/lpad'),
    'ltrim' : require('./string/ltrim'),
    'makePath' : require('./string/makePath'),
    'normalizeLineBreaks' : require('./string/normalizeLineBreaks'),
    'pascalCase' : require('./string/pascalCase'),
    'properCase' : require('./string/properCase'),
    'removeNonASCII' : require('./string/removeNonASCII'),
    'removeNonWord' : require('./string/removeNonWord'),
    'repeat' : require('./string/repeat'),
    'replace' : require('./string/replace'),
    'replaceAccents' : require('./string/replaceAccents'),
    'rpad' : require('./string/rpad'),
    'rtrim' : require('./string/rtrim'),
    'sentenceCase' : require('./string/sentenceCase'),
    'slugify' : require('./string/slugify'),
    'startsWith' : require('./string/startsWith'),
    'stripHtmlTags' : require('./string/stripHtmlTags'),
    'trim' : require('./string/trim'),
    'truncate' : require('./string/truncate'),
    'typecast' : require('./string/typecast'),
    'unCamelCase' : require('./string/unCamelCase'),
    'underscore' : require('./string/underscore'),
    'unescapeHtml' : require('./string/unescapeHtml'),
    'unescapeUnicode' : require('./string/unescapeUnicode'),
    'unhyphenate' : require('./string/unhyphenate'),
    'upperCase' : require('./string/upperCase')
};



},{"./string/WHITE_SPACES":"/Users/luke/dev/040715/node_modules/mout/string/WHITE_SPACES.js","./string/camelCase":"/Users/luke/dev/040715/node_modules/mout/string/camelCase.js","./string/contains":"/Users/luke/dev/040715/node_modules/mout/string/contains.js","./string/crop":"/Users/luke/dev/040715/node_modules/mout/string/crop.js","./string/endsWith":"/Users/luke/dev/040715/node_modules/mout/string/endsWith.js","./string/escapeHtml":"/Users/luke/dev/040715/node_modules/mout/string/escapeHtml.js","./string/escapeRegExp":"/Users/luke/dev/040715/node_modules/mout/string/escapeRegExp.js","./string/escapeUnicode":"/Users/luke/dev/040715/node_modules/mout/string/escapeUnicode.js","./string/hyphenate":"/Users/luke/dev/040715/node_modules/mout/string/hyphenate.js","./string/insert":"/Users/luke/dev/040715/node_modules/mout/string/insert.js","./string/interpolate":"/Users/luke/dev/040715/node_modules/mout/string/interpolate.js","./string/lowerCase":"/Users/luke/dev/040715/node_modules/mout/string/lowerCase.js","./string/lpad":"/Users/luke/dev/040715/node_modules/mout/string/lpad.js","./string/ltrim":"/Users/luke/dev/040715/node_modules/mout/string/ltrim.js","./string/makePath":"/Users/luke/dev/040715/node_modules/mout/string/makePath.js","./string/normalizeLineBreaks":"/Users/luke/dev/040715/node_modules/mout/string/normalizeLineBreaks.js","./string/pascalCase":"/Users/luke/dev/040715/node_modules/mout/string/pascalCase.js","./string/properCase":"/Users/luke/dev/040715/node_modules/mout/string/properCase.js","./string/removeNonASCII":"/Users/luke/dev/040715/node_modules/mout/string/removeNonASCII.js","./string/removeNonWord":"/Users/luke/dev/040715/node_modules/mout/string/removeNonWord.js","./string/repeat":"/Users/luke/dev/040715/node_modules/mout/string/repeat.js","./string/replace":"/Users/luke/dev/040715/node_modules/mout/string/replace.js","./string/replaceAccents":"/Users/luke/dev/040715/node_modules/mout/string/replaceAccents.js","./string/rpad":"/Users/luke/dev/040715/node_modules/mout/string/rpad.js","./string/rtrim":"/Users/luke/dev/040715/node_modules/mout/string/rtrim.js","./string/sentenceCase":"/Users/luke/dev/040715/node_modules/mout/string/sentenceCase.js","./string/slugify":"/Users/luke/dev/040715/node_modules/mout/string/slugify.js","./string/startsWith":"/Users/luke/dev/040715/node_modules/mout/string/startsWith.js","./string/stripHtmlTags":"/Users/luke/dev/040715/node_modules/mout/string/stripHtmlTags.js","./string/trim":"/Users/luke/dev/040715/node_modules/mout/string/trim.js","./string/truncate":"/Users/luke/dev/040715/node_modules/mout/string/truncate.js","./string/typecast":"/Users/luke/dev/040715/node_modules/mout/string/typecast.js","./string/unCamelCase":"/Users/luke/dev/040715/node_modules/mout/string/unCamelCase.js","./string/underscore":"/Users/luke/dev/040715/node_modules/mout/string/underscore.js","./string/unescapeHtml":"/Users/luke/dev/040715/node_modules/mout/string/unescapeHtml.js","./string/unescapeUnicode":"/Users/luke/dev/040715/node_modules/mout/string/unescapeUnicode.js","./string/unhyphenate":"/Users/luke/dev/040715/node_modules/mout/string/unhyphenate.js","./string/upperCase":"/Users/luke/dev/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke/dev/040715/node_modules/mout/string/WHITE_SPACES.js":[function(require,module,exports){

    /**
     * Contains all Unicode white-spaces. Taken from
     * http://en.wikipedia.org/wiki/Whitespace_character.
     */
    module.exports = [
        ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
        '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
        '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
        '\u205F', '\u3000'
    ];


},{}],"/Users/luke/dev/040715/node_modules/mout/string/camelCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
var replaceAccents = require('./replaceAccents');
var removeNonWord = require('./removeNonWord');
var upperCase = require('./upperCase');
var lowerCase = require('./lowerCase');
    /**
    * Convert string to camelCase text.
    */
    function camelCase(str){
        str = toString(str);
        str = replaceAccents(str);
        str = removeNonWord(str)
            .replace(/[\-_]/g, ' ') //convert all hyphens and underscores to spaces
            .replace(/\s[a-z]/g, upperCase) //convert first char of each word to UPPERCASE
            .replace(/\s+/g, '') //remove spaces
            .replace(/^[A-Z]/g, lowerCase); //convert first char to lowercase
        return str;
    }
    module.exports = camelCase;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./lowerCase":"/Users/luke/dev/040715/node_modules/mout/string/lowerCase.js","./removeNonWord":"/Users/luke/dev/040715/node_modules/mout/string/removeNonWord.js","./replaceAccents":"/Users/luke/dev/040715/node_modules/mout/string/replaceAccents.js","./upperCase":"/Users/luke/dev/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke/dev/040715/node_modules/mout/string/contains.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Searches for a given substring
     */
    function contains(str, substring, fromIndex){
        str = toString(str);
        substring = toString(substring);
        return str.indexOf(substring, fromIndex) !== -1;
    }

    module.exports = contains;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/crop.js":[function(require,module,exports){
var toString = require('../lang/toString');
var truncate = require('./truncate');
    /**
     * Truncate string at full words.
     */
     function crop(str, maxChars, append) {
         str = toString(str);
         return truncate(str, maxChars, append, true);
     }

     module.exports = crop;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./truncate":"/Users/luke/dev/040715/node_modules/mout/string/truncate.js"}],"/Users/luke/dev/040715/node_modules/mout/string/endsWith.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Checks if string ends with specified suffix.
     */
    function endsWith(str, suffix) {
        str = toString(str);
        suffix = toString(suffix);

        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }

    module.exports = endsWith;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/escapeHtml.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escapes a string for insertion into HTML.
     */
    function escapeHtml(str){
        str = toString(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/'/g, '&#39;')
            .replace(/"/g, '&quot;');
        return str;
    }

    module.exports = escapeHtml;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/escapeRegExp.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape RegExp string chars.
     */
    function escapeRegExp(str) {
        return toString(str).replace(/\W/g,'\\$&');
    }

    module.exports = escapeRegExp;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/escapeUnicode.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape string into unicode sequences
     */
    function escapeUnicode(str, shouldEscapePrintable){
        str = toString(str);
        return str.replace(/[\s\S]/g, function(ch){
            // skip printable ASCII chars if we should not escape them
            if (!shouldEscapePrintable && (/[\x20-\x7E]/).test(ch)) {
                return ch;
            }
            // we use "000" and slice(-4) for brevity, need to pad zeros,
            // unicode escape always have 4 chars after "\u"
            return '\\u'+ ('000'+ ch.charCodeAt(0).toString(16)).slice(-4);
        });
    }

    module.exports = escapeUnicode;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/hyphenate.js":[function(require,module,exports){
var toString = require('../lang/toString');
var slugify = require('./slugify');
var unCamelCase = require('./unCamelCase');
    /**
     * Replaces spaces with hyphens, split camelCase text, remove non-word chars, remove accents and convert to lower case.
     */
    function hyphenate(str){
        str = toString(str);
        str = unCamelCase(str);
        return slugify(str, "-");
    }

    module.exports = hyphenate;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./slugify":"/Users/luke/dev/040715/node_modules/mout/string/slugify.js","./unCamelCase":"/Users/luke/dev/040715/node_modules/mout/string/unCamelCase.js"}],"/Users/luke/dev/040715/node_modules/mout/string/insert.js":[function(require,module,exports){
var clamp = require('../math/clamp');
var toString = require('../lang/toString');

    /**
     * Inserts a string at a given index.
     */
    function insert(string, index, partial){
        string = toString(string);

        if (index < 0) {
            index = string.length + index;
        }

        index = clamp(index, 0, string.length);

        return string.substr(0, index) + partial + string.substr(index);
    }

    module.exports = insert;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","../math/clamp":"/Users/luke/dev/040715/node_modules/mout/math/clamp.js"}],"/Users/luke/dev/040715/node_modules/mout/string/interpolate.js":[function(require,module,exports){
var toString = require('../lang/toString');
var get = require('../object/get');

    var stache = /\{\{([^\}]+)\}\}/g; //mustache-like

    /**
     * String interpolation
     */
    function interpolate(template, replacements, syntax){
        template = toString(template);
        var replaceFn = function(match, prop){
            return toString( get(replacements, prop) );
        };
        return template.replace(syntax || stache, replaceFn);
    }

    module.exports = interpolate;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","../object/get":"/Users/luke/dev/040715/node_modules/mout/object/get.js"}],"/Users/luke/dev/040715/node_modules/mout/string/lowerCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * "Safer" String.toLowerCase()
     */
    function lowerCase(str){
        str = toString(str);
        return str.toLowerCase();
    }

    module.exports = lowerCase;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/lpad.js":[function(require,module,exports){
var toString = require('../lang/toString');
var repeat = require('./repeat');

    /**
     * Pad string with `char` if its' length is smaller than `minLen`
     */
    function lpad(str, minLen, ch) {
        str = toString(str);
        ch = ch || ' ';

        return (str.length < minLen) ?
            repeat(ch, minLen - str.length) + str : str;
    }

    module.exports = lpad;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./repeat":"/Users/luke/dev/040715/node_modules/mout/string/repeat.js"}],"/Users/luke/dev/040715/node_modules/mout/string/ltrim.js":[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from beginning of string.
     */
    function ltrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var start = 0,
            len = str.length,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && start < len) {
            found = false;
            i = -1;
            c = str.charAt(start);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    start++;
                    break;
                }
            }
        }

        return (start >= len) ? '' : str.substr(start, len);
    }

    module.exports = ltrim;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./WHITE_SPACES":"/Users/luke/dev/040715/node_modules/mout/string/WHITE_SPACES.js"}],"/Users/luke/dev/040715/node_modules/mout/string/makePath.js":[function(require,module,exports){
var join = require('../array/join');
var slice = require('../array/slice');

    /**
     * Group arguments as path segments, if any of the args is `null` or an
     * empty string it will be ignored from resulting path.
     */
    function makePath(var_args){
        var result = join(slice(arguments), '/');
        // need to disconsider duplicate '/' after protocol (eg: 'http://')
        return result.replace(/([^:\/]|^)\/{2,}/g, '$1/');
    }

    module.exports = makePath;


},{"../array/join":"/Users/luke/dev/040715/node_modules/mout/array/join.js","../array/slice":"/Users/luke/dev/040715/node_modules/mout/array/slice.js"}],"/Users/luke/dev/040715/node_modules/mout/string/normalizeLineBreaks.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Convert line-breaks from DOS/MAC to a single standard (UNIX by default)
     */
    function normalizeLineBreaks(str, lineEnd) {
        str = toString(str);
        lineEnd = lineEnd || '\n';

        return str
            .replace(/\r\n/g, lineEnd) // DOS
            .replace(/\r/g, lineEnd)   // Mac
            .replace(/\n/g, lineEnd);  // Unix
    }

    module.exports = normalizeLineBreaks;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/pascalCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
var camelCase = require('./camelCase');
var upperCase = require('./upperCase');
    /**
     * camelCase + UPPERCASE first char
     */
    function pascalCase(str){
        str = toString(str);
        return camelCase(str).replace(/^[a-z]/, upperCase);
    }

    module.exports = pascalCase;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./camelCase":"/Users/luke/dev/040715/node_modules/mout/string/camelCase.js","./upperCase":"/Users/luke/dev/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke/dev/040715/node_modules/mout/string/properCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
var lowerCase = require('./lowerCase');
var upperCase = require('./upperCase');
    /**
     * UPPERCASE first char of each word.
     */
    function properCase(str){
        str = toString(str);
        return lowerCase(str).replace(/^\w|\s\w/g, upperCase);
    }

    module.exports = properCase;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./lowerCase":"/Users/luke/dev/040715/node_modules/mout/string/lowerCase.js","./upperCase":"/Users/luke/dev/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke/dev/040715/node_modules/mout/string/removeNonASCII.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Remove non-printable ASCII chars
     */
    function removeNonASCII(str){
        str = toString(str);

        // Matches non-printable ASCII chars -
        // http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
        return str.replace(/[^\x20-\x7E]/g, '');
    }

    module.exports = removeNonASCII;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/removeNonWord.js":[function(require,module,exports){
var toString = require('../lang/toString');
    // This pattern is generated by the _build/pattern-removeNonWord.js script
    var PATTERN = /[^\x20\x2D0-9A-Z\x5Fa-z\xC0-\xD6\xD8-\xF6\xF8-\xFF]/g;

    /**
     * Remove non-word chars.
     */
    function removeNonWord(str){
        str = toString(str);
        return str.replace(PATTERN, '');
    }

    module.exports = removeNonWord;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/repeat.js":[function(require,module,exports){
var toString = require('../lang/toString');
var toInt = require('../number/toInt');

    /**
     * Repeat string n times
     */
     function repeat(str, n){
         var result = '';
         str = toString(str);
         n = toInt(n);
        if (n < 1) {
            return '';
        }
        while (n > 0) {
            if (n % 2) {
                result += str;
            }
            n = Math.floor(n / 2);
            str += str;
        }
        return result;
     }

     module.exports = repeat;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","../number/toInt":"/Users/luke/dev/040715/node_modules/mout/number/toInt.js"}],"/Users/luke/dev/040715/node_modules/mout/string/replace.js":[function(require,module,exports){
var toString = require('../lang/toString');
var toArray = require('../lang/toArray');

    /**
     * Replace string(s) with the replacement(s) in the source.
     */
    function replace(str, search, replacements) {
        str = toString(str);
        search = toArray(search);
        replacements = toArray(replacements);

        var searchLength = search.length,
            replacementsLength = replacements.length;

        if (replacementsLength !== 1 && searchLength !== replacementsLength) {
            throw new Error('Unequal number of searches and replacements');
        }

        var i = -1;
        while (++i < searchLength) {
            // Use the first replacement for all searches if only one
            // replacement is provided
            str = str.replace(
                search[i],
                replacements[(replacementsLength === 1) ? 0 : i]);
        }

        return str;
    }

    module.exports = replace;



},{"../lang/toArray":"/Users/luke/dev/040715/node_modules/mout/lang/toArray.js","../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/replaceAccents.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
    * Replaces all accented chars with regular ones
    */
    function replaceAccents(str){
        str = toString(str);

        // verifies if the String has accents and replace them
        if (str.search(/[\xC0-\xFF]/g) > -1) {
            str = str
                    .replace(/[\xC0-\xC5]/g, "A")
                    .replace(/[\xC6]/g, "AE")
                    .replace(/[\xC7]/g, "C")
                    .replace(/[\xC8-\xCB]/g, "E")
                    .replace(/[\xCC-\xCF]/g, "I")
                    .replace(/[\xD0]/g, "D")
                    .replace(/[\xD1]/g, "N")
                    .replace(/[\xD2-\xD6\xD8]/g, "O")
                    .replace(/[\xD9-\xDC]/g, "U")
                    .replace(/[\xDD]/g, "Y")
                    .replace(/[\xDE]/g, "P")
                    .replace(/[\xE0-\xE5]/g, "a")
                    .replace(/[\xE6]/g, "ae")
                    .replace(/[\xE7]/g, "c")
                    .replace(/[\xE8-\xEB]/g, "e")
                    .replace(/[\xEC-\xEF]/g, "i")
                    .replace(/[\xF1]/g, "n")
                    .replace(/[\xF2-\xF6\xF8]/g, "o")
                    .replace(/[\xF9-\xFC]/g, "u")
                    .replace(/[\xFE]/g, "p")
                    .replace(/[\xFD\xFF]/g, "y");
        }
        return str;
    }
    module.exports = replaceAccents;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/rpad.js":[function(require,module,exports){
var toString = require('../lang/toString');
var repeat = require('./repeat');

    /**
     * Pad string with `char` if its' length is smaller than `minLen`
     */
    function rpad(str, minLen, ch) {
        str = toString(str);
        ch = ch || ' ';
        return (str.length < minLen)? str + repeat(ch, minLen - str.length) : str;
    }

    module.exports = rpad;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./repeat":"/Users/luke/dev/040715/node_modules/mout/string/repeat.js"}],"/Users/luke/dev/040715/node_modules/mout/string/rtrim.js":[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from end of string.
     */
    function rtrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var end = str.length - 1,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && end >= 0) {
            found = false;
            i = -1;
            c = str.charAt(end);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    end--;
                    break;
                }
            }
        }

        return (end >= 0) ? str.substring(0, end + 1) : '';
    }

    module.exports = rtrim;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./WHITE_SPACES":"/Users/luke/dev/040715/node_modules/mout/string/WHITE_SPACES.js"}],"/Users/luke/dev/040715/node_modules/mout/string/sentenceCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
var lowerCase = require('./lowerCase');
var upperCase = require('./upperCase');
    /**
     * UPPERCASE first char of each sentence and lowercase other chars.
     */
    function sentenceCase(str){
        str = toString(str);

        // Replace first char of each sentence (new line or after '.\s+') to
        // UPPERCASE
        return lowerCase(str).replace(/(^\w)|\.\s+(\w)/gm, upperCase);
    }
    module.exports = sentenceCase;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./lowerCase":"/Users/luke/dev/040715/node_modules/mout/string/lowerCase.js","./upperCase":"/Users/luke/dev/040715/node_modules/mout/string/upperCase.js"}],"/Users/luke/dev/040715/node_modules/mout/string/slugify.js":[function(require,module,exports){
var toString = require('../lang/toString');
var replaceAccents = require('./replaceAccents');
var removeNonWord = require('./removeNonWord');
var trim = require('./trim');
    /**
     * Convert to lower case, remove accents, remove non-word chars and
     * replace spaces with the specified delimeter.
     * Does not split camelCase text.
     */
    function slugify(str, delimeter){
        str = toString(str);

        if (delimeter == null) {
            delimeter = "-";
        }
        str = replaceAccents(str);
        str = removeNonWord(str);
        str = trim(str) //should come after removeNonWord
                .replace(/ +/g, delimeter) //replace spaces with delimeter
                .toLowerCase();
        return str;
    }
    module.exports = slugify;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./removeNonWord":"/Users/luke/dev/040715/node_modules/mout/string/removeNonWord.js","./replaceAccents":"/Users/luke/dev/040715/node_modules/mout/string/replaceAccents.js","./trim":"/Users/luke/dev/040715/node_modules/mout/string/trim.js"}],"/Users/luke/dev/040715/node_modules/mout/string/startsWith.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Checks if string starts with specified prefix.
     */
    function startsWith(str, prefix) {
        str = toString(str);
        prefix = toString(prefix);

        return str.indexOf(prefix) === 0;
    }

    module.exports = startsWith;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/stripHtmlTags.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Remove HTML tags from string.
     */
    function stripHtmlTags(str){
        str = toString(str);

        return str.replace(/<[^>]*>/g, '');
    }
    module.exports = stripHtmlTags;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/trim.js":[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
var ltrim = require('./ltrim');
var rtrim = require('./rtrim');
    /**
     * Remove white-spaces from beginning and end of string.
     */
    function trim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;
        return ltrim(rtrim(str, chars), chars);
    }

    module.exports = trim;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./WHITE_SPACES":"/Users/luke/dev/040715/node_modules/mout/string/WHITE_SPACES.js","./ltrim":"/Users/luke/dev/040715/node_modules/mout/string/ltrim.js","./rtrim":"/Users/luke/dev/040715/node_modules/mout/string/rtrim.js"}],"/Users/luke/dev/040715/node_modules/mout/string/truncate.js":[function(require,module,exports){
var toString = require('../lang/toString');
var trim = require('./trim');
    /**
     * Limit number of chars.
     */
    function truncate(str, maxChars, append, onlyFullWords){
        str = toString(str);
        append = append || '...';
        maxChars = onlyFullWords? maxChars + 1 : maxChars;

        str = trim(str);
        if(str.length <= maxChars){
            return str;
        }
        str = str.substr(0, maxChars - append.length);
        //crop at last space or remove trailing whitespace
        str = onlyFullWords? str.substr(0, str.lastIndexOf(' ')) : trim(str);
        return str + append;
    }
    module.exports = truncate;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./trim":"/Users/luke/dev/040715/node_modules/mout/string/trim.js"}],"/Users/luke/dev/040715/node_modules/mout/string/typecast.js":[function(require,module,exports){


    var UNDEF;

    /**
     * Parses string and convert it into a native value.
     */
    function typecast(val) {
        var r;
        if ( val === null || val === 'null' ) {
            r = null;
        } else if ( val === 'true' ) {
            r = true;
        } else if ( val === 'false' ) {
            r = false;
        } else if ( val === UNDEF || val === 'undefined' ) {
            r = UNDEF;
        } else if ( val === '' || isNaN(val) ) {
            //isNaN('') returns false
            r = val;
        } else {
            //parseFloat(null || '') returns NaN
            r = parseFloat(val);
        }
        return r;
    }

    module.exports = typecast;


},{}],"/Users/luke/dev/040715/node_modules/mout/string/unCamelCase.js":[function(require,module,exports){
var toString = require('../lang/toString');

    var CAMEL_CASE_BORDER = /([a-z\xE0-\xFF])([A-Z\xC0\xDF])/g;

    /**
     * Add space between camelCase text.
     */
    function unCamelCase(str, delimiter){
        if (delimiter == null) {
            delimiter = ' ';
        }

        function join(str, c1, c2) {
            return c1 + delimiter + c2;
        }

        str = toString(str);
        str = str.replace(CAMEL_CASE_BORDER, join);
        str = str.toLowerCase(); //add space between camelCase text
        return str;
    }
    module.exports = unCamelCase;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/underscore.js":[function(require,module,exports){
var toString = require('../lang/toString');
var slugify = require('./slugify');
var unCamelCase = require('./unCamelCase');
    /**
     * Replaces spaces with underscores, split camelCase text, remove non-word chars, remove accents and convert to lower case.
     */
    function underscore(str){
        str = toString(str);
        str = unCamelCase(str);
        return slugify(str, "_");
    }
    module.exports = underscore;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js","./slugify":"/Users/luke/dev/040715/node_modules/mout/string/slugify.js","./unCamelCase":"/Users/luke/dev/040715/node_modules/mout/string/unCamelCase.js"}],"/Users/luke/dev/040715/node_modules/mout/string/unescapeHtml.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Unescapes HTML special chars
     */
    function unescapeHtml(str){
        str = toString(str)
            .replace(/&amp;/g , '&')
            .replace(/&lt;/g  , '<')
            .replace(/&gt;/g  , '>')
            .replace(/&#0*39;/g , "'")
            .replace(/&quot;/g, '"');
        return str;
    }

    module.exports = unescapeHtml;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/unescapeUnicode.js":[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Unescape unicode char sequences
     */
    function unescapeUnicode(str){
        str = toString(str);
        return str.replace(/\\u[0-9a-f]{4}/g, function(ch){
            var code = parseInt(ch.slice(2), 16);
            return String.fromCharCode(code);
        });
    }

    module.exports = unescapeUnicode;



},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/unhyphenate.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * Replaces hyphens with spaces. (only hyphens between word chars)
     */
    function unhyphenate(str){
        str = toString(str);
        return str.replace(/(\w)(-)(\w)/g, '$1 $3');
    }
    module.exports = unhyphenate;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/string/upperCase.js":[function(require,module,exports){
var toString = require('../lang/toString');
    /**
     * "Safer" String.toUpperCase()
     */
    function upperCase(str){
        str = toString(str);
        return str.toUpperCase();
    }
    module.exports = upperCase;


},{"../lang/toString":"/Users/luke/dev/040715/node_modules/mout/lang/toString.js"}],"/Users/luke/dev/040715/node_modules/mout/time.js":[function(require,module,exports){


//automatically generated, do not edit!
//run `node build` instead
module.exports = {
    'convert' : require('./time/convert'),
    'now' : require('./time/now'),
    'parseMs' : require('./time/parseMs'),
    'toTimeString' : require('./time/toTimeString')
};



},{"./time/convert":"/Users/luke/dev/040715/node_modules/mout/time/convert.js","./time/now":"/Users/luke/dev/040715/node_modules/mout/time/now.js","./time/parseMs":"/Users/luke/dev/040715/node_modules/mout/time/parseMs.js","./time/toTimeString":"/Users/luke/dev/040715/node_modules/mout/time/toTimeString.js"}],"/Users/luke/dev/040715/node_modules/mout/time/convert.js":[function(require,module,exports){


    /**
     * convert time into another unit
     */
    function convert(val, sourceUnitName, destinationUnitName){
        destinationUnitName = destinationUnitName || 'ms';
        return (val * getUnit(sourceUnitName)) / getUnit(destinationUnitName);
    }


    //TODO: maybe extract to a separate module
    function getUnit(unitName){
        switch(unitName){
            case 'ms':
            case 'millisecond':
                return 1;
            case 's':
            case 'second':
                 return 1000;
            case 'm':
            case 'minute':
                 return 60000;
            case 'h':
            case 'hour':
                 return 3600000;
            case 'd':
            case 'day':
                 return 86400000;
            case 'w':
            case 'week':
                 return 604800000;
            default:
                throw new Error('"'+ unitName + '" is not a valid unit');
        }
    }


    module.exports = convert;



},{}],"/Users/luke/dev/040715/node_modules/mout/time/now.js":[function(require,module,exports){


    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    module.exports = now;



},{}],"/Users/luke/dev/040715/node_modules/mout/time/parseMs.js":[function(require,module,exports){
var countSteps = require('../math/countSteps');

    /**
     * Parse timestamp into an object.
     */
    function parseMs(ms){
        return {
            milliseconds : countSteps(ms, 1, 1000),
            seconds      : countSteps(ms, 1000, 60),
            minutes      : countSteps(ms, 60000, 60),
            hours        : countSteps(ms, 3600000, 24),
            days         : countSteps(ms, 86400000)
        };
    }

    module.exports = parseMs;


},{"../math/countSteps":"/Users/luke/dev/040715/node_modules/mout/math/countSteps.js"}],"/Users/luke/dev/040715/node_modules/mout/time/toTimeString.js":[function(require,module,exports){
var countSteps = require('../math/countSteps');
var pad = require('../number/pad');

    var HOUR = 3600000,
        MINUTE = 60000,
        SECOND = 1000;

    /**
     * Format timestamp into a time string.
     */
    function toTimeString(ms){
        var h = ms < HOUR   ? 0 : countSteps(ms, HOUR),
            m = ms < MINUTE ? 0 : countSteps(ms, MINUTE, 60),
            s = ms < SECOND ? 0 : countSteps(ms, SECOND, 60),
            str = '';

        str += h? h + ':' : '';
        str += pad(m, 2) + ':';
        str += pad(s, 2);

        return str;
    }
    module.exports = toTimeString;


},{"../math/countSteps":"/Users/luke/dev/040715/node_modules/mout/math/countSteps.js","../number/pad":"/Users/luke/dev/040715/node_modules/mout/number/pad.js"}],"/Users/luke/dev/040715/node_modules/path-to-regexp/index.js":[function(require,module,exports){
var isArray = require('isarray');

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
  '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
  // Match regexp special characters that are always escaped.
  '([.+*?=^!:${}()[\\]|\\/])'
].join('|'), 'g');

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {String}
 */
function flags (options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {RegExp} path
 * @param  {Array}  keys
 * @return {RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name:      i,
        delimiter: null,
        optional:  false,
        repeat:    false
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {Array}  path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
  return attachKeys(regexp, keys);
}

/**
 * Replace the specific tags with regexp strings.
 *
 * @param  {String} path
 * @param  {Array}  keys
 * @return {String}
 */
function replacePath (path, keys) {
  var index = 0;

  function replace (_, escaped, prefix, key, capture, group, suffix, escape) {
    if (escaped) {
      return escaped;
    }

    if (escape) {
      return '\\' + escape;
    }

    var repeat   = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';

    keys.push({
      name:      key || index++,
      delimiter: prefix || '/',
      optional:  optional,
      repeat:    repeat
    });

    prefix = prefix ? ('\\' + prefix) : '';
    capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

    if (repeat) {
      capture = capture + '(?:' + prefix + capture + ')*';
    }

    if (optional) {
      return '(?:' + prefix + '(' + capture + '))?';
    }

    // Basic parameter support.
    return prefix + '(' + capture + ')';
  }

  return path.replace(PATH_REGEXP, replace);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 [keys]
 * @param  {Object}                [options]
 * @return {RegExp}
 */
function pathToRegexp (path, keys, options) {
  keys = keys || [];

  if (!isArray(keys)) {
    options = keys;
    keys = [];
  } else if (!options) {
    options = {};
  }

  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys, options);
  }

  if (isArray(path)) {
    return arrayToRegexp(path, keys, options);
  }

  var strict = options.strict;
  var end = options.end !== false;
  var route = replacePath(path, keys);
  var endsWithSlash = path.charAt(path.length - 1) === '/';

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

},{"isarray":"/Users/luke/dev/040715/node_modules/path-to-regexp/node_modules/isarray/index.js"}],"/Users/luke/dev/040715/node_modules/path-to-regexp/node_modules/isarray/index.js":[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],"/Users/luke/dev/040715/source/js/app-debug.coffee":[function(require,module,exports){
var dat, gui, options, page;

dat = require("dat-gui");

page = require("./../../vendor/page/page.js");

gui = window._gui = new dat.GUI();

options = {
  "debug": false,
  "index": function() {
    return page("/aandl");
  },
  "morning": function() {
    return page("/aandl/morning");
  },
  "day": function() {
    return page("/aandl/day");
  },
  "night": function() {
    return page("/aandl/night");
  }
};

module.exports = function() {
  var debug, folder;
  debug = gui.add(options, "debug");
  folder = gui.addFolder("navigation");
  folder.add(options, "index").name("/index");
  folder.add(options, "morning").name("/morning");
  folder.add(options, "day").name("/day");
  folder.add(options, "night").name("/night");
  return folder.open();
};



},{"./../../vendor/page/page.js":"/Users/luke/dev/040715/vendor/page/page.js","dat-gui":"/Users/luke/dev/040715/node_modules/dat-gui/index.js"}],"/Users/luke/dev/040715/source/js/config.coffee":[function(require,module,exports){
module.exports = {
  firebase: "aliceluke"
};



},{}],"/Users/luke/dev/040715/source/js/module/abstract-module.coffee":[function(require,module,exports){
var Ractive;

Ractive = require("./../../../vendor/ractive/ractive.js");

module.exports = Ractive.extend({
  isolated: true
});



},{"./../../../vendor/ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js"}],"/Users/luke/dev/040715/source/js/module/abstract-scene.coffee":[function(require,module,exports){

/*
	@module:   abstract-scene
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/abstract-scene.styl
	@html:     ./source/template/module/abstract-scene.html
 */
var Module;

Module = require("./abstract-module");

module.exports = Module.extend({
  template: require("module/abstract-scene.html"),
  oninit: function() {}
});



},{"./abstract-module":"/Users/luke/dev/040715/source/js/module/abstract-module.coffee","module/abstract-scene.html":"/Users/luke/dev/040715/source/template/module/abstract-scene.html"}],"/Users/luke/dev/040715/source/js/module/index.coffee":[function(require,module,exports){

/*
	THIS FILE IS GENERATED AUTOMATICALLY AND IT WILL
	BE REPLACED IF A NEW MODULE IS ADDED OR DELETED.
 */
var Ractive, register;

Ractive = require("./../../../vendor/ractive/ractive.js");

register = function() {
  Ractive.components["ui-abstract-scene"] = require("./abstract-scene");
  Ractive.components["ui-scene-day"] = require("./scene-day");
  Ractive.components["ui-scene-morning"] = require("./scene-morning");
  Ractive.components["ui-scene-night"] = require("./scene-night");
  Ractive.components["ui-stage"] = require("./stage");
  return true;
};

module.exports = register();



},{"./../../../vendor/ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js","./abstract-scene":"/Users/luke/dev/040715/source/js/module/abstract-scene.coffee","./scene-day":"/Users/luke/dev/040715/source/js/module/scene-day.coffee","./scene-morning":"/Users/luke/dev/040715/source/js/module/scene-morning.coffee","./scene-night":"/Users/luke/dev/040715/source/js/module/scene-night.coffee","./stage":"/Users/luke/dev/040715/source/js/module/stage.coffee"}],"/Users/luke/dev/040715/source/js/module/scene-day.coffee":[function(require,module,exports){

/*
	@module:   scene-day
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/scene-day.styl
	@html:     ./source/template/module/scene-day.html
 */
var Module, keys, last;

Module = require("./abstract-scene");

keys = require("mout").object.keys;

last = require("mout").array.last;

module.exports = Module.extend({
  template: require("module/scene-day.html"),
  partials: {
    slideControls: require("partials/slide-controls.html")
  },
  data: {
    current: 0,
    x: ["100%", "-200%"]
  },
  oninit: function() {
    return this._super();
  },
  onteardown: function() {
    this.prevSlide();
    return this.set("slides.*.active", false);
  },
  onrender: function() {
    this.on("goNextSlide", function() {
      return this.nextSlide();
    });
    this.on("goPrevSlide", function() {
      return this.prevSlide();
    });
    return this.nextSlide();
  },
  nextSlide: function() {
    var current, next;
    current = this.get("current");
    next = current === keys(this.get("slides")).length ? 1 : current += 1;
    if (this.get("current") !== 0) {
      this.set("slides." + (this.get("current")) + ".x", this.get("x[1]"));
    }
    this.set("slides." + next + ".x", this.get("x[0]"));
    return this.setSlide(next);
  },
  prevSlide: function() {
    var current, prev;
    current = this.get("current");
    prev = current === 1 ? keys(this.get("slides")).length : current -= 1;
    if (this.get("current") !== 0) {
      this.set("slides." + (this.get("current")) + ".x", this.get("x[0]"));
    }
    this.set("slides." + prev + ".x", this.get("x[1]"));
    return this.setSlide(prev);
  },
  setSlide: function(slide) {
    if (this.get("current") !== 0) {
      this.set("slides." + (this.get("current")) + ".active", false);
    }
    this.set("slides." + slide + ".active", true);
    return this.set({
      current: slide
    });
  }
});



},{"./abstract-scene":"/Users/luke/dev/040715/source/js/module/abstract-scene.coffee","module/scene-day.html":"/Users/luke/dev/040715/source/template/module/scene-day.html","mout":"/Users/luke/dev/040715/node_modules/mout/index.js","partials/slide-controls.html":"/Users/luke/dev/040715/source/template/partials/slide-controls.html"}],"/Users/luke/dev/040715/source/js/module/scene-morning.coffee":[function(require,module,exports){

/*
	@module:   scene-morning
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/scene-morning.styl
	@html:     ./source/template/module/scene-morning.html
 */
var Module;

Module = require("./abstract-scene");

module.exports = Module.extend({
  template: require("module/scene-morning.html"),
  oninit: function() {
    return this._super();
  },
  onrender: function() {}
});



},{"./abstract-scene":"/Users/luke/dev/040715/source/js/module/abstract-scene.coffee","module/scene-morning.html":"/Users/luke/dev/040715/source/template/module/scene-morning.html"}],"/Users/luke/dev/040715/source/js/module/scene-night.coffee":[function(require,module,exports){

/*
	@module:   scene-night
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/scene-night.styl
	@html:     ./source/template/module/scene-night.html
 */
var AddClass, Module;

Module = require("./abstract-scene");

AddClass = require("../util/addClass");

module.exports = Module.extend({
  template: require("module/scene-night.html"),
  oninit: function() {
    return this._super();
  },
  onrender: function() {
    return this.on("sendMessage", function(e) {
      var link;
      this.fire("msgSent", this.get("message"));
      this.off("sendMessage");
      document.getElementById("message").disabled = true;
      AddClass(e.node, "disabled");
      link = this.find(".postcard__send a");
      return link.innerHTML = "Sent";
    });
  }
});



},{"../util/addClass":"/Users/luke/dev/040715/source/js/util/addClass.coffee","./abstract-scene":"/Users/luke/dev/040715/source/js/module/abstract-scene.coffee","module/scene-night.html":"/Users/luke/dev/040715/source/template/module/scene-night.html"}],"/Users/luke/dev/040715/source/js/module/stage.coffee":[function(require,module,exports){

/*
	@module:   stage
	@author:   lukehedger <luke.hedger@gmail.com>
	@css:      ./source/css/module/stage.styl
	@html:     ./source/template/module/stage.html
 */
var AddClass, Module, forIn, keys, page;

Module = require("./abstract-module");

page = require("./../../../vendor/page/page.js");

keys = require("mout").object.keys;

forIn = require("mout").object.forIn;

AddClass = require("../util/addClass");

module.exports = Module.extend({
  template: require("module/stage.html"),
  partials: {
    stageControls: require("partials/stage-controls.html"),
    farm: require("partials/farm.html"),
    sun: require("partials/sun.html")
  },
  data: {
    current: 0,
    scenes: {
      1: "morning",
      2: "day",
      3: "night"
    }
  },
  oninit: function() {
    window.onkeydown = (function(_this) {
      return function(e) {
        if (e.keyCode === 38) {
          _this.prevScene();
        }
        if (e.keyCode === 40) {
          return _this.nextScene();
        }
      };
    })(this);
    this.on("goNextScene", function() {
      return this.nextScene();
    });
    this.on("goPrevScene", function() {
      return this.prevScene();
    });
    return this.observe("view", (function(_this) {
      return function(newValue) {
        if (newValue) {
          return forIn(_this.get("scenes"), function(v, k) {
            if (v === newValue) {
              return _this.set({
                current: parseInt(k, 10)
              });
            }
          });
        }
      };
    })(this));
  },
  nextScene: function() {
    var current, next;
    current = this.get("current");
    next = current === keys(this.get("scenes")).length ? 1 : current += 1;
    return this.setScene(next);
  },
  prevScene: function() {
    var current, prev;
    current = this.get("current");
    prev = current === 1 ? keys(this.get("scenes")).length : current -= 1;
    return this.setScene(prev);
  },
  setScene: function(scene) {
    return page("/" + (this.get("code")) + "/" + (this.get("scenes." + scene)));
  }
});



},{"../util/addClass":"/Users/luke/dev/040715/source/js/util/addClass.coffee","./../../../vendor/page/page.js":"/Users/luke/dev/040715/vendor/page/page.js","./abstract-module":"/Users/luke/dev/040715/source/js/module/abstract-module.coffee","module/stage.html":"/Users/luke/dev/040715/source/template/module/stage.html","mout":"/Users/luke/dev/040715/node_modules/mout/index.js","partials/farm.html":"/Users/luke/dev/040715/source/template/partials/farm.html","partials/stage-controls.html":"/Users/luke/dev/040715/source/template/partials/stage-controls.html","partials/sun.html":"/Users/luke/dev/040715/source/template/partials/sun.html"}],"/Users/luke/dev/040715/source/js/util/addClass.coffee":[function(require,module,exports){
module.exports = function(el, className) {
  if (el != null) {
    if (el.classList != null) {
      return el.classList.add(className);
    } else {
      return el.className += ' ' + className;
    }
  }
};



},{}],"/Users/luke/dev/040715/source/js/util/supported.coffee":[function(require,module,exports){
var platform;

platform = require("./../../../vendor/platform/platform.js");

module.exports = function() {
  if (platform.name === "IE" && parseFloat(platform.version) < 9) {
    return false;
  } else {
    return true;
  }
};



},{"./../../../vendor/platform/platform.js":"/Users/luke/dev/040715/vendor/platform/platform.js"}],"/Users/luke/dev/040715/source/js/view/main-view.coffee":[function(require,module,exports){
var Firebase, Ractive, Supported, config, keys, last, pad, page,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Ractive = require("./../../../vendor/ractive/ractive.js");

Firebase = require("firebase");

page = require("./../../../vendor/page/page.js");

Supported = require("../util/supported");

last = require("mout").array.last;

keys = require("mout").object.keys;

pad = require("mout").number.pad;

config = require("../config");

module.exports = Ractive.extend({
  el: document.body,
  append: true,
  template: require("main-view.html"),
  partials: {
    loader: require("partials/loader.html")
  },
  data: {
    code: null,
    view: null,
    content: null,
    guest: null,
    authorised: true,
    loaded: false,
    supported: true
  },
  db: null,
  oninit: function() {
    this.set_router();
    this.set({
      supported: Supported()
    });
    if (!this.get("supported")) {

    }
  },
  onrender: function() {
    var code;
    code = this.get("code");
    if (code != null) {
      return this.getData(code);
    } else {
      return this.set("authorised", false);
    }
  },
  getData: function(code) {
    this.db = new Firebase("https://" + config.firebase + ".firebaseio.com/");
    return this.db.once("value", (function(_this) {
      return function(snapshot) {
        var data;
        data = snapshot.val();
        _this.set({
          authorised: indexOf.call(keys(data.guests), code) >= 0 ? true : false
        });
        if (!_this.get("authorised")) {
          return;
        }
        return _this.onDataSuccess(data, code);
      };
    })(this), function(err) {
      return console.log("err:", err.code);
    });
  },
  onDataSuccess: function(data, code) {
    this.set({
      content: data.content,
      guest: data.guests["" + code],
      message: data.messages && (data.messages["" + code] != null) ? data.messages["" + code]["" + (last(keys(data.messages["" + code])))].message : "",
      loaded: true
    });
    return this.on("*.msgSent", function(msg) {
      var now, ts;
      now = new Date();
      ts = "" + (now.getFullYear()) + (pad(now.getMonth() + 1, 2)) + (pad(now.getDate(), 2));
      return this.db.child("messages/" + (this.get("code"))).push({
        message: msg,
        timestamp: ts
      });
    });
  },
  set_router: function() {
    var self;
    self = this;
    page("/:code/:scene?", function(ctx) {
      return self.set({
        code: ctx.params.code,
        view: ctx.params.scene != null ? ctx.params.scene : "morning"
      });
    });
    return page({
      click: false,
      dispatch: true,
      hashbang: false
    });
  }
});



},{"../config":"/Users/luke/dev/040715/source/js/config.coffee","../util/supported":"/Users/luke/dev/040715/source/js/util/supported.coffee","./../../../vendor/page/page.js":"/Users/luke/dev/040715/vendor/page/page.js","./../../../vendor/ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js","firebase":"/Users/luke/dev/040715/node_modules/firebase/lib/firebase-web.js","main-view.html":"/Users/luke/dev/040715/source/template/main-view.html","mout":"/Users/luke/dev/040715/node_modules/mout/index.js","partials/loader.html":"/Users/luke/dev/040715/source/template/partials/loader.html"}],"/Users/luke/dev/040715/source/template/main-view.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"wrapper"},"f":[{"t":4,"r":"supported","f":[{"t":4,"r":"authorised","f":[{"t":4,"r":"loaded","f":[{"t":7,"e":"div","a":{"class":["sky ",{"t":2,"r":"view"}]}}," ",{"t":7,"e":"ui-stage","a":{"view":[{"t":2,"r":"view"}],"code":[{"t":2,"r":"code"}],"content":[{"t":2,"r":"content"}],"guest":[{"t":2,"r":"guest"}],"message":[{"t":2,"r":"message"}]}}]}," ",{"t":4,"r":"loaded","f":[{"t":8,"r":"loader"}],"n":51}]}," ",{"t":4,"r":"authorised","f":[{"t":7,"e":"div","a":{"class":"info"},"f":["Sorry, you need an invite ;)"]}],"n":51}]}," ",{"t":4,"r":"supported","f":[{"t":7,"e":"div","a":{"class":"info--unsupported"},"f":["Sorry, you need a ",{"t":7,"e":"a","a":{"href":"http://outdatedbrowser.com/en"},"f":["better browser"]},"!"]}],"n":51}]}]}
},{}],"/Users/luke/dev/040715/source/template/module/abstract-scene.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"abstract-scene"},"f":[{"t":7,"e":"h1","f":["abstract-scene :)"]}]}]}
},{}],"/Users/luke/dev/040715/source/template/module/scene-day.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"scene scene-day"},"t1":{"n":"fly","a":[{"x":"0%","y":"100%","opacity":1}]},"f":[{"t":7,"e":"div","a":{"class":"showtime"},"v":{"swiperight":"goPrevSlide","swipeleft":"goNextSlide"},"f":[{"t":8,"r":"slideControls"}," ",{"t":4,"r":"slides","i":"slide","f":[{"t":4,"r":"active","f":[{"t":7,"e":"div","a":{"class":["slide--",{"t":2,"r":"slide"}]},"t0":{"n":"fly","d":["{ x:'",{"t":2,"r":"x"},"', y:'0%', opacity:1 }"]},"f":[{"t":7,"e":"div","a":{"class":"slide__title"},"f":[{"t":7,"e":"h3","f":[{"t":2,"r":"title"}]}]}," ",{"t":7,"e":"div","a":{"class":"slide__body"},"f":[{"t":4,"x":{"r":["slide"],"s":"_0==1"},"f":[{"t":7,"e":"div","a":{"class":"slide__feature"},"f":[{"t":7,"e":"div","a":{"class":"feature__inner"},"f":["11am"]}]}," ",{"t":7,"e":"div","a":{"class":"slide__section"},"f":[{"t":7,"e":"div","a":{"class":"section__inner"},"f":[{"t":7,"e":"p","f":["We shall be getting married at Otham Court Chapel."]}," ",{"t":7,"e":"p","f":["It's pretty cosy inside with only a few pews. The ceremony will be short (and sweet) but let us know if you'll need a seat and we'll save one especially."]}," ",{"t":7,"e":"p","f":["We've also been asked to let those of you with little ones (or those prone to falling in lakes) know that there are two open ponds so take care."]}," ",{"t":7,"e":"p","f":["There is plenty of parking available on-site!"]}]}]}," ",{"t":7,"e":"div","a":{"class":"slide__section"},"f":[{"t":7,"e":"div","a":{"class":"section__inner--address"},"f":[{"t":7,"e":"p","a":{"class":"slide__address"},"f":["Otham Court",{"t":7,"e":"br"}," Otham Court Lane",{"t":7,"e":"br"}," Polegate",{"t":7,"e":"br"}," East Sussex",{"t":7,"e":"br"}," BN26 6QS",{"t":7,"e":"br"}]}]}]}," ",{"t":7,"e":"div","a":{"class":"flower--5"}}," ",{"t":7,"e":"div","a":{"class":"flower--9"}}]}," ",{"t":4,"x":{"r":["slide"],"s":"_0==2"},"f":[{"t":7,"e":"div","a":{"class":"slide__feature"},"f":[{"t":7,"e":"div","a":{"class":"feature__inner"},"f":["1pm"]}]}," ",{"t":7,"e":"div","a":{"class":"slide__section"},"f":[{"t":7,"e":"div","a":{"class":"section__inner"},"f":[{"t":7,"e":"p","f":["Following the ceremony we shall be celebrating at Hawthbush Farm, with plenty of paella, ice cream and cheese! Including wine from our personal vineyard in Bordeaux and beers from Camden Town Brewery and Gun Brewery (which is brewed on site!)"]}," ",{"t":7,"e":"p","f":["Again plenty of parking!"]}," ",{"t":7,"e":"div","a":{"class":"beer"},"f":[{"t":7,"e":"div","a":{"class":"beer__clip--ctb"}}," ",{"t":7,"e":"div","a":{"class":"beer__clip--gun"}}]}]}]}," ",{"t":7,"e":"div","a":{"class":"slide__section"},"f":[{"t":7,"e":"div","a":{"class":"section__inner--address"},"f":[{"t":7,"e":"p","a":{"class":"slide__address"},"f":["Hawthbush Farm",{"t":7,"e":"br"}," Gun Hill",{"t":7,"e":"br"}," Heathfield",{"t":7,"e":"br"}," East Sussex",{"t":7,"e":"br"}," TN21 0JY",{"t":7,"e":"br"}," (TN21 0JX for SatNav)"]}]}]}," ",{"t":7,"e":"div","a":{"class":"flower--2"}}," ",{"t":7,"e":"div","a":{"class":"flower--13"}}]}," ",{"t":4,"x":{"r":["slide"],"s":"_0==3"},"f":[{"t":7,"e":"div","a":{"class":"slide__feature"},"f":[{"t":7,"e":"div","a":{"class":"feature__inner"},"f":[""]}]}," ",{"t":7,"e":"div","a":{"class":"slide__section"},"f":[{"t":7,"e":"div","a":{"class":"section__inner"},"f":[{"t":7,"e":"p","f":["Here are a few nice hotels if you need accomodation over the weekend:"]}," ",{"t":7,"e":"ul","a":{"class":"slide__list"},"f":[{"t":7,"e":"li","f":[{"t":7,"e":"a","a":{"href":"http://www.skyhousesussex.com/","class":"slide__link"},"f":["Skyhouse"]}]}," ",{"t":7,"e":"li","f":[{"t":7,"e":"a","a":{"href":"http://www.maygarlandinn.co.uk/","class":"slide__link"},"f":["May Garland Inn"]}," (close to reception)"]}," ",{"t":7,"e":"li","f":[{"t":7,"e":"a","a":{"href":"http://www.powdermillshotel.com/","class":"slide__link"},"f":["Powder Mills Hotel"]}]}," ",{"t":7,"e":"li","f":[{"t":7,"e":"a","a":{"href":"http://thelimes-bandb.co.uk/","class":"slide__link"},"f":["The Limes (close to ceremony)"]}]}]}," ",{"t":7,"e":"hr"}," ",{"t":7,"e":"p","f":["If you'd like to buy us a gift we've got a ",{"t":7,"e":"a","a":{"class":"slide__link","href":0},"f":["wedding list on Amazon"]}," :)"]}]}]}," ",{"t":7,"e":"div","a":{"class":"slide__section"},"f":[{"t":7,"e":"div","a":{"class":"section__inner"},"f":[{"t":7,"e":"p","f":["Let us know what tunes you'd like to hear at the reception in the RSVP below."]}," ",{"t":7,"e":"p","f":["Keep it classy - think along the lines of Backstreet Boys, Craig David & Toploader..."]}," ",{"t":7,"e":"p","f":["All requests for Rod Stewart will be ignored. Ok, mum, you're allowed one blast of Maggie May but THAT'S ALL!"]}]}]}," ",{"t":7,"e":"div","a":{"class":"flower--11"}}," ",{"t":7,"e":"div","a":{"class":"flower--12"}}]}]}]}]}]}]}]}]}
},{}],"/Users/luke/dev/040715/source/template/module/scene-morning.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"scene scene-morning"},"t1":"fade","f":[{"t":7,"e":"div","a":{"class":"greeting"},"f":[{"t":7,"e":"h2","f":["Dear ",{"t":2,"r":"guest.name"}]}," ",{"t":7,"e":"p","f":["We hope you can join us to celebrate our marriage on"]}," ",{"t":4,"x":{"r":["guest.name"],"s":"_0==\"Izzy\""},"f":[{"t":7,"e":"span","a":{"class":"hashtag"},"f":["#BiggerThanWoodstock"]}]}," ",{"t":7,"e":"h2","a":{"class":"date"},"f":["4th July 2015"]}," ",{"t":7,"e":"p","f":[{"t":7,"e":"span","a":{"style":"color:#e74c3c;"},"f":[""]}]}," ",{"t":7,"e":"p","f":["Alice & Luke"]}]}]}]}
},{}],"/Users/luke/dev/040715/source/template/module/scene-night.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"scene scene-night"},"t1":{"n":"fly","a":[{"x":"0%","y":"100%","opacity":1}]},"f":[{"t":7,"e":"div","a":{"class":"postcard"},"t1":"fade","f":[{"t":7,"e":"div","a":{"class":"postcard__inner"},"f":[{"t":7,"e":"div","a":{"class":"postcard__stamp"},"f":[{"t":7,"e":"span","a":{"class":"stamp__number--20"},"f":["20"]}," ",{"t":7,"e":"span","a":{"class":"stamp__number--15"},"f":["15"]}," ",{"t":7,"e":"span","a":{"class":"stamp__letter--l"},"f":["L"]}," ",{"t":7,"e":"span","a":{"class":"stamp__letter--a"},"f":["A"]}," ",{"t":7,"e":"div","a":{"class":"stamp__line"}}," ",{"t":7,"e":"div","a":{"class":"stamp__line--flipped"}}]}," ",{"t":7,"e":"div","a":{"class":"postcard__section--message"},"f":[{"t":7,"e":"textarea","a":{"class":"message","name":"message","id":"message","cols":"30","rows":"10","value":[{"t":2,"r":"message"}],"placeholder":"RSVP here..."}}," ",{"t":7,"e":"div","a":{"class":"postcard__from"},"f":["from ",{"t":2,"r":"guest.name"}]}," ",{"t":7,"e":"div","a":{"class":"postcard__send"},"f":[{"t":7,"e":"a","v":{"tap":"sendMessage"},"f":["Send"]}]}]}," ",{"t":7,"e":"div","a":{"class":"postcard__section--address"},"f":[{"t":7,"e":"div","a":{"class":"postcard__address"},"f":["Alice & Luke",{"t":7,"e":"br"}," London"]}," ",{"t":7,"e":"div","a":{"class":"postcard__description"},"f":["Hawthbush Farm, Gun Hill - circa 2015"]}]}]}]}]}]}
},{}],"/Users/luke/dev/040715/source/template/module/stage.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"stage"},"f":[{"x":{"r":["view"],"s":"{view:_0}"},"f":[{"t":8,"r":"stageControls"}],"t":4,"n":53}," ",{"t":4,"x":{"r":["view"],"s":"_0==\"morning\""},"f":[{"t":8,"r":"sun"}," ",{"t":7,"e":"ui-scene-morning","a":{"guest":[{"t":2,"r":"guest"}]}}]}," ",{"t":4,"x":{"r":["view"],"s":"_0==\"night\""},"f":[{"t":7,"e":"ui-scene-night","a":{"code":[{"t":2,"r":"code"}],"guest":[{"t":2,"r":"guest"}],"message":[{"t":2,"r":"message"}]}}]}," ",{"t":4,"x":{"r":["view"],"s":"_0==\"day\""},"f":[{"t":7,"e":"ui-scene-day","a":{"guest":[{"t":2,"r":"guest"}],"slides":[{"t":2,"r":"content.slides"}]}}]}," ",{"x":{"r":["view"],"s":"{view:_0}"},"f":[{"t":8,"r":"farm"}],"t":4,"n":53}]}]}
},{}],"/Users/luke/dev/040715/source/template/partials/farm.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":["farm--",{"t":2,"r":"view"}]},"f":[{"t":7,"e":"div","a":{"class":"field"},"f":[{"t":7,"e":"div","a":{"class":"camber"},"f":[{"t":7,"e":"svg","a":{"version":"1.1","xmlns":"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink","x":"0px","y":"0px","viewBox":"0 0 593.2 28.8","enable-background":"new 0 0 593.2 28.8","xml:space":"preserve"},"f":[{"t":7,"e":"path","a":{"fill":"#7AB490","stroke":"#7AB490","stroke-miterlimit":"10","d":"M593.2,29.3H0c0,0,0.5-3,0-20c43.4,23.1,518.7-24.7,593.2,0 C592.7,22.6,593.2,29.3,593.2,29.3z"}}]}]}]}," ",{"t":7,"e":"div","a":{"class":"bunting"},"f":[{"t":7,"e":"div","a":{"class":"cable--left"},"f":[{"t":7,"e":"svg","a":{"version":"1.1","xmlns":"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink","x":"0px","y":"0px","viewBox":"0 0 600 51.9","enable-background":"new 0 0 600 51.9","xml:space":"preserve"},"f":[{"t":7,"e":"path","a":{"fill":"none","stroke":"#FFFFFF","stroke-miterlimit":"10","d":"M0,0L0,0c266.8,25.2,599.9,13.6,600,0v0"}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"3.2,0.5 28.1,2.6 13.3,29.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"35.2,3.5 60.1,5.6 45.3,32.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"66,5.7 90.9,7.4 76.6,34.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"98,7.7 122.9,9.4 108.6,36.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"130.7,9.9 155.7,11.1 141.8,38.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"162.7,10.9 187.6,12.1 173.9,39.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"193.7,11.9 218.6,13.1 204.9,40.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"224.4,13.1 249.4,13.9 236.1,41.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"254.4,14.1 279.4,14.9 266.1,42.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"284,14.5 309,14.5 296.5,42.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"314.2,15.3 339.2,15.7 326.3,43.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"346,15.5 371,15.5 358.5,43.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"377,15.5 402,15.5 389.5,43.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"409,14.5 434,14.5 421.5,42.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"440.6,13.9 465.5,13.1 453.9,41.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"471.6,12.9 496.5,12.1 484.9,40.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"502.3,12.2 527.2,10.8 516.3,39.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"533,10.5 557.9,8.6 547.6,37.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"563.4,8.1 588.2,5.1 579.2,34.5 "}}]}]}," ",{"t":7,"e":"div","a":{"class":"pole"}}," ",{"t":7,"e":"div","a":{"class":"cable--right"},"f":[{"t":7,"e":"svg","a":{"version":"1.1","xmlns":"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink","x":"0px","y":"0px","viewBox":"0 0 600 51.9","enable-background":"new 0 0 600 51.9","xml:space":"preserve"},"f":[{"t":7,"e":"path","a":{"fill":"none","stroke":"#FFFFFF","stroke-miterlimit":"10","d":"M0,0L0,0c266.8,25.2,599.9,13.6,600,0v0"}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"3.2,0.5 28.1,2.6 13.3,29.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"35.2,3.5 60.1,5.6 45.3,32.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"66,5.7 90.9,7.4 76.6,34.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"98,7.7 122.9,9.4 108.6,36.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"130.7,9.9 155.7,11.1 141.8,38.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"162.7,10.9 187.6,12.1 173.9,39.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"193.7,11.9 218.6,13.1 204.9,40.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"224.4,13.1 249.4,13.9 236.1,41.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"254.4,14.1 279.4,14.9 266.1,42.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"284,14.5 309,14.5 296.5,42.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"314.2,15.3 339.2,15.7 326.3,43.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"346,15.5 371,15.5 358.5,43.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"377,15.5 402,15.5 389.5,43.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"409,14.5 434,14.5 421.5,42.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"440.6,13.9 465.5,13.1 453.9,41.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"471.6,12.9 496.5,12.1 484.9,40.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"502.3,12.2 527.2,10.8 516.3,39.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"533,10.5 557.9,8.6 547.6,37.6 "}}," ",{"t":7,"e":"polygon","a":{"class":"flag","fill":"#FFFFFF","stroke":"none","stroke-miterlimit":"10","points":"563.4,8.1 588.2,5.1 579.2,34.5 "}}]}]}]}," ",{"t":7,"e":"div","a":{"class":"trees"},"f":[{"t":7,"e":"div","a":{"class":"tree--dark"}}," ",{"t":7,"e":"div","a":{"class":"tree"}}," ",{"t":7,"e":"div","a":{"class":"tree--dark"}}," ",{"t":7,"e":"div","a":{"class":"tree"}}," ",{"t":7,"e":"div","a":{"class":"tree--green"}}," ",{"t":7,"e":"div","a":{"class":"tree--dark"}}," ",{"t":7,"e":"div","a":{"class":"tree"}}]}," ",{"t":7,"e":"div","a":{"class":"tents"},"f":[{"t":7,"e":"div","a":{"class":"tent--pink"},"f":[{"t":7,"e":"div","a":{"class":"canvas"},"f":[{"t":7,"e":"div","a":{"class":"awning"}}," ",{"t":7,"e":"div","a":{"class":"flaps"}}]}]}," ",{"t":7,"e":"div","a":{"class":"tent--blue"},"f":[{"t":7,"e":"div","a":{"class":"canvas"},"f":[{"t":7,"e":"div","a":{"class":"awning"}}," ",{"t":7,"e":"div","a":{"class":"flaps"}}]}]}," ",{"t":7,"e":"div","a":{"class":"tent"},"f":[{"t":7,"e":"div","a":{"class":"canvas"},"f":[{"t":7,"e":"div","a":{"class":"awning"}}," ",{"t":7,"e":"div","a":{"class":"flaps"}}]}]}]}," ",{"t":4,"x":{"r":["view"],"s":"_0==\"night\""},"f":[{"t":7,"e":"div","a":{"class":"fire"},"f":[{"t":7,"e":"div","a":{"class":"logs"}}]}]}]}]}
},{}],"/Users/luke/dev/040715/source/template/partials/loader.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"info--loading"},"f":[{"t":7,"e":"div","a":{"class":"tree"}}," Loading..."]}]}
},{}],"/Users/luke/dev/040715/source/template/partials/slide-controls.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"showtime__controls"},"f":[{"t":7,"e":"a","a":{"class":"showtime__control--prev"},"t0":"fade","v":{"tap":"goPrevSlide"},"f":[{"t":7,"e":"svg","a":{"version":"1.1","xmlns":"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink","x":"0px","y":"0px","viewBox":"22 -4 55 107","enable-background":"new 22 -4 55 107","xml:space":"preserve"},"f":[{"t":7,"e":"path","a":{"fill":"none","stroke":"#000000","stroke-miterlimit":"10","d":"M72,99.3L28.5,51.8c-0.9-1-0.9-2.4,0-3.4L72,1.1"}}]}]}," ",{"t":7,"e":"a","a":{"class":"showtime__control--next"},"t0":"fade","v":{"tap":"goNextSlide"},"f":[{"t":7,"e":"svg","a":{"version":"1.1","xmlns":"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink","x":"0px","y":"0px","viewBox":"22 -4 55 107","enable-background":"new 22 -4 55 107","xml:space":"preserve"},"f":[{"t":7,"e":"path","a":{"fill":"none","stroke":"#000000","stroke-miterlimit":"10","d":"M27.8,1.1l43.6,47.4c0.9,1,0.9,2.4,0,3.4L27.8,99.3"}}]}]}]}]}
},{}],"/Users/luke/dev/040715/source/template/partials/stage-controls.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"a","a":{"class":"stage__control--prev"},"v":{"tap":"goPrevScene"},"f":[{"t":7,"e":"svg","a":{"version":"1.1","xmlns":"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink","x":"0px","y":"0px","viewBox":"0 0 70 32.1","enable-background":"new 0 0 70 32.1","xml:space":"preserve"},"f":[{"t":7,"e":"path","a":{"fill":"none","stroke":"#000000","stroke-miterlimit":"10","d":"M0.6,31.6L33.8,1.2c0.7-0.6,1.7-0.6,2.4,0l33.1,30.4"}}]}]}," ",{"t":7,"e":"a","a":{"class":"stage__control--next"},"v":{"tap":"goNextScene"},"f":[{"t":7,"e":"span","a":{"class":"control__label"},"f":[{"t":4,"x":{"r":["view"],"s":"_0==\"morning\""},"f":["What's happening?"]}," ",{"t":4,"x":{"r":["view"],"s":"_0==\"day\""},"f":["RSVP..."]}," ",{"t":4,"x":{"r":["view"],"s":"_0==\"night\""},"f":["That's all folks!"]}]}," ",{"t":7,"e":"svg","a":{"version":"1.1","xmlns":"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink","x":"0px","y":"0px","viewBox":"0 0 70 32.1","enable-background":"new 0 0 70 32.1","xml:space":"preserve"},"f":[{"t":7,"e":"path","a":{"fill":"none","stroke":"#000000","stroke-miterlimit":"10","d":"M69.3,0.7L36.1,31.2c-0.7,0.6-1.7,0.6-2.4,0L0.6,0.7"}}]}]}]}
},{}],"/Users/luke/dev/040715/source/template/partials/sun.html":[function(require,module,exports){
module.exports={"v":1,"t":[{"t":7,"e":"div","a":{"class":"sun"},"t0":"fade","f":[{"t":7,"e":"svg","a":{"version":"1.1","xmlns":"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink","x":"0px","y":"0px","viewBox":"0 0 100 100","enable-background":"new 0 0 100 100","xml:space":"preserve"},"f":[{"t":7,"e":"circle","a":{"cx":"50","cy":"49.9","r":"25","fill":"#FDB813"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"23","y1":"49.5","x2":"2","y2":"49.5"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"98","y1":"49.5","x2":"77","y2":"49.5"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"49.5","y1":"77","x2":"49.5","y2":"98"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"49.5","y1":"2","x2":"49.5","y2":"23"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"30.6","y1":"68.7","x2":"15.7","y2":"83.6"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"83.6","y1":"15.7","x2":"68.7","y2":"30.6"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"68.7","y1":"69.4","x2":"83.6","y2":"84.3"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"15.7","y1":"16.4","x2":"30.6","y2":"31.3"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"24.9","y1":"59.9","x2":"5.5","y2":"67.9"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"94.2","y1":"31.2","x2":"74.8","y2":"39.2"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"59.9","y1":"75.1","x2":"67.9","y2":"94.5"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"31.2","y1":"5.8","x2":"39.2","y2":"25.2"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"39.2","y1":"74.8","x2":"31.2","y2":"94.2"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"67.9","y1":"5.5","x2":"59.9","y2":"24.9"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"74.8","y1":"60.8","x2":"94.2","y2":"68.8"}}," ",{"t":7,"e":"line","a":{"fill":"none","stroke":"#FDB813","stroke-miterlimit":"10","x1":"5.5","y1":"32.1","x2":"24.9","y2":"40.1"}}]}]}]}
},{}],"/Users/luke/dev/040715/vendor/domready/ready.js":[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? fn() : fns.push(fn)
  }

});

},{}],"/Users/luke/dev/040715/vendor/gsap/src/uncompressed/TweenMax.js":[function(require,module,exports){
(function (global){
/*!
 * VERSION: 1.16.0
 * DATE: 2015-03-01
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	_gsScope._gsDefine("TweenMax", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

		var _slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			TweenMax = function(target, duration, vars) {
				TweenLite.call(this, target, duration, vars);
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
				this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
			_blankArray = [];

		TweenMax.version = "1.16.0";
		p.constructor = TweenMax;
		p.kill()._gc = false;
		TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
		TweenMax.getTweensOf = TweenLite.getTweensOf;
		TweenMax.lagSmoothing = TweenLite.lagSmoothing;
		TweenMax.ticker = TweenLite.ticker;
		TweenMax.render = TweenLite.render;

		p.invalidate = function() {
			this._yoyo = (this.vars.yoyo === true);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TweenLite.prototype.invalidate.call(this);
		};
		
		p.updateTo = function(vars, resetDuration) {
			var curRatio = this.ratio,
				immediate = this.vars.immediateRender || vars.immediateRender,
				p;
			if (resetDuration && this._startTime < this._timeline._time) {
				this._startTime = this._timeline._time;
				this._uncache(false);
				if (this._gc) {
					this._enabled(true, false);
				} else {
					this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			for (p in vars) {
				this.vars[p] = vars[p];
			}
			if (this._initted || immediate) {
				if (resetDuration) {
					this._initted = false;
					if (immediate) {
						this.render(0, true, true);
					}
				} else {
					if (this._gc) {
						this._enabled(true, false);
					}
					if (this._notifyPluginsOfEnabled && this._firstPT) {
						TweenLite._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks
					}
					if (this._time / this._duration > 0.998) { //if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards. 
						var prevTime = this._time;
						this.render(0, true, false);
						this._initted = false;
						this.render(prevTime, true, false);
					} else if (this._time > 0 || immediate) {
						this._initted = false;
						this._init();
						var inv = 1 / (1 - curRatio),
							pt = this._firstPT, endValue;
						while (pt) {
							endValue = pt.s + pt.c; 
							pt.c *= inv;
							pt.s = endValue - pt.c;
							pt = pt._next;
						}
					}
				}
			}
			return this;
		};
				
		p.render = function(time, suppressEvents, force) {
			if (!this._initted) if (this._duration === 0 && this.vars.repeat) { //zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
				this.invalidate();
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevTotalTime = this._totalTime, 
				prevCycle = this._cycle,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime, i;
			if (time >= totalDur) {
				this._totalTime = totalDur;
				this._cycle = this._repeat;
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = 0;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				} else {
					this._time = duration;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				}
				if (!this._reversed) {
					isComplete = true;
					callback = "onComplete";
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (time === 0 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time) {
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}
				
			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = this._cycle = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTotalTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;
				
				if (this._repeat !== 0) {
					cycleDuration = duration + this._repeatDelay;
					this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but Flash reports it as 0.79999999!)
					if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration) {
						this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
					}
					this._time = this._totalTime - (this._cycle * cycleDuration);
					if (this._yoyo) if ((this._cycle & 1) !== 0) {
						this._time = duration - this._time;
					}
					if (this._time > duration) {
						this._time = duration;
					} else if (this._time < 0) {
						this._time = 0;
					}
				}

				if (this._easeType) {
					r = this._time / duration;
					type = this._easeType;
					pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (this._time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else {
					this.ratio = this._ease.getRatio(this._time / duration);
				}
				
			}
				
			if (prevTime === this._time && !force && prevCycle === this._cycle) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
				}
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) { //we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
					this._time = prevTime;
					this._totalTime = prevTotalTime;
					this._rawPrevTime = prevRawPrevTime;
					this._cycle = prevCycle;
					TweenLiteInternals.lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) {
				this._lazy = false;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTotalTime === 0) {
				if (this._initted === 2 && time > 0) {
					//this.invalidate();
					this._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true
				}
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._totalTime !== 0 || duration === 0) if (!suppressEvents) {
					this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
				}
			}
			
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}
			
			if (this._onUpdate) {
				if (time < 0) if (this._startAt && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._totalTime !== prevTotalTime || isComplete) {
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
				}
			}
			if (this._cycle !== prevCycle) if (!suppressEvents) if (!this._gc) if (this.vars.onRepeat) {
				this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _blankArray);
			}
			if (callback) if (!this._gc || force) { //check gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};
		
//---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------
		
		TweenMax.to = function(target, duration, vars) {
			return new TweenMax(target, duration, vars);
		};
		
		TweenMax.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenMax(target, duration, vars);
		};
		
		TweenMax.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenMax(target, duration, toVars);
		};
		
		TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = vars.delay || 0,
				a = [],
				finalComplete = function() {
					if (vars.onComplete) {
						vars.onComplete.apply(vars.onCompleteScope || this, arguments);
					}
					onCompleteAll.apply(onCompleteAllScope || this, onCompleteAllParams || _blankArray);
				},
				l, copy, i, p;
			if (!_isArray(targets)) {
				if (typeof(targets) === "string") {
					targets = TweenLite.selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i <= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				copy.delay = delay;
				if (i === l && onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		};
		
		TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
		
		TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
				
		TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenMax(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, onCompleteScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, onReverseCompleteScope:scope, immediateRender:false, useFrames:useFrames, overwrite:0});
		};
		
		TweenMax.set = function(target, vars) {
			return new TweenMax(target, 0, vars);
		};
		
		TweenMax.isTweening = function(target) {
			return (TweenLite.getTweensOf(target, true).length > 0);
		};
		
		var _getChildrenOf = function(timeline, includeTimelines) {
				var a = [],
					cnt = 0,
					tween = timeline._first;
				while (tween) {
					if (tween instanceof TweenLite) {
						a[cnt++] = tween;
					} else {
						if (includeTimelines) {
							a[cnt++] = tween;
						}
						a = a.concat(_getChildrenOf(tween, includeTimelines));
						cnt = a.length;
					}
					tween = tween._next;
				}
				return a;
			}, 
			getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {
				return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat( _getChildrenOf(Animation._rootFramesTimeline, includeTimelines) );
			};
		
		TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {
			if (tweens == null) {
				tweens = true;
			}
			if (delayedCalls == null) {
				delayedCalls = true;
			}
			var a = getAllTweens((timelines != false)),
				l = a.length,
				allTrue = (tweens && delayedCalls && timelines),
				isDC, tween, i;
			for (i = 0; i < l; i++) {
				tween = a[i];
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					if (complete) {
						tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
					} else {
						tween._enabled(false, false);
					}
				}
			}
		};
		
		TweenMax.killChildTweensOf = function(parent, complete) {
			if (parent == null) {
				return;
			}
			var tl = TweenLiteInternals.tweenLookup,
				a, curParent, p, i, l;
			if (typeof(parent) === "string") {
				parent = TweenLite.selector(parent) || parent;
			}
			if (_isSelector(parent)) {
				parent = _slice(parent);
			}
			if (_isArray(parent)) {
				i = parent.length;
				while (--i > -1) {
					TweenMax.killChildTweensOf(parent[i], complete);
				}
				return;
			}
			a = [];
			for (p in tl) {
				curParent = tl[p].target.parentNode;
				while (curParent) {
					if (curParent === parent) {
						a = a.concat(tl[p].tweens);
					}
					curParent = curParent.parentNode;
				}
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				if (complete) {
					a[i].totalTime(a[i].totalDuration());
				}
				a[i]._enabled(false, false);
			}
		};

		var _changePause = function(pause, tweens, delayedCalls, timelines) {
			tweens = (tweens !== false);
			delayedCalls = (delayedCalls !== false);
			timelines = (timelines !== false);
			var a = getAllTweens(timelines),
				allTrue = (tweens && delayedCalls && timelines),
				i = a.length,
				isDC, tween;
			while (--i > -1) {
				tween = a[i];
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					tween.paused(pause);
				}
			}
		};
		
		TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {
			_changePause(true, tweens, delayedCalls, timelines);
		};
		
		TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {
			_changePause(false, tweens, delayedCalls, timelines);
		};

		TweenMax.globalTimeScale = function(value) {
			var tl = Animation._rootTimeline,
				t = TweenLite.ticker.time;
			if (!arguments.length) {
				return tl._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl = Animation._rootFramesTimeline;
			t = TweenLite.ticker.frame;
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl._timeScale = Animation._rootTimeline._timeScale = value;
			return value;
		};
		
	
//---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------
		
		p.progress = function(value) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), false);
		};
		
		p.totalProgress = function(value) {
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, false);
		};
		
		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.duration = function(value) {
			if (!arguments.length) {
				return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
			}
			return Animation.prototype.duration.call(this, value);
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					//instead of Infinity, we use 999999999999 so that we can accommodate reverses
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return (this._repeat === -1) ? this : this.duration( (value - (this._repeat * this._repeatDelay)) / (this._repeat + 1) );
		};
		
		p.repeat = function(value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};
		
		p.repeatDelay = function(value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};
		
		p.yoyo = function(value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};
		
		
		return TweenMax;
		
	}, true);








/*
 * ----------------------------------------------------------------
 * TimelineLite
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("TimelineLite", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

		var TimelineLite = function(vars) {
				SimpleTimeline.call(this, vars);
				this._labels = {};
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);
				this._sortChildren = true;
				this._onUpdate = this.vars.onUpdate;
				var v = this.vars,
					val, p;
				for (p in v) {
					val = v[p];
					if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
						v[p] = this._swapSelfInParams(val);
					}
				}
				if (_isArray(v.tweens)) {
					this.add(v.tweens, 0, v.align, v.stagger);
				}
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_internals = TimelineLite._internals = {},
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_blankArray = [],
			_globals = _gsScope._gsDefine.globals,
			_copy = function(vars) {
				var copy = {}, p;
				for (p in vars) {
					copy[p] = vars[p];
				}
				return copy;
			},
			_pauseCallback = _internals.pauseCallback = function(tween, callback, params, scope) {
				var tl = tween._timeline,
					time = tl._totalTime,
					startTime = tween._startTime,
					next = tween.ratio ? _tinyNum : 0,
					prev = tween.ratio ? 0 : _tinyNum,
					sibling;
				if (callback || !this._forcingPlayhead) { //if the user calls a method that moves the playhead (like progress() or time()), it should honor that and skip any pauses (although if there's a callback positioned at that pause, it must jump there and make the call to ensure the time is EXACTLY what it is supposed to be, and then proceed to where the playhead is being forced). Otherwise, imagine placing a pause in the middle of a timeline and then doing timeline.progress(0.9) - it would get stuck where the pause is.
					tl.pause(startTime);
					//now find sibling tweens that are EXACTLY at the same spot on the timeline and adjust the _rawPrevTime so that they fire (or don't fire) correctly on the next render. This is primarily to accommodate zero-duration tweens/callbacks that are positioned right on top of a pause. For example, tl.to(...).call(...).addPause(...).call(...) - notice that there's a call() on each side of the pause, so when it's running forward it should call the first one and then pause, and then when resumed, call the other. Zero-duration tweens use _rawPrevTime to sense momentum figure out if events were suppressed when arriving directly on top of that time.
					sibling = tween._prev;
					while (sibling && sibling._startTime === startTime) {
						sibling._rawPrevTime = prev;
						sibling = sibling._prev;
					}
					sibling = tween._next;
					while (sibling && sibling._startTime === startTime) {
						sibling._rawPrevTime = next;
						sibling = sibling._next;
					}
					if (callback) {
						callback.apply(scope || tl, params || _blankArray);
					}
					if (this._forcingPlayhead) {
						tl.seek(time);
					}
				}
			},
			_slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			p = TimelineLite.prototype = new SimpleTimeline();

		TimelineLite.version = "1.16.0";
		p.constructor = TimelineLite;
		p.kill()._gc = p._forcingPlayhead = false;

		/* might use later...
		//translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
		function localToGlobal(time, animation) {
			while (animation) {
				time = (time / animation._timeScale) + animation._startTime;
				animation = animation.timeline;
			}
			return time;
		}

		//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
		function globalToLocal(time, animation) {
			var scale = 1;
			time -= localToGlobal(0, animation);
			while (animation) {
				scale *= animation._timeScale;
				animation = animation.timeline;
			}
			return time * scale;
		}
		*/

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat && _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};

		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, onCompleteScope:onCompleteAllScope, smoothChildTiming:this.smoothChildTiming}),
				i;
			if (typeof(targets) === "string") {
				targets = TweenLite.selector(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) { //senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			for (i = 0; i < targets.length; i++) {
				if (vars.startAt) {
					vars.startAt = _copy(vars.startAt);
				}
				tl.to(targets[i], duration, _copy(vars), i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function(callback, params, scope, position) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.set = function(target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = (position === this._time && !this._paused);
			}
			return this.add( new TweenLite(target, 0, vars), position);
		};

		TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
			vars = vars || {};
			if (vars.smoothChildTiming == null) {
				vars.smoothChildTiming = true;
			}
			var tl = new TimelineLite(vars),
				root = tl._timeline,
				tween, next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root._remove(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
					tl.add(tween, tween._startTime - tween._delay);
				}
				tween = next;
			}
			root.add(tl, 0);
			return tl;
		};

		p.add = function(value, position, align, stagger) {
			var curTime, l, i, child, tl, beforeRawTime;
			if (typeof(position) !== "number") {
				position = this._parseTimeOrLabel(position, 0, true, value);
			}
			if (!(value instanceof Animation)) {
				if ((value instanceof Array) || (value && value.push && _isArray(value))) {
					align = align || "normal";
					stagger = stagger || 0;
					curTime = position;
					l = value.length;
					for (i = 0; i < l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({tweens:child});
						}
						this.add(child, curTime);
						if (typeof(child) !== "string" && typeof(child) !== "function") {
							if (align === "sequence") {
								curTime = child._startTime + (child.totalDuration() / child._timeScale);
							} else if (align === "start") {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof(value) === "string") {
					return this.addLabel(value, position);
				} else if (typeof(value) === "function") {
					value = TweenLite.delayedCall(0, value);
				} else {
					throw("Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.");
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() > value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime && tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		};

		p.remove = function(value) {
			if (value instanceof Animation) {
				return this._remove(value, false);
			} else if (value instanceof Array || (value && value.push && _isArray(value))) {
				var i = value.length;
				while (--i > -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof(value) === "string") {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		};

		p._remove = function(tween, skipDisable) {
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
			if (!last) {
				this._time = this._totalTime = this._duration = this._totalDuration = 0;
			} else if (this._time > last._startTime + last._totalDuration / last._timeScale) {
				this._time = this.duration();
				this._totalTime = this._totalDuration;
			}
			return this;
		};

		p.append = function(value, offsetOrLabel) {
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
		};

		p.insert = p.insertMultiple = function(value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		};

		p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
		};

		p.addLabel = function(label, position) {
			this._labels[label] = this._parseTimeOrLabel(position);
			return this;
		};

		p.addPause = function(position, callback, params, scope) {
			var t = TweenLite.delayedCall(0, _pauseCallback, ["{self}", callback, params, scope], this);
			t.data = "isPause"; // we use this flag in TweenLite's render() method to identify it as a special case that shouldn't be triggered when the virtual playhead is LEAVING the exact position where the pause is, otherwise timeline.addPause(1).play(1) would end up paused on the very next tick.
			return this.add(t, position);
		};

		p.removeLabel = function(label) {
			delete this._labels[label];
			return this;
		};

		p.getLabelTime = function(label) {
			return (this._labels[label] != null) ? this._labels[label] : -1;
		};

		p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
			var i;
			//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
			if (ignore instanceof Animation && ignore.timeline === this) {
				this.remove(ignore);
			} else if (ignore && ((ignore instanceof Array) || (ignore.push && _isArray(ignore)))) {
				i = ignore.length;
				while (--i > -1) {
					if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
						this.remove(ignore[i]);
					}
				}
			}
			if (typeof(offsetOrLabel) === "string") {
				return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && this._labels[offsetOrLabel] == null) ? timeOrLabel - this.duration() : 0, appendIfAbsent);
			}
			offsetOrLabel = offsetOrLabel || 0;
			if (typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) { //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf("=");
				if (i === -1) {
					if (this._labels[timeOrLabel] == null) {
						return appendIfAbsent ? (this._labels[timeOrLabel] = this.duration() + offsetOrLabel) : offsetOrLabel;
					}
					return this._labels[timeOrLabel] + offsetOrLabel;
				}
				offsetOrLabel = parseInt(timeOrLabel.charAt(i-1) + "1", 10) * Number(timeOrLabel.substr(i+1));
				timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i-1), 0, appendIfAbsent) : this.duration();
			} else if (timeOrLabel == null) {
				timeOrLabel = this.duration();
			}
			return Number(timeOrLabel) + offsetOrLabel;
		};

		p.seek = function(position, suppressEvents) {
			return this.totalTime((typeof(position) === "number") ? position : this._parseTimeOrLabel(position), (suppressEvents !== false));
		};

		p.stop = function() {
			return this.paused(true);
		};

		p.gotoAndPlay = function(position, suppressEvents) {
			return this.play(position, suppressEvents);
		};

		p.gotoAndStop = function(position, suppressEvents) {
			return this.pause(position, suppressEvents);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevPaused = this._paused,
				tween, isComplete, next, callback, internalForce;
			if (time >= totalDur) {
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					if (this._duration === 0) if (time === 0 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
						internalForce = true;
						if (this._rawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || (time < 0 && this._rawPrevTime >= 0)))) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) { //ensures proper GC if a timeline is resumed after it's finished reversing.
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (this._rawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {
				this._totalTime = this._time = this._rawPrevTime = time;
			}
			if ((this._time === prevTime || !this._first) && !force && !internalForce) {
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0) if (!suppressEvents) {
				this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
			}

			if (this._time >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
			}

			if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
			}
		};

		p._hasPausedChild = function() {
			var tween = this._first;
			while (tween) {
				if (tween._paused || ((tween instanceof TimelineLite) && tween._hasPausedChild())) {
					return true;
				}
				tween = tween._next;
			}
			return false;
		};

		p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;
			var a = [],
				tween = this._first,
				cnt = 0;
			while (tween) {
				if (tween._startTime < ignoreBeforeTime) {
					//do nothing
				} else if (tween instanceof TweenLite) {
					if (tweens !== false) {
						a[cnt++] = tween;
					}
				} else {
					if (timelines !== false) {
						a[cnt++] = tween;
					}
					if (nested !== false) {
						a = a.concat(tween.getChildren(true, tweens, timelines));
						cnt = a.length;
					}
				}
				tween = tween._next;
			}
			return a;
		};

		p.getTweensOf = function(target, nested) {
			var disabled = this._gc,
				a = [],
				cnt = 0,
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.getTweensOf(target);
			i = tweens.length;
			while (--i > -1) {
				if (tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
		};

		p.recent = function() {
			return this._recent;
		};

		p._contains = function(tween) {
			var tl = tween.timeline;
			while (tl) {
				if (tl === this) {
					return true;
				}
				tl = tl.timeline;
			}
			return false;
		};

		p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || 0;
			var tween = this._first,
				labels = this._labels,
				p;
			while (tween) {
				if (tween._startTime >= ignoreBeforeTime) {
					tween._startTime += amount;
				}
				tween = tween._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] >= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return this._uncache(true);
		};

		p._kill = function(vars, target) {
			if (!vars && !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i > -1) {
				if (tweens[i]._kill(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
			var tweens = this.getChildren(false, true, true),
				i = tweens.length;
			this._time = this._totalTime = 0;
			while (--i > -1) {
				tweens[i]._enabled(false, false);
			}
			if (labels !== false) {
				this._labels = {};
			}
			return this._uncache(true);
		};

		p.invalidate = function() {
			var tween = this._first;
			while (tween) {
				tween.invalidate();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (enabled === this._gc) {
				var tween = this._first;
				while (tween) {
					tween._enabled(enabled, true);
					tween = tween._next;
				}
			}
			return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			this._forcingPlayhead = true;
			var val = Animation.prototype.totalTime.apply(this, arguments);
			this._forcingPlayhead = false;
			return val;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					this.totalDuration(); //just triggers recalculation
				}
				return this._duration;
			}
			if (this.duration() !== 0 && value !== 0) {
				this.timeScale(this._duration / value);
			}
			return this;
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					var max = 0,
						tween = this._last,
						prevStart = 999999999999,
						prev, end;
					while (tween) {
						prev = tween._prev; //record it here in case the tween changes position in the sequence...
						if (tween._dirty) {
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
						}
						if (tween._startTime > prevStart && this._sortChildren && !tween._paused) { //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
							this.add(tween, tween._startTime - tween._delay);
						} else {
							prevStart = tween._startTime;
						}
						if (tween._startTime < 0 && !tween._paused) { //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
							}
							this.shiftChildren(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + (tween._totalDuration / tween._timeScale);
						if (end > max) {
							max = end;
						}
						tween = prev;
					}
					this._duration = this._totalDuration = max;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			if (this.totalDuration() !== 0) if (value !== 0) {
				this.timeScale(this._totalDuration / value);
			}
			return this;
		};

		p.paused = function(value) {
			if (!value) { //if there's a pause directly at the spot from where we're unpausing, skip it.
				var tween = this._first,
					time = this._time;
				while (tween) {
					if (tween._startTime === time && tween.data === "isPause") {
						tween._rawPrevTime = time; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
					}
					tween = tween._next;
				}
			}
			return Animation.prototype.paused.apply(this, arguments);
		};

		p.usesFrames = function() {
			var tl = this._timeline;
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return (tl === Animation._rootFramesTimeline);
		};

		p.rawTime = function() {
			return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
		};

		return TimelineLite;

	}, true);
	







	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * TimelineMax
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("TimelineMax", ["TimelineLite","TweenLite","easing.Ease"], function(TimelineLite, TweenLite, Ease) {

		var TimelineMax = function(vars) {
				TimelineLite.call(this, vars);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._dirty = true;
			},
			_tinyNum = 0.0000000001,
			_blankArray = [],
			TweenLiteInternals = TweenLite._internals,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_easeNone = new Ease(null, null, 1, 0),
			p = TimelineMax.prototype = new TimelineLite();

		p.constructor = TimelineMax;
		p.kill()._gc = false;
		TimelineMax.version = "1.16.0";

		p.invalidate = function() {
			this._yoyo = (this.vars.yoyo === true);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TimelineLite.prototype.invalidate.call(this);
		};

		p.addCallback = function(callback, position, params, scope) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.removeCallback = function(callback, position) {
			if (callback) {
				if (position == null) {
					this._kill(null, callback);
				} else {
					var a = this.getTweensOf(callback, false),
						i = a.length,
						time = this._parseTimeOrLabel(position);
					while (--i > -1) {
						if (a[i]._startTime === time) {
							a[i]._enabled(false, false);
						}
					}
				}
			}
			return this;
		};

		p.removePause = function(position) {
			return this.removeCallback(TimelineLite._internals.pauseCallback, position);
		};

		p.tweenTo = function(position, vars) {
			vars = vars || {};
			var copy = {ease:_easeNone, useFrames:this.usesFrames(), immediateRender:false},
				duration, p, t;
			for (p in vars) {
				copy[p] = vars[p];
			}
			copy.time = this._parseTimeOrLabel(position);
			duration = (Math.abs(Number(copy.time) - this._time) / this._timeScale) || 0.001;
			t = new TweenLite(this, duration, copy);
			copy.onStart = function() {
				t.target.paused(true);
				if (t.vars.time !== t.target.time() && duration === t.duration()) { //don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
					t.duration( Math.abs( t.vars.time - t.target.time()) / t.target._timeScale );
				}
				if (vars.onStart) { //in case the user had an onStart in the vars - we don't want to overwrite it.
					vars.onStart.apply(vars.onStartScope || t, vars.onStartParams || _blankArray);
				}
			};
			return t;
		};

		p.tweenFromTo = function(fromPosition, toPosition, vars) {
			vars = vars || {};
			fromPosition = this._parseTimeOrLabel(fromPosition);
			vars.startAt = {onComplete:this.seek, onCompleteParams:[fromPosition], onCompleteScope:this};
			vars.immediateRender = (vars.immediateRender !== false);
			var t = this.tweenTo(toPosition, vars);
			return t.duration((Math.abs( t.vars.time - fromPosition) / this._timeScale) || 0.001);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				dur = this._duration,
				prevTime = this._time,
				prevTotalTime = this._totalTime,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevRawPrevTime = this._rawPrevTime,
				prevPaused = this._paused,
				prevCycle = this._cycle,
				tween, isComplete, next, callback, internalForce, cycleDuration;
			if (time >= totalDur) {
				if (!this._locked) {
					this._totalTime = totalDur;
					this._cycle = this._repeat;
				}
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					if (this._duration === 0) if (time === 0 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && this._first) {
						internalForce = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = time = 0;
				} else {
					this._time = dur;
					time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				if (!this._locked) {
					this._totalTime = this._cycle = 0;
				}
				this._time = 0;
				if (prevTime !== 0 || (dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || (time < 0 && prevRawPrevTime >= 0)) && !this._locked)) { //edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) {
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (prevRawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (dur || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {
				if (dur === 0 && prevRawPrevTime < 0) { //without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
					internalForce = true;
				}
				this._time = this._rawPrevTime = time;
				if (!this._locked) {
					this._totalTime = time;
					if (this._repeat !== 0) {
						cycleDuration = dur + this._repeatDelay;
						this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
						if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration) {
							this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
						}
						this._time = this._totalTime - (this._cycle * cycleDuration);
						if (this._yoyo) if ((this._cycle & 1) !== 0) {
							this._time = dur - this._time;
						}
						if (this._time > dur) {
							this._time = dur;
							time = dur + 0.0001; //to avoid occasional floating point rounding error
						} else if (this._time < 0) {
							this._time = time = 0;
						} else {
							time = this._time;
						}
					}
				}
			}

			if (this._cycle !== prevCycle) if (!this._locked) {
				/*
				make sure children at the end/beginning of the timeline are rendered properly. If, for example,
				a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
				would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
				could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
				we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
				ensure that zero-duration tweens at the very beginning or end of the TimelineMax work.
				*/
				var backwards = (this._yoyo && (prevCycle & 1) !== 0),
					wrap = (backwards === (this._yoyo && (this._cycle & 1) !== 0)),
					recTotalTime = this._totalTime,
					recCycle = this._cycle,
					recRawPrevTime = this._rawPrevTime,
					recTime = this._time;

				this._totalTime = prevCycle * dur;
				if (this._cycle < prevCycle) {
					backwards = !backwards;
				} else {
					this._totalTime += dur;
				}
				this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.

				this._rawPrevTime = (dur === 0) ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
				this._cycle = prevCycle;
				this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
				prevTime = (backwards) ? 0 : dur;
				this.render(prevTime, suppressEvents, (dur === 0));
				if (!suppressEvents) if (!this._gc) {
					if (this.vars.onRepeat) {
						this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _blankArray);
					}
				}
				if (wrap) {
					prevTime = (backwards) ? dur + 0.0001 : -0.0001;
					this.render(prevTime, true, false);
				}
				this._locked = false;
				if (this._paused && !prevPaused) { //if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
					return;
				}
				this._time = recTime;
				this._totalTime = recTotalTime;
				this._cycle = recCycle;
				this._rawPrevTime = recRawPrevTime;
			}

			if ((this._time === prevTime || !this._first) && !force && !internalForce) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
				}
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTotalTime === 0) if (this.vars.onStart) if (this._totalTime !== 0) if (!suppressEvents) {
				this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
			}

			if (this._time >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}

					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
			}
			if (callback) if (!this._locked) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
			}
		};

		p.getActive = function(nested, tweens, timelines) {
			if (nested == null) {
				nested = true;
			}
			if (tweens == null) {
				tweens = true;
			}
			if (timelines == null) {
				timelines = false;
			}
			var a = [],
				all = this.getChildren(nested, tweens, timelines),
				cnt = 0,
				l = all.length,
				i, tween;
			for (i = 0; i < l; i++) {
				tween = all[i];
				if (tween.isActive()) {
					a[cnt++] = tween;
				}
			}
			return a;
		};


		p.getLabelAfter = function(time) {
			if (!time) if (time !== 0) { //faster than isNan()
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				l = labels.length,
				i;
			for (i = 0; i < l; i++) {
				if (labels[i].time > time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelBefore = function(time) {
			if (time == null) {
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				i = labels.length;
			while (--i > -1) {
				if (labels[i].time < time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelsArray = function() {
			var a = [],
				cnt = 0,
				p;
			for (p in this._labels) {
				a[cnt++] = {time:this._labels[p], name:p};
			}
			a.sort(function(a,b) {
				return a.time - b.time;
			});
			return a;
		};


//---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------

		p.progress = function(value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
		};

		p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, suppressEvents);
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					TimelineLite.prototype.totalDuration.call(this); //just forces refresh
					//Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
				}
				return this._totalDuration;
			}
			return (this._repeat === -1) ? this : this.duration( (value - (this._repeat * this._repeatDelay)) / (this._repeat + 1) );
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.repeat = function(value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function(value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function(value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};

		p.currentLabel = function(value) {
			if (!arguments.length) {
				return this.getLabelBefore(this._time + 0.00000001);
			}
			return this.seek(value, true);
		};

		return TimelineMax;

	}, true);
	




	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * BezierPlugin
 * ----------------------------------------------------------------
 */
	(function() {

		var _RAD2DEG = 180 / Math.PI,
			_r1 = [],
			_r2 = [],
			_r3 = [],
			_corProps = {},
			_globals = _gsScope._gsDefine.globals,
			Segment = function(a, b, c, d) {
				this.a = a;
				this.b = b;
				this.c = c;
				this.d = d;
				this.da = d - a;
				this.ca = c - a;
				this.ba = b - a;
			},
			_correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
			cubicToQuadratic = function(a, b, c, d) {
				var q1 = {a:a},
					q2 = {},
					q3 = {},
					q4 = {c:d},
					mab = (a + b) / 2,
					mbc = (b + c) / 2,
					mcd = (c + d) / 2,
					mabc = (mab + mbc) / 2,
					mbcd = (mbc + mcd) / 2,
					m8 = (mbcd - mabc) / 8;
				q1.b = mab + (a - mab) / 4;
				q2.b = mabc + m8;
				q1.c = q2.a = (q1.b + q2.b) / 2;
				q2.c = q3.a = (mabc + mbcd) / 2;
				q3.b = mbcd - m8;
				q4.b = mcd + (d - mcd) / 4;
				q3.c = q4.a = (q3.b + q4.b) / 2;
				return [q1, q2, q3, q4];
			},
			_calculateControlPoints = function(a, curviness, quad, basic, correlate) {
				var l = a.length - 1,
					ii = 0,
					cp1 = a[0].a,
					i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;
				for (i = 0; i < l; i++) {
					seg = a[ii];
					p1 = seg.a;
					p2 = seg.d;
					p3 = a[ii+1].d;

					if (correlate) {
						r1 = _r1[i];
						r2 = _r2[i];
						tl = ((r2 + r1) * curviness * 0.25) / (basic ? 0.5 : _r3[i] || 0.5);
						m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : (r1 !== 0 ? tl / r1 : 0));
						m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : (r2 !== 0 ? tl / r2 : 0));
						mm = p2 - (m1 + (((m2 - m1) * ((r1 * 3 / (r1 + r2)) + 0.5) / 4) || 0));
					} else {
						m1 = p2 - (p2 - p1) * curviness * 0.5;
						m2 = p2 + (p3 - p2) * curviness * 0.5;
						mm = p2 - (m1 + m2) / 2;
					}
					m1 += mm;
					m2 += mm;

					seg.c = cp2 = m1;
					if (i !== 0) {
						seg.b = cp1;
					} else {
						seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
					}

					seg.da = p2 - p1;
					seg.ca = cp2 - p1;
					seg.ba = cp1 - p1;

					if (quad) {
						qb = cubicToQuadratic(p1, cp1, cp2, p2);
						a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
						ii += 4;
					} else {
						ii++;
					}

					cp1 = m2;
				}
				seg = a[ii];
				seg.b = cp1;
				seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
				seg.da = seg.d - seg.a;
				seg.ca = seg.c - seg.a;
				seg.ba = cp1 - seg.a;
				if (quad) {
					qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
					a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
				}
			},
			_parseAnchors = function(values, p, correlate, prepend) {
				var a = [],
					l, i, p1, p2, p3, tmp;
				if (prepend) {
					values = [prepend].concat(values);
					i = values.length;
					while (--i > -1) {
						if (typeof( (tmp = values[i][p]) ) === "string") if (tmp.charAt(1) === "=") {
							values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
						}
					}
				}
				l = values.length - 2;
				if (l < 0) {
					a[0] = new Segment(values[0][p], 0, 0, values[(l < -1) ? 0 : 1][p]);
					return a;
				}
				for (i = 0; i < l; i++) {
					p1 = values[i][p];
					p2 = values[i+1][p];
					a[i] = new Segment(p1, 0, 0, p2);
					if (correlate) {
						p3 = values[i+2][p];
						_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
						_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
					}
				}
				a[i] = new Segment(values[i][p], 0, 0, values[i+1][p]);
				return a;
			},
			bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
				var obj = {},
					props = [],
					first = prepend || values[0],
					i, p, a, j, r, l, seamless, last;
				correlate = (typeof(correlate) === "string") ? ","+correlate+"," : _correlate;
				if (curviness == null) {
					curviness = 1;
				}
				for (p in values[0]) {
					props.push(p);
				}
				//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
				if (values.length > 1) {
					last = values[values.length - 1];
					seamless = true;
					i = props.length;
					while (--i > -1) {
						p = props[i];
						if (Math.abs(first[p] - last[p]) > 0.05) { //build in a tolerance of +/-0.05 to accommodate rounding errors. For example, if you set an object's position to 4.945, Flash will make it 4.9
							seamless = false;
							break;
						}
					}
					if (seamless) {
						values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
						if (prepend) {
							values.unshift(prepend);
						}
						values.push(values[1]);
						prepend = values[values.length - 3];
					}
				}
				_r1.length = _r2.length = _r3.length = 0;
				i = props.length;
				while (--i > -1) {
					p = props[i];
					_corProps[p] = (correlate.indexOf(","+p+",") !== -1);
					obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
				}
				i = _r1.length;
				while (--i > -1) {
					_r1[i] = Math.sqrt(_r1[i]);
					_r2[i] = Math.sqrt(_r2[i]);
				}
				if (!basic) {
					i = props.length;
					while (--i > -1) {
						if (_corProps[p]) {
							a = obj[props[i]];
							l = a.length - 1;
							for (j = 0; j < l; j++) {
								r = a[j+1].da / _r2[j] + a[j].da / _r1[j];
								_r3[j] = (_r3[j] || 0) + r * r;
							}
						}
					}
					i = _r3.length;
					while (--i > -1) {
						_r3[i] = Math.sqrt(_r3[i]);
					}
				}
				i = props.length;
				j = quadratic ? 4 : 1;
				while (--i > -1) {
					p = props[i];
					a = obj[p];
					_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
					if (seamless) {
						a.splice(0, j);
						a.splice(a.length - j, j);
					}
				}
				return obj;
			},
			_parseBezierData = function(values, type, prepend) {
				type = type || "soft";
				var obj = {},
					inc = (type === "cubic") ? 3 : 2,
					soft = (type === "soft"),
					props = [],
					a, b, c, d, cur, i, j, l, p, cnt, tmp;
				if (soft && prepend) {
					values = [prepend].concat(values);
				}
				if (values == null || values.length < inc + 1) { throw "invalid Bezier data"; }
				for (p in values[0]) {
					props.push(p);
				}
				i = props.length;
				while (--i > -1) {
					p = props[i];
					obj[p] = cur = [];
					cnt = 0;
					l = values.length;
					for (j = 0; j < l; j++) {
						a = (prepend == null) ? values[j][p] : (typeof( (tmp = values[j][p]) ) === "string" && tmp.charAt(1) === "=") ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
						if (soft) if (j > 1) if (j < l - 1) {
							cur[cnt++] = (a + cur[cnt-2]) / 2;
						}
						cur[cnt++] = a;
					}
					l = cnt - inc + 1;
					cnt = 0;
					for (j = 0; j < l; j += inc) {
						a = cur[j];
						b = cur[j+1];
						c = cur[j+2];
						d = (inc === 2) ? 0 : cur[j+3];
						cur[cnt++] = tmp = (inc === 3) ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
					}
					cur.length = cnt;
				}
				return obj;
			},
			_addCubicLengths = function(a, steps, resolution) {
				var inc = 1 / resolution,
					j = a.length,
					d, d1, s, da, ca, ba, p, i, inv, bez, index;
				while (--j > -1) {
					bez = a[j];
					s = bez.a;
					da = bez.d - s;
					ca = bez.c - s;
					ba = bez.b - s;
					d = d1 = 0;
					for (i = 1; i <= resolution; i++) {
						p = inc * i;
						inv = 1 - p;
						d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
						index = j * resolution + i - 1;
						steps[index] = (steps[index] || 0) + d * d;
					}
				}
			},
			_parseLengthData = function(obj, resolution) {
				resolution = resolution >> 0 || 6;
				var a = [],
					lengths = [],
					d = 0,
					total = 0,
					threshold = resolution - 1,
					segments = [],
					curLS = [], //current length segments array
					p, i, l, index;
				for (p in obj) {
					_addCubicLengths(obj[p], a, resolution);
				}
				l = a.length;
				for (i = 0; i < l; i++) {
					d += Math.sqrt(a[i]);
					index = i % resolution;
					curLS[index] = d;
					if (index === threshold) {
						total += d;
						index = (i / resolution) >> 0;
						segments[index] = curLS;
						lengths[index] = total;
						d = 0;
						curLS = [];
					}
				}
				return {length:total, lengths:lengths, segments:segments};
			},



			BezierPlugin = _gsScope._gsDefine.plugin({
					propName: "bezier",
					priority: -1,
					version: "1.3.4",
					API: 2,
					global:true,

					//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
					init: function(target, vars, tween) {
						this._target = target;
						if (vars instanceof Array) {
							vars = {values:vars};
						}
						this._func = {};
						this._round = {};
						this._props = [];
						this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);
						var values = vars.values || [],
							first = {},
							second = values[0],
							autoRotate = vars.autoRotate || tween.vars.orientToBezier,
							p, isFunc, i, j, prepend;

						this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [["x","y","rotation",((autoRotate === true) ? 0 : Number(autoRotate) || 0)]] : null;
						for (p in second) {
							this._props.push(p);
						}

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];

							this._overwriteProps.push(p);
							isFunc = this._func[p] = (typeof(target[p]) === "function");
							first[p] = (!isFunc) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
							if (!prepend) if (first[p] !== values[0][p]) {
								prepend = first;
							}
						}
						this._beziers = (vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft") ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, (vars.type === "thruBasic"), vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
						this._segCount = this._beziers[p].length;

						if (this._timeRes) {
							var ld = _parseLengthData(this._beziers, this._timeRes);
							this._length = ld.length;
							this._lengths = ld.lengths;
							this._segments = ld.segments;
							this._l1 = this._li = this._s1 = this._si = 0;
							this._l2 = this._lengths[0];
							this._curSeg = this._segments[0];
							this._s2 = this._curSeg[0];
							this._prec = 1 / this._curSeg.length;
						}

						if ((autoRotate = this._autoRotate)) {
							this._initialRotations = [];
							if (!(autoRotate[0] instanceof Array)) {
								this._autoRotate = autoRotate = [autoRotate];
							}
							i = autoRotate.length;
							while (--i > -1) {
								for (j = 0; j < 3; j++) {
									p = autoRotate[i][j];
									this._func[p] = (typeof(target[p]) === "function") ? target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ] : false;
								}
								p = autoRotate[i][2];
								this._initialRotations[i] = this._func[p] ? this._func[p].call(this._target) : this._target[p];
							}
						}
						this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
						return true;
					},

					//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
					set: function(v) {
						var segments = this._segCount,
							func = this._func,
							target = this._target,
							notStart = (v !== this._startRatio),
							curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
						if (!this._timeRes) {
							curIndex = (v < 0) ? 0 : (v >= 1) ? segments - 1 : (segments * v) >> 0;
							t = (v - (curIndex * (1 / segments))) * segments;
						} else {
							lengths = this._lengths;
							curSeg = this._curSeg;
							v *= this._length;
							i = this._li;
							//find the appropriate segment (if the currently cached one isn't correct)
							if (v > this._l2 && i < segments - 1) {
								l = segments - 1;
								while (i < l && (this._l2 = lengths[++i]) <= v) {	}
								this._l1 = lengths[i-1];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s2 = curSeg[(this._s1 = this._si = 0)];
							} else if (v < this._l1 && i > 0) {
								while (i > 0 && (this._l1 = lengths[--i]) >= v) { }
								if (i === 0 && v < this._l1) {
									this._l1 = 0;
								} else {
									i++;
								}
								this._l2 = lengths[i];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
								this._s2 = curSeg[this._si];
							}
							curIndex = i;
							//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
							v -= this._l1;
							i = this._si;
							if (v > this._s2 && i < curSeg.length - 1) {
								l = curSeg.length - 1;
								while (i < l && (this._s2 = curSeg[++i]) <= v) {	}
								this._s1 = curSeg[i-1];
								this._si = i;
							} else if (v < this._s1 && i > 0) {
								while (i > 0 && (this._s1 = curSeg[--i]) >= v) {	}
								if (i === 0 && v < this._s1) {
									this._s1 = 0;
								} else {
									i++;
								}
								this._s2 = curSeg[i];
								this._si = i;
							}
							t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec;
						}
						inv = 1 - t;

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];
							b = this._beziers[p][curIndex];
							val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
							if (this._round[p]) {
								val = Math.round(val);
							}
							if (func[p]) {
								target[p](val);
							} else {
								target[p] = val;
							}
						}

						if (this._autoRotate) {
							var ar = this._autoRotate,
								b2, x1, y1, x2, y2, add, conv;
							i = ar.length;
							while (--i > -1) {
								p = ar[i][2];
								add = ar[i][3] || 0;
								conv = (ar[i][4] === true) ? 1 : _RAD2DEG;
								b = this._beziers[ar[i][0]];
								b2 = this._beziers[ar[i][1]];

								if (b && b2) { //in case one of the properties got overwritten.
									b = b[curIndex];
									b2 = b2[curIndex];

									x1 = b.a + (b.b - b.a) * t;
									x2 = b.b + (b.c - b.b) * t;
									x1 += (x2 - x1) * t;
									x2 += ((b.c + (b.d - b.c) * t) - x2) * t;

									y1 = b2.a + (b2.b - b2.a) * t;
									y2 = b2.b + (b2.c - b2.b) * t;
									y1 += (y2 - y1) * t;
									y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;

									val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

									if (func[p]) {
										target[p](val);
									} else {
										target[p] = val;
									}
								}
							}
						}
					}
			}),
			p = BezierPlugin.prototype;


		BezierPlugin.bezierThrough = bezierThrough;
		BezierPlugin.cubicToQuadratic = cubicToQuadratic;
		BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		BezierPlugin.quadraticToCubic = function(a, b, c) {
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
		};

		BezierPlugin._cssRegister = function() {
			var CSSPlugin = _globals.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
				_parseToProxy = _internals._parseToProxy,
				_setPluginRatio = _internals._setPluginRatio,
				CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp("bezier", {parser:function(t, e, prop, cssp, pt, plugin) {
				if (e instanceof Array) {
					e = {values:e};
				}
				plugin = new BezierPlugin();
				var values = e.values,
					l = values.length - 1,
					pluginValues = [],
					v = {},
					i, p, data;
				if (l < 0) {
					return pt;
				}
				for (i = 0; i <= l; i++) {
					data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));
					pluginValues[i] = data.end;
				}
				for (p in e) {
					v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
				}
				v.values = pluginValues;
				pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
				pt.data = data;
				pt.plugin = plugin;
				pt.setRatio = _setPluginRatio;
				if (v.autoRotate === 0) {
					v.autoRotate = true;
				}
				if (v.autoRotate && !(v.autoRotate instanceof Array)) {
					i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);
					v.autoRotate = (data.end.left != null) ? [["left","top","rotation",i,false]] : (data.end.x != null) ? [["x","y","rotation",i,false]] : false;
				}
				if (v.autoRotate) {
					if (!cssp._transform) {
						cssp._enableTransforms(false);
					}
					data.autoRotate = cssp._target._gsTransform;
				}
				plugin._onInitTween(data.proxy, v, cssp._tween);
				return pt;
			}});
		};

		p._roundProps = function(lookup, value) {
			var op = this._overwriteProps,
				i = op.length;
			while (--i > -1) {
				if (lookup[op[i]] || lookup.bezier || lookup.bezierThrough) {
					this._round[op[i]] = value;
				}
			}
		};

		p._kill = function(lookup) {
			var a = this._props,
				p, i;
			for (p in this._beziers) {
				if (p in lookup) {
					delete this._beziers[p];
					delete this._func[p];
					i = a.length;
					while (--i > -1) {
						if (a[i] === p) {
							a.splice(i, 1);
						}
					}
				}
			}
			return this._super._kill.call(this, lookup);
		};

	}());






	
	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * CSSPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin","TweenLite"], function(TweenPlugin, TweenLite) {

		/** @constructor **/
		var CSSPlugin = function() {
				TweenPlugin.call(this, "css");
				this._overwriteProps.length = 0;
				this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
			},
			_globals = _gsScope._gsDefine.globals,
			_hasPriority, //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
			_suffixMap, //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
			_cs, //computed style (we store this in a shared variable to conserve memory and make minification tighter
			_overwriteProps, //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
			_specialProps = {},
			p = CSSPlugin.prototype = new TweenPlugin("css");

		p.constructor = CSSPlugin;
		CSSPlugin.version = "1.16.0";
		CSSPlugin.API = 2;
		CSSPlugin.defaultTransformPerspective = 0;
		CSSPlugin.defaultSkewType = "compensated";
		p = "px"; //we'll reuse the "p" variable to keep file size down
		CSSPlugin.suffixMap = {top:p, right:p, bottom:p, left:p, width:p, height:p, fontSize:p, padding:p, margin:p, perspective:p, lineHeight:""};


		var _numExp = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
			_relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
			_valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
			_NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
			_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
			_opacityExp = /opacity *= *([^)]*)/i,
			_opacityValExp = /opacity:([^;]*)/i,
			_alphaFilterExp = /alpha\(opacity *=.+?\)/i,
			_rgbhslExp = /^(rgb|hsl)/,
			_capsExp = /([A-Z])/g,
			_camelExp = /-([a-z])/gi,
			_urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
			_camelFunc = function(s, g) { return g.toUpperCase(); },
			_horizExp = /(?:Left|Right|Width)/i,
			_ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
			_ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
			_commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi, //finds any commas that are not within parenthesis
			_DEG2RAD = Math.PI / 180,
			_RAD2DEG = 180 / Math.PI,
			_forcePT = {},
			_doc = document,
			_createElement = function(type) {
				return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
			},
			_tempDiv = _createElement("div"),
			_tempImg = _createElement("img"),
			_internals = CSSPlugin._internals = {_specialProps:_specialProps}, //provides a hook to a few internal methods that we need to access from inside other plugins
			_agent = navigator.userAgent,
			_autoRound,
			_reqSafariFix, //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).

			_isSafari,
			_isFirefox, //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
			_isSafariLT6, //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
			_ieVers,
			_supportsOpacity = (function() { //we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
				var i = _agent.indexOf("Android"),
					a = _createElement("a");
				_isSafari = (_agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || Number(_agent.substr(i+8, 1)) > 3));
				_isSafariLT6 = (_isSafari && (Number(_agent.substr(_agent.indexOf("Version/")+8, 1)) < 6));
				_isFirefox = (_agent.indexOf("Firefox") !== -1);
				if ((/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(_agent) || (/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/).exec(_agent)) {
					_ieVers = parseFloat( RegExp.$1 );
				}
				if (!a) {
					return false;
				}
				a.style.cssText = "top:1px;opacity:.55;";
				return /^0.55/.test(a.style.opacity);
			}()),
			_getIEOpacity = function(v) {
				return (_opacityExp.test( ((typeof(v) === "string") ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ) ? ( parseFloat( RegExp.$1 ) / 100 ) : 1);
			},
			_log = function(s) {//for logging messages, but in a way that won't throw errors in old versions of IE.
				if (window.console) {
					console.log(s);
				}
			},

			_prefixCSS = "", //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
			_prefix = "", //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".

			// @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
			_checkPropPrefix = function(p, e) {
				e = e || _tempDiv;
				var s = e.style,
					a, i;
				if (s[p] !== undefined) {
					return p;
				}
				p = p.charAt(0).toUpperCase() + p.substr(1);
				a = ["O","Moz","ms","Ms","Webkit"];
				i = 5;
				while (--i > -1 && s[a[i]+p] === undefined) { }
				if (i >= 0) {
					_prefix = (i === 3) ? "ms" : a[i];
					_prefixCSS = "-" + _prefix.toLowerCase() + "-";
					return _prefix + p;
				}
				return null;
			},

			_getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function() {},

			/**
			 * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
			 * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
			 *
			 * @param {!Object} t Target element whose style property you want to query
			 * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
			 * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
			 * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
			 * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
			 * @return {?string} The current property value
			 */
			_getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
				var rv;
				if (!_supportsOpacity) if (p === "opacity") { //several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
					return _getIEOpacity(t);
				}
				if (!calc && t.style[p]) {
					rv = t.style[p];
				} else if ((cs = cs || _getComputedStyle(t))) {
					rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
				} else if (t.currentStyle) {
					rv = t.currentStyle[p];
				}
				return (dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto")) ? dflt : rv;
			},

			/**
			 * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
			 * @param {!Object} t Target element
			 * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
			 * @param {!number} v Value
			 * @param {string=} sfx Suffix (like "px" or "%" or "em")
			 * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
			 * @return {number} value in pixels
			 */
			_convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
				if (sfx === "px" || !sfx) { return v; }
				if (sfx === "auto" || !v) { return 0; }
				var horiz = _horizExp.test(p),
					node = t,
					style = _tempDiv.style,
					neg = (v < 0),
					pix, cache, time;
				if (neg) {
					v = -v;
				}
				if (sfx === "%" && p.indexOf("border") !== -1) {
					pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);
				} else {
					style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
					if (sfx === "%" || !node.appendChild) {
						node = t.parentNode || _doc.body;
						cache = node._gsCache;
						time = TweenLite.ticker.frame;
						if (cache && horiz && cache.time === time) { //performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
							return cache.width * v / 100;
						}
						style[(horiz ? "width" : "height")] = v + sfx;
					} else {
						style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;
					}
					node.appendChild(_tempDiv);
					pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);
					node.removeChild(_tempDiv);
					if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
						cache = node._gsCache = node._gsCache || {};
						cache.time = time;
						cache.width = pix / v * 100;
					}
					if (pix === 0 && !recurse) {
						pix = _convertToPixels(t, p, v, sfx, true);
					}
				}
				return neg ? -pix : pix;
			},
			_calculateOffset = _internals.calculateOffset = function(t, p, cs) { //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
				if (_getStyle(t, "position", cs) !== "absolute") { return 0; }
				var dim = ((p === "left") ? "Left" : "Top"),
					v = _getStyle(t, "margin" + dim, cs);
				return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
			},

			// @private returns at object containing ALL of the style properties in camelCase and their associated values.
			_getAllStyles = function(t, cs) {
				var s = {},
					i, tr, p;
				if ((cs = cs || _getComputedStyle(t, null))) {
					if ((i = cs.length)) {
						while (--i > -1) {
							p = cs[i];
							if (p.indexOf("-transform") === -1 || _transformPropCSS === p) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
							}
						}
					} else { //some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
						for (i in cs) {
							if (i.indexOf("Transform") === -1 || _transformProp === i) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[i] = cs[i];
							}
						}
					}
				} else if ((cs = t.currentStyle || t.style)) {
					for (i in cs) {
						if (typeof(i) === "string" && s[i] === undefined) {
							s[i.replace(_camelExp, _camelFunc)] = cs[i];
						}
					}
				}
				if (!_supportsOpacity) {
					s.opacity = _getIEOpacity(t);
				}
				tr = _getTransform(t, cs, false);
				s.rotation = tr.rotation;
				s.skewX = tr.skewX;
				s.scaleX = tr.scaleX;
				s.scaleY = tr.scaleY;
				s.x = tr.x;
				s.y = tr.y;
				if (_supports3D) {
					s.z = tr.z;
					s.rotationX = tr.rotationX;
					s.rotationY = tr.rotationY;
					s.scaleZ = tr.scaleZ;
				}
				if (s.filters) {
					delete s.filters;
				}
				return s;
			},

			// @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
			_cssDif = function(t, s1, s2, vars, forceLookup) {
				var difs = {},
					style = t.style,
					val, p, mpt;
				for (p in s2) {
					if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || (forceLookup && forceLookup[p])) if (p.indexOf("Origin") === -1) if (typeof(val) === "number" || typeof(val) === "string") {
						difs[p] = (val === "auto" && (p === "left" || p === "top")) ? _calculateOffset(t, p) : ((val === "" || val === "auto" || val === "none") && typeof(s1[p]) === "string" && s1[p].replace(_NaNExp, "") !== "") ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
						if (style[p] !== undefined) { //for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
							mpt = new MiniPropTween(style, p, style[p], mpt);
						}
					}
				}
				if (vars) {
					for (p in vars) { //copy properties (except className)
						if (p !== "className") {
							difs[p] = vars[p];
						}
					}
				}
				return {difs:difs, firstMPT:mpt};
			},
			_dimensions = {width:["Left","Right"], height:["Top","Bottom"]},
			_margins = ["marginLeft","marginRight","marginTop","marginBottom"],

			/**
			 * @private Gets the width or height of an element
			 * @param {!Object} t Target element
			 * @param {!string} p Property name ("width" or "height")
			 * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
			 * @return {number} Dimension (in pixels)
			 */
			_getDimension = function(t, p, cs) {
				var v = parseFloat((p === "width") ? t.offsetWidth : t.offsetHeight),
					a = _dimensions[p],
					i = a.length;
				cs = cs || _getComputedStyle(t, null);
				while (--i > -1) {
					v -= parseFloat( _getStyle(t, "padding" + a[i], cs, true) ) || 0;
					v -= parseFloat( _getStyle(t, "border" + a[i] + "Width", cs, true) ) || 0;
				}
				return v;
			},

			// @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
			_parsePosition = function(v, recObj) {
				if (v == null || v === "" || v === "auto" || v === "auto auto") { //note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
					v = "0 0";
				}
				var a = v.split(" "),
					x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],
					y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1];
				if (y == null) {
					y = (x === "center") ? "50%" : "0";
				} else if (y === "center") {
					y = "50%";
				}
				if (x === "center" || (isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1)) { //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
					x = "50%";
				}
				if (recObj) {
					recObj.oxp = (x.indexOf("%") !== -1);
					recObj.oyp = (y.indexOf("%") !== -1);
					recObj.oxr = (x.charAt(1) === "=");
					recObj.oyr = (y.charAt(1) === "=");
					recObj.ox = parseFloat(x.replace(_NaNExp, ""));
					recObj.oy = parseFloat(y.replace(_NaNExp, ""));
				}
				return x + " " + y + ((a.length > 2) ? " " + a[2] : "");
			},

			/**
			 * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
			 * @param {(number|string)} e End value which is typically a string, but could be a number
			 * @param {(number|string)} b Beginning value which is typically a string but could be a number
			 * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
			 */
			_parseChange = function(e, b) {
				return (typeof(e) === "string" && e.charAt(1) === "=") ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b);
			},

			/**
			 * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
			 * @param {Object} v Value to be parsed
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @return {number} Parsed value
			 */
			_parseVal = function(v, d) {
				return (v == null) ? d : (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v);
			},

			/**
			 * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
			 * @param {Object} v Value to be parsed
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
			 * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
			 * @return {number} parsed angle in radians
			 */
			_parseAngle = function(v, d, p, directionalEnd) {
				var min = 0.000001,
					cap, split, dif, result, isRelative;
				if (v == null) {
					result = d;
				} else if (typeof(v) === "number") {
					result = v;
				} else {
					cap = 360;
					split = v.split("_");
					isRelative = (v.charAt(1) === "=");
					dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * ((v.indexOf("rad") === -1) ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
					if (split.length) {
						if (directionalEnd) {
							directionalEnd[p] = d + dif;
						}
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					result = d + dif;
				}
				if (result < min && result > -min) {
					result = 0;
				}
				return result;
			},

			_colorLookup = {aqua:[0,255,255],
				lime:[0,255,0],
				silver:[192,192,192],
				black:[0,0,0],
				maroon:[128,0,0],
				teal:[0,128,128],
				blue:[0,0,255],
				navy:[0,0,128],
				white:[255,255,255],
				fuchsia:[255,0,255],
				olive:[128,128,0],
				yellow:[255,255,0],
				orange:[255,165,0],
				gray:[128,128,128],
				purple:[128,0,128],
				green:[0,128,0],
				red:[255,0,0],
				pink:[255,192,203],
				cyan:[0,255,255],
				transparent:[255,255,255,0]},

			_hue = function(h, m1, m2) {
				h = (h < 0) ? h + 1 : (h > 1) ? h - 1 : h;
				return ((((h * 6 < 1) ? m1 + (m2 - m1) * h * 6 : (h < 0.5) ? m2 : (h * 3 < 2) ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255) + 0.5) | 0;
			},

			/**
			 * @private Parses a color (like #9F0, #FF9900, or rgb(255,51,153)) into an array with 3 elements for red, green, and blue. Also handles rgba() values (splits into array of 4 elements of course)
			 * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
			 * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order.
			 */
			_parseColor = CSSPlugin.parseColor = function(v) {
				var c1, c2, c3, h, s, l;
				if (!v || v === "") {
					return _colorLookup.black;
				}
				if (typeof(v) === "number") {
					return [v >> 16, (v >> 8) & 255, v & 255];
				}
				if (v.charAt(v.length - 1) === ",") { //sometimes a trailing commma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
					v = v.substr(0, v.length - 1);
				}
				if (_colorLookup[v]) {
					return _colorLookup[v];
				}
				if (v.charAt(0) === "#") {
					if (v.length === 4) { //for shorthand like #9F0
						c1 = v.charAt(1),
						c2 = v.charAt(2),
						c3 = v.charAt(3);
						v = "#" + c1 + c1 + c2 + c2 + c3 + c3;
					}
					v = parseInt(v.substr(1), 16);
					return [v >> 16, (v >> 8) & 255, v & 255];
				}
				if (v.substr(0, 3) === "hsl") {
					v = v.match(_numExp);
					h = (Number(v[0]) % 360) / 360;
					s = Number(v[1]) / 100;
					l = Number(v[2]) / 100;
					c2 = (l <= 0.5) ? l * (s + 1) : l + s - l * s;
					c1 = l * 2 - c2;
					if (v.length > 3) {
						v[3] = Number(v[3]);
					}
					v[0] = _hue(h + 1 / 3, c1, c2);
					v[1] = _hue(h, c1, c2);
					v[2] = _hue(h - 1 / 3, c1, c2);
					return v;
				}
				v = v.match(_numExp) || _colorLookup.transparent;
				v[0] = Number(v[0]);
				v[1] = Number(v[1]);
				v[2] = Number(v[2]);
				if (v.length > 3) {
					v[3] = Number(v[3]);
				}
				return v;
			},
			_colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

		for (p in _colorLookup) {
			_colorExp += "|" + p + "\\b";
		}
		_colorExp = new RegExp(_colorExp+")", "gi");

		/**
		 * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
		 * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
		 * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
		 * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
		 * @return {Function} formatter function
		 */
		var _getFormatter = function(dflt, clr, collapsible, multi) {
				if (dflt == null) {
					return function(v) {return v;};
				}
				var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
					dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
					pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
					sfx = (dflt.charAt(dflt.length - 1) === ")") ? ")" : "",
					delim = (dflt.indexOf(" ") !== -1) ? " " : ",",
					numVals = dVals.length,
					dSfx = (numVals > 0) ? dVals[0].replace(_numExp, "") : "",
					formatter;
				if (!numVals) {
					return function(v) {return v;};
				}
				if (clr) {
					formatter = function(v) {
						var color, vals, i, a;
						if (typeof(v) === "number") {
							v += dSfx;
						} else if (multi && _commasOutsideParenExp.test(v)) {
							a = v.replace(_commasOutsideParenExp, "|").split("|");
							for (i = 0; i < a.length; i++) {
								a[i] = formatter(a[i]);
							}
							return a.join(",");
						}
						color = (v.match(_colorExp) || [dColor])[0];
						vals = v.split(color).join("").match(_valuesExp) || [];
						i = vals.length;
						if (numVals > i--) {
							while (++i < numVals) {
								vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
							}
						}
						return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
					};
					return formatter;

				}
				formatter = function(v) {
					var vals, a, i;
					if (typeof(v) === "number") {
						v += dSfx;
					} else if (multi && _commasOutsideParenExp.test(v)) {
						a = v.replace(_commasOutsideParenExp, "|").split("|");
						for (i = 0; i < a.length; i++) {
							a[i] = formatter(a[i]);
						}
						return a.join(",");
					}
					vals = v.match(_valuesExp) || [];
					i = vals.length;
					if (numVals > i--) {
						while (++i < numVals) {
							vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
						}
					}
					return pfx + vals.join(delim) + sfx;
				};
				return formatter;
			},

			/**
			 * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
			 * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
			 * @return {Function} a formatter function
			 */
			_getEdgeParser = function(props) {
				props = props.split(",");
				return function(t, e, p, cssp, pt, plugin, vars) {
					var a = (e + "").split(" "),
						i;
					vars = {};
					for (i = 0; i < 4; i++) {
						vars[props[i]] = a[i] = a[i] || a[(((i - 1) / 2) >> 0)];
					}
					return cssp.parse(t, vars, pt, plugin);
				};
			},

			// @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens  which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
			_setPluginRatio = _internals._setPluginRatio = function(v) {
				this.plugin.setRatio(v);
				var d = this.data,
					proxy = d.proxy,
					mpt = d.firstMPT,
					min = 0.000001,
					val, pt, i, str;
				while (mpt) {
					val = proxy[mpt.v];
					if (mpt.r) {
						val = Math.round(val);
					} else if (val < min && val > -min) {
						val = 0;
					}
					mpt.t[mpt.p] = val;
					mpt = mpt._next;
				}
				if (d.autoRotate) {
					d.autoRotate.rotation = proxy.rotation;
				}
				//at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method.
				if (v === 1) {
					mpt = d.firstMPT;
					while (mpt) {
						pt = mpt.t;
						if (!pt.type) {
							pt.e = pt.s + pt.xs0;
						} else if (pt.type === 1) {
							str = pt.xs0 + pt.s + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn"+i] + pt["xs"+(i+1)];
							}
							pt.e = str;
						}
						mpt = mpt._next;
					}
				}
			},

			/**
			 * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
			 * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
			 * @param {!string} p property name
			 * @param {(number|string|object)} v value
			 * @param {MiniPropTween=} next next MiniPropTween in the linked list
			 * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
			 */
			MiniPropTween = function(t, p, v, next, r) {
				this.t = t;
				this.p = p;
				this.v = v;
				this.r = r;
				if (next) {
					next._prev = this;
					this._next = next;
				}
			},

			/**
			 * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
			 * This method returns an object that has the following properties:
			 *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
			 *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
			 *  - firstMPT: the first MiniPropTween in the linked list
			 *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
			 * @param {!Object} t target object to be tweened
			 * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
			 * @param {!CSSPlugin} cssp The CSSPlugin instance
			 * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
			 * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
			 * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
			 * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
			 */
			_parseToProxy = _internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
				var bpt = pt,
					start = {},
					end = {},
					transform = cssp._transform,
					oldForce = _forcePT,
					i, p, xp, mpt, firstPT;
				cssp._transform = null;
				_forcePT = vars;
				pt = firstPT = cssp.parse(t, vars, pt, plugin);
				_forcePT = oldForce;
				//break off from the linked list so the new ones are isolated.
				if (shallow) {
					cssp._transform = transform;
					if (bpt) {
						bpt._prev = null;
						if (bpt._prev) {
							bpt._prev._next = null;
						}
					}
				}
				while (pt && pt !== bpt) {
					if (pt.type <= 1) {
						p = pt.p;
						end[p] = pt.s + pt.c;
						start[p] = pt.s;
						if (!shallow) {
							mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
							pt.c = 0;
						}
						if (pt.type === 1) {
							i = pt.l;
							while (--i > 0) {
								xp = "xn" + i;
								p = pt.p + "_" + xp;
								end[p] = pt.data[xp];
								start[p] = pt[xp];
								if (!shallow) {
									mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
								}
							}
						}
					}
					pt = pt._next;
				}
				return {proxy:start, end:end, firstMPT:mpt, pt:firstPT};
			},



			/**
			 * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
			 * CSSPropTweens have the following optional properties as well (not defined through the constructor):
			 *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
			 *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
			 *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
			 *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
			 *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
			 * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
			 * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
			 * @param {number} s Starting numeric value
			 * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
			 * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
			 * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
			 * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
			 * @param {boolean=} r If true, the value(s) should be rounded
			 * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
			 * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
			 * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
			 */
			CSSPropTween = _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
				this.t = t; //target
				this.p = p; //property
				this.s = s; //starting value
				this.c = c; //change value
				this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
				if (!(t instanceof CSSPropTween)) {
					_overwriteProps.push(this.n);
				}
				this.r = r; //round (boolean)
				this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
				if (pr) {
					this.pr = pr;
					_hasPriority = true;
				}
				this.b = (b === undefined) ? s : b;
				this.e = (e === undefined) ? s + c : e;
				if (next) {
					this._next = next;
					next._prev = this;
				}
			},

			/**
			 * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
			 * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
			 * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
			 * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
			 *
			 * @param {!Object} t Target whose property will be tweened
			 * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
			 * @param {string} b Beginning value
			 * @param {string} e Ending value
			 * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
			 * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
			 * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
			 * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
			 * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
			 * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
			 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
			 */
			_parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
				//DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
				b = b || dflt || "";
				pt = new CSSPropTween(t, p, 0, 0, pt, (setRatio ? 2 : 1), null, false, pr, b, e);
				e += ""; //ensures it's a string
				var ba = b.split(", ").join(",").split(" "), //beginning array
					ea = e.split(", ").join(",").split(" "), //ending array
					l = ba.length,
					autoRound = (_autoRound !== false),
					i, xi, ni, bv, ev, bnums, enums, bn, rgba, temp, cv, str;
				if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
					ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
					ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
					l = ba.length;
				}
				if (l !== ea.length) {
					//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
					ba = (dflt || "").split(" ");
					l = ba.length;
				}
				pt.plugin = plugin;
				pt.setRatio = setRatio;
				for (i = 0; i < l; i++) {
					bv = ba[i];
					ev = ea[i];
					bn = parseFloat(bv);

					//if the value begins with a number (most common). It's fine if it has a suffix like px
					if (bn || bn === 0) {
						pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), (autoRound && ev.indexOf("px") !== -1), true);

					//if the value is a color
					} else if (clrs && (bv.charAt(0) === "#" || _colorLookup[bv] || _rgbhslExp.test(bv))) {
						str = ev.charAt(ev.length - 1) === "," ? ")," : ")"; //if there's a comma at the end, retain it.
						bv = _parseColor(bv);
						ev = _parseColor(ev);
						rgba = (bv.length + ev.length > 6);
						if (rgba && !_supportsOpacity && ev[3] === 0) { //older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
							pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
							pt.e = pt.e.split(ea[i]).join("transparent");
						} else {
							if (!_supportsOpacity) { //old versions of IE don't support rgba().
								rgba = false;
							}
							pt.appendXtra((rgba ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", true, true)
								.appendXtra("", bv[1], ev[1] - bv[1], ",", true)
								.appendXtra("", bv[2], ev[2] - bv[2], (rgba ? "," : str), true);
							if (rgba) {
								bv = (bv.length < 4) ? 1 : bv[3];
								pt.appendXtra("", bv, ((ev.length < 4) ? 1 : ev[3]) - bv, str, false);
							}
						}

					} else {
						bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

						//if no number is found, treat it as a non-tweening value and just append the string to the current xs.
						if (!bnums) {
							pt["xs" + pt.l] += pt.l ? " " + bv : bv;

						//loop through all the numbers that are found and construct the extra values on the pt.
						} else {
							enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
							if (!enums || enums.length !== bnums.length) {
								//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
								return pt;
							}
							ni = 0;
							for (xi = 0; xi < bnums.length; xi++) {
								cv = bnums[xi];
								temp = bv.indexOf(cv, ni);
								pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", (autoRound && bv.substr(temp + cv.length, 2) === "px"), (xi === 0));
								ni = temp + cv.length;
							}
							pt["xs" + pt.l] += bv.substr(ni);
						}
					}
				}
				//if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
				if (e.indexOf("=") !== -1) if (pt.data) {
					str = pt.xs0 + pt.data.s;
					for (i = 1; i < pt.l; i++) {
						str += pt["xs" + i] + pt.data["xn" + i];
					}
					pt.e = str + pt["xs" + i];
				}
				if (!pt.l) {
					pt.type = -1;
					pt.xs0 = pt.e;
				}
				return pt.xfirst || pt;
			},
			i = 9;


		p = CSSPropTween.prototype;
		p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.
		while (--i > 0) {
			p["xn" + i] = 0;
			p["xs" + i] = "";
		}
		p.xs0 = "";
		p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;


		/**
		 * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
		 * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
		 * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
		 * @param {string=} pfx Prefix (if any)
		 * @param {!number} s Starting value
		 * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
		 * @param {string=} sfx Suffix (if any)
		 * @param {boolean=} r Round (if true).
		 * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
		 * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
		 */
		p.appendXtra = function(pfx, s, c, sfx, r, pad) {
			var pt = this,
				l = pt.l;
			pt["xs" + l] += (pad && l) ? " " + pfx : pfx || "";
			if (!c) if (l !== 0 && !pt.plugin) { //typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
				pt["xs" + l] += s + (sfx || "");
				return pt;
			}
			pt.l++;
			pt.type = pt.setRatio ? 2 : 1;
			pt["xs" + pt.l] = sfx || "";
			if (l > 0) {
				pt.data["xn" + l] = s + c;
				pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
				pt["xn" + l] = s;
				if (!pt.plugin) {
					pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
					pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
				}
				return pt;
			}
			pt.data = {s:s + c};
			pt.rxp = {};
			pt.s = s;
			pt.c = c;
			pt.r = r;
			return pt;
		};

		/**
		 * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
		 * @param {!string} p Property name (like "boxShadow" or "throwProps")
		 * @param {Object=} options An object containing any of the following configuration options:
		 *                      - defaultValue: the default value
		 *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
		 *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
		 *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
		 *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
		 *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
		 *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
		 *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
		 *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
		 */
		var SpecialProp = function(p, options) {
				options = options || {};
				this.p = options.prefix ? _checkPropPrefix(p) || p : p;
				_specialProps[p] = _specialProps[this.p] = this;
				this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
				if (options.parser) {
					this.parse = options.parser;
				}
				this.clrs = options.color;
				this.multi = options.multi;
				this.keyword = options.keyword;
				this.dflt = options.defaultValue;
				this.pr = options.priority || 0;
			},

			//shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
			_registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
				if (typeof(options) !== "object") {
					options = {parser:defaults}; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
				}
				var a = p.split(","),
					d = options.defaultValue,
					i, temp;
				defaults = defaults || [d];
				for (i = 0; i < a.length; i++) {
					options.prefix = (i === 0 && options.prefix);
					options.defaultValue = defaults[i] || d;
					temp = new SpecialProp(a[i], options);
				}
			},

			//creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
			_registerPluginProp = function(p) {
				if (!_specialProps[p]) {
					var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
					_registerComplexSpecialProp(p, {parser:function(t, e, p, cssp, pt, plugin, vars) {
						var pluginClass = _globals.com.greensock.plugins[pluginName];
						if (!pluginClass) {
							_log("Error: " + pluginName + " js file not loaded.");
							return pt;
						}
						pluginClass._cssRegister();
						return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
					}});
				}
			};


		p = SpecialProp.prototype;

		/**
		 * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
		 * @param {!Object} t target element
		 * @param {(string|number|object)} b beginning value
		 * @param {(string|number|object)} e ending (destination) value
		 * @param {CSSPropTween=} pt next CSSPropTween in the linked list
		 * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
		 * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
		 * @return {CSSPropTween=} First CSSPropTween in the linked list
		 */
		p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
			var kwd = this.keyword,
				i, ba, ea, l, bi, ei;
			//if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
			if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
				ba = b.replace(_commasOutsideParenExp, "|").split("|");
				ea = e.replace(_commasOutsideParenExp, "|").split("|");
			} else if (kwd) {
				ba = [b];
				ea = [e];
			}
			if (ea) {
				l = (ea.length > ba.length) ? ea.length : ba.length;
				for (i = 0; i < l; i++) {
					b = ba[i] = ba[i] || this.dflt;
					e = ea[i] = ea[i] || this.dflt;
					if (kwd) {
						bi = b.indexOf(kwd);
						ei = e.indexOf(kwd);
						if (bi !== ei) {
							if (ei === -1) { //if the keyword isn't in the end value, remove it from the beginning one.
								ba[i] = ba[i].split(kwd).join("");
							} else if (bi === -1) { //if the keyword isn't in the beginning, add it.
								ba[i] += " " + kwd;
							}
						}
					}
				}
				b = ba.join(", ");
				e = ea.join(", ");
			}
			return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
		};

		/**
		 * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
		 * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
		 * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
		 * @param {!Object} t Target object whose property is being tweened
		 * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
		 * @param {!string} p Property name
		 * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
		 * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
		 * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
		 * @param {Object=} vars Original vars object that contains the data for parsing.
		 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
		 */
		p.parse = function(t, e, p, cssp, pt, plugin, vars) {
			return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
		};

		/**
		 * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
		 *  1) Target object whose property should be tweened (typically a DOM element)
		 *  2) The end/destination value (could be a string, number, object, or whatever you want)
		 *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
		 *
		 * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
		 *
		 * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
		 *      var start = target.style.width;
		 *      return function(ratio) {
		 *              target.style.width = (start + value * ratio) + "px";
		 *              console.log("set width to " + target.style.width);
		 *          }
		 * }, 0);
		 *
		 * Then, when I do this tween, it will trigger my special property:
		 *
		 * TweenLite.to(element, 1, {css:{myCustomProp:100}});
		 *
		 * In the example, of course, we're just changing the width, but you can do anything you want.
		 *
		 * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
		 * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
		 * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
		 */
		CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
			_registerComplexSpecialProp(name, {parser:function(t, e, p, cssp, pt, plugin, vars) {
				var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
				rv.plugin = plugin;
				rv.setRatio = onInitTween(t, e, cssp._tween, p);
				return rv;
			}, priority:priority});
		};






		//transform-related methods and properties
		CSSPlugin.useSVGTransformAttr = _isSafari; //Safari has some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead.
		var _transformProps = ("scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent").split(","),
			_transformProp = _checkPropPrefix("transform"), //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
			_transformPropCSS = _prefixCSS + "transform",
			_transformOriginProp = _checkPropPrefix("transformOrigin"),
			_supports3D = (_checkPropPrefix("perspective") !== null),
			Transform = _internals.Transform = function() {
				this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
				this.force3D = (CSSPlugin.defaultForce3D === false || !_supports3D) ? false : CSSPlugin.defaultForce3D || "auto";
			},
			_SVGElement = window.SVGElement,
			_useSVGTransformAttr,
			//Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.

			_createSVG = function(type, container, attributes) {
				var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
					reg = /([a-z])([A-Z])/g,
					p;
				for (p in attributes) {
					element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
				}
				container.appendChild(element);
				return element;
			},
			_docElement = _doc.documentElement,
			_forceSVGTransformAttr = (function() {
				//IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
				var force = _ieVers || (/Android/i.test(_agent) && !window.chrome),
					svg, rect, width;
				if (_doc.createElementNS && !force) { //IE8 and earlier doesn't support SVG anyway
					svg = _createSVG("svg", _docElement);
					rect = _createSVG("rect", svg, {width:100, height:50, x:100});
					width = rect.getBoundingClientRect().width;
					rect.style[_transformOriginProp] = "50% 50%";
					rect.style[_transformProp] = "scaleX(0.5)";
					force = (width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D)); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
					_docElement.removeChild(svg);
				}
				return force;
			})(),
			_parseSVGOrigin = function(e, local, decoratee, absolute) {
				var bbox, v;
				if (!absolute || !(v = absolute.split(" ")).length) {
					bbox = e.getBBox();
					local = _parsePosition(local).split(" ");
					v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * bbox.width : parseFloat(local[0])) + bbox.x,
						 (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * bbox.height : parseFloat(local[1])) + bbox.y];
				}
				decoratee.xOrigin = parseFloat(v[0]);
				decoratee.yOrigin = parseFloat(v[1]);
				e.setAttribute("data-svg-origin", v.join(" "));
			},

			/**
			 * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
			 * @param {!Object} t target element
			 * @param {Object=} cs computed style object (optional)
			 * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
			 * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
			 * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
			 */
			_getTransform = _internals.getTransform = function(t, cs, rec, parse) {
				if (t._gsTransform && rec && !parse) {
					return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
				}
				var tm = rec ? t._gsTransform || new Transform() : new Transform(),
					invX = (tm.scaleX < 0), //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
					min = 0.00002,
					rnd = 100000,
					zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin  || 0 : 0,
					defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
					isDefault, s, m, i, n, dec, scaleX, scaleY, rotation, skewX;
				if (_transformProp) {
					s = _getStyle(t, _transformPropCSS, cs, true);
				} else if (t.currentStyle) {
					//for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
					s = t.currentStyle.filter.match(_ieGetMatrixExp);
					s = (s && s.length === 4) ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), (tm.x || 0), (tm.y || 0)].join(",") : "";
				}
				isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
				tm.svg = !!(_SVGElement && typeof(t.getBBox) === "function" && t.getCTM && (!t.parentNode || (t.parentNode.getBBox && t.parentNode.getCTM))); //don't just rely on "instanceof _SVGElement" because if the SVG is embedded via an object tag, it won't work (SVGElement is mapped to a different object)
				if (tm.svg) {
					if (isDefault && (t.style[_transformProp] + "").indexOf("matrix") !== -1) { //some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
						s = t.style[_transformProp];
						isDefault = false;
					}
					_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, _cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
					_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
					m = t.getAttribute("transform");
					if (isDefault && m && m.indexOf("matrix") !== -1) { //just in case there's a "transform" value specified as an attribute instead of CSS style. Only accept a matrix, though.
						s = m;
						isDefault = 0;
					}
				}
				if (!isDefault) {
					//split the matrix values out into an array (m for matrix)
					m = (s || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [];
					i = m.length;
					while (--i > -1) {
						n = Number(m[i]);
						m[i] = (dec = n - (n |= 0)) ? ((dec * rnd + (dec < 0 ? -0.5 : 0.5)) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
					}
					if (m.length === 16) {
						//we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
						var a11 = m[0], a21 = m[1], a31 = m[2], a41 = m[3],
							a12 = m[4], a22 = m[5], a32 = m[6], a42 = m[7],
							a13 = m[8], a23 = m[9], a33 = m[10],
							a14 = m[12], a24 = m[13], a34 = m[14],
							a43 = m[11],
							angle = Math.atan2(a32, a33),
							t1, t2, t3, t4, cos, sin;

						//we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
						if (tm.zOrigin) {
							a34 = -tm.zOrigin;
							a14 = a13*a34-m[12];
							a24 = a23*a34-m[13];
							a34 = a33*a34+tm.zOrigin-m[14];
						}
						tm.rotationX = angle * _RAD2DEG;
						//rotationX
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a12*cos+a13*sin;
							t2 = a22*cos+a23*sin;
							t3 = a32*cos+a33*sin;
							a13 = a12*-sin+a13*cos;
							a23 = a22*-sin+a23*cos;
							a33 = a32*-sin+a33*cos;
							a43 = a42*-sin+a43*cos;
							a12 = t1;
							a22 = t2;
							a32 = t3;
						}
						//rotationY
						angle = Math.atan2(a13, a33);
						tm.rotationY = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a11*cos-a13*sin;
							t2 = a21*cos-a23*sin;
							t3 = a31*cos-a33*sin;
							a23 = a21*sin+a23*cos;
							a33 = a31*sin+a33*cos;
							a43 = a41*sin+a43*cos;
							a11 = t1;
							a21 = t2;
							a31 = t3;
						}
						//rotationZ
						angle = Math.atan2(a21, a11);
						tm.rotation = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							a11 = a11*cos+a12*sin;
							t2 = a21*cos+a22*sin;
							a22 = a21*-sin+a22*cos;
							a32 = a31*-sin+a32*cos;
							a21 = t2;
						}

						if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) { //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
							tm.rotationX = tm.rotation = 0;
							tm.rotationY += 180;
						}

						tm.scaleX = ((Math.sqrt(a11 * a11 + a21 * a21) * rnd + 0.5) | 0) / rnd;
						tm.scaleY = ((Math.sqrt(a22 * a22 + a23 * a23) * rnd + 0.5) | 0) / rnd;
						tm.scaleZ = ((Math.sqrt(a32 * a32 + a33 * a33) * rnd + 0.5) | 0) / rnd;
						tm.skewX = 0;
						tm.perspective = a43 ? 1 / ((a43 < 0) ? -a43 : a43) : 0;
						tm.x = a14;
						tm.y = a24;
						tm.z = a34;
						if (tm.svg) {
							tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
							tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
						}

					} else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || (!tm.rotationX && !tm.rotationY)) && !(tm.x !== undefined && _getStyle(t, "display", cs) === "none")) { //sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
						var k = (m.length >= 6),
							a = k ? m[0] : 1,
							b = m[1] || 0,
							c = m[2] || 0,
							d = k ? m[3] : 1;
						tm.x = m[4] || 0;
						tm.y = m[5] || 0;
						scaleX = Math.sqrt(a * a + b * b);
						scaleY = Math.sqrt(d * d + c * c);
						rotation = (a || b) ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
						skewX = (c || d) ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
						if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
							if (invX) {
								scaleX *= -1;
								skewX += (rotation <= 0) ? 180 : -180;
								rotation += (rotation <= 0) ? 180 : -180;
							} else {
								scaleY *= -1;
								skewX += (skewX <= 0) ? 180 : -180;
							}
						}
						tm.scaleX = scaleX;
						tm.scaleY = scaleY;
						tm.rotation = rotation;
						tm.skewX = skewX;
						if (_supports3D) {
							tm.rotationX = tm.rotationY = tm.z = 0;
							tm.perspective = defaultTransformPerspective;
							tm.scaleZ = 1;
						}
						if (tm.svg) {
							tm.x -= tm.xOrigin - (tm.xOrigin * a - tm.yOrigin * b);
							tm.y -= tm.yOrigin - (tm.yOrigin * d - tm.xOrigin * c);
						}
					}
					tm.zOrigin = zOrigin;
					//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
					for (i in tm) {
						if (tm[i] < min) if (tm[i] > -min) {
							tm[i] = 0;
						}
					}
				}
				//DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective);
				if (rec) {
					t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
					if (tm.svg) { //if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
						if (_useSVGTransformAttr && t.style[_transformProp]) {
							_removeProp(t.style, _transformProp);
						} else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
							t.removeAttribute("transform");
						}
					}
				}
				return tm;
			},

			//for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
			_setIETransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					ang = -t.rotation * _DEG2RAD,
					skew = ang + t.skewX * _DEG2RAD,
					rnd = 100000,
					a = ((Math.cos(ang) * t.scaleX * rnd) | 0) / rnd,
					b = ((Math.sin(ang) * t.scaleX * rnd) | 0) / rnd,
					c = ((Math.sin(skew) * -t.scaleY * rnd) | 0) / rnd,
					d = ((Math.cos(skew) * t.scaleY * rnd) | 0) / rnd,
					style = this.t.style,
					cs = this.t.currentStyle,
					filters, val;
				if (!cs) {
					return;
				}
				val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
				b = -c;
				c = -val;
				filters = cs.filter;
				style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
				var w = this.t.offsetWidth,
					h = this.t.offsetHeight,
					clip = (cs.position !== "absolute"),
					m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
					ox = t.x + (w * t.xPercent / 100),
					oy = t.y + (h * t.yPercent / 100),
					dx, dy;

				//if transformOrigin is being used, adjust the offset x and y
				if (t.ox != null) {
					dx = ((t.oxp) ? w * t.ox * 0.01 : t.ox) - w / 2;
					dy = ((t.oyp) ? h * t.oy * 0.01 : t.oy) - h / 2;
					ox += dx - (dx * a + dy * b);
					oy += dy - (dx * c + dy * d);
				}

				if (!clip) {
					m += ", sizingMethod='auto expand')";
				} else {
					dx = (w / 2);
					dy = (h / 2);
					//translate to ensure that transformations occur around the correct origin (default is center).
					m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
				}
				if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
					style.filter = filters.replace(_ieSetMatrixExp, m);
				} else {
					style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
				}

				//at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
				if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
					style.removeAttribute("filter");
				}

				//we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
				if (!clip) {
					var mult = (_ieVers < 8) ? 1 : -1, //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
						marg, prop, dif;
					dx = t.ieOffsetX || 0;
					dy = t.ieOffsetY || 0;
					t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
					t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
					for (i = 0; i < 4; i++) {
						prop = _margins[i];
						marg = cs[prop];
						//we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
						val = (marg.indexOf("px") !== -1) ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
						if (val !== t[prop]) {
							dif = (i < 2) ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
						} else {
							dif = (i < 2) ? dx - t.ieOffsetX : dy - t.ieOffsetY;
						}
						style[prop] = (t[prop] = Math.round( val - dif * ((i === 0 || i === 2) ? 1 : mult) )) + "px";
					}
				}
			},

			/* translates a super small decimal to a string WITHOUT scientific notation
			_safeDecimal = function(n) {
				var s = (n < 0 ? -n : n) + "",
					a = s.split("e-");
				return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
			},
			*/

			_set3DTransformRatio = _internals.set3DTransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					style = this.t.style,
					angle = t.rotation * _DEG2RAD,
					sx = t.scaleX,
					sy = t.scaleY,
					sz = t.scaleZ,
					x = t.x,
					y = t.y,
					z = t.z,
					perspective = t.perspective,
					a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43,
					zOrigin, min, cos, sin, t1, t2, transform, comma, zero;
				if (v === 1 || v === 0 || !t.force3D) if (t.force3D !== true) if (!t.rotationY && !t.rotationX && sz === 1 && !perspective && !z && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime)) { //on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.
					_set2DTransformRatio.call(this, v);
					return;
				}
				if (_isFirefox) {
					min = 0.0001;
					if (sx < min && sx > -min) { //Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
						sx = sz = 0.00002;
					}
					if (sy < min && sy > -min) {
						sy = sz = 0.00002;
					}
					if (perspective && !t.z && !t.rotationX && !t.rotationY) { //Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
						perspective = 0;
					}
				}
				if (angle || t.skewX) {
					cos = a11 = Math.cos(angle);
					sin = a21 = Math.sin(angle);
					if (t.skewX) {
						angle -= t.skewX * _DEG2RAD;
						cos = Math.cos(angle);
						sin = Math.sin(angle);
						if (t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
							t1 = Math.tan(t.skewX * _DEG2RAD);
							t1 = Math.sqrt(1 + t1 * t1);
							cos *= t1;
							sin *= t1;
						}
					}
					a12 = -sin;
					a22 = cos;

				} else if (!t.rotationY && !t.rotationX && sz === 1 && !perspective && !t.svg) { //if we're only translating and/or 2D scaling, this is faster...
					style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z +"px)" + ((sx !== 1 || sy !== 1) ? " scale(" + sx + "," + sy + ")" : "");
					return;
				} else {
					a11 = a22 = 1;
					a12 = a21 = 0;
				}
				// KEY  INDEX   AFFECTS
				// a11  0       rotation, rotationY, scaleX
				// a21  1       rotation, rotationY, scaleX
				// a31  2       rotationY, scaleX
				// a41  3       rotationY, scaleX
				// a12  4       rotation, skewX, rotationX, scaleY
				// a22  5       rotation, skewX, rotationX, scaleY
				// a32  6       rotationX, scaleY
				// a42  7       rotationX, scaleY
				// a13  8       rotationY, rotationX, scaleZ
				// a23  9       rotationY, rotationX, scaleZ
				// a33  10      rotationY, rotationX, scaleZ
				// a43  11      rotationY, rotationX, perspective, scaleZ
				// a14  12      x, zOrigin, svgOrigin
				// a24  13      y, zOrigin, svgOrigin
				// a34  14      z, zOrigin
				// a44  15
				// rotation: Math.atan2(a21, a11)
				// rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))
				// rotationX: Math.atan2(a32, a33)
				a33 = 1;
				a13 = a23 = a31 = a32 = a41 = a42 = 0;
				a43 = (perspective) ? -1 / perspective : 0;
				zOrigin = t.zOrigin;
				min = 0.000001; //threshold below which browsers use scientific notation which won't work.
				comma = ",";
				zero = "0";
				angle = t.rotationY * _DEG2RAD;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					a31 = -sin;
					a41 = a43*-sin;
					a13 = a11*sin;
					a23 = a21*sin;
					a33 = cos;
					a43 *= cos;
					a11 *= cos;
					a21 *= cos;
				}
				angle = t.rotationX * _DEG2RAD;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					t1 = a12*cos+a13*sin;
					t2 = a22*cos+a23*sin;
					a32 = a33*sin;
					a42 = a43*sin;
					a13 = a12*-sin+a13*cos;
					a23 = a22*-sin+a23*cos;
					a33 = a33*cos;
					a43 = a43*cos;
					a12 = t1;
					a22 = t2;
				}
				if (sz !== 1) {
					a13*=sz;
					a23*=sz;
					a33*=sz;
					a43*=sz;
				}
				if (sy !== 1) {
					a12*=sy;
					a22*=sy;
					a32*=sy;
					a42*=sy;
				}
				if (sx !== 1) {
					a11*=sx;
					a21*=sx;
					a31*=sx;
					a41*=sx;
				}

				if (zOrigin || t.svg) {
					if (zOrigin) {
						x += a13*-zOrigin;
						y += a23*-zOrigin;
						z += a33*-zOrigin+zOrigin;
					}
					if (t.svg) { //due to bugs in some browsers, we need to manage the transform-origin of SVG manually
						x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12);
						y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22);
					}
					if (x < min && x > -min) {
						x = zero;
					}
					if (y < min && y > -min) {
						y = zero;
					}
					if (z < min && z > -min) {
						z = 0; //don't use string because we calculate perspective later and need the number.
					}
				}

				//optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:
				transform = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(");
				transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
				transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
				if (t.rotationX || t.rotationY) { //performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
					transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
					transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
				} else {
					transform += ",0,0,0,0,1,0,";
				}
				transform += x + comma + y + comma + z + comma + (perspective ? (1 + (-z / perspective)) : 1) + ")";

				style[_transformProp] = transform;
			},

			_set2DTransformRatio = _internals.set2DTransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					targ = this.t,
					style = targ.style,
					x = t.x,
					y = t.y,
					ang, skew, rnd, sx, sy, a, b, c, d, matrix, min, t1;
				if ((t.rotationX || t.rotationY || t.z || t.force3D === true || (t.force3D === "auto" && v !== 1 && v !== 0)) && !(t.svg && _useSVGTransformAttr) && _supports3D) { //if a 3D tween begins while a 2D one is running, we need to kick the rendering over to the 3D method. For example, imagine a yoyo-ing, infinitely repeating scale tween running, and then the object gets rotated in 3D space with a different tween.
					this.setRatio = _set3DTransformRatio;
					_set3DTransformRatio.call(this, v);
					return;
				}
				sx = t.scaleX;
				sy = t.scaleY;
				if (t.rotation || t.skewX || t.svg) {
					ang = t.rotation * _DEG2RAD;
					skew = t.skewX * _DEG2RAD;
					rnd = 100000;
					a = Math.cos(ang) * sx;
					b = Math.sin(ang) * sx;
					c = Math.sin(ang - skew) * -sy;
					d = Math.cos(ang - skew) * sy;
					if (skew && t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
						t1 = Math.tan(skew);
						t1 = Math.sqrt(1 + t1 * t1);
						c *= t1;
						d *= t1;
					}
					if (t.svg) {
						x += t.xOrigin - (t.xOrigin * a + t.yOrigin * c);
						y += t.yOrigin - (t.xOrigin * b + t.yOrigin * d);
						min = 0.000001;
						if (x < min) if (x > -min) {
							x = 0;
						}
						if (y < min) if (y > -min) {
							y = 0;
						}
					}
					matrix = (((a * rnd) | 0) / rnd) + "," + (((b * rnd) | 0) / rnd) + "," + (((c * rnd) | 0) / rnd) + "," + (((d * rnd) | 0) / rnd) + "," + x + "," + y + ")";
					if (t.svg && _useSVGTransformAttr) {
						targ.setAttribute("transform", "matrix(" + matrix);
					} else {
						//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
						style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + matrix;
					}
				} else {
					style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
				}
			};

		p = Transform.prototype;
		p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = 0;
		p.scaleX = p.scaleY = p.scaleZ = 1;

		_registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent", {parser:function(t, e, p, cssp, pt, plugin, vars) {
			if (cssp._lastParsedTransform === vars) { return pt; } //only need to parse the transform once, and only if the browser supports it.
			cssp._lastParsedTransform = vars;
			var m1 = cssp._transform = _getTransform(t, _cs, true, vars.parseTransform),
				style = t.style,
				min = 0.000001,
				i = _transformProps.length,
				v = vars,
				endRotations = {},
				m2, skewY, copy, orig, has3D, hasChange, dr;
			if (typeof(v.transform) === "string" && _transformProp) { //for values like transform:"rotate(60deg) scale(0.5, 0.8)"
				copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.
				copy[_transformProp] = v.transform;
				copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
				copy.position = "absolute";
				_doc.body.appendChild(_tempDiv);
				m2 = _getTransform(_tempDiv, null, false);
				_doc.body.removeChild(_tempDiv);
			} else if (typeof(v) === "object") { //for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
				m2 = {scaleX:_parseVal((v.scaleX != null) ? v.scaleX : v.scale, m1.scaleX),
					scaleY:_parseVal((v.scaleY != null) ? v.scaleY : v.scale, m1.scaleY),
					scaleZ:_parseVal(v.scaleZ, m1.scaleZ),
					x:_parseVal(v.x, m1.x),
					y:_parseVal(v.y, m1.y),
					z:_parseVal(v.z, m1.z),
					xPercent:_parseVal(v.xPercent, m1.xPercent),
					yPercent:_parseVal(v.yPercent, m1.yPercent),
					perspective:_parseVal(v.transformPerspective, m1.perspective)};
				dr = v.directionalRotation;
				if (dr != null) {
					if (typeof(dr) === "object") {
						for (copy in dr) {
							v[copy] = dr[copy];
						}
					} else {
						v.rotation = dr;
					}
				}
				if (typeof(v.x) === "string" && v.x.indexOf("%") !== -1) {
					m2.x = 0;
					m2.xPercent = _parseVal(v.x, m1.xPercent);
				}
				if (typeof(v.y) === "string" && v.y.indexOf("%") !== -1) {
					m2.y = 0;
					m2.yPercent = _parseVal(v.y, m1.yPercent);
				}

				m2.rotation = _parseAngle(("rotation" in v) ? v.rotation : ("shortRotation" in v) ? v.shortRotation + "_short" : ("rotationZ" in v) ? v.rotationZ : m1.rotation, m1.rotation, "rotation", endRotations);
				if (_supports3D) {
					m2.rotationX = _parseAngle(("rotationX" in v) ? v.rotationX : ("shortRotationX" in v) ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
					m2.rotationY = _parseAngle(("rotationY" in v) ? v.rotationY : ("shortRotationY" in v) ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
				}
				m2.skewX = (v.skewX == null) ? m1.skewX : _parseAngle(v.skewX, m1.skewX);

				//note: for performance reasons, we combine all skewing into the skewX and rotation values, ignoring skewY but we must still record it so that we can discern how much of the overall skew is attributed to skewX vs. skewY. Otherwise, if the skewY would always act relative (tween skewY to 10deg, for example, multiple times and if we always combine things into skewX, we can't remember that skewY was 10 from last time). Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of -10 degrees.
				m2.skewY = (v.skewY == null) ? m1.skewY : _parseAngle(v.skewY, m1.skewY);
				if ((skewY = m2.skewY - m1.skewY)) {
					m2.skewX += skewY;
					m2.rotation += skewY;
				}
			}
			if (_supports3D && v.force3D != null) {
				m1.force3D = v.force3D;
				hasChange = true;
			}

			m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;

			has3D = (m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective);
			if (!has3D && v.scale != null) {
				m2.scaleZ = 1; //no need to tween scaleZ.
			}

			while (--i > -1) {
				p = _transformProps[i];
				orig = m2[p] - m1[p];
				if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
					hasChange = true;
					pt = new CSSPropTween(m1, p, m1[p], orig, pt);
					if (p in endRotations) {
						pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
					}
					pt.xs0 = 0; //ensures the value stays numeric in setRatio()
					pt.plugin = plugin;
					cssp._overwriteProps.push(pt.n);
				}
			}

			orig = v.transformOrigin;
			if (m1.svg && (orig || v.svgOrigin)) {
				_parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin);
				pt = new CSSPropTween(m1, "xOrigin", m1.xOrigin, m2.xOrigin - m1.xOrigin, pt, -1, "transformOrigin");
				pt.b = m1.xOrigin;
				pt.e = pt.xs0 = m2.xOrigin;
				pt = new CSSPropTween(m1, "yOrigin", m1.yOrigin, m2.yOrigin - m1.yOrigin, pt, -1, "transformOrigin");
				pt.b = m1.yOrigin;
				pt.e = pt.xs0 = m2.yOrigin;
				orig = _useSVGTransformAttr ? null : "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
			}
			if (orig || (_supports3D && has3D && m1.zOrigin)) { //if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
				if (_transformProp) {
					hasChange = true;
					p = _transformOriginProp;
					orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors
					pt = new CSSPropTween(style, p, 0, 0, pt, -1, "transformOrigin");
					pt.b = style[p];
					pt.plugin = plugin;
					if (_supports3D) {
						copy = m1.zOrigin;
						orig = orig.split(" ");
						m1.zOrigin = ((orig.length > 2 && !(copy !== 0 && orig[2] === "0px")) ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
						pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
						pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
						pt.b = copy;
						pt.xs0 = pt.e = m1.zOrigin;
					} else {
						pt.xs0 = pt.e = orig;
					}

				//for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
				} else {
					_parsePosition(orig + "", m1);
				}
			}
			if (hasChange) {
				cssp._transformType = (!(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3)) ? 3 : 2; //quicker than calling cssp._enableTransforms();
			}
			return pt;
		}, prefix:true});

		_registerComplexSpecialProp("boxShadow", {defaultValue:"0px 0px 0px 0px #999", prefix:true, color:true, multi:true, keyword:"inset"});

		_registerComplexSpecialProp("borderRadius", {defaultValue:"0px", parser:function(t, e, p, cssp, pt, plugin) {
			e = this.format(e);
			var props = ["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],
				style = t.style,
				ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em;
			w = parseFloat(t.offsetWidth);
			h = parseFloat(t.offsetHeight);
			ea1 = e.split(" ");
			for (i = 0; i < props.length; i++) { //if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
				if (this.p.indexOf("border")) { //older browsers used a prefix
					props[i] = _checkPropPrefix(props[i]);
				}
				bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
				if (bs.indexOf(" ") !== -1) {
					bs2 = bs.split(" ");
					bs = bs2[0];
					bs2 = bs2[1];
				}
				es = es2 = ea1[i];
				bn = parseFloat(bs);
				bsfx = bs.substr((bn + "").length);
				rel = (es.charAt(1) === "=");
				if (rel) {
					en = parseInt(es.charAt(0)+"1", 10);
					es = es.substr(2);
					en *= parseFloat(es);
					esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
				} else {
					en = parseFloat(es);
					esfx = es.substr((en + "").length);
				}
				if (esfx === "") {
					esfx = _suffixMap[p] || bsfx;
				}
				if (esfx !== bsfx) {
					hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
					vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number
					if (esfx === "%") {
						bs = (hn / w * 100) + "%";
						bs2 = (vn / h * 100) + "%";
					} else if (esfx === "em") {
						em = _convertToPixels(t, "borderLeft", 1, "em");
						bs = (hn / em) + "em";
						bs2 = (vn / em) + "em";
					} else {
						bs = hn + "px";
						bs2 = vn + "px";
					}
					if (rel) {
						es = (parseFloat(bs) + en) + esfx;
						es2 = (parseFloat(bs2) + en) + esfx;
					}
				}
				pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
			}
			return pt;
		}, prefix:true, formatter:_getFormatter("0px 0px 0px 0px", false, true)});
		_registerComplexSpecialProp("backgroundPosition", {defaultValue:"0 0", parser:function(t, e, p, cssp, pt, plugin) {
			var bp = "background-position",
				cs = (_cs || _getComputedStyle(t, null)),
				bs = this.format( ((cs) ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
				es = this.format(e),
				ba, ea, i, pct, overlap, src;
			if ((bs.indexOf("%") !== -1) !== (es.indexOf("%") !== -1)) {
				src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
				if (src && src !== "none") {
					ba = bs.split(" ");
					ea = es.split(" ");
					_tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height
					i = 2;
					while (--i > -1) {
						bs = ba[i];
						pct = (bs.indexOf("%") !== -1);
						if (pct !== (ea[i].indexOf("%") !== -1)) {
							overlap = (i === 0) ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
							ba[i] = pct ? (parseFloat(bs) / 100 * overlap) + "px" : (parseFloat(bs) / overlap * 100) + "%";
						}
					}
					bs = ba.join(" ");
				}
			}
			return this.parseComplex(t.style, bs, es, pt, plugin);
		}, formatter:_parsePosition});
		_registerComplexSpecialProp("backgroundSize", {defaultValue:"0 0", formatter:_parsePosition});
		_registerComplexSpecialProp("perspective", {defaultValue:"0px", prefix:true});
		_registerComplexSpecialProp("perspectiveOrigin", {defaultValue:"50% 50%", prefix:true});
		_registerComplexSpecialProp("transformStyle", {prefix:true});
		_registerComplexSpecialProp("backfaceVisibility", {prefix:true});
		_registerComplexSpecialProp("userSelect", {prefix:true});
		_registerComplexSpecialProp("margin", {parser:_getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")});
		_registerComplexSpecialProp("padding", {parser:_getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")});
		_registerComplexSpecialProp("clip", {defaultValue:"rect(0px,0px,0px,0px)", parser:function(t, e, p, cssp, pt, plugin){
			var b, cs, delim;
			if (_ieVers < 9) { //IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
				cs = t.currentStyle;
				delim = _ieVers < 8 ? " " : ",";
				b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
				e = this.format(e).split(",").join(delim);
			} else {
				b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
				e = this.format(e);
			}
			return this.parseComplex(t.style, b, e, pt, plugin);
		}});
		_registerComplexSpecialProp("textShadow", {defaultValue:"0px 0px 0px #999", color:true, multi:true});
		_registerComplexSpecialProp("autoRound,strictUnits", {parser:function(t, e, p, cssp, pt) {return pt;}}); //just so that we can ignore these properties (not tween them)
		_registerComplexSpecialProp("border", {defaultValue:"0px solid #000", parser:function(t, e, p, cssp, pt, plugin) {
				return this.parseComplex(t.style, this.format(_getStyle(t, "borderTopWidth", _cs, false, "0px") + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), this.format(e), pt, plugin);
			}, color:true, formatter:function(v) {
				var a = v.split(" ");
				return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
			}});
		_registerComplexSpecialProp("borderWidth", {parser:_getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).
		_registerComplexSpecialProp("float,cssFloat,styleFloat", {parser:function(t, e, p, cssp, pt, plugin) {
			var s = t.style,
				prop = ("cssFloat" in s) ? "cssFloat" : "styleFloat";
			return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
		}});

		//opacity-related
		var _setIEOpacityRatio = function(v) {
				var t = this.t, //refers to the element's style property
					filters = t.filter || _getStyle(this.data, "filter") || "",
					val = (this.s + this.c * v) | 0,
					skip;
				if (val === 100) { //for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
					if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
						t.removeAttribute("filter");
						skip = (!_getStyle(this.data, "filter")); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
					} else {
						t.filter = filters.replace(_alphaFilterExp, "");
						skip = true;
					}
				}
				if (!skip) {
					if (this.xn1) {
						t.filter = filters = filters || ("alpha(opacity=" + val + ")"); //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
					}
					if (filters.indexOf("pacity") === -1) { //only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
						if (val !== 0 || !this.xn1) { //bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
							t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
						}
					} else {
						t.filter = filters.replace(_opacityExp, "opacity=" + val);
					}
				}
			};
		_registerComplexSpecialProp("opacity,alpha,autoAlpha", {defaultValue:"1", parser:function(t, e, p, cssp, pt, plugin) {
			var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
				style = t.style,
				isAutoAlpha = (p === "autoAlpha");
			if (typeof(e) === "string" && e.charAt(1) === "=") {
				e = ((e.charAt(0) === "-") ? -1 : 1) * parseFloat(e.substr(2)) + b;
			}
			if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) { //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
				b = 0;
			}
			if (_supportsOpacity) {
				pt = new CSSPropTween(style, "opacity", b, e - b, pt);
			} else {
				pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
				pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
				style.zoom = 1; //helps correct an IE issue.
				pt.type = 2;
				pt.b = "alpha(opacity=" + pt.s + ")";
				pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
				pt.data = t;
				pt.plugin = plugin;
				pt.setRatio = _setIEOpacityRatio;
			}
			if (isAutoAlpha) { //we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
				pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, ((b !== 0) ? "inherit" : "hidden"), ((e === 0) ? "hidden" : "inherit"));
				pt.xs0 = "inherit";
				cssp._overwriteProps.push(pt.n);
				cssp._overwriteProps.push(p);
			}
			return pt;
		}});


		var _removeProp = function(s, p) {
				if (p) {
					if (s.removeProperty) {
						if (p.substr(0,2) === "ms" || p.substr(0,6) === "webkit") { //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
							p = "-" + p;
						}
						s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
					} else { //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
						s.removeAttribute(p);
					}
				}
			},
			_setClassNameRatio = function(v) {
				this.t._gsClassPT = this;
				if (v === 1 || v === 0) {
					this.t.setAttribute("class", (v === 0) ? this.b : this.e);
					var mpt = this.data, //first MiniPropTween
						s = this.t.style;
					while (mpt) {
						if (!mpt.v) {
							_removeProp(s, mpt.p);
						} else {
							s[mpt.p] = mpt.v;
						}
						mpt = mpt._next;
					}
					if (v === 1 && this.t._gsClassPT === this) {
						this.t._gsClassPT = null;
					}
				} else if (this.t.getAttribute("class") !== this.e) {
					this.t.setAttribute("class", this.e);
				}
			};
		_registerComplexSpecialProp("className", {parser:function(t, e, p, cssp, pt, plugin, vars) {
			var b = t.getAttribute("class") || "", //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
				cssText = t.style.cssText,
				difData, bs, cnpt, cnptLookup, mpt;
			pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
			pt.setRatio = _setClassNameRatio;
			pt.pr = -11;
			_hasPriority = true;
			pt.b = b;
			bs = _getAllStyles(t, _cs);
			//if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
			cnpt = t._gsClassPT;
			if (cnpt) {
				cnptLookup = {};
				mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
				while (mpt) {
					cnptLookup[mpt.p] = 1;
					mpt = mpt._next;
				}
				cnpt.setRatio(1);
			}
			t._gsClassPT = pt;
			pt.e = (e.charAt(1) !== "=") ? e : b.replace(new RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ((e.charAt(0) === "+") ? " " + e.substr(2) : "");
			if (cssp._tween._duration) { //if it's a zero-duration tween, there's no need to tween anything or parse the data. In fact, if we switch classes temporarily (which we must do for proper parsing) and the class has a transition applied, it could cause a quick flash to the end state and back again initially in some browsers.
				t.setAttribute("class", pt.e);
				difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
				t.setAttribute("class", b);
				pt.data = difData.firstMPT;
				t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
				pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
			}
			return pt;
		}});


		var _setClearPropsRatio = function(v) {
			if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") { //this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
				var s = this.t.style,
					transformParse = _specialProps.transform.parse,
					a, p, i, clearTransform;
				if (this.e === "all") {
					s.cssText = "";
					clearTransform = true;
				} else {
					a = this.e.split(" ").join("").split(",");
					i = a.length;
					while (--i > -1) {
						p = a[i];
						if (_specialProps[p]) {
							if (_specialProps[p].parse === transformParse) {
								clearTransform = true;
							} else {
								p = (p === "transformOrigin") ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
							}
						}
						_removeProp(s, p);
					}
				}
				if (clearTransform) {
					_removeProp(s, _transformProp);
					if (this.t._gsTransform) {
						delete this.t._gsTransform;
					}
				}

			}
		};
		_registerComplexSpecialProp("clearProps", {parser:function(t, e, p, cssp, pt) {
			pt = new CSSPropTween(t, p, 0, 0, pt, 2);
			pt.setRatio = _setClearPropsRatio;
			pt.e = e;
			pt.pr = -10;
			pt.data = cssp._tween;
			_hasPriority = true;
			return pt;
		}});

		p = "bezier,throwProps,physicsProps,physics2D".split(",");
		i = p.length;
		while (i--) {
			_registerPluginProp(p[i]);
		}








		p = CSSPlugin.prototype;
		p._firstPT = p._lastParsedTransform = p._transform = null;

		//gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
		p._onInitTween = function(target, vars, tween) {
			if (!target.nodeType) { //css is only for dom elements
				return false;
			}
			this._target = target;
			this._tween = tween;
			this._vars = vars;
			_autoRound = vars.autoRound;
			_hasPriority = false;
			_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
			_cs = _getComputedStyle(target, "");
			_overwriteProps = this._overwriteProps;
			var style = target.style,
				v, pt, pt2, first, last, next, zIndex, tpt, threeD;
			if (_reqSafariFix) if (style.zIndex === "") {
				v = _getStyle(target, "zIndex", _cs);
				if (v === "auto" || v === "") {
					//corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
					this._addLazySet(style, "zIndex", 0);
				}
			}

			if (typeof(vars) === "string") {
				first = style.cssText;
				v = _getAllStyles(target, _cs);
				style.cssText = first + ";" + vars;
				v = _cssDif(target, v, _getAllStyles(target)).difs;
				if (!_supportsOpacity && _opacityValExp.test(vars)) {
					v.opacity = parseFloat( RegExp.$1 );
				}
				vars = v;
				style.cssText = first;
			}
			this._firstPT = pt = this.parse(target, vars, null);

			if (this._transformType) {
				threeD = (this._transformType === 3);
				if (!_transformProp) {
					style.zoom = 1; //helps correct an IE issue.
				} else if (_isSafari) {
					_reqSafariFix = true;
					//if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).
					if (style.zIndex === "") {
						zIndex = _getStyle(target, "zIndex", _cs);
						if (zIndex === "auto" || zIndex === "") {
							this._addLazySet(style, "zIndex", 0);
						}
					}
					//Setting WebkitBackfaceVisibility corrects 3 bugs:
					// 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
					// 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
					// 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
					//Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
					if (_isSafariLT6) {
						this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
					}
				}
				pt2 = pt;
				while (pt2 && pt2._next) {
					pt2 = pt2._next;
				}
				tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
				this._linkCSSP(tpt, null, pt2);
				tpt.setRatio = (threeD && _supports3D) ? _set3DTransformRatio : _transformProp ? _set2DTransformRatio : _setIETransformRatio;
				tpt.data = this._transform || _getTransform(target, _cs, true);
				tpt.tween = tween;
				_overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
			}

			if (_hasPriority) {
				//reorders the linked list in order of pr (priority)
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				this._firstPT = first;
			}
			return true;
		};


		p.parse = function(target, vars, pt, plugin) {
			var style = target.style,
				p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel;
			for (p in vars) {
				es = vars[p]; //ending value string
				sp = _specialProps[p]; //SpecialProp lookup.
				if (sp) {
					pt = sp.parse(target, es, p, this, pt, plugin, vars);

				} else {
					bs = _getStyle(target, p, _cs) + "";
					isStr = (typeof(es) === "string");
					if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || (isStr && _rgbhslExp.test(es))) { //Opera uses background: to define color sometimes in addition to backgroundColor:
						if (!isStr) {
							es = _parseColor(es);
							es = ((es.length > 3) ? "rgba(" : "rgb(") + es.join(",") + ")";
						}
						pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);

					} else if (isStr && (es.indexOf(" ") !== -1 || es.indexOf(",") !== -1)) {
						pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);

					} else {
						bn = parseFloat(bs);
						bsfx = (bn || bn === 0) ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

						if (bs === "" || bs === "auto") {
							if (p === "width" || p === "height") {
								bn = _getDimension(target, p, _cs);
								bsfx = "px";
							} else if (p === "left" || p === "top") {
								bn = _calculateOffset(target, p, _cs);
								bsfx = "px";
							} else {
								bn = (p !== "opacity") ? 0 : 1;
								bsfx = "";
							}
						}

						rel = (isStr && es.charAt(1) === "=");
						if (rel) {
							en = parseInt(es.charAt(0) + "1", 10);
							es = es.substr(2);
							en *= parseFloat(es);
							esfx = es.replace(_suffixExp, "");
						} else {
							en = parseFloat(es);
							esfx = isStr ? es.replace(_suffixExp, "") : "";
						}

						if (esfx === "") {
							esfx = (p in _suffixMap) ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
						}

						es = (en || en === 0) ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.

						//if the beginning/ending suffixes don't match, normalize them...
						if (bsfx !== esfx) if (esfx !== "") if (en || en === 0) if (bn) { //note: if the beginning value (bn) is 0, we don't need to convert units!
							bn = _convertToPixels(target, p, bn, bsfx);
							if (esfx === "%") {
								bn /= _convertToPixels(target, p, 100, "%") / 100;
								if (vars.strictUnits !== true) { //some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
									bs = bn + "%";
								}

							} else if (esfx === "em") {
								bn /= _convertToPixels(target, p, 1, "em");

							//otherwise convert to pixels.
							} else if (esfx !== "px") {
								en = _convertToPixels(target, p, en, esfx);
								esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
							}
							if (rel) if (en || en === 0) {
								es = (en + bn) + esfx; //the changes we made affect relative calculations, so adjust the end value here.
							}
						}

						if (rel) {
							en += bn;
						}

						if ((bn || bn === 0) && (en || en === 0)) { //faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
							pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, (_autoRound !== false && (esfx === "px" || p === "zIndex")), 0, bs, es);
							pt.xs0 = esfx;
							//DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
						} else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
							_log("invalid " + p + " tween value: " + vars[p]);
						} else {
							pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
							pt.xs0 = (es === "none" && (p === "display" || p.indexOf("Style") !== -1)) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
							//DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
						}
					}
				}
				if (plugin) if (pt && !pt.plugin) {
					pt.plugin = plugin;
				}
			}
			return pt;
		};


		//gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
		p.setRatio = function(v) {
			var pt = this._firstPT,
				min = 0.000001,
				val, str, i;
			//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
			if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
				while (pt) {
					if (pt.type !== 2) {
						pt.t[pt.p] = pt.e;
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
				while (pt) {
					val = pt.c * v + pt.s;
					if (pt.r) {
						val = Math.round(val);
					} else if (val < min) if (val > -min) {
						val = 0;
					}
					if (!pt.type) {
						pt.t[pt.p] = val + pt.xs0;
					} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
						i = pt.l;
						if (i === 2) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
						} else if (i === 3) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
						} else if (i === 4) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
						} else if (i === 5) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
						} else {
							str = pt.xs0 + val + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn"+i] + pt["xs"+(i+1)];
							}
							pt.t[pt.p] = str;
						}

					} else if (pt.type === -1) { //non-tweening value
						pt.t[pt.p] = pt.xs0;

					} else if (pt.setRatio) { //custom setRatio() for things like SpecialProps, external plugins, etc.
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
			} else {
				while (pt) {
					if (pt.type !== 2) {
						pt.t[pt.p] = pt.b;
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			}
		};

		/**
		 * @private
		 * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
		 * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
		 * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
		 * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
		 * doesn't have any transform-related properties of its own. You can call this method as many times as you
		 * want and it won't create duplicate CSSPropTweens.
		 *
		 * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
		 */
		p._enableTransforms = function(threeD) {
			this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
			this._transformType = (!(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3)) ? 3 : 2;
		};

		var lazySet = function(v) {
			this.t[this.p] = this.e;
			this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.
		};
		/** @private Gives us a way to set a value on the first render (and only the first render). **/
		p._addLazySet = function(t, p, v) {
			var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
			pt.e = v;
			pt.setRatio = lazySet;
			pt.data = this;
		};

		/** @private **/
		p._linkCSSP = function(pt, next, prev, remove) {
			if (pt) {
				if (next) {
					next._prev = pt;
				}
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
					remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
				}
				if (prev) {
					prev._next = pt;
				} else if (!remove && this._firstPT === null) {
					this._firstPT = pt;
				}
				pt._next = next;
				pt._prev = prev;
			}
			return pt;
		};

		//we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
		p._kill = function(lookup) {
			var copy = lookup,
				pt, p, xfirst;
			if (lookup.autoAlpha || lookup.alpha) {
				copy = {};
				for (p in lookup) { //copy the lookup so that we're not changing the original which may be passed elsewhere.
					copy[p] = lookup[p];
				}
				copy.opacity = 1;
				if (copy.autoAlpha) {
					copy.visibility = 1;
				}
			}
			if (lookup.className && (pt = this._classNamePT)) { //for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
				xfirst = pt.xfirst;
				if (xfirst && xfirst._prev) {
					this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
				} else if (xfirst === this._firstPT) {
					this._firstPT = pt._next;
				}
				if (pt._next) {
					this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
				}
				this._classNamePT = null;
			}
			return TweenPlugin.prototype._kill.call(this, copy);
		};



		//used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
		var _getChildStyles = function(e, props, targets) {
				var children, i, child, type;
				if (e.slice) {
					i = e.length;
					while (--i > -1) {
						_getChildStyles(e[i], props, targets);
					}
					return;
				}
				children = e.childNodes;
				i = children.length;
				while (--i > -1) {
					child = children[i];
					type = child.type;
					if (child.style) {
						props.push(_getAllStyles(child));
						if (targets) {
							targets.push(child);
						}
					}
					if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
						_getChildStyles(child, props, targets);
					}
				}
			};

		/**
		 * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
		 * and then compares the style properties of all the target's child elements at the tween's start and end, and
		 * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
		 * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
		 * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
		 * is because it creates entirely new tweens that may have completely different targets than the original tween,
		 * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
		 * and it would create other problems. For example:
		 *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
		 *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
		 *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
		 *
		 * @param {Object} target object to be tweened
		 * @param {number} Duration in seconds (or frames for frames-based tweens)
		 * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
		 * @return {Array} An array of TweenLite instances
		 */
		CSSPlugin.cascadeTo = function(target, duration, vars) {
			var tween = TweenLite.to(target, duration, vars),
				results = [tween],
				b = [],
				e = [],
				targets = [],
				_reservedProps = TweenLite._internals.reservedProps,
				i, difs, p, from;
			target = tween._targets || tween.target;
			_getChildStyles(target, b, targets);
			tween.render(duration, true, true);
			_getChildStyles(target, e);
			tween.render(0, true, true);
			tween._enabled(true);
			i = targets.length;
			while (--i > -1) {
				difs = _cssDif(targets[i], b[i], e[i]);
				if (difs.firstMPT) {
					difs = difs.difs;
					for (p in vars) {
						if (_reservedProps[p]) {
							difs[p] = vars[p];
						}
					}
					from = {};
					for (p in difs) {
						from[p] = b[i][p];
					}
					results.push(TweenLite.fromTo(targets[i], duration, from, difs));
				}
			}
			return results;
		};

		TweenPlugin.activate([CSSPlugin]);
		return CSSPlugin;

	}, true);

	
	
	
	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * RoundPropsPlugin
 * ----------------------------------------------------------------
 */
	(function() {

		var RoundPropsPlugin = _gsScope._gsDefine.plugin({
				propName: "roundProps",
				priority: -1,
				API: 2,

				//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
				init: function(target, value, tween) {
					this._tween = tween;
					return true;
				}

			}),
			p = RoundPropsPlugin.prototype;

		p._onInitAllProps = function() {
			var tween = this._tween,
				rp = (tween.vars.roundProps instanceof Array) ? tween.vars.roundProps : tween.vars.roundProps.split(","),
				i = rp.length,
				lookup = {},
				rpt = tween._propLookup.roundProps,
				prop, pt, next;
			while (--i > -1) {
				lookup[rp[i]] = 1;
			}
			i = rp.length;
			while (--i > -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t._roundProps(lookup, true);
					} else if (pt.n === prop) {
						this._add(pt.t, prop, pt.s, pt.c);
						//remove from linked list
						if (next) {
							next._prev = pt._prev;
						}
						if (pt._prev) {
							pt._prev._next = next;
						} else if (tween._firstPT === pt) {
							tween._firstPT = next;
						}
						pt._next = pt._prev = null;
						tween._propLookup[prop] = rpt;
					}
					pt = next;
				}
			}
			return false;
		};

		p._add = function(target, p, s, c) {
			this._addTween(target, p, s, s + c, p, true);
			this._overwriteProps.push(p);
		};

	}());










/*
 * ----------------------------------------------------------------
 * AttrPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine.plugin({
		propName: "attr",
		API: 2,
		version: "0.3.3",

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween) {
			var p, start, end;
			if (typeof(target.setAttribute) !== "function") {
				return false;
			}
			this._target = target;
			this._proxy = {};
			this._start = {}; // we record start and end values exactly as they are in case they're strings (not numbers) - we need to be able to revert to them cleanly.
			this._end = {};
			for (p in value) {
				this._start[p] = this._proxy[p] = start = target.getAttribute(p);
				end = this._addTween(this._proxy, p, parseFloat(start), value[p], p);
				this._end[p] = end ? end.s + end.c : value[p];
				this._overwriteProps.push(p);
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(ratio) {
			this._super.setRatio.call(this, ratio);
			var props = this._overwriteProps,
				i = props.length,
				lookup = (ratio === 1) ? this._end : ratio ? this._proxy : this._start,
				p;
			while (--i > -1) {
				p = props[i];
				this._target.setAttribute(p, lookup[p] + "");
			}
		}

	});










/*
 * ----------------------------------------------------------------
 * DirectionalRotationPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine.plugin({
		propName: "directionalRotation",
		version: "0.2.1",
		API: 2,

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween) {
			if (typeof(value) !== "object") {
				value = {rotation:value};
			}
			this.finals = {};
			var cap = (value.useRadians === true) ? Math.PI * 2 : 360,
				min = 0.000001,
				p, v, start, end, dif, split;
			for (p in value) {
				if (p !== "useRadians") {
					split = (value[p] + "").split("_");
					v = split[0];
					start = parseFloat( (typeof(target[p]) !== "function") ? target[p] : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]() );
					end = this.finals[p] = (typeof(v) === "string" && v.charAt(1) === "=") ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
					dif = end - start;
					if (split.length) {
						v = split.join("_");
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					if (dif > min || dif < -min) {
						this._addTween(target, p, start, start + dif, p);
						this._overwriteProps.push(p);
					}
				}
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(ratio) {
			var pt;
			if (ratio !== 1) {
				this._super.setRatio.call(this, ratio);
			} else {
				pt = this._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](this.finals[pt.p]);
					} else {
						pt.t[pt.p] = this.finals[pt.p];
					}
					pt = pt._next;
				}
			}
		}

	})._autoCSS = true;







	
	
	
	
/*
 * ----------------------------------------------------------------
 * EasePack
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("easing.Back", ["easing.Ease"], function(Ease) {
		
		var w = (_gsScope.GreenSockGlobals || _gsScope),
			gs = w.com.greensock,
			_2PI = Math.PI * 2,
			_HALF_PI = Math.PI / 2,
			_class = gs._class,
			_create = function(n, f) {
				var C = _class("easing." + n, function(){}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				return C;
			},
			_easeReg = Ease.register || function(){}, //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
			_wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
				var C = _class("easing."+name, {
					easeOut:new EaseOut(),
					easeIn:new EaseIn(),
					easeInOut:new EaseInOut()
				}, true);
				_easeReg(C, name);
				return C;
			},
			EasePoint = function(time, value, next) {
				this.t = time;
				this.v = value;
				if (next) {
					this.next = next;
					next.prev = this;
					this.c = next.v - value;
					this.gap = next.t - time;
				}
			},

			//Back
			_createBack = function(n, f) {
				var C = _class("easing." + n, function(overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				p.config = function(overshoot) {
					return new C(overshoot);
				};
				return C;
			},

			Back = _wrap("Back",
				_createBack("BackOut", function(p) {
					return ((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);
				}),
				_createBack("BackIn", function(p) {
					return p * p * ((this._p1 + 1) * p - this._p1);
				}),
				_createBack("BackInOut", function(p) {
					return ((p *= 2) < 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
				})
			),


			//SlowMo
			SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
				power = (power || power === 0) ? power : 0.7;
				if (linearRatio == null) {
					linearRatio = 0.7;
				} else if (linearRatio > 1) {
					linearRatio = 1;
				}
				this._p = (linearRatio !== 1) ? power : 0;
				this._p1 = (1 - linearRatio) / 2;
				this._p2 = linearRatio;
				this._p3 = this._p1 + this._p2;
				this._calcEnd = (yoyoMode === true);
			}, true),
			p = SlowMo.prototype = new Ease(),
			SteppedEase, RoughEase, _createElastic;

		p.constructor = SlowMo;
		p.getRatio = function(p) {
			var r = p + (0.5 - p) * this._p;
			if (p < this._p1) {
				return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);
			} else if (p > this._p3) {
				return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p);
			}
			return this._calcEnd ? 1 : r;
		};
		SlowMo.ease = new SlowMo(0.7, 0.7);

		p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		};


		//SteppedEase
		SteppedEase = _class("easing.SteppedEase", function(steps) {
				steps = steps || 1;
				this._p1 = 1 / steps;
				this._p2 = steps + 1;
			}, true);
		p = SteppedEase.prototype = new Ease();
		p.constructor = SteppedEase;
		p.getRatio = function(p) {
			if (p < 0) {
				p = 0;
			} else if (p >= 1) {
				p = 0.999999999;
			}
			return ((this._p2 * p) >> 0) * this._p1;
		};
		p.config = SteppedEase.config = function(steps) {
			return new SteppedEase(steps);
		};


		//RoughEase
		RoughEase = _class("easing.RoughEase", function(vars) {
			vars = vars || {};
			var taper = vars.taper || "none",
				a = [],
				cnt = 0,
				points = (vars.points || 20) | 0,
				i = points,
				randomize = (vars.randomize !== false),
				clamp = (vars.clamp === true),
				template = (vars.template instanceof Ease) ? vars.template : null,
				strength = (typeof(vars.strength) === "number") ? vars.strength * 0.4 : 0.4,
				x, y, bump, invX, obj, pnt;
			while (--i > -1) {
				x = randomize ? Math.random() : (1 / points) * i;
				y = template ? template.getRatio(x) : x;
				if (taper === "none") {
					bump = strength;
				} else if (taper === "out") {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === "in") {
					bump = x * x * strength;
				} else if (x < 0.5) {  //"both" (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {				//"both" (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += (Math.random() * bump) - (bump * 0.5);
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y > 1) {
						y = 1;
					} else if (y < 0) {
						y = 0;
					}
				}
				a[cnt++] = {x:x, y:y};
			}
			a.sort(function(a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i > -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
		}, true);
		p = RoughEase.prototype = new Ease();
		p.constructor = RoughEase;
		p.getRatio = function(p) {
			var pnt = this._prev;
			if (p > pnt.t) {
				while (pnt.next && p >= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev && p <= pnt.t) {
					pnt = pnt.prev;
				}
			}
			this._prev = pnt;
			return (pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);
		};
		p.config = function(vars) {
			return new RoughEase(vars);
		};
		RoughEase.ease = new RoughEase();


		//Bounce
		_wrap("Bounce",
			_create("BounceOut", function(p) {
				if (p < 1 / 2.75) {
					return 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				}
				return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
			}),
			_create("BounceIn", function(p) {
				if ((p = 1 - p) < 1 / 2.75) {
					return 1 - (7.5625 * p * p);
				} else if (p < 2 / 2.75) {
					return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
				} else if (p < 2.5 / 2.75) {
					return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
				}
				return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
			}),
			_create("BounceInOut", function(p) {
				var invert = (p < 0.5);
				if (invert) {
					p = 1 - (p * 2);
				} else {
					p = (p * 2) - 1;
				}
				if (p < 1 / 2.75) {
					p = 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				} else {
					p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
				}
				return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
			})
		);


		//CIRC
		_wrap("Circ",
			_create("CircOut", function(p) {
				return Math.sqrt(1 - (p = p - 1) * p);
			}),
			_create("CircIn", function(p) {
				return -(Math.sqrt(1 - (p * p)) - 1);
			}),
			_create("CircInOut", function(p) {
				return ((p*=2) < 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
			})
		);


		//Elastic
		_createElastic = function(n, f, def) {
			var C = _class("easing." + n, function(amplitude, period) {
					this._p1 = (amplitude >= 1) ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}, true),
				p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function(amplitude, period) {
				return new C(amplitude, period);
			};
			return C;
		};
		_wrap("Elastic",
			_createElastic("ElasticOut", function(p) {
				return this._p1 * Math.pow(2, -10 * p) * Math.sin( (p - this._p3) * this._p2 ) + 1;
			}, 0.3),
			_createElastic("ElasticIn", function(p) {
				return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2 ));
			}, 0.3),
			_createElastic("ElasticInOut", function(p) {
				return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 *(p -= 1)) * Math.sin( (p - this._p3) * this._p2 ) * 0.5 + 1;
			}, 0.45)
		);


		//Expo
		_wrap("Expo",
			_create("ExpoOut", function(p) {
				return 1 - Math.pow(2, -10 * p);
			}),
			_create("ExpoIn", function(p) {
				return Math.pow(2, 10 * (p - 1)) - 0.001;
			}),
			_create("ExpoInOut", function(p) {
				return ((p *= 2) < 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
			})
		);


		//Sine
		_wrap("Sine",
			_create("SineOut", function(p) {
				return Math.sin(p * _HALF_PI);
			}),
			_create("SineIn", function(p) {
				return -Math.cos(p * _HALF_PI) + 1;
			}),
			_create("SineInOut", function(p) {
				return -0.5 * (Math.cos(Math.PI * p) - 1);
			})
		);

		_class("easing.EaseLookup", {
				find:function(s) {
					return Ease.map[s];
				}
			}, true);

		//register the non-standard eases
		_easeReg(w.SlowMo, "SlowMo", "ease,");
		_easeReg(RoughEase, "RoughEase", "ease,");
		_easeReg(SteppedEase, "SteppedEase", "ease,");

		return Back;
		
	}, true);


});

if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); } //necessary in case TweenLite was already loaded separately.











/*
 * ----------------------------------------------------------------
 * Base classes like TweenLite, SimpleTimeline, Ease, Ticker, etc.
 * ----------------------------------------------------------------
 */
(function(window, moduleName) {

		"use strict";
		var _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
		if (_globals.TweenLite) {
			return; //in case the core set of classes is already loaded, don't instantiate twice.
		}
		var _namespace = function(ns) {
				var a = ns.split("."),
					p = _globals, i;
				for (i = 0; i < a.length; i++) {
					p[a[i]] = p = p[a[i]] || {};
				}
				return p;
			},
			gs = _namespace("com.greensock"),
			_tinyNum = 0.0000000001,
			_slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			_emptyFunc = function() {},
			_isArray = (function() { //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
				var toString = Object.prototype.toString,
					array = toString.call([]);
				return function(obj) {
					return obj != null && (obj instanceof Array || (typeof(obj) === "object" && !!obj.push && toString.call(obj) === array));
				};
			}()),
			a, i, p, _ticker, _tickerActive,
			_defLookup = {},

			/**
			 * @constructor
			 * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
			 * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
			 * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
			 * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
			 *
			 * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
			 * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
			 * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
			 * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
			 * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
			 * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
			 * sandbox the banner one like:
			 *
			 * <script>
			 *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
			 * </script>
			 * <script src="js/greensock/v1.7/TweenMax.js"></script>
			 * <script>
			 *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
			 * </script>
			 * <script src="js/greensock/v1.6/TweenMax.js"></script>
			 * <script>
			 *     gs.TweenLite.to(...); //would use v1.7
			 *     TweenLite.to(...); //would use v1.6
			 * </script>
			 *
			 * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
			 * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
			 * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
			 * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
			 */
			Definition = function(ns, dependencies, func, global) {
				this.sc = (_defLookup[ns]) ? _defLookup[ns].sc : []; //subclasses
				_defLookup[ns] = this;
				this.gsClass = null;
				this.func = func;
				var _classes = [];
				this.check = function(init) {
					var i = dependencies.length,
						missing = i,
						cur, a, n, cl;
					while (--i > -1) {
						if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
							_classes[i] = cur.gsClass;
							missing--;
						} else if (init) {
							cur.sc.push(this);
						}
					}
					if (missing === 0 && func) {
						a = ("com.greensock." + ns).split(".");
						n = a.pop();
						cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

						//exports to multiple environments
						if (global) {
							_globals[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
							if (typeof(define) === "function" && define.amd){ //AMD
								define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() { return cl; });
							} else if (ns === moduleName && typeof(module) !== "undefined" && module.exports){ //node
								module.exports = cl;
							}
						}
						for (i = 0; i < this.sc.length; i++) {
							this.sc[i].check();
						}
					}
				};
				this.check(true);
			},

			//used to create Definition instances (which basically registers a class that has dependencies).
			_gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
				return new Definition(ns, dependencies, func, global);
			},

			//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
			_class = gs._class = function(ns, func, global) {
				func = func || function() {};
				_gsDefine(ns, [], function(){ return func; }, global);
				return func;
			};

		_gsDefine.globals = _globals;



/*
 * ----------------------------------------------------------------
 * Ease
 * ----------------------------------------------------------------
 */
		var _baseParams = [0, 0, 1, 1],
			_blankArray = [],
			Ease = _class("easing.Ease", function(func, extraParams, type, power) {
				this._func = func;
				this._type = type || 0;
				this._power = power || 0;
				this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
			}, true),
			_easeMap = Ease.map = {},
			_easeReg = Ease.register = function(ease, names, types, create) {
				var na = names.split(","),
					i = na.length,
					ta = (types || "easeIn,easeOut,easeInOut").split(","),
					e, name, j, type;
				while (--i > -1) {
					name = na[i];
					e = create ? _class("easing."+name, null, true) : gs.easing[name] || {};
					j = ta.length;
					while (--j > -1) {
						type = ta[j];
						_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
					}
				}
			};

		p = Ease.prototype;
		p._calcEnd = false;
		p.getRatio = function(p) {
			if (this._func) {
				this._params[0] = p;
				return this._func.apply(null, this._params);
			}
			var t = this._type,
				pw = this._power,
				r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;
			if (pw === 1) {
				r *= r;
			} else if (pw === 2) {
				r *= r * r;
			} else if (pw === 3) {
				r *= r * r * r;
			} else if (pw === 4) {
				r *= r * r * r * r;
			}
			return (t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);
		};

		//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
		a = ["Linear","Quad","Cubic","Quart","Quint,Strong"];
		i = a.length;
		while (--i > -1) {
			p = a[i]+",Power"+i;
			_easeReg(new Ease(null,null,1,i), p, "easeOut", true);
			_easeReg(new Ease(null,null,2,i), p, "easeIn" + ((i === 0) ? ",easeNone" : ""));
			_easeReg(new Ease(null,null,3,i), p, "easeInOut");
		}
		_easeMap.linear = gs.easing.Linear.easeIn;
		_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks


/*
 * ----------------------------------------------------------------
 * EventDispatcher
 * ----------------------------------------------------------------
 */
		var EventDispatcher = _class("events.EventDispatcher", function(target) {
			this._listeners = {};
			this._eventTarget = target || this;
		});
		p = EventDispatcher.prototype;

		p.addEventListener = function(type, callback, scope, useParam, priority) {
			priority = priority || 0;
			var list = this._listeners[type],
				index = 0,
				listener, i;
			if (list == null) {
				this._listeners[type] = list = [];
			}
			i = list.length;
			while (--i > -1) {
				listener = list[i];
				if (listener.c === callback && listener.s === scope) {
					list.splice(i, 1);
				} else if (index === 0 && listener.pr < priority) {
					index = i + 1;
				}
			}
			list.splice(index, 0, {c:callback, s:scope, up:useParam, pr:priority});
			if (this === _ticker && !_tickerActive) {
				_ticker.wake();
			}
		};

		p.removeEventListener = function(type, callback) {
			var list = this._listeners[type], i;
			if (list) {
				i = list.length;
				while (--i > -1) {
					if (list[i].c === callback) {
						list.splice(i, 1);
						return;
					}
				}
			}
		};

		p.dispatchEvent = function(type) {
			var list = this._listeners[type],
				i, t, listener;
			if (list) {
				i = list.length;
				t = this._eventTarget;
				while (--i > -1) {
					listener = list[i];
					if (listener) {
						if (listener.up) {
							listener.c.call(listener.s || t, {type:type, target:t});
						} else {
							listener.c.call(listener.s || t);
						}
					}
				}
			}
		};


/*
 * ----------------------------------------------------------------
 * Ticker
 * ----------------------------------------------------------------
 */
 		var _reqAnimFrame = window.requestAnimationFrame,
			_cancelAnimFrame = window.cancelAnimationFrame,
			_getTime = Date.now || function() {return new Date().getTime();},
			_lastUpdate = _getTime();

		//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
		a = ["ms","moz","webkit","o"];
		i = a.length;
		while (--i > -1 && !_reqAnimFrame) {
			_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
			_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
		}

		_class("Ticker", function(fps, useRAF) {
			var _self = this,
				_startTime = _getTime(),
				_useRAF = (useRAF !== false && _reqAnimFrame),
				_lagThreshold = 500,
				_adjustedLag = 33,
				_tickWord = "tick", //helps reduce gc burden
				_fps, _req, _id, _gap, _nextTime,
				_tick = function(manual) {
					var elapsed = _getTime() - _lastUpdate,
						overlap, dispatch;
					if (elapsed > _lagThreshold) {
						_startTime += elapsed - _adjustedLag;
					}
					_lastUpdate += elapsed;
					_self.time = (_lastUpdate - _startTime) / 1000;
					overlap = _self.time - _nextTime;
					if (!_fps || overlap > 0 || manual === true) {
						_self.frame++;
						_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
						dispatch = true;
					}
					if (manual !== true) { //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
						_id = _req(_tick);
					}
					if (dispatch) {
						_self.dispatchEvent(_tickWord);
					}
				};

			EventDispatcher.call(_self);
			_self.time = _self.frame = 0;
			_self.tick = function() {
				_tick(true);
			};

			_self.lagSmoothing = function(threshold, adjustedLag) {
				_lagThreshold = threshold || (1 / _tinyNum); //zero should be interpreted as basically unlimited
				_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
			};

			_self.sleep = function() {
				if (_id == null) {
					return;
				}
				if (!_useRAF || !_cancelAnimFrame) {
					clearTimeout(_id);
				} else {
					_cancelAnimFrame(_id);
				}
				_req = _emptyFunc;
				_id = null;
				if (_self === _ticker) {
					_tickerActive = false;
				}
			};

			_self.wake = function() {
				if (_id !== null) {
					_self.sleep();
				} else if (_self.frame > 10) { //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
					_lastUpdate = _getTime() - _lagThreshold + 5;
				}
				_req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) { return setTimeout(f, ((_nextTime - _self.time) * 1000 + 1) | 0); } : _reqAnimFrame;
				if (_self === _ticker) {
					_tickerActive = true;
				}
				_tick(2);
			};

			_self.fps = function(value) {
				if (!arguments.length) {
					return _fps;
				}
				_fps = value;
				_gap = 1 / (_fps || 60);
				_nextTime = this.time + _gap;
				_self.wake();
			};

			_self.useRAF = function(value) {
				if (!arguments.length) {
					return _useRAF;
				}
				_self.sleep();
				_useRAF = value;
				_self.fps(_fps);
			};
			_self.fps(fps);

			//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
			setTimeout(function() {
				if (_useRAF && (!_id || _self.frame < 5)) {
					_self.useRAF(false);
				}
			}, 1500);
		});

		p = gs.Ticker.prototype = new gs.events.EventDispatcher();
		p.constructor = gs.Ticker;


/*
 * ----------------------------------------------------------------
 * Animation
 * ----------------------------------------------------------------
 */
		var Animation = _class("core.Animation", function(duration, vars) {
				this.vars = vars = vars || {};
				this._duration = this._totalDuration = duration || 0;
				this._delay = Number(vars.delay) || 0;
				this._timeScale = 1;
				this._active = (vars.immediateRender === true);
				this.data = vars.data;
				this._reversed = (vars.reversed === true);

				if (!_rootTimeline) {
					return;
				}
				if (!_tickerActive) { //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
					_ticker.wake();
				}

				var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
				tl.add(this, tl._time);

				if (this.vars.paused) {
					this.paused(true);
				}
			});

		_ticker = Animation.ticker = new gs.Ticker();
		p = Animation.prototype;
		p._dirty = p._gc = p._initted = p._paused = false;
		p._totalTime = p._time = 0;
		p._rawPrevTime = -1;
		p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
		p._paused = false;


		//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
		var _checkTimeout = function() {
				if (_tickerActive && _getTime() - _lastUpdate > 2000) {
					_ticker.wake();
				}
				setTimeout(_checkTimeout, 2000);
			};
		_checkTimeout();


		p.play = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.reversed(false).paused(false);
		};

		p.pause = function(atTime, suppressEvents) {
			if (atTime != null) {
				this.seek(atTime, suppressEvents);
			}
			return this.paused(true);
		};

		p.resume = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.paused(false);
		};

		p.seek = function(time, suppressEvents) {
			return this.totalTime(Number(time), suppressEvents !== false);
		};

		p.restart = function(includeDelay, suppressEvents) {
			return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, (suppressEvents !== false), true);
		};

		p.reverse = function(from, suppressEvents) {
			if (from != null) {
				this.seek((from || this.totalDuration()), suppressEvents);
			}
			return this.reversed(true).paused(false);
		};

		p.render = function(time, suppressEvents, force) {
			//stub - we override this method in subclasses.
		};

		p.invalidate = function() {
			this._time = this._totalTime = 0;
			this._initted = this._gc = false;
			this._rawPrevTime = -1;
			if (this._gc || !this.timeline) {
				this._enabled(true);
			}
			return this;
		};

		p.isActive = function() {
			var tl = this._timeline, //the 2 root timelines won't have a _timeline; they're always active.
				startTime = this._startTime,
				rawTime;
			return (!tl || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale));
		};

		p._enabled = function (enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			this._gc = !enabled;
			this._active = this.isActive();
			if (ignoreTimeline !== true) {
				if (enabled && !this.timeline) {
					this._timeline.add(this, this._startTime - this._delay);
				} else if (!enabled && this.timeline) {
					this._timeline._remove(this, true);
				}
			}
			return false;
		};


		p._kill = function(vars, target) {
			return this._enabled(false, false);
		};

		p.kill = function(vars, target) {
			this._kill(vars, target);
			return this;
		};

		p._uncache = function(includeSelf) {
			var tween = includeSelf ? this : this.timeline;
			while (tween) {
				tween._dirty = true;
				tween = tween.timeline;
			}
			return this;
		};

		p._swapSelfInParams = function(params) {
			var i = params.length,
				copy = params.concat();
			while (--i > -1) {
				if (params[i] === "{self}") {
					copy[i] = this;
				}
			}
			return copy;
		};

//----Animation getters/setters --------------------------------------------------------

		p.eventCallback = function(type, callback, params, scope) {
			if ((type || "").substr(0,2) === "on") {
				var v = this.vars;
				if (arguments.length === 1) {
					return v[type];
				}
				if (callback == null) {
					delete v[type];
				} else {
					v[type] = callback;
					v[type + "Params"] = (_isArray(params) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
					v[type + "Scope"] = scope;
				}
				if (type === "onUpdate") {
					this._onUpdate = callback;
				}
			}
			return this;
		};

		p.delay = function(value) {
			if (!arguments.length) {
				return this._delay;
			}
			if (this._timeline.smoothChildTiming) {
				this.startTime( this._startTime + value - this._delay );
			}
			this._delay = value;
			return this;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				this._dirty = false;
				return this._duration;
			}
			this._duration = this._totalDuration = value;
			this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
			if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
				this.totalTime(this._totalTime * (value / this._duration), true);
			}
			return this;
		};

		p.totalDuration = function(value) {
			this._dirty = false;
			return (!arguments.length) ? this._totalDuration : this.duration(value);
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			return this.totalTime((value > this._duration) ? this._duration : value, suppressEvents);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (!arguments.length) {
				return this._totalTime;
			}
			if (this._timeline) {
				if (time < 0 && !uncapped) {
					time += this.totalDuration();
				}
				if (this._timeline.smoothChildTiming) {
					if (this._dirty) {
						this.totalDuration();
					}
					var totalDuration = this._totalDuration,
						tl = this._timeline;
					if (time > totalDuration && !uncapped) {
						time = totalDuration;
					}
					this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale);
					if (!tl._dirty) { //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
						this._uncache(false);
					}
					//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
					if (tl._timeline) {
						while (tl._timeline) {
							if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
								tl.totalTime(tl._totalTime, true);
							}
							tl = tl._timeline;
						}
					}
				}
				if (this._gc) {
					this._enabled(true, false);
				}
				if (this._totalTime !== time || this._duration === 0) {
					this.render(time, suppressEvents, false);
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
						_lazyRender();
					}
				}
			}
			return this;
		};

		p.progress = p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime(this.duration() * value, suppressEvents);
		};

		p.startTime = function(value) {
			if (!arguments.length) {
				return this._startTime;
			}
			if (value !== this._startTime) {
				this._startTime = value;
				if (this.timeline) if (this.timeline._sortChildren) {
					this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			return this;
		};

		p.endTime = function(includeRepeats) {
			return this._startTime + ((includeRepeats != false) ? this.totalDuration() : this.duration()) / this._timeScale;
		};

		p.timeScale = function(value) {
			if (!arguments.length) {
				return this._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			if (this._timeline && this._timeline.smoothChildTiming) {
				var pauseTime = this._pauseTime,
					t = (pauseTime || pauseTime === 0) ? pauseTime : this._timeline.totalTime();
				this._startTime = t - ((t - this._startTime) * this._timeScale / value);
			}
			this._timeScale = value;
			return this._uncache(false);
		};

		p.reversed = function(value) {
			if (!arguments.length) {
				return this._reversed;
			}
			if (value != this._reversed) {
				this._reversed = value;
				this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
			}
			return this;
		};

		p.paused = function(value) {
			if (!arguments.length) {
				return this._paused;
			}
			var tl = this._timeline,
				raw, elapsed;
			if (value != this._paused) if (tl) {
				if (!_tickerActive && !value) {
					_ticker.wake();
				}
				raw = tl.rawTime();
				elapsed = raw - this._pauseTime;
				if (!value && tl.smoothChildTiming) {
					this._startTime += elapsed;
					this._uncache(false);
				}
				this._pauseTime = value ? raw : null;
				this._paused = value;
				this._active = this.isActive();
				if (!value && elapsed !== 0 && this._initted && this.duration()) {
					this.render((tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale), true, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
				}
			}
			if (this._gc && !value) {
				this._enabled(true, false);
			}
			return this;
		};


/*
 * ----------------------------------------------------------------
 * SimpleTimeline
 * ----------------------------------------------------------------
 */
		var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
			Animation.call(this, 0, vars);
			this.autoRemoveChildren = this.smoothChildTiming = true;
		});

		p = SimpleTimeline.prototype = new Animation();
		p.constructor = SimpleTimeline;
		p.kill()._gc = false;
		p._first = p._last = p._recent = null;
		p._sortChildren = false;

		p.add = p.insert = function(child, position, align, stagger) {
			var prevTween, st;
			child._startTime = Number(position || 0) + child._delay;
			if (child._paused) if (this !== child._timeline) { //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
				child._pauseTime = child._startTime + ((this.rawTime() - child._startTime) / child._timeScale);
			}
			if (child.timeline) {
				child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
			}
			child.timeline = child._timeline = this;
			if (child._gc) {
				child._enabled(true, true);
			}
			prevTween = this._last;
			if (this._sortChildren) {
				st = child._startTime;
				while (prevTween && prevTween._startTime > st) {
					prevTween = prevTween._prev;
				}
			}
			if (prevTween) {
				child._next = prevTween._next;
				prevTween._next = child;
			} else {
				child._next = this._first;
				this._first = child;
			}
			if (child._next) {
				child._next._prev = child;
			} else {
				this._last = child;
			}
			child._prev = prevTween;
			this._recent = child;
			if (this._timeline) {
				this._uncache(true);
			}
			return this;
		};

		p._remove = function(tween, skipDisable) {
			if (tween.timeline === this) {
				if (!skipDisable) {
					tween._enabled(false, true);
				}

				if (tween._prev) {
					tween._prev._next = tween._next;
				} else if (this._first === tween) {
					this._first = tween._next;
				}
				if (tween._next) {
					tween._next._prev = tween._prev;
				} else if (this._last === tween) {
					this._last = tween._prev;
				}
				tween._next = tween._prev = tween.timeline = null;
				if (tween === this._recent) {
					this._recent = this._last;
				}

				if (this._timeline) {
					this._uncache(true);
				}
			}
			return this;
		};

		p.render = function(time, suppressEvents, force) {
			var tween = this._first,
				next;
			this._totalTime = this._time = this._rawPrevTime = time;
			while (tween) {
				next = tween._next; //record it here because the value could change after rendering...
				if (tween._active || (time >= tween._startTime && !tween._paused)) {
					if (!tween._reversed) {
						tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
					} else {
						tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
					}
				}
				tween = next;
			}
		};

		p.rawTime = function() {
			if (!_tickerActive) {
				_ticker.wake();
			}
			return this._totalTime;
		};

/*
 * ----------------------------------------------------------------
 * TweenLite
 * ----------------------------------------------------------------
 */
		var TweenLite = _class("TweenLite", function(target, duration, vars) {
				Animation.call(this, duration, vars);
				this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

				if (target == null) {
					throw "Cannot tween a null target.";
				}

				this.target = target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;

				var isSelector = (target.jquery || (target.length && target !== window && target[0] && (target[0] === window || (target[0].nodeType && target[0].style && !target.nodeType)))),
					overwrite = this.vars.overwrite,
					i, targ, targets;

				this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === "number") ? overwrite >> 0 : _overwriteLookup[overwrite];

				if ((isSelector || target instanceof Array || (target.push && _isArray(target))) && typeof(target[0]) !== "number") {
					this._targets = targets = _slice(target);  //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
					this._propLookup = [];
					this._siblings = [];
					for (i = 0; i < targets.length; i++) {
						targ = targets[i];
						if (!targ) {
							targets.splice(i--, 1);
							continue;
						} else if (typeof(targ) === "string") {
							targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
							if (typeof(targ) === "string") {
								targets.splice(i+1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
							}
							continue;
						} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || (targ[0].nodeType && targ[0].style && !targ.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
							targets.splice(i--, 1);
							this._targets = targets = targets.concat(_slice(targ));
							continue;
						}
						this._siblings[i] = _register(targ, this, false);
						if (overwrite === 1) if (this._siblings[i].length > 1) {
							_applyOverwrite(targ, this, null, 1, this._siblings[i]);
						}
					}

				} else {
					this._propLookup = {};
					this._siblings = _register(target, this, false);
					if (overwrite === 1) if (this._siblings.length > 1) {
						_applyOverwrite(target, this, null, 1, this._siblings);
					}
				}
				if (this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender !== false)) {
					this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
					this.render(-this._delay);
				}
			}, true),
			_isSelector = function(v) {
				return (v && v.length && v !== window && v[0] && (v[0] === window || (v[0].nodeType && v[0].style && !v.nodeType))); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
			},
			_autoCSS = function(vars, target) {
				var css = {},
					p;
				for (p in vars) {
					if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))) { //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
						css[p] = vars[p];
						delete vars[p];
					}
				}
				vars.css = css;
			};

		p = TweenLite.prototype = new Animation();
		p.constructor = TweenLite;
		p.kill()._gc = false;

//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

		p.ratio = 0;
		p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
		p._notifyPluginsOfEnabled = p._lazy = false;

		TweenLite.version = "1.16.0";
		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
		TweenLite.defaultOverwrite = "auto";
		TweenLite.ticker = _ticker;
		TweenLite.autoSleep = 120;
		TweenLite.lagSmoothing = function(threshold, adjustedLag) {
			_ticker.lagSmoothing(threshold, adjustedLag);
		};

		TweenLite.selector = window.$ || window.jQuery || function(e) {
			var selector = window.$ || window.jQuery;
			if (selector) {
				TweenLite.selector = selector;
				return selector(e);
			}
			return (typeof(document) === "undefined") ? e : (document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById((e.charAt(0) === "#") ? e.substr(1) : e));
		};

		var _lazyTweens = [],
			_lazyLookup = {},
			_internals = TweenLite._internals = {isArray:_isArray, isSelector:_isSelector, lazyTweens:_lazyTweens}, //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
			_plugins = TweenLite._plugins = {},
			_tweenLookup = _internals.tweenLookup = {},
			_tweenLookupNum = 0,
			_reservedProps = _internals.reservedProps = {ease:1, delay:1, overwrite:1, onComplete:1, onCompleteParams:1, onCompleteScope:1, useFrames:1, runBackwards:1, startAt:1, onUpdate:1, onUpdateParams:1, onUpdateScope:1, onStart:1, onStartParams:1, onStartScope:1, onReverseComplete:1, onReverseCompleteParams:1, onReverseCompleteScope:1, onRepeat:1, onRepeatParams:1, onRepeatScope:1, easeParams:1, yoyo:1, immediateRender:1, repeat:1, repeatDelay:1, data:1, paused:1, reversed:1, autoCSS:1, lazy:1, onOverwrite:1},
			_overwriteLookup = {none:0, all:1, auto:2, concurrent:3, allOnStart:4, preexisting:5, "true":1, "false":0},
			_rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
			_rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
			_nextGCFrame = 30,
			_lazyRender = _internals.lazyRender = function() {
				var i = _lazyTweens.length,
					tween;
				_lazyLookup = {};
				while (--i > -1) {
					tween = _lazyTweens[i];
					if (tween && tween._lazy !== false) {
						tween.render(tween._lazy[0], tween._lazy[1], true);
						tween._lazy = false;
					}
				}
				_lazyTweens.length = 0;
			};

		_rootTimeline._startTime = _ticker.time;
		_rootFramesTimeline._startTime = _ticker.frame;
		_rootTimeline._active = _rootFramesTimeline._active = true;
		setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

		Animation._updateRoot = TweenLite.render = function() {
				var i, a, p;
				if (_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
					_lazyRender();
				}
				_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
				_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
				if (_lazyTweens.length) {
					_lazyRender();
				}
				if (_ticker.frame >= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
					_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
					for (p in _tweenLookup) {
						a = _tweenLookup[p].tweens;
						i = a.length;
						while (--i > -1) {
							if (a[i]._gc) {
								a.splice(i, 1);
							}
						}
						if (a.length === 0) {
							delete _tweenLookup[p];
						}
					}
					//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
					p = _rootTimeline._first;
					if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
						while (p && p._paused) {
							p = p._next;
						}
						if (!p) {
							_ticker.sleep();
						}
					}
				}
			};

		_ticker.addEventListener("tick", Animation._updateRoot);

		var _register = function(target, tween, scrub) {
				var id = target._gsTweenID, a, i;
				if (!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {
					_tweenLookup[id] = {target:target, tweens:[]};
				}
				if (tween) {
					a = _tweenLookup[id].tweens;
					a[(i = a.length)] = tween;
					if (scrub) {
						while (--i > -1) {
							if (a[i] === tween) {
								a.splice(i, 1);
							}
						}
					}
				}
				return _tweenLookup[id].tweens;
			},

			_onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
				var func = overwrittenTween.vars.onOverwrite, r1, r2;
				if (func) {
					r1 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				func = TweenLite.onOverwrite;
				if (func) {
					r2 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				return (r1 !== false && r2 !== false);
			},
			_applyOverwrite = function(target, tween, props, mode, siblings) {
				var i, changed, curTween, l;
				if (mode === 1 || mode >= 4) {
					l = siblings.length;
					for (i = 0; i < l; i++) {
						if ((curTween = siblings[i]) !== tween) {
							if (!curTween._gc) {
								if (_onOverwrite(curTween, tween) && curTween._enabled(false, false)) {
									changed = true;
								}
							}
						} else if (mode === 5) {
							break;
						}
					}
					return changed;
				}
				//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
				var startTime = tween._startTime + _tinyNum,
					overlaps = [],
					oCount = 0,
					zeroDur = (tween._duration === 0),
					globalStart;
				i = siblings.length;
				while (--i > -1) {
					if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
						//ignore
					} else if (curTween._timeline !== tween._timeline) {
						globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
						if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
							overlaps[oCount++] = curTween;
						}
					} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
						overlaps[oCount++] = curTween;
					}
				}

				i = oCount;
				while (--i > -1) {
					curTween = overlaps[i];
					if (mode === 2) if (curTween._kill(props, target, tween)) {
						changed = true;
					}
					if (mode !== 2 || (!curTween._firstPT && curTween._initted)) {
						if (mode !== 2 && !_onOverwrite(curTween, tween)) {
							continue;
						}
						if (curTween._enabled(false, false)) { //if all property tweens have been overwritten, kill the tween.
							changed = true;
						}
					}
				}
				return changed;
			},

			_checkOverlap = function(tween, reference, zeroDur) {
				var tl = tween._timeline,
					ts = tl._timeScale,
					t = tween._startTime;
				while (tl._timeline) {
					t += tl._startTime;
					ts *= tl._timeScale;
					if (tl._paused) {
						return -100;
					}
					tl = tl._timeline;
				}
				t /= ts;
				return (t > reference) ? t - reference : ((zeroDur && t === reference) || (!tween._initted && t - reference < 2 * _tinyNum)) ? _tinyNum : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum) ? 0 : t - reference - _tinyNum;
			};


//---- TweenLite instance methods -----------------------------------------------------------------------------

		p._init = function() {
			var v = this.vars,
				op = this._overwrittenProps,
				dur = this._duration,
				immediate = !!v.immediateRender,
				ease = v.ease,
				i, initPlugins, pt, p, startVars;
			if (v.startAt) {
				if (this._startAt) {
					this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
					this._startAt.kill();
				}
				startVars = {};
				for (p in v.startAt) { //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
					startVars[p] = v.startAt[p];
				}
				startVars.overwrite = false;
				startVars.immediateRender = true;
				startVars.lazy = (immediate && v.lazy !== false);
				startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
				this._startAt = TweenLite.to(this.target, 0, startVars);
				if (immediate) {
					if (this._time > 0) {
						this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
					} else if (dur !== 0) {
						return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
					}
				}
			} else if (v.runBackwards && dur !== 0) {
				//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
				if (this._startAt) {
					this._startAt.render(-1, true);
					this._startAt.kill();
					this._startAt = null;
				} else {
					if (this._time !== 0) { //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
						immediate = false;
					}
					pt = {};
					for (p in v) { //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
						if (!_reservedProps[p] || p === "autoCSS") {
							pt[p] = v[p];
						}
					}
					pt.overwrite = 0;
					pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
					pt.lazy = (immediate && v.lazy !== false);
					pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
					this._startAt = TweenLite.to(this.target, 0, pt);
					if (!immediate) {
						this._startAt._init(); //ensures that the initial values are recorded
						this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
						if (this.vars.immediateRender) {
							this._startAt = null;
						}
					} else if (this._time === 0) {
						return;
					}
				}
			}
			this._ease = ease = (!ease) ? TweenLite.defaultEase : (ease instanceof Ease) ? ease : (typeof(ease) === "function") ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
			if (v.easeParams instanceof Array && ease.config) {
				this._ease = ease.config.apply(ease, v.easeParams);
			}
			this._easeType = this._ease._type;
			this._easePower = this._ease._power;
			this._firstPT = null;

			if (this._targets) {
				i = this._targets.length;
				while (--i > -1) {
					if ( this._initProps( this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (op ? op[i] : null)) ) {
						initPlugins = true;
					}
				}
			} else {
				initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op);
			}

			if (initPlugins) {
				TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
			}
			if (op) if (!this._firstPT) if (typeof(this.target) !== "function") { //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
				this._enabled(false, false);
			}
			if (v.runBackwards) {
				pt = this._firstPT;
				while (pt) {
					pt.s += pt.c;
					pt.c = -pt.c;
					pt = pt._next;
				}
			}
			this._onUpdate = v.onUpdate;
			this._initted = true;
		};

		p._initProps = function(target, propLookup, siblings, overwrittenProps) {
			var p, i, initPlugins, plugin, pt, v;
			if (target == null) {
				return false;
			}

			if (_lazyLookup[target._gsTweenID]) {
				_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
			}

			if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) { //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
				_autoCSS(this.vars, target);
			}
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push && _isArray(v))) if (v.join("").indexOf("{self}") !== -1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
					//pg - isPlugin 	[boolean]
					//pr - priority		[number]
					this._firstPT = pt = {_next:this._firstPT, t:plugin, p:"setRatio", s:0, c:1, f:true, n:p, pg:true, pr:plugin._priority};
					i = plugin._overwriteProps.length;
					while (--i > -1) {
						propLookup[plugin._overwriteProps[i]] = this._firstPT;
					}
					if (plugin._priority || plugin._onInitAllProps) {
						initPlugins = true;
					}
					if (plugin._onDisable || plugin._onEnable) {
						this._notifyPluginsOfEnabled = true;
					}

				} else {
					this._firstPT = propLookup[p] = pt = {_next:this._firstPT, t:target, p:p, f:(typeof(target[p]) === "function"), n:p, pg:false, pr:0};
					pt.s = (!pt.f) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
					pt.c = (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : (Number(v) - pt.s) || 0;
				}
				if (pt) if (pt._next) {
					pt._next._prev = pt;
				}
			}

			if (overwrittenProps) if (this._kill(overwrittenProps, target)) { //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
				return this._initProps(target, propLookup, siblings, overwrittenProps);
			}
			if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
				this._kill(propLookup, target);
				return this._initProps(target, propLookup, siblings, overwrittenProps);
			}
			if (this._firstPT) if ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration)) { //zero duration tweens don't lazy render by default; everything else does.
				_lazyLookup[target._gsTweenID] = true;
			}
			return initPlugins;
		};

		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time >= duration) {
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = "onComplete";
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (time === 0 || prevRawPrevTime < 0 || (prevRawPrevTime === _tinyNum && this.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;

				if (this._easeType) {
					var r = time / duration, type = this._easeType, pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else {
					this.ratio = this._ease.getRatio(time / duration);
				}
			}

			if (this._time === prevTime && !force) {
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
					this._time = this._totalTime = prevTime;
					this._rawPrevTime = prevRawPrevTime;
					_lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) { //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
				this._lazy = false;
			}
			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true;  //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTime === 0) {
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
					this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
				}
			}
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}

			if (this._onUpdate) {
				if (time < 0) if (this._startAt && time !== -0.0001) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._time !== prevTime || isComplete) {
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
				}
			}
			if (callback) if (!this._gc || force) { //check _gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) { //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};

		p._kill = function(vars, target, overwritingTween) {
			if (vars === "all") {
				vars = null;
			}
			if (vars == null) if (target == null || target === this.target) {
				this._lazy = false;
				return this._enabled(false, false);
			}
			target = (typeof(target) !== "string") ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
			var i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				while (--i > -1) {
					if (this._kill(vars, target[i])) {
						changed = true;
					}
				}
			} else {
				if (this._targets) {
					i = this._targets.length;
					while (--i > -1) {
						if (target === this._targets[i]) {
							propLookup = this._propLookup[i] || {};
							this._overwrittenProps = this._overwrittenProps || [];
							overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
							break;
						}
					}
				} else if (target !== this.target) {
					return false;
				} else {
					propLookup = this._propLookup;
					overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
				}

				if (propLookup) {
					killProps = vars || propLookup;
					record = (vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof(vars) !== "object" || !vars._tempKill)); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
					if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
						for (p in killProps) {
							if (propLookup[p]) {
								if (!killed) {
									killed = [];
								}
								killed.push(p);
							}
						}
						if (!_onOverwrite(this, overwritingTween, target, killed)) { //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
							return false;
						}
					}

					for (p in killProps) {
						if ((pt = propLookup[p])) {
							if (pt.pg && pt.t._kill(killProps)) {
								changed = true; //some plugins need to be notified so they can perform cleanup tasks first
							}
							if (!pt.pg || pt.t._overwriteProps.length === 0) {
								if (pt._prev) {
									pt._prev._next = pt._next;
								} else if (pt === this._firstPT) {
									this._firstPT = pt._next;
								}
								if (pt._next) {
									pt._next._prev = pt._prev;
								}
								pt._next = pt._prev = null;
							}
							delete propLookup[p];
						}
						if (record) {
							overwrittenProps[p] = 1;
						}
					}
					if (!this._firstPT && this._initted) { //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
						this._enabled(false, false);
					}
				}
			}
			return changed;
		};

		p.invalidate = function() {
			if (this._notifyPluginsOfEnabled) {
				TweenLite._onPluginEvent("_onDisable", this);
			}
			this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
			this._notifyPluginsOfEnabled = this._active = this._lazy = false;
			this._propLookup = (this._targets) ? {} : [];
			Animation.prototype.invalidate.call(this);
			if (this.vars.immediateRender) {
				this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
				this.render(-this._delay);
			}
			return this;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (enabled && this._gc) {
				var targets = this._targets,
					i;
				if (targets) {
					i = targets.length;
					while (--i > -1) {
						this._siblings[i] = _register(targets[i], this, true);
					}
				} else {
					this._siblings = _register(this.target, this, true);
				}
			}
			Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
			if (this._notifyPluginsOfEnabled) if (this._firstPT) {
				return TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);
			}
			return false;
		};


//----TweenLite static methods -----------------------------------------------------

		TweenLite.to = function(target, duration, vars) {
			return new TweenLite(target, duration, vars);
		};

		TweenLite.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenLite(target, duration, vars);
		};

		TweenLite.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenLite(target, duration, toVars);
		};

		TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenLite(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, onCompleteScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, onReverseCompleteScope:scope, immediateRender:false, lazy:false, useFrames:useFrames, overwrite:0});
		};

		TweenLite.set = function(target, vars) {
			return new TweenLite(target, 0, vars);
		};

		TweenLite.getTweensOf = function(target, onlyActive) {
			if (target == null) { return []; }
			target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
			var i, a, j, t;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				a = [];
				while (--i > -1) {
					a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
				}
				i = a.length;
				//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
				while (--i > -1) {
					t = a[i];
					j = i;
					while (--j > -1) {
						if (t === a[j]) {
							a.splice(i, 1);
						}
					}
				}
			} else {
				a = _register(target).concat();
				i = a.length;
				while (--i > -1) {
					if (a[i]._gc || (onlyActive && !a[i].isActive())) {
						a.splice(i, 1);
					}
				}
			}
			return a;
		};

		TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
			if (typeof(onlyActive) === "object") {
				vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i > -1) {
				a[i]._kill(vars, target);
			}
		};



/*
 * ----------------------------------------------------------------
 * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
 * ----------------------------------------------------------------
 */
		var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
					this._overwriteProps = (props || "").split(",");
					this._propName = this._overwriteProps[0];
					this._priority = priority || 0;
					this._super = TweenPlugin.prototype;
				}, true);

		p = TweenPlugin.prototype;
		TweenPlugin.version = "1.10.1";
		TweenPlugin.API = 2;
		p._firstPT = null;

		p._addTween = function(target, prop, start, end, overwriteProp, round) {
			var c, pt;
			if (end != null && (c = (typeof(end) === "number" || end.charAt(1) !== "=") ? Number(end) - start : parseInt(end.charAt(0) + "1", 10) * Number(end.substr(2)))) {
				this._firstPT = pt = {_next:this._firstPT, t:target, p:prop, s:start, c:c, f:(typeof(target[prop]) === "function"), n:overwriteProp || prop, r:round};
				if (pt._next) {
					pt._next._prev = pt;
				}
				return pt;
			}
		};

		p.setRatio = function(v) {
			var pt = this._firstPT,
				min = 0.000001,
				val;
			while (pt) {
				val = pt.c * v + pt.s;
				if (pt.r) {
					val = Math.round(val);
				} else if (val < min) if (val > -min) { //prevents issues with converting very small numbers to strings in the browser
					val = 0;
				}
				if (pt.f) {
					pt.t[pt.p](val);
				} else {
					pt.t[pt.p] = val;
				}
				pt = pt._next;
			}
		};

		p._kill = function(lookup) {
			var a = this._overwriteProps,
				pt = this._firstPT,
				i;
			if (lookup[this._propName] != null) {
				this._overwriteProps = [];
			} else {
				i = a.length;
				while (--i > -1) {
					if (lookup[a[i]] != null) {
						a.splice(i, 1);
					}
				}
			}
			while (pt) {
				if (lookup[pt.n] != null) {
					if (pt._next) {
						pt._next._prev = pt._prev;
					}
					if (pt._prev) {
						pt._prev._next = pt._next;
						pt._prev = null;
					} else if (this._firstPT === pt) {
						this._firstPT = pt._next;
					}
				}
				pt = pt._next;
			}
			return false;
		};

		p._roundProps = function(lookup, value) {
			var pt = this._firstPT;
			while (pt) {
				if (lookup[this._propName] || (pt.n != null && lookup[ pt.n.split(this._propName + "_").join("") ])) { //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
					pt.r = value;
				}
				pt = pt._next;
			}
		};

		TweenLite._onPluginEvent = function(type, tween) {
			var pt = tween._firstPT,
				changed, pt2, first, last, next;
			if (type === "_onInitAllProps") {
				//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				pt = tween._firstPT = first;
			}
			while (pt) {
				if (pt.pg) if (typeof(pt.t[type]) === "function") if (pt.t[type]()) {
					changed = true;
				}
				pt = pt._next;
			}
			return changed;
		};

		TweenPlugin.activate = function(plugins) {
			var i = plugins.length;
			while (--i > -1) {
				if (plugins[i].API === TweenPlugin.API) {
					_plugins[(new plugins[i]())._propName] = plugins[i];
				}
			}
			return true;
		};

		//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
		_gsDefine.plugin = function(config) {
			if (!config || !config.propName || !config.init || !config.API) { throw "illegal plugin definition."; }
			var propName = config.propName,
				priority = config.priority || 0,
				overwriteProps = config.overwriteProps,
				map = {init:"_onInitTween", set:"setRatio", kill:"_kill", round:"_roundProps", initAll:"_onInitAllProps"},
				Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin",
					function() {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}, (config.global === true)),
				p = Plugin.prototype = new TweenPlugin(propName),
				prop;
			p.constructor = Plugin;
			Plugin.API = config.API;
			for (prop in map) {
				if (typeof(config[prop]) === "function") {
					p[map[prop]] = config[prop];
				}
			}
			Plugin.version = config.version;
			TweenPlugin.activate([Plugin]);
			return Plugin;
		};


		//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
		a = window._gsQueue;
		if (a) {
			for (i = 0; i < a.length; i++) {
				a[i]();
			}
			for (p in _defLookup) {
				if (!_defLookup[p].func) {
					window.console.log("GSAP encountered missing dependency: com.greensock." + p);
				}
			}
		}

		_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

})((typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window, "TweenMax");
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/luke/dev/040715/vendor/hammerjs/hammer.js":[function(require,module,exports){
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge]
 * @returns {Object} dest
 */
function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
function merge(dest, src) {
    return extend(dest, src, true);
}

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        extend(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return (doc.defaultView || doc.parentWindow);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = last.deltaX - input.deltaX;
        var deltaY = last.deltaY - input.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.allow = true; // used by Input.TouchMouse to disable mouse events
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        if (!this.pressed || !this.allow) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.id = uniqueId();

    this.manager = null;
    this.options = merge(options || {}, this.defaults);

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        extend(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(withState) {
            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(true);
        }

        emit(); // simple 'eventName' events

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(true);
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = extend({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        this._super.emit.call(this, input);
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            this.manager.emit(this.options.event + inOut, input);
        }
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 500, // minimal time of the pointer to be pressed
        threshold: 5 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.65,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.velocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.velocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.velocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.direction &&
            input.distance > this.options.threshold &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 2, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED ) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create an manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.4';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ['rotate']],
        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    options = options || {};

    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        extend(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        var recognizers = this.recognizers;
        recognizer = this.get(recognizer);
        recognizers.splice(inArray(recognizers, recognizer), 1);

        this.touchAction.update();
        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

if (typeof define == TYPE_FUNCTION && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],"/Users/luke/dev/040715/vendor/page/page.js":[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.page=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
  /* globals require, module */

/**
   * Module dependencies.
   */

  var pathtoRegexp = require('path-to-regexp');

  /**
   * Module exports.
   */

  module.exports = page;

  /**
   * To work properly with the URL
   * history.location generated polyfill in https://github.com/devote/HTML5-History-API
   */

  var location = window.history.location || window.location;

  /**
   * Perform initial dispatch.
   */

  var dispatch = true;

  /**
   * Base path.
   */

  var base = '';

  /**
   * Running flag.
   */

  var running;

  /**
  * HashBang option
  */

  var hashbang = false;

  /**
   * Previous context, for capturing
   * page exit events.
   */

  var prevContext;

  /**
   * Register `path` with callback `fn()`,
   * or route `path`, or redirection,
   * or `page.start()`.
   *
   *   page(fn);
   *   page('*', fn);
   *   page('/user/:id', load, user);
   *   page('/user/' + user.id, { some: 'thing' });
   *   page('/user/' + user.id);
   *   page('/from', '/to')
   *   page();
   *
   * @param {String|Function} path
   * @param {Function} fn...
   * @api public
   */

  function page(path, fn) {
    // <callback>
    if ('function' === typeof path) {
      return page('*', path);
    }

    // route <path> to <callback ...>
    if ('function' === typeof fn) {
      var route = new Route(path);
      for (var i = 1; i < arguments.length; ++i) {
        page.callbacks.push(route.middleware(arguments[i]));
      }
    // show <path> with [state]
    } else if ('string' == typeof path) {
      'string' === typeof fn
        ? page.redirect(path, fn)
        : page.show(path, fn);
    // start [options]
    } else {
      page.start(path);
    }
  }

  /**
   * Callback functions.
   */

  page.callbacks = [];
  page.exits = [];

  /**
   * Get or set basepath to `path`.
   *
   * @param {String} path
   * @api public
   */

  page.base = function(path){
    if (0 === arguments.length) return base;
    base = path;
  };

  /**
   * Bind with the given `options`.
   *
   * Options:
   *
   *    - `click` bind to click events [true]
   *    - `popstate` bind to popstate [true]
   *    - `dispatch` perform initial dispatch [true]
   *
   * @param {Object} options
   * @api public
   */

  page.start = function(options){
    options = options || {};
    if (running) return;
    running = true;
    if (false === options.dispatch) dispatch = false;
    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);
    if (false !== options.click) window.addEventListener('click', onclick, false);
    if (true === options.hashbang) hashbang = true;
    if (!dispatch) return;
    var url = (hashbang && ~location.hash.indexOf('#!'))
      ? location.hash.substr(2) + location.search
      : location.pathname + location.search + location.hash;
    page.replace(url, null, true, dispatch);
  };

  /**
   * Unbind click and popstate event handlers.
   *
   * @api public
   */

  page.stop = function(){
    if (!running) return;
    running = false;
    window.removeEventListener('click', onclick, false);
    window.removeEventListener('popstate', onpopstate, false);
  };

  /**
   * Show `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @param {Boolean} dispatch
   * @return {Context}
   * @api public
   */

  page.show = function(path, state, dispatch){
    var ctx = new Context(path, state);
    if (false !== dispatch) page.dispatch(ctx);
    if (false !== ctx.handled) ctx.pushState();
    return ctx;
  };

  /**
   * Register route to redirect from one path to other
   * or just redirect to another route
   *
   * @param {String} from - if param 'to' is undefined redirects to 'from'
   * @param {String} [to]
   * @api public
   */
  page.redirect = function(from, to) {
    // Define route from a path to another
    if ('string' === typeof from && 'string' === typeof to) {
      page(from, function (e) {
        setTimeout(function() {
          page.replace(to);
        },0);
      });
    }

    // Wait for the push state and replace it with another
    if('string' === typeof from && 'undefined' === typeof to) {
      setTimeout(function() {
          page.replace(from);
      },0);
    }
  };

  /**
   * Replace `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @return {Context}
   * @api public
   */

  page.replace = function(path, state, init, dispatch){
    var ctx = new Context(path, state);
    ctx.init = init;
    ctx.save(); // save before dispatching, which may redirect
    if (false !== dispatch) page.dispatch(ctx);
    return ctx;
  };

  /**
   * Dispatch the given `ctx`.
   *
   * @param {Object} ctx
   * @api private
   */

  page.dispatch = function(ctx){
    var prev = prevContext;
    var i = 0;
    var j = 0;

    prevContext = ctx;

    function nextExit() {
      var fn = page.exits[j++];
      if (!fn) return nextEnter();
      fn(prev, nextExit);
    }

    function nextEnter() {
      var fn = page.callbacks[i++];
      if (!fn) return unhandled(ctx);
      fn(ctx, nextEnter);
    }

    if (prev) {
      nextExit();
    } else {
      nextEnter();
    }
  };

  /**
   * Unhandled `ctx`. When it's not the initial
   * popstate then redirect. If you wish to handle
   * 404s on your own use `page('*', callback)`.
   *
   * @param {Context} ctx
   * @api private
   */

  function unhandled(ctx) {
    if (ctx.handled) return;
    var current;

    if (hashbang) {
      current = base + location.hash.replace('#!','');
    } else {
      current = location.pathname + location.search;
    }

    if (current === ctx.canonicalPath) return;
    page.stop();
    ctx.handled = false;
    location.href = ctx.canonicalPath;
  }

  /**
   * Register an exit route on `path` with
   * callback `fn()`, which will be called
   * on the previous context when a new
   * page is visited.
   */
  page.exit = function(path, fn) {
    if (typeof path == 'function') {
      return page.exit('*', path);
    };

    var route = new Route(path);
    for (var i = 1; i < arguments.length; ++i) {
      page.exits.push(route.middleware(arguments[i]));
    }
  };

  /**
  * Remove URL encoding from the given `str`.
  * Accommodates whitespace in both x-www-form-urlencoded
  * and regular percent-encoded form.
  *
  * @param {str} URL component to decode
  */
  function decodeURLEncodedURIComponent(str) {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  }

  /**
   * Initialize a new "request" `Context`
   * with the given `path` and optional initial `state`.
   *
   * @param {String} path
   * @param {Object} state
   * @api public
   */

  function Context(path, state) {
    path = decodeURLEncodedURIComponent(path);
    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + path;
    var i = path.indexOf('?');

    this.canonicalPath = path;
    this.path = path.replace(base, '') || '/';

    this.title = document.title;
    this.state = state || {};
    this.state.path = path;
    this.querystring = ~i
      ? path.slice(i + 1)
      : '';
    this.pathname = ~i
      ? path.slice(0, i)
      : path;
    this.params = [];

    // fragment
    this.hash = '';
    if (!~this.path.indexOf('#')) return;
    var parts = this.path.split('#');
    this.path = parts[0];
    this.hash = parts[1] || '';
    this.querystring = this.querystring.split('#')[0];
  }

  /**
   * Expose `Context`.
   */

  page.Context = Context;

  /**
   * Push state.
   *
   * @api private
   */

  Context.prototype.pushState = function(){
    history.pushState(this.state
      , this.title
      , hashbang && this.path !== '/'
        ? '#!' + this.path
        : this.canonicalPath);
  };

  /**
   * Save the context state.
   *
   * @api public
   */

  Context.prototype.save = function(){
    history.replaceState(this.state
      , this.title
      , hashbang && this.path !== '/'
        ? '#!' + this.path
        : this.canonicalPath);
  };

  /**
   * Initialize `Route` with the given HTTP `path`,
   * and an array of `callbacks` and `options`.
   *
   * Options:
   *
   *   - `sensitive`    enable case-sensitive routes
   *   - `strict`       enable strict matching for trailing slashes
   *
   * @param {String} path
   * @param {Object} options.
   * @api private
   */

  function Route(path, options) {
    options = options || {};
    this.path = (path === '*') ? '(.*)' : path;
    this.method = 'GET';
    this.regexp = pathtoRegexp(this.path,
      this.keys = [],
      options.sensitive,
      options.strict);
  }

  /**
   * Expose `Route`.
   */

  page.Route = Route;

  /**
   * Return route middleware with
   * the given callback `fn()`.
   *
   * @param {Function} fn
   * @return {Function}
   * @api public
   */

  Route.prototype.middleware = function(fn){
    var self = this;
    return function(ctx, next){
      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);
      next();
    };
  };

  /**
   * Check if this route matches `path`, if so
   * populate `params`.
   *
   * @param {String} path
   * @param {Array} params
   * @return {Boolean}
   * @api private
   */

  Route.prototype.match = function(path, params){
    var keys = this.keys,
        qsIndex = path.indexOf('?'),
        pathname = ~qsIndex
          ? path.slice(0, qsIndex)
          : path,
        m = this.regexp.exec(decodeURIComponent(pathname));

    if (!m) return false;

    for (var i = 1, len = m.length; i < len; ++i) {
      var key = keys[i - 1];

      var val = 'string' === typeof m[i]
        ? decodeURIComponent(m[i])
        : m[i];

      if (key) {
        params[key.name] = undefined !== params[key.name]
          ? params[key.name]
          : val;
      } else {
        params.push(val);
      }
    }

    return true;
  };

  /**
   * Handle "populate" events.
   */

  function onpopstate(e) {
    if (e.state) {
      var path = e.state.path;
      page.replace(path, e.state);
    }
  }

  /**
   * Handle "click" events.
   */

  function onclick(e) {
    if (1 != which(e)) return;
    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
    if (e.defaultPrevented) return;

    // ensure link
    var el = e.target;
    while (el && 'A' != el.nodeName) el = el.parentNode;
    if (!el || 'A' != el.nodeName) return;

    // Ignore if tag has a "download" attribute
    if (el.getAttribute("download")) return;

    // ensure non-hash for the same path
    var link = el.getAttribute('href');
    if (el.pathname === location.pathname && (el.hash || '#' === link)) return;

    // Check for mailto: in the href
    if (link && link.indexOf("mailto:") > -1) return;

    // check target
    if (el.target) return;

    // x-origin
    if (!sameOrigin(el.href)) return;

    // rebuild path
    var path = el.pathname + el.search + (el.hash || '');

    // same page
    var orig = path;

    path = path.replace(base, '');

    if (base && orig === path) return;

    e.preventDefault();
    page.show(orig);
  }

  /**
   * Event button.
   */

  function which(e) {
    e = e || window.event;
    return null === e.which
      ? e.button
      : e.which;
  }

  /**
   * Check if `href` is the same origin.
   */

  function sameOrigin(href) {
    var origin = location.protocol + '//' + location.hostname;
    if (location.port) origin += ':' + location.port;
    return (href && (0 === href.indexOf(origin)));
  }

  page.sameOrigin = sameOrigin;

},{"path-to-regexp":2}],2:[function(require,module,exports){
/**
 * Expose `pathtoRegexp`.
 */
module.exports = pathtoRegexp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match already escaped characters that would otherwise incorrectly appear
  // in future matches. This allows the user to escape special characters that
  // shouldn't be transformed.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
  '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
  // Match regexp special characters that should always be escaped.
  '([.+*?=^!:${}()[\\]|\\/])'
].join('|'), 'g');

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
var attachKeys = function (re, keys) {
  re.keys = keys;

  return re;
};

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array should be passed in, which will contain the placeholder key
 * names. For example `/user/:id` will then contain `["id"]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 keys
 * @param  {Object}                options
 * @return {RegExp}
 */
function pathtoRegexp (path, keys, options) {
  if (keys && !Array.isArray(keys)) {
    options = keys;
    keys = null;
  }

  keys = keys || [];
  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var flags = options.sensitive ? '' : 'i';
  var index = 0;

  if (path instanceof RegExp) {
    // Match all capturing groups of a regexp.
    var groups = path.source.match(/\((?!\?)/g) || [];

    // Map all the matches to their numeric keys and push into the keys.
    keys.push.apply(keys, groups.map(function (match, index) {
      return {
        name:      index,
        delimiter: null,
        optional:  false,
        repeat:    false
      };
    }));

    // Return the source back to the user.
    return attachKeys(path, keys);
  }

  if (Array.isArray(path)) {
    // Map array parts into regexps and return their source. We also pass
    // the same keys and options instance into every generation to get
    // consistent matching groups before we join the sources together.
    path = path.map(function (value) {
      return pathtoRegexp(value, keys, options).source;
    });

    // Generate a new regexp instance by joining all the parts together.
    return attachKeys(new RegExp('(?:' + path.join('|') + ')', flags), keys);
  }

  // Alter the path string into a usable regexp.
  path = path.replace(PATH_REGEXP, function (match, escaped, prefix, key, capture, group, suffix, escape) {
    // Avoiding re-escaping escaped characters.
    if (escaped) {
      return escaped;
    }

    // Escape regexp special characters.
    if (escape) {
      return '\\' + escape;
    }

    var repeat   = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';

    keys.push({
      name:      key || index++,
      delimiter: prefix || '/',
      optional:  optional,
      repeat:    repeat
    });

    // Escape the prefix character.
    prefix = prefix ? '\\' + prefix : '';

    // Match using the custom capturing group, or fallback to capturing
    // everything up to the next slash (or next period if the param was
    // prefixed with a period).
    capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

    // Allow parameters to be repeated more than once.
    if (repeat) {
      capture = capture + '(?:' + prefix + capture + ')*';
    }

    // Allow a parameter to be optional.
    if (optional) {
      return '(?:' + prefix + '(' + capture + '))?';
    }

    // Basic parameter support.
    return prefix + '(' + capture + ')';
  });

  // Check whether the path ends in a slash as it alters some match behaviour.
  var endsWithSlash = path[path.length - 1] === '/';

  // In non-strict mode we allow an optional trailing slash in the match. If
  // the path to match already ended with a slash, we need to remove it for
  // consistency. The slash is only valid at the very end of a path match, not
  // anywhere in the middle. This is important for non-ending mode, otherwise
  // "/test/" will match "/test//route".
  if (!strict) {
    path = (endsWithSlash ? path.slice(0, -2) : path) + '(?:\\/(?=$))?';
  }

  // In non-ending mode, we need prompt the capturing groups to match as much
  // as possible by using a positive lookahead for the end or next path segment.
  if (!end) {
    path += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return attachKeys(new RegExp('^' + path + (end ? '$' : ''), flags), keys);
};

},{}]},{},[1])(1)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"path-to-regexp":"/Users/luke/dev/040715/node_modules/path-to-regexp/index.js"}],"/Users/luke/dev/040715/vendor/platform/platform.js":[function(require,module,exports){
(function (global){
/*!
 * Platform.js v1.3.0 <http://mths.be/platform>
 * Copyright 2010-2014 John-David Dalton <http://allyoucanleet.com/>
 * Available under MIT license <http://mths.be/mit>
 */
;(function() {
  'use strict';

  /** Used to determine if values are of the language type `Object` */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Backup possible global object */
  var oldRoot = root;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /**
   * Used as the maximum length of an array-like object.
   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
   * for more details.
   */
  var maxSafeInteger = Math.pow(2, 53) - 1;

  /** Opera regexp */
  var reOpera = /\bOpera/;

  /** Possible global object */
  var thisBinding = this;

  /** Used for native method references */
  var objectProto = Object.prototype;

  /** Used to check for own properties of an object */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to resolve the internal `[[Class]]` of values */
  var toString = objectProto.toString;

  /*--------------------------------------------------------------------------*/

  /**
   * Capitalizes a string value.
   *
   * @private
   * @param {string} string The string to capitalize.
   * @returns {string} The capitalized string.
   */
  function capitalize(string) {
    string = String(string);
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  /**
   * A utility function to clean up the OS name.
   *
   * @private
   * @param {string} os The OS name to clean up.
   * @param {string} [pattern] A `RegExp` pattern matching the OS name.
   * @param {string} [label] A label for the OS.
   */
  function cleanupOS(os, pattern, label) {
    // platform tokens defined at
    // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    var data = {
      '6.4':  '10',
      '6.3':  '8.1',
      '6.2':  '8',
      '6.1':  'Server 2008 R2 / 7',
      '6.0':  'Server 2008 / Vista',
      '5.2':  'Server 2003 / XP 64-bit',
      '5.1':  'XP',
      '5.01': '2000 SP1',
      '5.0':  '2000',
      '4.0':  'NT',
      '4.90': 'ME'
    };
    // detect Windows version from platform tokens
    if (pattern && label && /^Win/i.test(os) &&
        (data = data[0/*Opera 9.25 fix*/, /[\d.]+$/.exec(os)])) {
      os = 'Windows ' + data;
    }
    // correct character case and cleanup
    os = String(os);

    if (pattern && label) {
      os = os.replace(RegExp(pattern, 'i'), label);
    }

    os = format(
      os.replace(/ ce$/i, ' CE')
        .replace(/\bhpw/i, 'web')
        .replace(/\bMacintosh\b/, 'Mac OS')
        .replace(/_PowerPC\b/i, ' OS')
        .replace(/\b(OS X) [^ \d]+/i, '$1')
        .replace(/\bMac (OS X)\b/, '$1')
        .replace(/\/(\d)/, ' $1')
        .replace(/_/g, '.')
        .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '')
        .replace(/\bx86\.64\b/gi, 'x86_64')
        .replace(/\b(Windows Phone) OS\b/, '$1')
        .split(' on ')[0]
    );

    return os;
  }

  /**
   * An iteration utility for arrays and objects.
   *
   * @private
   * @param {Array|Object} object The object to iterate over.
   * @param {Function} callback The function called per iteration.
   */
  function each(object, callback) {
    var index = -1,
        length = object ? object.length : 0;

    if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
      while (++index < length) {
        callback(object[index], index, object);
      }
    } else {
      forOwn(object, callback);
    }
  }

  /**
   * Trim and conditionally capitalize string values.
   *
   * @private
   * @param {string} string The string to format.
   * @returns {string} The formatted string.
   */
  function format(string) {
    string = trim(string);
    return /^(?:webOS|i(?:OS|P))/.test(string)
      ? string
      : capitalize(string);
  }

  /**
   * Iterates over an object's own properties, executing the `callback` for each.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function executed per own property.
   */
  function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty.call(object, key)) {
        callback(object[key], key, object);
      }
    }
  }

  /**
   * Gets the internal `[[Class]]` of a value.
   *
   * @private
   * @param {*} value The value.
   * @returns {string} The `[[Class]]`.
   */
  function getClassOf(value) {
    return value == null
      ? capitalize(value)
      : toString.call(value).slice(8, -1);
  }

  /**
   * Host objects can return type values that are different from their actual
   * data type. The objects we are concerned with usually return non-primitive
   * types of "object", "function", or "unknown".
   *
   * @private
   * @param {*} object The owner of the property.
   * @param {string} property The property to check.
   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
   */
  function isHostType(object, property) {
    var type = object != null ? typeof object[property] : 'number';
    return !/^(?:boolean|number|string|undefined)$/.test(type) &&
      (type == 'object' ? !!object[property] : true);
  }

  /**
   * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
   *
   * @private
   * @param {string} string The string to qualify.
   * @returns {string} The qualified string.
   */
  function qualify(string) {
    return String(string).replace(/([ -])(?!$)/g, '$1?');
  }

  /**
   * A bare-bones `Array#reduce` like utility function.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function called per iteration.
   * @returns {*} The accumulated result.
   */
  function reduce(array, callback) {
    var accumulator = null;
    each(array, function(value, index) {
      accumulator = callback(accumulator, value, index, array);
    });
    return accumulator;
  }

  /**
   * Removes leading and trailing whitespace from a string.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} The trimmed string.
   */
  function trim(string) {
    return String(string).replace(/^ +| +$/g, '');
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a new platform object.
   *
   * @memberOf platform
   * @param {Object|string} [ua=navigator.userAgent] The user agent string or
   *  context object.
   * @returns {Object} A platform object.
   */
  function parse(ua) {

    /** The environment context object */
    var context = root;

    /** Used to flag when a custom context is provided */
    var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';

    // juggle arguments
    if (isCustomContext) {
      context = ua;
      ua = null;
    }

    /** Browser navigator object */
    var nav = context.navigator || {};

    /** Browser user agent string */
    var userAgent = nav.userAgent || '';

    ua || (ua = userAgent);

    /** Used to flag when `thisBinding` is the [ModuleScope] */
    var isModuleScope = isCustomContext || thisBinding == oldRoot;

    /** Used to detect if browser is like Chrome */
    var likeChrome = isCustomContext
      ? !!nav.likeChrome
      : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());

    /** Internal `[[Class]]` value shortcuts */
    var objectClass = 'Object',
        airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
        enviroClass = isCustomContext ? objectClass : 'Environment',
        javaClass = (isCustomContext && context.java) ? 'JavaPackage' : getClassOf(context.java),
        phantomClass = isCustomContext ? objectClass : 'RuntimeObject';

    /** Detect Java environment */
    var java = /\bJava/.test(javaClass) && context.java;

    /** Detect Rhino */
    var rhino = java && getClassOf(context.environment) == enviroClass;

    /** A character to represent alpha */
    var alpha = java ? 'a' : '\u03b1';

    /** A character to represent beta */
    var beta = java ? 'b' : '\u03b2';

    /** Browser document object */
    var doc = context.document || {};

    /**
     * Detect Opera browser (Presto-based)
     * http://www.howtocreate.co.uk/operaStuff/operaObject.html
     * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
     */
    var opera = context.operamini || context.opera;

    /** Opera `[[Class]]` */
    var operaClass = reOpera.test(operaClass = (isCustomContext && opera) ? opera['[[Class]]'] : getClassOf(opera))
      ? operaClass
      : (opera = null);

    /*------------------------------------------------------------------------*/

    /** Temporary variable used over the script's lifetime */
    var data;

    /** The CPU architecture */
    var arch = ua;

    /** Platform description array */
    var description = [];

    /** Platform alpha/beta indicator */
    var prerelease = null;

    /** A flag to indicate that environment features should be used to resolve the platform */
    var useFeatures = ua == userAgent;

    /** The browser/environment version */
    var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();

    /** A flag to indicate if the OS ends with "/ Version" */
    var isSpecialCasedOS;

    /* Detectable layout engines (order is important) */
    var layout = getLayout([
      'Trident',
      { 'label': 'WebKit', 'pattern': 'AppleWebKit' },
      'iCab',
      'Presto',
      'NetFront',
      'Tasman',
      'KHTML',
      'Gecko'
    ]);

    /* Detectable browser names (order is important) */
    var name = getName([
      'Adobe AIR',
      'Arora',
      'Avant Browser',
      'Breach',
      'Camino',
      'Epiphany',
      'Fennec',
      'Flock',
      'Galeon',
      'GreenBrowser',
      'iCab',
      'Iceweasel',
      { 'label': 'SRWare Iron', 'pattern': 'Iron' },
      'K-Meleon',
      'Konqueror',
      'Lunascape',
      'Maxthon',
      'Midori',
      'Nook Browser',
      'PhantomJS',
      'Raven',
      'Rekonq',
      'RockMelt',
      'SeaMonkey',
      { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Sleipnir',
      'SlimBrowser',
      'Sunrise',
      'Swiftfox',
      'WebPositive',
      'Opera Mini',
      { 'label': 'Opera Mini', 'pattern': 'OPiOS' },
      'Opera',
      { 'label': 'Opera', 'pattern': 'OPR' },
      'Chrome',
      { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' },
      { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' },
      { 'label': 'IE', 'pattern': 'IEMobile' },
      { 'label': 'IE', 'pattern': 'MSIE' },
      'Safari'
    ]);

    /* Detectable products (order is important) */
    var product = getProduct([
      { 'label': 'BlackBerry', 'pattern': 'BB10' },
      'BlackBerry',
      { 'label': 'Galaxy S', 'pattern': 'GT-I9000' },
      { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' },
      { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' },
      { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' },
      'Google TV',
      'Lumia',
      'iPad',
      'iPod',
      'iPhone',
      'Kindle',
      { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Nook',
      'PlayBook',
      'PlayStation 4',
      'PlayStation 3',
      'PlayStation Vita',
      'TouchPad',
      'Transformer',
      { 'label': 'Wii U', 'pattern': 'WiiU' },
      'Wii',
      'Xbox One',
      { 'label': 'Xbox 360', 'pattern': 'Xbox' },
      'Xoom'
    ]);

    /* Detectable manufacturers */
    var manufacturer = getManufacturer({
      'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },
      'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },
      'Asus': { 'Transformer': 1 },
      'Barnes & Noble': { 'Nook': 1 },
      'BlackBerry': { 'PlayBook': 1 },
      'Google': { 'Google TV': 1 },
      'HP': { 'TouchPad': 1 },
      'HTC': {},
      'LG': {},
      'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },
      'Motorola': { 'Xoom': 1 },
      'Nintendo': { 'Wii U': 1,  'Wii': 1 },
      'Nokia': { 'Lumia': 1 },
      'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
      'Sony': { 'PlayStation 4': 1, 'PlayStation 3': 1, 'PlayStation Vita': 1 }
    });

    /* Detectable OSes (order is important) */
    var os = getOS([
      'Windows Phone ',
      'Android',
      'CentOS',
      'Debian',
      'Fedora',
      'FreeBSD',
      'Gentoo',
      'Haiku',
      'Kubuntu',
      'Linux Mint',
      'Red Hat',
      'SuSE',
      'Ubuntu',
      'Xubuntu',
      'Cygwin',
      'Symbian OS',
      'hpwOS',
      'webOS ',
      'webOS',
      'Tablet OS',
      'Linux',
      'Mac OS X',
      'Macintosh',
      'Mac',
      'Windows 98;',
      'Windows '
    ]);

    /*------------------------------------------------------------------------*/

    /**
     * Picks the layout engine from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected layout engine.
     */
    function getLayout(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the manufacturer from an array of guesses.
     *
     * @private
     * @param {Array} guesses An object of guesses.
     * @returns {null|string} The detected manufacturer.
     */
    function getManufacturer(guesses) {
      return reduce(guesses, function(result, value, key) {
        // lookup the manufacturer by product or scan the UA for the manufacturer
        return result || (
          value[product] ||
          value[0/*Opera 9.25 fix*/, /^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] ||
          RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)
        ) && key;
      });
    }

    /**
     * Picks the browser name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected browser name.
     */
    function getName(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the OS name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected OS name.
     */
    function getOS(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua)
            )) {
          result = cleanupOS(result, pattern, guess.label || guess);
        }
        return result;
      });
    }

    /**
     * Picks the product name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected product name.
     */
    function getProduct(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) ||
              RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua)
            )) {
          // split by forward slash and append product version if needed
          if ((result = String((guess.label && !RegExp(pattern, 'i').test(guess.label)) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
            result[0] += ' ' + result[1];
          }
          // correct character case and cleanup
          guess = guess.label || guess;
          result = format(result[0]
            .replace(RegExp(pattern, 'i'), guess)
            .replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ')
            .replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
        }
        return result;
      });
    }

    /**
     * Resolves the version using an array of UA patterns.
     *
     * @private
     * @param {Array} patterns An array of UA patterns.
     * @returns {null|string} The detected version.
     */
    function getVersion(patterns) {
      return reduce(patterns, function(result, pattern) {
        return result || (RegExp(pattern +
          '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
      });
    }

    /**
     * Returns `platform.description` when the platform object is coerced to a string.
     *
     * @name toString
     * @memberOf platform
     * @returns {string} Returns `platform.description` if available, else an empty string.
     */
    function toStringPlatform() {
      return this.description || '';
    }

    /*------------------------------------------------------------------------*/

    // convert layout to an array so we can add extra details
    layout && (layout = [layout]);

    // detect product names that contain their manufacturer's name
    if (manufacturer && !product) {
      product = getProduct([manufacturer]);
    }
    // clean up Google TV
    if ((data = /\bGoogle TV\b/.exec(product))) {
      product = data[0];
    }
    // detect simulators
    if (/\bSimulator\b/i.test(ua)) {
      product = (product ? product + ' ' : '') + 'Simulator';
    }
    // detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS
    if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
      description.push('running in Turbo/Uncompressed mode');
    }
    // detect iOS
    if (/^iP/.test(product)) {
      name || (name = 'Safari');
      os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua))
        ? ' ' + data[1].replace(/_/g, '.')
        : '');
    }
    // detect Kubuntu
    else if (name == 'Konqueror' && !/buntu/i.test(os)) {
      os = 'Kubuntu';
    }
    // detect Android browsers
    else if (manufacturer && manufacturer != 'Google' &&
        ((/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua)) || /\bVita\b/.test(product))) {
      name = 'Android Browser';
      os = /\bAndroid\b/.test(os) ? os : 'Android';
    }
    // detect false positives for Firefox/Safari
    else if (!name || (data = !/\bMinefield\b|\(Android;/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
      // escape the `/` for Firefox 1
      if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
        // clear name of false positives
        name = null;
      }
      // reassign a generic name
      if ((data = product || manufacturer || os) &&
          (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
        name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
      }
    }
    // detect Firefox OS
    if ((data = /\((Mobile|Tablet).*?Firefox\b/i.exec(ua)) && data[1]) {
      os = 'Firefox OS';
      if (!product) {
        product = data[1];
      }
    }
    // detect non-Opera versions (order is important)
    if (!version) {
      version = getVersion([
        '(?:Cloud9|CriOS|CrMo|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|Silk(?!/[\\d.]+$))',
        'Version',
        qualify(name),
        '(?:Firefox|Minefield|NetFront)'
      ]);
    }
    // detect stubborn layout engines
    if (layout == 'iCab' && parseFloat(version) > 3) {
      layout = ['WebKit'];
    } else if (
        layout != 'Trident' &&
        (data =
          /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') ||
          /\b(?:Midori|Nook|Safari)\b/i.test(ua) && 'WebKit' ||
          !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident')
        )
    ) {
      layout = [data];
    }
    // detect NetFront on PlayStation
    else if (/\bPlayStation\b(?! Vita\b)/i.test(name) && layout == 'WebKit') {
      layout = ['NetFront'];
    }
    // detect Windows Phone 7 desktop mode
    if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
      name += ' Mobile';
      os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
      description.unshift('desktop mode');
    }
    // detect Windows Phone 8+ desktop mode
    else if (/\bWPDesktop\b/i.test(ua)) {
      name = 'IE Mobile';
      os = 'Windows Phone 8+';
      description.unshift('desktop mode');
      version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
    }
    // detect IE 11 and above
    else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
      if (!/\bWPDesktop\b/i.test(ua)) {
        if (name) {
          description.push('identifying as ' + name + (version ? ' ' + version : ''));
        }
        name = 'IE';
      }
      version = data[1];
    }
    // detect IE Tech Preview
    else if ((name == 'Chrome' || name != 'IE') && (data = /\bEdge\/([\d.]+)/.exec(ua))) {
      name = 'IE';
      version = data[1];
      layout = ['Trident'];
      description.unshift('platform preview');
    }
    // leverage environment features
    if (useFeatures) {
      // detect server-side environments
      // Rhino has a global function while others have a global object
      if (isHostType(context, 'global')) {
        if (java) {
          data = java.lang.System;
          arch = data.getProperty('os.arch');
          os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
        }
        if (isModuleScope && isHostType(context, 'system') && (data = [context.system])[0]) {
          os || (os = data[0].os || null);
          try {
            data[1] = context.require('ringo/engine').version;
            version = data[1].join('.');
            name = 'RingoJS';
          } catch(e) {
            if (data[0].global.system == context.system) {
              name = 'Narwhal';
            }
          }
        }
        else if (typeof context.process == 'object' && (data = context.process)) {
          name = 'Node.js';
          arch = data.arch;
          os = data.platform;
          version = /[\d.]+/.exec(data.version)[0];
        }
        else if (rhino) {
          name = 'Rhino';
        }
      }
      // detect Adobe AIR
      else if (getClassOf((data = context.runtime)) == airRuntimeClass) {
        name = 'Adobe AIR';
        os = data.flash.system.Capabilities.os;
      }
      // detect PhantomJS
      else if (getClassOf((data = context.phantom)) == phantomClass) {
        name = 'PhantomJS';
        version = (data = data.version || null) && (data.major + '.' + data.minor + '.' + data.patch);
      }
      // detect IE compatibility modes
      else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
        // we're in compatibility mode when the Trident version + 4 doesn't
        // equal the document mode
        version = [version, doc.documentMode];
        if ((data = +data[1] + 4) != version[1]) {
          description.push('IE ' + version[1] + ' mode');
          layout && (layout[1] = '');
          version[1] = data;
        }
        version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
      }
      os = os && format(os);
    }
    // detect prerelease phases
    if (version && (data =
          /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) ||
          /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) ||
          /\bMinefield\b/i.test(ua) && 'a'
        )) {
      prerelease = /b/i.test(data) ? 'beta' : 'alpha';
      version = version.replace(RegExp(data + '\\+?$'), '') +
        (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
    }
    // detect Firefox Mobile
    if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS)\b/.test(os)) {
      name = 'Firefox Mobile';
    }
    // obscure Maxthon's unreliable version
    else if (name == 'Maxthon' && version) {
      version = version.replace(/\.[\d.]+/, '.x');
    }
    // detect Silk desktop/accelerated modes
    else if (name == 'Silk') {
      if (!/\bMobi/i.test(ua)) {
        os = 'Android';
        description.unshift('desktop mode');
      }
      if (/Accelerated *= *true/i.test(ua)) {
        description.unshift('accelerated');
      }
    }
    // detect Xbox 360 and Xbox One
    else if (/\bXbox\b/i.test(product)) {
      os = null;
      if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
        description.unshift('mobile mode');
      }
    }
    // add mobile postfix
    else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) &&
        (os == 'Windows CE' || /Mobi/i.test(ua))) {
      name += ' Mobile';
    }
    // detect IE platform preview
    else if (name == 'IE' && useFeatures && context.external === null) {
      description.unshift('platform preview');
    }
    // detect BlackBerry OS version
    // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
    else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data =
          (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] ||
          version
        )) {
      data = [data, /BB10/.test(ua)];
      os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
      version = null;
    }
    // detect Opera identifying/masking itself as another browser
    // http://www.opera.com/support/kb/view/843/
    else if (this != forOwn && (
          product != 'Wii' && (
            (useFeatures && opera) ||
            (/Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua)) ||
            (name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os)) ||
            (name == 'IE' && (
              (os && !/^Win/.test(os) && version > 5.5) ||
              /\bWindows XP\b/.test(os) && version > 8 ||
              version == 8 && !/\bTrident\b/.test(ua)
            ))
          )
        ) && !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, '') + ';'))) && data.name) {

      // when "indentifying", the UA contains both Opera and the other browser's name
      data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
      if (reOpera.test(name)) {
        if (/\bIE\b/.test(data) && os == 'Mac OS') {
          os = null;
        }
        data = 'identify' + data;
      }
      // when "masking", the UA contains only the other browser's name
      else {
        data = 'mask' + data;
        if (operaClass) {
          name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
        } else {
          name = 'Opera';
        }
        if (/\bIE\b/.test(data)) {
          os = null;
        }
        if (!useFeatures) {
          version = null;
        }
      }
      layout = ['Presto'];
      description.push(data);
    }
    // detect WebKit Nightly and approximate Chrome/Safari versions
    if ((data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
      // correct build for numeric comparison
      // (e.g. "532.5" becomes "532.05")
      data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
      // nightly builds are postfixed with a `+`
      if (name == 'Safari' && data[1].slice(-1) == '+') {
        name = 'WebKit Nightly';
        prerelease = 'alpha';
        version = data[1].slice(0, -1);
      }
      // clear incorrect browser versions
      else if (version == data[1] ||
          version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
        version = null;
      }
      // use the full Chrome version when available
      data[1] = (/\bChrome\/([\d.]+)/i.exec(ua) || 0)[1];
      // detect Blink layout engine
      if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && name != 'IE') {
        layout = ['Blink'];
      }
      // detect JavaScriptCore
      // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
      if (!useFeatures || (!likeChrome && !data[1])) {
        layout && (layout[1] = 'like Safari');
        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : '8');
      } else {
        layout && (layout[1] = 'like Chrome');
        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
      }
      // add the postfix of ".x" or "+" for approximate versions
      layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
      // obscure version for some Safari 1-2 releases
      if (name == 'Safari' && (!version || parseInt(version) > 45)) {
        version = data;
      }
    }
    // detect Opera desktop modes
    if (name == 'Opera' &&  (data = /\bzbov|zvav$/.exec(os))) {
      name += ' ';
      description.unshift('desktop mode');
      if (data == 'zvav') {
        name += 'Mini';
        version = null;
      } else {
        name += 'Mobile';
      }
      os = os.replace(RegExp(' *' + data + '$'), '');
    }
    // detect Chrome desktop mode
    else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
      description.unshift('desktop mode');
      name = 'Chrome Mobile';
      version = null;

      if (/\bOS X\b/.test(os)) {
        manufacturer = 'Apple';
        os = 'iOS 4.3+';
      } else {
        os = null;
      }
    }
    // strip incorrect OS versions
    if (version && version.indexOf((data = /[\d.]+$/.exec(os))) == 0 &&
        ua.indexOf('/' + data + '-') > -1) {
      os = trim(os.replace(data, ''));
    }
    // add layout engine
    if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (
        /Browser|Lunascape|Maxthon/.test(name) ||
        /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Sleipnir|Web)/.test(name) && layout[1])) {
      // don't add layout details to description if they are falsey
      (data = layout[layout.length - 1]) && description.push(data);
    }
    // combine contextual information
    if (description.length) {
      description = ['(' + description.join('; ') + ')'];
    }
    // append manufacturer
    if (manufacturer && product && product.indexOf(manufacturer) < 0) {
      description.push('on ' + manufacturer);
    }
    // append product
    if (product) {
      description.push((/^on /.test(description[description.length -1]) ? '' : 'on ') + product);
    }
    // parse OS into an object
    if (os) {
      data = / ([\d.+]+)$/.exec(os);
      isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
      os = {
        'architecture': 32,
        'family': (data && !isSpecialCasedOS) ? os.replace(data[0], '') : os,
        'version': data ? data[1] : null,
        'toString': function() {
          var version = this.version;
          return this.family + ((version && !isSpecialCasedOS) ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
        }
      };
    }
    // add browser/OS architecture
    if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
      if (os) {
        os.architecture = 64;
        os.family = os.family.replace(RegExp(' *' + data), '');
      }
      if (
          name && (/\bWOW64\b/i.test(ua) ||
          (useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua)))
      ) {
        description.unshift('32-bit');
      }
    }

    ua || (ua = null);

    /*------------------------------------------------------------------------*/

    /**
     * The platform object.
     *
     * @name platform
     * @type Object
     */
    var platform = {};

    /**
     * The platform description.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.description = ua;

    /**
     * The name of the browser's layout engine.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.layout = layout && layout[0];

    /**
     * The name of the product's manufacturer.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.manufacturer = manufacturer;

    /**
     * The name of the browser/environment.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.name = name;

    /**
     * The alpha/beta release indicator.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.prerelease = prerelease;

    /**
     * The name of the product hosting the browser.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.product = product;

    /**
     * The browser's user agent string.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.ua = ua;

    /**
     * The browser/environment version.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.version = name && version;

    /**
     * The name of the operating system.
     *
     * @memberOf platform
     * @type Object
     */
    platform.os = os || {

      /**
       * The CPU architecture the OS is built for.
       *
       * @memberOf platform.os
       * @type number|null
       */
      'architecture': null,

      /**
       * The family of the OS.
       *
       * Common values include:
       * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
       * "Windows XP", "OS X", "Ubuntu", "Debian", "Fedora", "Red Hat", "SuSE",
       * "Android", "iOS" and "Windows Phone"
       *
       * @memberOf platform.os
       * @type string|null
       */
      'family': null,

      /**
       * The version of the OS.
       *
       * @memberOf platform.os
       * @type string|null
       */
      'version': null,

      /**
       * Returns the OS string.
       *
       * @memberOf platform.os
       * @returns {string} The OS string.
       */
      'toString': function() { return 'null'; }
    };

    platform.parse = parse;
    platform.toString = toStringPlatform;

    if (platform.version) {
      description.unshift(version);
    }
    if (platform.name) {
      description.unshift(name);
    }
    if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
      description.push(product ? '(' + os + ')' : 'on ' + os);
    }
    if (description.length) {
      platform.description = description.join(' ');
    }
    return platform;
  }

  /*--------------------------------------------------------------------------*/

  // export platform
  // some AMD build optimizers, like r.js, check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // define as an anonymous module so, through path mapping, it can be aliased
    define(function() {
      return parse();
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Narwhal, Node.js, Rhino -require, or RingoJS
    forOwn(parse(), function(value, key) {
      freeExports[key] = value;
    });
  }
  // in a browser or Rhino
  else {
    root.platform = parse();
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/luke/dev/040715/vendor/ractive-events-tap/ractive-events-tap.js":[function(require,module,exports){
/*

	ractive-events-tap
	==================

	Version 0.1.2.

	On mobile devices, using `on-click` isn't good enough. Tapping the
	touchscreen will fire a simulated click event, but only after a 300
	millisecond delay, which makes your app feel sluggish. It also
	causes the tapped area to highlight, which in most cases looks a
	bit messy.

	Instead, use `on-tap`. When you tap an area, the simulated click
	event will be prevented, and the user's action is responded to
	instantly. The `on-tap` event also differs from `on-click` in that
	the click event will (frankly rather bizarrely) fire even if you
	hold the mouse down over a single element for several seconds and
	waggle it about.

	Pointer events are also supported, as is pressing the spacebar when
	the relevant element is focused (which triggers a click event, and
	is good for accessibility).

	==========================

	Troubleshooting: If you're using a module system in your app (AMD or
	something more nodey) then you may need to change the paths below,
	where it says `require( 'ractive' )` or `define([ 'ractive' ]...)`.

	==========================

	Usage: Include this file on your page below Ractive, e.g:

	    <script src='lib/ractive.js'></script>
	    <script src='lib/ractive-events-tap.js'></script>

	Or, if you're using a module loader, require this module:

	    // requiring the plugin will 'activate' it - no need to use
	    // the return value
	    require( 'ractive-events-tap' );

	Add a tap event in the normal fashion:

	    <div on-tap='foo'>tap me!</div>

	Then add a handler:

	    ractive.on( 'foo', function ( event ) {
	      alert( 'tapped' );
	    });

*/

(function ( global, factory ) {

	'use strict';

	// Common JS (i.e. browserify) environment
	if ( typeof module !== 'undefined' && module.exports && typeof require === 'function' ) {
		factory( require( "./../ractive/ractive.js" ) );
	}

	// AMD?
	else if ( typeof define === 'function' && define.amd ) {
		define([ 'ractive' ], factory );
	}

	// browser global
	else if ( global.Ractive ) {
		factory( global.Ractive );
	}

	else {
		throw new Error( 'Could not find Ractive! It must be loaded before the ractive-events-tap plugin' );
	}

}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

	'use strict';

	var tap = function ( node, fire ) {
		var mousedown, touchstart, focusHandler, distanceThreshold, timeThreshold, preventMousedownEvents, preventMousedownTimeout;

		distanceThreshold = 5; // maximum pixels pointer can move before cancel
		timeThreshold = 400;   // maximum milliseconds between down and up before cancel

		mousedown = function ( event ) {
			var currentTarget, x, y, pointerId, up, move, cancel;

			if ( preventMousedownEvents ) {
				return;
			}

			if ( event.which !== undefined && event.which !== 1 ) {
				return;
			}

			x = event.clientX;
			y = event.clientY;
			currentTarget = this;
			// This will be null for mouse events.
			pointerId = event.pointerId;

			up = function ( event ) {
				if ( event.pointerId != pointerId ) {
					return;
				}

				fire({
					node: currentTarget,
					original: event
				});

				cancel();
			};

			move = function ( event ) {
				if ( event.pointerId != pointerId ) {
					return;
				}

				if ( ( Math.abs( event.clientX - x ) >= distanceThreshold ) || ( Math.abs( event.clientY - y ) >= distanceThreshold ) ) {
					cancel();
				}
			};

			cancel = function () {
				node.removeEventListener( 'MSPointerUp', up, false );
				document.removeEventListener( 'MSPointerMove', move, false );
				document.removeEventListener( 'MSPointerCancel', cancel, false );
				node.removeEventListener( 'pointerup', up, false );
				document.removeEventListener( 'pointermove', move, false );
				document.removeEventListener( 'pointercancel', cancel, false );
				node.removeEventListener( 'click', up, false );
				document.removeEventListener( 'mousemove', move, false );
			};

			if ( window.navigator.pointerEnabled ) {
				node.addEventListener( 'pointerup', up, false );
				document.addEventListener( 'pointermove', move, false );
				document.addEventListener( 'pointercancel', cancel, false );
			} else if ( window.navigator.msPointerEnabled ) {
				node.addEventListener( 'MSPointerUp', up, false );
				document.addEventListener( 'MSPointerMove', move, false );
				document.addEventListener( 'MSPointerCancel', cancel, false );
			} else {
				node.addEventListener( 'click', up, false );
				document.addEventListener( 'mousemove', move, false );
			}

			setTimeout( cancel, timeThreshold );
		};

		if ( window.navigator.pointerEnabled ) {
			node.addEventListener( 'pointerdown', mousedown, false );
		} else if ( window.navigator.msPointerEnabled ) {
			node.addEventListener( 'MSPointerDown', mousedown, false );
		} else {
			node.addEventListener( 'mousedown', mousedown, false );
		}


		touchstart = function ( event ) {
			var currentTarget, x, y, touch, finger, move, up, cancel;

			if ( event.touches.length !== 1 ) {
				return;
			}

			touch = event.touches[0];

			x = touch.clientX;
			y = touch.clientY;
			currentTarget = this;

			finger = touch.identifier;

			up = function ( event ) {
				var touch;

				touch = event.changedTouches[0];
				if ( touch.identifier !== finger ) {
					cancel();
				}

				event.preventDefault();  // prevent compatibility mouse event

				// for the benefit of mobile Firefox and old Android browsers, we need this absurd hack.
				preventMousedownEvents = true;
				clearTimeout( preventMousedownTimeout );

				preventMousedownTimeout = setTimeout( function () {
					preventMousedownEvents = false;
				}, 400 );

				fire({
					node: currentTarget,
					original: event
				});

				cancel();
			};

			move = function ( event ) {
				var touch;

				if ( event.touches.length !== 1 || event.touches[0].identifier !== finger ) {
					cancel();
				}

				touch = event.touches[0];
				if ( ( Math.abs( touch.clientX - x ) >= distanceThreshold ) || ( Math.abs( touch.clientY - y ) >= distanceThreshold ) ) {
					cancel();
				}
			};

			cancel = function () {
				node.removeEventListener( 'touchend', up, false );
				window.removeEventListener( 'touchmove', move, false );
				window.removeEventListener( 'touchcancel', cancel, false );
			};

			node.addEventListener( 'touchend', up, false );
			window.addEventListener( 'touchmove', move, false );
			window.addEventListener( 'touchcancel', cancel, false );

			setTimeout( cancel, timeThreshold );
		};

		node.addEventListener( 'touchstart', touchstart, false );


		// native buttons, and <input type='button'> elements, should fire a tap event
		// when the space key is pressed
		if ( node.tagName === 'BUTTON' || node.type === 'button' ) {
			focusHandler = function () {
				var blurHandler, keydownHandler;

				keydownHandler = function ( event ) {
					if ( event.which === 32 ) { // space key
						fire({
							node: node,
							original: event
						});
					}
				};

				blurHandler = function () {
					node.removeEventListener( 'keydown', keydownHandler, false );
					node.removeEventListener( 'blur', blurHandler, false );
				};

				node.addEventListener( 'keydown', keydownHandler, false );
				node.addEventListener( 'blur', blurHandler, false );
			};

			node.addEventListener( 'focus', focusHandler, false );
		}


		return {
			teardown: function () {
				node.removeEventListener( 'pointerdown', mousedown, false );
				node.removeEventListener( 'MSPointerDown', mousedown, false );
				node.removeEventListener( 'mousedown', mousedown, false );
				node.removeEventListener( 'touchstart', touchstart, false );
				node.removeEventListener( 'focus', focusHandler, false );
			}
		};
	};

	Ractive.events.tap = tap;

}));

},{"./../ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js"}],"/Users/luke/dev/040715/vendor/ractive-touch/index.js":[function(require,module,exports){
;(function (root, factory) {

  if (typeof define === 'function' && define.amd) {
    define(['ractive', 'hammerjs'], factory);
  }

  else if (typeof module !== 'undefined') {
    factory(require("./../ractive/ractive.js"), require("./../hammerjs/hammer.js"));
  }

  else {
    factory(root.Ractive, root.Hammer);
  }

}(this, function (Ractive, Hammer) {

  // Check the recognizers documentation.
  // http://hammerjs.github.io/recognizer-tap

  var defaults = {
    tap: {
      recognizerClass: Hammer.Tap,
      options: {
        time: 500
      },
      events: [
        'tap' 
      ]
    },
    doubletap: {
      recognizerClass: Hammer.Tap,
      options: {
        taps: 2,
        event: 'doubletap'
      },
      recognizeWith: ['tap'],
      events: [
        'doubletap' 
      ]
    },
    swipe: {
      recognizerClass: Hammer.Swipe,
      options: {},
      events: [
        'swipe',
        'swipeleft',
        'swiperight',
        'swipeup',
        'swipedown' 
      ]
    },
    pan: {
      recognizerClass: Hammer.Pan,
      options: {
        direction: Hammer.DIRECTION_HORIZONTAL
      },
      recognizeWith: ['swipe'],
      events: [
        'pan',
        'panstart',
        'panmove',
        'panend',
        'pancancel',
        'panleft',
        'panright',
        'panup',
        'pandown' 
      ]
    },
    press: {
      recognizerClass: Hammer.Press,
      options: {},
      events: [
        'press' 
      ]
    },
    rotate: {
      recognizerClass: Hammer.Rotate,
      options: {},
      events: [
        'rotate',
        'rotatestart',
        'rotatemove',
        'rotateend',
        'rotatecancel' 
      ]
    },
    pinch: {
      recognizerClass: Hammer.Pinch,
      options: {},
      recognizeWith: ['rotate'],
      events: [
        'pinch',
        'pinchstart',
        'pinchmove',
        'pinchend',
        'pinchcancel',
        'pinchin',
        'pinchout' 
      ]
    }
  };

  var aliases;

  // bind all events using buildEvent
  for (var recognizerName in defaults) {
    if (!defaults.hasOwnProperty(recognizerName)) continue;
    
    var events = defaults[recognizerName].events;
    for (var i = 0; i < events.length; i++) {
      buildEvent(events[i], recognizerName, defaults[recognizerName]);
    }
  }

  /**
   * buildEvent : buildEvent(event, recognizerName, config)
   * (private) registers an event handler for buildEvent.
   *
   *     buildEvent('panstart', 'pan', { ... });
   */

  function buildEvent(eventName, recognizerName, config) {
    Ractive.events[eventName] = buildEventHandler(eventName, recognizerName, config);
  }

  /**
   * buildEventHandler() : buildEventHandler(event, recognizerName, config)
   * (private) Creates the event handler for a given `eventName` that will be
   * registered to `Ractive.events`.
   */

  function buildEventHandler(eventName, recognizerName, config) {
    return function (node, fire) {
      var hammerManager = getHammerManager(node);

      var recognizerExists = (hammerManager.get(recognizerName) !== null);

      if (!recognizerExists) {
        // init with default options
        var recognizer = new config.recognizerClass(config.options);

        // Hammer.Recognizer.set merges it on top of the defaults supplied above
        var options = parseOptions(node, recognizerName);
        if (options)
          recognizer.set(options);

        hammerManager.add(recognizer);
        
        updateRecognizeWith(hammerManager);
      }

      // register the handler
      hammerManager.on(eventName, function (e) {
        fire({
          node: node,
          original: e
        });
      });

      // handle exits
      function teardown() {
        getHammerManager(node).destroy();
        delete node._hammer;
      }

      return { teardown: teardown };
    };
  }

  /**
   * updateRecognizeWith : updateRecognizeWith(hammerManager)
   * (private) Sets recognizeWith if defaults have it
   *
   * Since we add recognizers dynamically and without any strict order,
   *  we need to guard against trying to set a requireWith for a recognizer
   *  that haven't been created yet.
   * 
   */
  function updateRecognizeWith(hammerManager) {
    for (var i = 0; i < hammerManager.recognizers.length; i++) {
      var recognizer = hammerManager.recognizers[i];
      var recognizerName = recognizer.options.event;

      if (!defaults[recognizerName].hasOwnProperty('recognizeWith')) continue;
      
      var recognizeWiths = defaults[recognizerName].recognizeWith;
      for (var k = 0; k < recognizeWiths.length; k++) {
        // Verify that the recgonizer we're trying to depend on is really there
        if (!hammerManager.get(recognizeWiths[k])) continue;

        // It's safe to recognizeWith multiple times for the same recognizer
        recognizer.recognizeWith(recognizeWiths[k]);
      }
    }
  }

  /**
   * parseOptions : parseOptions(node, key)
   * (private) Returns options for a given DOM node.
   *
   *     node = <div data-swipe-direction='left' data-swipe-threshold='2'>
   *
   *     parseOptions(node, 'swipe')
   *     => { direction: 'left', threshold: 2 }
   */

  function parseOptions(node, key) {
    var attrs = node.attributes,
        output,
        re = new RegExp("^(?:data-)?"+key+"-(.*)$");

    for (var i = attrs.length-1; i >= 0; i--) {
      var attr = attrs[i],
          m = attr.name.match(re);

      if (!m) continue;
      if (!output) output = {};
      output[m[1]] = parseHammerValue(attr.value, m[1]);
    }

    return output;
  }

  /**
   * parseHammerValue : parseHammerValue(str, key)
   * (private) Value-izes a given string `str`, converting it to a number as
   * needed. If `key` is given, it can also resolve aliases for that given
   * key.
   *
   * Used by `getData()`. 
   *
   *     parseHammerValue("100")   => 100
   *     parseHammerValue("right") => "right"
   *     parseHammerValue("right", "direction") => Hammer.DIRECTION_RIGHT
   */

  function parseHammerValue(str, key) {
    if (str.match && str.match(/^-?\d+(?:\.\d+)?$/)) return +str;
    return (aliases[key] && aliases[key][str]) ||
      aliases.all[str] || str;
  }

  /*
   * Aliases for `val()`.
   */

  aliases = {
    all: {
      'true': true,
      'false': false,
      'undefined': undefined,
      'null': null
    },
    direction: {
      'none': Hammer.DIRECTION_NONE,
      'all': Hammer.DIRECTION_ALL,
      'up': Hammer.DIRECTION_UP,
      'down': Hammer.DIRECTION_DOWN,
      'left': Hammer.DIRECTION_LEFT,
      'right': Hammer.DIRECTION_RIGHT,
      'horizontal': Hammer.DIRECTION_HORIZONTAL,
      'vertical': Hammer.DIRECTION_VERTICAL
    }
  };

  /**
   * getHammerManager : getHammerManager(node)
   * (private) Returns the `HammerManager` instance for the given node.
   */

  function getHammerManager(node) {
    if (node._hammer) return node._hammer;

    node._hammer = new Hammer.Manager(node, {recognizers: []});
    return node._hammer;
  }


  return {defaults: defaults};

}));

},{"./../hammerjs/hammer.js":"/Users/luke/dev/040715/vendor/hammerjs/hammer.js","./../ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js"}],"/Users/luke/dev/040715/vendor/ractive-transitions-fade/ractive-transitions-fade.js":[function(require,module,exports){
/*

	ractive-transitions-fade
	========================

	Version 0.1.2.

	This plugin does exactly what it says on the tin - it fades elements
	in and out, using CSS transitions. You can control the following
	properties: `duration`, `delay` and `easing` (which must be a valid
	CSS transition timing function, and defaults to `linear`).

	The `duration` property is in milliseconds, and defaults to 300 (you
	can also use `fast` or `slow` instead of a millisecond value, which
	equate to 200 and 600 respectively). As a shorthand, you can use
	`intro='fade:500'` instead of `intro='fade:{"duration":500}'` - this
	applies to many other transition plugins as well.

	If an element has an opacity other than 1 (whether directly, because
	of an inline style, or indirectly because of a CSS rule), it will be
	respected. You can override the target opacity of an intro fade by
	specifying a `to` property between 0 and 1.

	==========================

	Troubleshooting: If you're using a module system in your app (AMD or
	something more nodey) then you may need to change the paths below,
	where it says `require( 'Ractive' )` or `define([ 'Ractive' ]...)`.

	==========================

	Usage: Include this file on your page below Ractive, e.g:

	    <script src='lib/ractive.js'></script>
	    <script src='lib/ractive-transitions-fade.js'></script>

	Or, if you're using a module loader, require this module:

	    // requiring the plugin will 'activate' it - no need to use
	    // the return value
	    require( 'ractive-transitions-fade' );

	Add a fade transition like so:

	    <div intro='fade'>this will fade in</div>

*/

(function ( global, factory ) {

	'use strict';

	// Common JS (i.e. browserify) environment
	if ( typeof module !== 'undefined' && module.exports && typeof require === 'function' ) {
		factory( require( "./../ractive/ractive.js" ) );
	}

	// AMD?
	else if ( typeof define === 'function' && define.amd ) {
		define([ 'ractive' ], factory );
	}

	// browser global
	else if ( global.Ractive ) {
		factory( global.Ractive );
	}

	else {
		throw new Error( 'Could not find Ractive! It must be loaded before the ractive-transitions-fade plugin' );
	}

}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

	'use strict';

	var fade, defaults;

	defaults = {
		delay: 0,
		duration: 300,
		easing: 'linear'
	};

	fade = function ( t, params ) {
		var targetOpacity;

		params = t.processParams( params, defaults );

		if ( t.isIntro ) {
			targetOpacity = t.getStyle( 'opacity' );
			t.setStyle( 'opacity', 0 );
		} else {
			targetOpacity = 0;
		}

		t.animateStyle( 'opacity', targetOpacity, params ).then( t.complete );
	};

	Ractive.transitions.fade = fade;

}));

},{"./../ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js"}],"/Users/luke/dev/040715/vendor/ractive-transitions-fly/ractive-transitions-fly.js":[function(require,module,exports){
/*

	ractive-transitions-fly
	=======================

	Version 0.1.3.

	This transition uses CSS transforms to 'fly' elements to their
	natural location on the page, fading in from transparent as they go.
	By default, they will fly in from left.

	==========================

	Troubleshooting: If you're using a module system in your app (AMD or
	something more nodey) then you may need to change the paths below,
	where it says `require( 'ractive' )` or `define([ 'ractive' ]...)`.

	==========================

	Usage: Include this file on your page below Ractive, e.g:

	    <script src='lib/ractive.js'></script>
	    <script src='lib/ractive-transitions-fly.js'></script>

	Or, if you're using a module loader, require this module:

	    // requiring the plugin will 'activate' it - no need to use
	    // the return value
	    require( 'ractive-transitions-fly' );

	You can adjust the following parameters: `x`, `y`, `duration`,
	`delay` and `easing`.

*/

(function ( global, factory ) {

	'use strict';

	// Common JS (i.e. browserify) environment
	if ( typeof module !== 'undefined' && module.exports && typeof require === 'function' ) {
		factory( require( "./../ractive/ractive.js" ) );
	}

	// AMD?
	else if ( typeof define === 'function' && define.amd ) {
		define([ 'ractive' ], factory );
	}

	// browser global
	else if ( global.Ractive ) {
		factory( global.Ractive );
	}

	else {
		throw new Error( 'Could not find Ractive! It must be loaded before the ractive-transitions-fly plugin' );
	}

}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

	'use strict';

	var fly, addPx, defaults;

	defaults = {
		duration: 800,
		easing: 'cubic-bezier(0.770, 0.000, 0.175, 1.000)',
		x: -500,
		y: 0
	};

	addPx = function ( num ) {
		if ( num === 0 || typeof num === 'string' ) {
			return num;
		}

		return num + 'px';
	};

	fly = function ( t, params ) {
		var x, y, offscreen, target;

		params = t.processParams( params, defaults );

		x = addPx( params.x );
		y = addPx( params.y );

		offscreen = {
			transform: 'translate(' + x + ',' + y + ')'
		};

		if ( t.isIntro ) {
			// animate to the current style
			target = t.getStyle([ 'transform' ]);

			// set offscreen style
			t.setStyle( offscreen );
		} else {
			target = offscreen;
		}

		t.animateStyle( target, params ).then( t.complete );
	};

	Ractive.transitions.fly = fly;

}));

},{"./../ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js"}],"/Users/luke/dev/040715/vendor/ractive-transitions-slide/ractive-transitions-slide.js":[function(require,module,exports){
/*

	ractive-transitions-slide
	=========================

	Version 0.1.2.

	This transition slides an element in and out of view,
	using CSS transitions where possible.

	==========================

	Troubleshooting: If you're using a module system in your app (AMD or
	something more nodey) then you may need to change the paths below,
	where it says `require( 'ractive' )` or `define([ 'ractive' ]...)`.

	==========================

	Usage: Include this file on your page below Ractive, e.g:

	    <script src='lib/ractive.js'></script>
	    <script src='lib/ractive-transitions-slide.js'></script>

	Or, if you're using a module loader, require this module:

	    // requiring the plugin will 'activate' it - no need to use
	    // the return value
	    require( 'ractive-transitions-slide' );

	You can specify the `delay`, `duration` and `easing` properties
	using the conventional syntax:

	    <div intro='slide:{"delay":500,"easing":"ease-out"}'>content</div>

	Both `delay` and `duration` are in milliseconds. The `easing` value
	must be a valid CSS easing function (see http://cubic-bezier.com/).

*/

(function ( global, factory ) {

	'use strict';

	// Common JS (i.e. browserify) environment
	if ( typeof module !== 'undefined' && module.exports && typeof require === 'function' ) {
		factory( require( "./../ractive/ractive.js" ) );
	}

	// AMD?
	else if ( typeof define === 'function' && define.amd ) {
		define([ 'ractive' ], factory );
	}

	// browser global
	else if ( global.Ractive ) {
		factory( global.Ractive );
	}

	else {
		throw new Error( 'Could not find Ractive! It must be loaded before the ractive-transitions-slide plugin' );
	}

}( typeof window !== 'undefined' ? window : this, function ( Ractive ) {

	'use strict';

	var slide, props, collapsed, defaults;

	defaults = {
		duration: 300,
		easing: 'easeInOut'
	};

	props = [
		'height',
		'borderTopWidth',
		'borderBottomWidth',
		'paddingTop',
		'paddingBottom',
		'marginTop',
		'marginBottom'
	];

	collapsed = {
		height: 0,
		borderTopWidth: 0,
		borderBottomWidth: 0,
		paddingTop: 0,
		paddingBottom: 0,
		marginTop: 0,
		marginBottom: 0
	};

	slide = function ( t, params ) {
		var targetStyle;

		params = t.processParams( params, defaults );

		if ( t.isIntro ) {
			targetStyle = t.getStyle( props );
			t.setStyle( collapsed );
		} else {
			// make style explicit, so we're not transitioning to 'auto'
			t.setStyle( t.getStyle( props ) );
			targetStyle = collapsed;
		}

		t.setStyle( 'overflowY', 'hidden' );

		t.animateStyle( targetStyle, params ).then( t.complete );
	};

	Ractive.transitions.slide = slide;

}));

},{"./../ractive/ractive.js":"/Users/luke/dev/040715/vendor/ractive/ractive.js"}],"/Users/luke/dev/040715/vendor/ractive/ractive.js":[function(require,module,exports){
/*
	ractive.js v0.6.1
	2014-10-25 - commit 3a576eb3 

	http://ractivejs.org
	http://twitter.com/RactiveJS

	Released under the MIT License.
*/

( function( global ) {

	'use strict';

	var noConflict = global.Ractive;

	/* config/defaults/options.js */
	var options = function() {

		var defaultOptions = {
			// render placement:
			el: void 0,
			append: false,
			// template:
			template: {
				v: 1,
				t: []
			},
			yield: null,
			// parse:
			preserveWhitespace: false,
			sanitize: false,
			stripComments: true,
			// data & binding:
			data: {},
			computed: {},
			magic: false,
			modifyArrays: true,
			adapt: [],
			isolated: false,
			twoway: true,
			lazy: false,
			// transitions:
			noIntro: false,
			transitionsEnabled: true,
			complete: void 0,
			// css:
			noCssTransform: false,
			// debug:
			debug: false
		};
		return defaultOptions;
	}();

	/* config/defaults/easing.js */
	var easing = {
		linear: function( pos ) {
			return pos;
		},
		easeIn: function( pos ) {
			return Math.pow( pos, 3 );
		},
		easeOut: function( pos ) {
			return Math.pow( pos - 1, 3 ) + 1;
		},
		easeInOut: function( pos ) {
			if ( ( pos /= 0.5 ) < 1 ) {
				return 0.5 * Math.pow( pos, 3 );
			}
			return 0.5 * ( Math.pow( pos - 2, 3 ) + 2 );
		}
	};

	/* circular.js */
	var circular = [];

	/* utils/hasOwnProperty.js */
	var hasOwn = Object.prototype.hasOwnProperty;

	/* utils/isArray.js */
	var isArray = function() {

		var toString = Object.prototype.toString;
		// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
		return function( thing ) {
			return toString.call( thing ) === '[object Array]';
		};
	}();

	/* utils/isObject.js */
	var isObject = function() {

		var toString = Object.prototype.toString;
		return function( thing ) {
			return thing && toString.call( thing ) === '[object Object]';
		};
	}();

	/* utils/isNumeric.js */
	var isNumeric = function( thing ) {
		return !isNaN( parseFloat( thing ) ) && isFinite( thing );
	};

	/* config/defaults/interpolators.js */
	var interpolators = function( circular, hasOwnProperty, isArray, isObject, isNumeric ) {

		var interpolators, interpolate, cssLengthPattern;
		circular.push( function() {
			interpolate = circular.interpolate;
		} );
		cssLengthPattern = /^([+-]?[0-9]+\.?(?:[0-9]+)?)(px|em|ex|%|in|cm|mm|pt|pc)$/;
		interpolators = {
			number: function( from, to ) {
				var delta;
				if ( !isNumeric( from ) || !isNumeric( to ) ) {
					return null;
				}
				from = +from;
				to = +to;
				delta = to - from;
				if ( !delta ) {
					return function() {
						return from;
					};
				}
				return function( t ) {
					return from + t * delta;
				};
			},
			array: function( from, to ) {
				var intermediate, interpolators, len, i;
				if ( !isArray( from ) || !isArray( to ) ) {
					return null;
				}
				intermediate = [];
				interpolators = [];
				i = len = Math.min( from.length, to.length );
				while ( i-- ) {
					interpolators[ i ] = interpolate( from[ i ], to[ i ] );
				}
				// surplus values - don't interpolate, but don't exclude them either
				for ( i = len; i < from.length; i += 1 ) {
					intermediate[ i ] = from[ i ];
				}
				for ( i = len; i < to.length; i += 1 ) {
					intermediate[ i ] = to[ i ];
				}
				return function( t ) {
					var i = len;
					while ( i-- ) {
						intermediate[ i ] = interpolators[ i ]( t );
					}
					return intermediate;
				};
			},
			object: function( from, to ) {
				var properties, len, interpolators, intermediate, prop;
				if ( !isObject( from ) || !isObject( to ) ) {
					return null;
				}
				properties = [];
				intermediate = {};
				interpolators = {};
				for ( prop in from ) {
					if ( hasOwnProperty.call( from, prop ) ) {
						if ( hasOwnProperty.call( to, prop ) ) {
							properties.push( prop );
							interpolators[ prop ] = interpolate( from[ prop ], to[ prop ] );
						} else {
							intermediate[ prop ] = from[ prop ];
						}
					}
				}
				for ( prop in to ) {
					if ( hasOwnProperty.call( to, prop ) && !hasOwnProperty.call( from, prop ) ) {
						intermediate[ prop ] = to[ prop ];
					}
				}
				len = properties.length;
				return function( t ) {
					var i = len,
						prop;
					while ( i-- ) {
						prop = properties[ i ];
						intermediate[ prop ] = interpolators[ prop ]( t );
					}
					return intermediate;
				};
			}
		};
		return interpolators;
	}( circular, hasOwn, isArray, isObject, isNumeric );

	/* config/svg.js */
	var svg = function() {

		var svg;
		if ( typeof document === 'undefined' ) {
			svg = false;
		} else {
			svg = document && document.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' );
		}
		return svg;
	}();

	/* utils/warn.js */
	var warn = function() {

		/* global console */
		var warn, warned = {};
		if ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' ) {
			warn = function( message, allowDuplicates ) {
				if ( !allowDuplicates ) {
					if ( warned[ message ] ) {
						return;
					}
					warned[ message ] = true;
				}
				console.warn( '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' );
			};
		} else {
			warn = function() {};
		}
		return warn;
	}();

	/* config/errors.js */
	var errors = {
		missingParser: 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser',
		mergeComparisonFail: 'Merge operation: comparison failed. Falling back to identity checking',
		noComponentEventArguments: 'Components currently only support simple events - you cannot include arguments. Sorry!',
		noTemplateForPartial: 'Could not find template for partial "{name}"',
		noNestedPartials: 'Partials ({{>{name}}}) cannot contain nested inline partials',
		evaluationError: 'Error evaluating "{uniqueString}": {err}',
		badArguments: 'Bad arguments "{arguments}". I\'m not allowed to argue unless you\'ve paid.',
		failedComputation: 'Failed to compute "{key}": {err}',
		missingPlugin: 'Missing "{name}" {plugin} plugin. You may need to download a {plugin} via http://docs.ractivejs.org/latest/plugins#{plugin}s',
		badRadioInputBinding: 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',
		noRegistryFunctionReturn: 'A function was specified for "{name}" {registry}, but no {registry} was returned',
		defaultElSpecified: 'The <{name}/> component has a default `el` property; it has been disregarded',
		noElementProxyEventWildcards: 'Only component proxy-events may contain "*" wildcards, <{element} on-{event}/> is not valid.',
		methodDeprecated: 'The method "{deprecated}" has been deprecated in favor of "{replacement}" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.'
	};

	/* utils/log.js */
	var log = function( consolewarn, errors ) {

		var log = {
			warn: function( options, passthru ) {
				if ( !options.debug && !passthru ) {
					return;
				}
				this.warnAlways( options );
			},
			warnAlways: function( options ) {
				this.logger( getMessage( options ), options.allowDuplicates );
			},
			error: function( options ) {
				this.errorOnly( options );
				if ( !options.debug ) {
					this.warn( options, true );
				}
			},
			errorOnly: function( options ) {
				if ( options.debug ) {
					this.critical( options );
				}
			},
			critical: function( options ) {
				var err = options.err || new Error( getMessage( options ) );
				this.thrower( err );
			},
			logger: consolewarn,
			thrower: function( err ) {
				throw err;
			}
		};

		function getMessage( options ) {
			var message = errors[ options.message ] || options.message || '';
			return interpolate( message, options.args );
		}
		// simple interpolation. probably quicker (and better) out there,
		// but log is not in golden path of execution, only exceptions
		function interpolate( message, args ) {
			return message.replace( /{([^{}]*)}/g, function( a, b ) {
				return args[ b ];
			} );
		}
		return log;
	}( warn, errors );

	/* Ractive/prototype/shared/hooks/Hook.js */
	var Ractive$shared_hooks_Hook = function( log ) {

		var deprecations = {
			construct: {
				deprecated: 'beforeInit',
				replacement: 'onconstruct'
			},
			render: {
				deprecated: 'init',
				message: 'The "init" method has been deprecated ' + 'and will likely be removed in a future release. ' + 'You can either use the "oninit" method which will fire ' + 'only once prior to, and regardless of, any eventual ractive ' + 'instance being rendered, or if you need to access the ' + 'rendered DOM, use "onrender" instead. ' + 'See http://docs.ractivejs.org/latest/migrating for more information.'
			},
			complete: {
				deprecated: 'complete',
				replacement: 'oncomplete'
			}
		};

		function Hook( event ) {
			this.event = event;
			this.method = 'on' + event;
			this.deprecate = deprecations[ event ];
		}
		Hook.prototype.fire = function( ractive, arg ) {
			function call( method ) {
				if ( ractive[ method ] ) {
					arg ? ractive[ method ]( arg ) : ractive[ method ]();
					return true;
				}
			}
			call( this.method );
			if ( !ractive[ this.method ] && this.deprecate && call( this.deprecate.deprecated ) ) {
				log.warnAlways( {
					debug: ractive.debug,
					message: this.deprecate.message || 'methodDeprecated',
					args: this.deprecate
				} );
			}
			arg ? ractive.fire( this.event, arg ) : ractive.fire( this.event );
		};
		return Hook;
	}( log );

	/* utils/removeFromArray.js */
	var removeFromArray = function( array, member ) {
		var index = array.indexOf( member );
		if ( index !== -1 ) {
			array.splice( index, 1 );
		}
	};

	/* utils/Promise.js */
	var Promise = function() {

		var __export;
		var _Promise, PENDING = {},
			FULFILLED = {},
			REJECTED = {};
		if ( typeof Promise === 'function' ) {
			// use native Promise
			_Promise = Promise;
		} else {
			_Promise = function( callback ) {
				var fulfilledHandlers = [],
					rejectedHandlers = [],
					state = PENDING,
					result, dispatchHandlers, makeResolver, fulfil, reject, promise;
				makeResolver = function( newState ) {
					return function( value ) {
						if ( state !== PENDING ) {
							return;
						}
						result = value;
						state = newState;
						dispatchHandlers = makeDispatcher( state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result );
						// dispatch onFulfilled and onRejected handlers asynchronously
						wait( dispatchHandlers );
					};
				};
				fulfil = makeResolver( FULFILLED );
				reject = makeResolver( REJECTED );
				try {
					callback( fulfil, reject );
				} catch ( err ) {
					reject( err );
				}
				promise = {
					// `then()` returns a Promise - 2.2.7
					then: function( onFulfilled, onRejected ) {
						var promise2 = new _Promise( function( fulfil, reject ) {
							var processResolutionHandler = function( handler, handlers, forward ) {
								// 2.2.1.1
								if ( typeof handler === 'function' ) {
									handlers.push( function( p1result ) {
										var x;
										try {
											x = handler( p1result );
											resolve( promise2, x, fulfil, reject );
										} catch ( err ) {
											reject( err );
										}
									} );
								} else {
									// Forward the result of promise1 to promise2, if resolution handlers
									// are not given
									handlers.push( forward );
								}
							};
							// 2.2
							processResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );
							processResolutionHandler( onRejected, rejectedHandlers, reject );
							if ( state !== PENDING ) {
								// If the promise has resolved already, dispatch the appropriate handlers asynchronously
								wait( dispatchHandlers );
							}
						} );
						return promise2;
					}
				};
				promise[ 'catch' ] = function( onRejected ) {
					return this.then( null, onRejected );
				};
				return promise;
			};
			_Promise.all = function( promises ) {
				return new _Promise( function( fulfil, reject ) {
					var result = [],
						pending, i, processPromise;
					if ( !promises.length ) {
						fulfil( result );
						return;
					}
					processPromise = function( i ) {
						promises[ i ].then( function( value ) {
							result[ i ] = value;
							if ( !--pending ) {
								fulfil( result );
							}
						}, reject );
					};
					pending = i = promises.length;
					while ( i-- ) {
						processPromise( i );
					}
				} );
			};
			_Promise.resolve = function( value ) {
				return new _Promise( function( fulfil ) {
					fulfil( value );
				} );
			};
			_Promise.reject = function( reason ) {
				return new _Promise( function( fulfil, reject ) {
					reject( reason );
				} );
			};
		}
		__export = _Promise;
		// TODO use MutationObservers or something to simulate setImmediate
		function wait( callback ) {
			setTimeout( callback, 0 );
		}

		function makeDispatcher( handlers, result ) {
			return function() {
				var handler;
				while ( handler = handlers.shift() ) {
					handler( result );
				}
			};
		}

		function resolve( promise, x, fulfil, reject ) {
			// Promise Resolution Procedure
			var then;
			// 2.3.1
			if ( x === promise ) {
				throw new TypeError( 'A promise\'s fulfillment handler cannot return the same promise' );
			}
			// 2.3.2
			if ( x instanceof _Promise ) {
				x.then( fulfil, reject );
			} else if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {
				try {
					then = x.then;
				} catch ( e ) {
					reject( e );
					// 2.3.3.2
					return;
				}
				// 2.3.3.3
				if ( typeof then === 'function' ) {
					var called, resolvePromise, rejectPromise;
					resolvePromise = function( y ) {
						if ( called ) {
							return;
						}
						called = true;
						resolve( promise, y, fulfil, reject );
					};
					rejectPromise = function( r ) {
						if ( called ) {
							return;
						}
						called = true;
						reject( r );
					};
					try {
						then.call( x, resolvePromise, rejectPromise );
					} catch ( e ) {
						if ( !called ) {
							// 2.3.3.3.4.1
							reject( e );
							// 2.3.3.3.4.2
							called = true;
							return;
						}
					}
				} else {
					fulfil( x );
				}
			} else {
				fulfil( x );
			}
		}
		return __export;
	}();

	/* utils/normaliseRef.js */
	var normaliseRef = function() {

		var regex = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
		return function normaliseRef( ref ) {
			return ( ref || '' ).replace( regex, '.$1' );
		};
	}();

	/* shared/getInnerContext.js */
	var getInnerContext = function( fragment ) {
		do {
			if ( fragment.context !== undefined ) {
				return fragment.context;
			}
		} while ( fragment = fragment.parent );
		return '';
	};

	/* utils/isEqual.js */
	var isEqual = function( a, b ) {
		if ( a === null && b === null ) {
			return true;
		}
		if ( typeof a === 'object' || typeof b === 'object' ) {
			return false;
		}
		return a === b;
	};

	/* shared/createComponentBinding.js */
	var createComponentBinding = function( circular, isEqual ) {

		var runloop;
		circular.push( function() {
			return runloop = circular.runloop;
		} );
		var Binding = function( ractive, keypath, otherInstance, otherKeypath ) {
			var this$0 = this;
			this.root = ractive;
			this.keypath = keypath;
			this.otherInstance = otherInstance;
			this.otherKeypath = otherKeypath;
			this.lock = function() {
				return this$0.updating = true;
			};
			this.unlock = function() {
				return this$0.updating = false;
			};
			this.bind();
			this.value = this.root.viewmodel.get( this.keypath );
		};
		Binding.prototype = {
			isLocked: function() {
				return this.updating || this.counterpart && this.counterpart.updating;
			},
			shuffle: function( newIndices, value ) {
				this.propagateChange( value, newIndices );
			},
			setValue: function( value ) {
				this.propagateChange( value );
			},
			propagateChange: function( value, newIndices ) {
				var other;
				// Only *you* can prevent infinite loops
				if ( this.isLocked() ) {
					this.value = value;
					return;
				}
				if ( !isEqual( value, this.value ) ) {
					this.lock();
					// TODO maybe the case that `value === this.value` - should that result
					// in an update rather than a set?
					// if the other viewmodel is already locked up, need to do a deferred update
					if ( !runloop.addViewmodel( other = this.otherInstance.viewmodel ) && this.counterpart.value !== value ) {
						runloop.scheduleTask( function() {
							return runloop.addViewmodel( other );
						} );
					}
					if ( newIndices ) {
						other.smartUpdate( this.otherKeypath, value, newIndices );
					} else {
						if ( isSettable( other, this.otherKeypath ) ) {
							other.set( this.otherKeypath, value );
						}
					}
					this.value = value;
					// TODO will the counterpart update after this line, during
					// the runloop end cycle? may be a problem...
					runloop.scheduleTask( this.unlock );
				}
			},
			refineValue: function( keypaths ) {
				var this$0 = this;
				var other;
				if ( this.isLocked() ) {
					return;
				}
				this.lock();
				runloop.addViewmodel( other = this.otherInstance.viewmodel );
				keypaths.map( function( keypath ) {
					return this$0.otherKeypath + keypath.substr( this$0.keypath.length );
				} ).forEach( function( keypath ) {
					return other.mark( keypath );
				} );
				runloop.scheduleTask( this.unlock );
			},
			bind: function() {
				this.root.viewmodel.register( this.keypath, this );
			},
			rebind: function( newKeypath ) {
				this.unbind();
				this.keypath = newKeypath;
				this.counterpart.otherKeypath = newKeypath;
				this.bind();
			},
			unbind: function() {
				this.root.viewmodel.unregister( this.keypath, this );
			}
		};

		function isSettable( viewmodel, keypath ) {
			var computed = viewmodel.computations[ keypath ];
			return !computed || computed.setter;
		}
		return function createComponentBinding( component, parentInstance, parentKeypath, childKeypath ) {
			var hash, childInstance, bindings, parentToChildBinding, childToParentBinding;
			hash = parentKeypath + '=' + childKeypath;
			bindings = component.bindings;
			if ( bindings[ hash ] ) {
				// TODO does this ever happen?
				return;
			}
			childInstance = component.instance;
			parentToChildBinding = new Binding( parentInstance, parentKeypath, childInstance, childKeypath );
			bindings.push( parentToChildBinding );
			if ( childInstance.twoway ) {
				childToParentBinding = new Binding( childInstance, childKeypath, parentInstance, parentKeypath );
				bindings.push( childToParentBinding );
				parentToChildBinding.counterpart = childToParentBinding;
				childToParentBinding.counterpart = parentToChildBinding;
			}
			bindings[ hash ] = parentToChildBinding;
		};
	}( circular, isEqual );

	/* shared/resolveRef.js */
	var resolveRef = function( normaliseRef, getInnerContext, createComponentBinding ) {

		var __export;
		var ancestorErrorMessage, getOptions;
		ancestorErrorMessage = 'Could not resolve reference - too many "../" prefixes';
		getOptions = {
			evaluateWrapped: true
		};
		__export = function resolveRef( ractive, ref, fragment, isParentLookup ) {
			var context, key, index, keypath, parentValue, hasContextChain, parentKeys, childKeys, parentKeypath, childKeypath;
			ref = normaliseRef( ref );
			// If a reference begins '~/', it's a top-level reference
			if ( ref.substr( 0, 2 ) === '~/' ) {
				return ref.substring( 2 );
			}
			// If a reference begins with '.', it's either a restricted reference or
			// an ancestor reference...
			if ( ref.charAt( 0 ) === '.' ) {
				return resolveAncestorReference( getInnerContext( fragment ), ref );
			}
			// ...otherwise we need to find the keypath
			key = ref.split( '.' )[ 0 ];
			// get() in viewmodel creation means no fragment (yet)
			fragment = fragment || {};
			do {
				context = fragment.context;
				if ( !context ) {
					continue;
				}
				hasContextChain = true;
				parentValue = ractive.viewmodel.get( context, getOptions );
				if ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) && key in parentValue ) {
					return context + '.' + ref;
				}
			} while ( fragment = fragment.parent );
			// Root/computed property?
			if ( key in ractive.data || key in ractive.viewmodel.computations ) {
				return ref;
			}
			// If this is an inline component, and it's not isolated, we
			// can try going up the scope chain
			if ( ractive._parent && !ractive.isolated ) {
				hasContextChain = true;
				fragment = ractive.component.parentFragment;
				// Special case - index refs
				if ( fragment.indexRefs && ( index = fragment.indexRefs[ ref ] ) !== undefined ) {
					// Create an index ref binding, so that it can be rebound letter if necessary.
					// It doesn't have an alias since it's an implicit binding, hence `...[ ref ] = ref`
					ractive.component.indexRefBindings[ ref ] = ref;
					ractive.viewmodel.set( ref, index, true );
					return;
				}
				keypath = resolveRef( ractive._parent, ref, fragment, true );
				if ( keypath ) {
					// We need to create an inter-component binding
					// If parent keypath is 'one.foo' and child is 'two.foo', we bind
					// 'one' to 'two' as it's more efficient and avoids edge cases
					parentKeys = keypath.split( '.' );
					childKeys = ref.split( '.' );
					while ( parentKeys.length > 1 && childKeys.length > 1 && parentKeys[ parentKeys.length - 1 ] === childKeys[ childKeys.length - 1 ] ) {
						parentKeys.pop();
						childKeys.pop();
					}
					parentKeypath = parentKeys.join( '.' );
					childKeypath = childKeys.join( '.' );
					ractive.viewmodel.set( childKeypath, ractive._parent.viewmodel.get( parentKeypath ), true );
					createComponentBinding( ractive.component, ractive._parent, parentKeypath, childKeypath );
					return ref;
				}
			}
			// If there's no context chain, and the instance is either a) isolated or
			// b) an orphan, then we know that the keypath is identical to the reference
			if ( !isParentLookup && !hasContextChain ) {
				// the data object needs to have a property by this name,
				// to prevent future failed lookups
				ractive.viewmodel.set( ref, undefined );
				return ref;
			}
			if ( ractive.viewmodel.get( ref ) !== undefined ) {
				return ref;
			}
		};

		function resolveAncestorReference( baseContext, ref ) {
			var contextKeys;
			// {{.}} means 'current context'
			if ( ref === '.' )
				return baseContext;
			contextKeys = baseContext ? baseContext.split( '.' ) : [];
			// ancestor references (starting "../") go up the tree
			if ( ref.substr( 0, 3 ) === '../' ) {
				while ( ref.substr( 0, 3 ) === '../' ) {
					if ( !contextKeys.length ) {
						throw new Error( ancestorErrorMessage );
					}
					contextKeys.pop();
					ref = ref.substring( 3 );
				}
				contextKeys.push( ref );
				return contextKeys.join( '.' );
			}
			// not an ancestor reference - must be a restricted reference (prepended with "." or "./")
			if ( !baseContext ) {
				return ref.replace( /^\.\/?/, '' );
			}
			return baseContext + ref.replace( /^\.\//, '.' );
		}
		return __export;
	}( normaliseRef, getInnerContext, createComponentBinding );

	/* global/TransitionManager.js */
	var TransitionManager = function( removeFromArray ) {

		var TransitionManager = function( callback, parent ) {
			this.callback = callback;
			this.parent = parent;
			this.intros = [];
			this.outros = [];
			this.children = [];
			this.totalChildren = this.outroChildren = 0;
			this.detachQueue = [];
			this.outrosComplete = false;
			if ( parent ) {
				parent.addChild( this );
			}
		};
		TransitionManager.prototype = {
			addChild: function( child ) {
				this.children.push( child );
				this.totalChildren += 1;
				this.outroChildren += 1;
			},
			decrementOutros: function() {
				this.outroChildren -= 1;
				check( this );
			},
			decrementTotal: function() {
				this.totalChildren -= 1;
				check( this );
			},
			add: function( transition ) {
				var list = transition.isIntro ? this.intros : this.outros;
				list.push( transition );
			},
			remove: function( transition ) {
				var list = transition.isIntro ? this.intros : this.outros;
				removeFromArray( list, transition );
				check( this );
			},
			init: function() {
				this.ready = true;
				check( this );
			},
			detachNodes: function() {
				this.detachQueue.forEach( detach );
				this.children.forEach( detachNodes );
			}
		};

		function detach( element ) {
			element.detach();
		}

		function detachNodes( tm ) {
			tm.detachNodes();
		}

		function check( tm ) {
			if ( !tm.ready || tm.outros.length || tm.outroChildren )
				return;
			// If all outros are complete, and we haven't already done this,
			// we notify the parent if there is one, otherwise
			// start detaching nodes
			if ( !tm.outrosComplete ) {
				if ( tm.parent ) {
					tm.parent.decrementOutros( tm );
				} else {
					tm.detachNodes();
				}
				tm.outrosComplete = true;
			}
			// Once everything is done, we can notify parent transition
			// manager and call the callback
			if ( !tm.intros.length && !tm.totalChildren ) {
				if ( typeof tm.callback === 'function' ) {
					tm.callback();
				}
				if ( tm.parent ) {
					tm.parent.decrementTotal();
				}
			}
		}
		return TransitionManager;
	}( removeFromArray );

	/* global/runloop.js */
	var runloop = function( circular, Hook, removeFromArray, Promise, resolveRef, TransitionManager ) {

		var __export;
		var batch, runloop, unresolved = [],
			changeHook = new Hook( 'change' );
		runloop = {
			start: function( instance, returnPromise ) {
				var promise, fulfilPromise;
				if ( returnPromise ) {
					promise = new Promise( function( f ) {
						return fulfilPromise = f;
					} );
				}
				batch = {
					previousBatch: batch,
					transitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),
					views: [],
					tasks: [],
					viewmodels: [],
					instance: instance
				};
				if ( instance ) {
					batch.viewmodels.push( instance.viewmodel );
				}
				return promise;
			},
			end: function() {
				flushChanges();
				batch.transitionManager.init();
				if ( !batch.previousBatch && !!batch.instance )
					batch.instance.viewmodel.changes = [];
				batch = batch.previousBatch;
			},
			addViewmodel: function( viewmodel ) {
				if ( batch ) {
					if ( batch.viewmodels.indexOf( viewmodel ) === -1 ) {
						batch.viewmodels.push( viewmodel );
						return true;
					} else {
						return false;
					}
				} else {
					viewmodel.applyChanges();
					return false;
				}
			},
			registerTransition: function( transition ) {
				transition._manager = batch.transitionManager;
				batch.transitionManager.add( transition );
			},
			addView: function( view ) {
				batch.views.push( view );
			},
			addUnresolved: function( thing ) {
				unresolved.push( thing );
			},
			removeUnresolved: function( thing ) {
				removeFromArray( unresolved, thing );
			},
			// synchronise node detachments with transition ends
			detachWhenReady: function( thing ) {
				batch.transitionManager.detachQueue.push( thing );
			},
			scheduleTask: function( task, postRender ) {
				var _batch;
				if ( !batch ) {
					task();
				} else {
					_batch = batch;
					while ( postRender && _batch.previousBatch ) {
						// this can't happen until the DOM has been fully updated
						// otherwise in some situations (with components inside elements)
						// transitions and decorators will initialise prematurely
						_batch = _batch.previousBatch;
					}
					_batch.tasks.push( task );
				}
			}
		};
		circular.runloop = runloop;
		__export = runloop;

		function flushChanges() {
			var i, thing, changeHash;
			for ( i = 0; i < batch.viewmodels.length; i += 1 ) {
				thing = batch.viewmodels[ i ];
				changeHash = thing.applyChanges();
				if ( changeHash ) {
					changeHook.fire( thing.ractive, changeHash );
				}
			}
			batch.viewmodels.length = 0;
			attemptKeypathResolution();
			// Now that changes have been fully propagated, we can update the DOM
			// and complete other tasks
			for ( i = 0; i < batch.views.length; i += 1 ) {
				batch.views[ i ].update();
			}
			batch.views.length = 0;
			for ( i = 0; i < batch.tasks.length; i += 1 ) {
				batch.tasks[ i ]();
			}
			batch.tasks.length = 0;
			// If updating the view caused some model blowback - e.g. a triple
			// containing <option> elements caused the binding on the <select>
			// to update - then we start over
			if ( batch.viewmodels.length )
				return flushChanges();
		}

		function attemptKeypathResolution() {
			var i, item, keypath, resolved;
			i = unresolved.length;
			// see if we can resolve any unresolved references
			while ( i-- ) {
				item = unresolved[ i ];
				if ( item.keypath ) {
					// it resolved some other way. TODO how? two-way binding? Seems
					// weird that we'd still end up here
					unresolved.splice( i, 1 );
				}
				if ( keypath = resolveRef( item.root, item.ref, item.parentFragment ) ) {
					( resolved || ( resolved = [] ) ).push( {
						item: item,
						keypath: keypath
					} );
					unresolved.splice( i, 1 );
				}
			}
			if ( resolved ) {
				resolved.forEach( resolve );
			}
		}

		function resolve( resolved ) {
			resolved.item.resolve( resolved.keypath );
		}
		return __export;
	}( circular, Ractive$shared_hooks_Hook, removeFromArray, Promise, resolveRef, TransitionManager );

	/* utils/createBranch.js */
	var createBranch = function() {

		var numeric = /^\s*[0-9]+\s*$/;
		return function( key ) {
			return numeric.test( key ) ? [] : {};
		};
	}();

	/* viewmodel/prototype/get/magicAdaptor.js */
	var viewmodel$get_magicAdaptor = function( runloop, createBranch, isArray ) {

		var __export;
		var magicAdaptor, MagicWrapper;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
			magicAdaptor = {
				filter: function( object, keypath, ractive ) {
					var keys, key, parentKeypath, parentWrapper, parentValue;
					if ( !keypath ) {
						return false;
					}
					keys = keypath.split( '.' );
					key = keys.pop();
					parentKeypath = keys.join( '.' );
					// If the parent value is a wrapper, other than a magic wrapper,
					// we shouldn't wrap this property
					if ( ( parentWrapper = ractive.viewmodel.wrapped[ parentKeypath ] ) && !parentWrapper.magic ) {
						return false;
					}
					parentValue = ractive.get( parentKeypath );
					// if parentValue is an array that doesn't include this member,
					// we should return false otherwise lengths will get messed up
					if ( isArray( parentValue ) && /^[0-9]+$/.test( key ) ) {
						return false;
					}
					return parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' );
				},
				wrap: function( ractive, property, keypath ) {
					return new MagicWrapper( ractive, property, keypath );
				}
			};
			MagicWrapper = function( ractive, value, keypath ) {
				var keys, objKeypath, template, siblings;
				this.magic = true;
				this.ractive = ractive;
				this.keypath = keypath;
				this.value = value;
				keys = keypath.split( '.' );
				this.prop = keys.pop();
				objKeypath = keys.join( '.' );
				this.obj = objKeypath ? ractive.get( objKeypath ) : ractive.data;
				template = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );
				// Has this property already been wrapped?
				if ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {
					// Yes. Register this wrapper to this property, if it hasn't been already
					if ( siblings.indexOf( this ) === -1 ) {
						siblings.push( this );
					}
					return;
				}
				// No, it hasn't been wrapped
				createAccessors( this, value, template );
			};
			MagicWrapper.prototype = {
				get: function() {
					return this.value;
				},
				reset: function( value ) {
					if ( this.updating ) {
						return;
					}
					this.updating = true;
					this.obj[ this.prop ] = value;
					// trigger set() accessor
					runloop.addViewmodel( this.ractive.viewmodel );
					this.ractive.viewmodel.mark( this.keypath );
					this.updating = false;
				},
				set: function( key, value ) {
					if ( this.updating ) {
						return;
					}
					if ( !this.obj[ this.prop ] ) {
						this.updating = true;
						this.obj[ this.prop ] = createBranch( key );
						this.updating = false;
					}
					this.obj[ this.prop ][ key ] = value;
				},
				teardown: function() {
					var template, set, value, wrappers, index;
					// If this method was called because the cache was being cleared as a
					// result of a set()/update() call made by this wrapper, we return false
					// so that it doesn't get torn down
					if ( this.updating ) {
						return false;
					}
					template = Object.getOwnPropertyDescriptor( this.obj, this.prop );
					set = template && template.set;
					if ( !set ) {
						// most likely, this was an array member that was spliced out
						return;
					}
					wrappers = set._ractiveWrappers;
					index = wrappers.indexOf( this );
					if ( index !== -1 ) {
						wrappers.splice( index, 1 );
					}
					// Last one out, turn off the lights
					if ( !wrappers.length ) {
						value = this.obj[ this.prop ];
						Object.defineProperty( this.obj, this.prop, this.originalDescriptor || {
							writable: true,
							enumerable: true,
							configurable: true
						} );
						this.obj[ this.prop ] = value;
					}
				}
			};
		} catch ( err ) {
			magicAdaptor = false;
		}
		__export = magicAdaptor;

		function createAccessors( originalWrapper, value, template ) {
			var object, property, oldGet, oldSet, get, set;
			object = originalWrapper.obj;
			property = originalWrapper.prop;
			// Is this template configurable?
			if ( template && !template.configurable ) {
				// Special case - array length
				if ( property === 'length' ) {
					return;
				}
				throw new Error( 'Cannot use magic mode with property "' + property + '" - object is not configurable' );
			}
			// Time to wrap this property
			if ( template ) {
				oldGet = template.get;
				oldSet = template.set;
			}
			get = oldGet || function() {
				return value;
			};
			set = function( v ) {
				if ( oldSet ) {
					oldSet( v );
				}
				value = oldGet ? oldGet() : v;
				set._ractiveWrappers.forEach( updateWrapper );
			};

			function updateWrapper( wrapper ) {
				var keypath, ractive;
				wrapper.value = value;
				if ( wrapper.updating ) {
					return;
				}
				ractive = wrapper.ractive;
				keypath = wrapper.keypath;
				wrapper.updating = true;
				runloop.start( ractive );
				ractive.viewmodel.mark( keypath );
				runloop.end();
				wrapper.updating = false;
			}
			// Create an array of wrappers, in case other keypaths/ractives depend on this property.
			// Handily, we can store them as a property of the set function. Yay JavaScript.
			set._ractiveWrappers = [ originalWrapper ];
			Object.defineProperty( object, property, {
				get: get,
				set: set,
				enumerable: true,
				configurable: true
			} );
		}
		return __export;
	}( runloop, createBranch, isArray );

	/* config/magic.js */
	var magic = function( magicAdaptor ) {

		return !!magicAdaptor;
	}( viewmodel$get_magicAdaptor );

	/* config/namespaces.js */
	var namespaces = {
		html: 'http://www.w3.org/1999/xhtml',
		mathml: 'http://www.w3.org/1998/Math/MathML',
		svg: 'http://www.w3.org/2000/svg',
		xlink: 'http://www.w3.org/1999/xlink',
		xml: 'http://www.w3.org/XML/1998/namespace',
		xmlns: 'http://www.w3.org/2000/xmlns/'
	};

	/* utils/createElement.js */
	var createElement = function( svg, namespaces ) {

		var createElement;
		// Test for SVG support
		if ( !svg ) {
			createElement = function( type, ns ) {
				if ( ns && ns !== namespaces.html ) {
					throw 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';
				}
				return document.createElement( type );
			};
		} else {
			createElement = function( type, ns ) {
				if ( !ns || ns === namespaces.html ) {
					return document.createElement( type );
				}
				return document.createElementNS( ns, type );
			};
		}
		return createElement;
	}( svg, namespaces );

	/* config/isClient.js */
	var isClient = function() {

		var isClient = typeof document === 'object';
		return isClient;
	}();

	/* utils/defineProperty.js */
	var defineProperty = function( isClient ) {

		var defineProperty;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
			if ( isClient ) {
				Object.defineProperty( document.createElement( 'div' ), 'test', {
					value: 0
				} );
			}
			defineProperty = Object.defineProperty;
		} catch ( err ) {
			// Object.defineProperty doesn't exist, or we're in IE8 where you can
			// only use it with DOM objects (what the fuck were you smoking, MSFT?)
			defineProperty = function( obj, prop, desc ) {
				obj[ prop ] = desc.value;
			};
		}
		return defineProperty;
	}( isClient );

	/* utils/defineProperties.js */
	var defineProperties = function( createElement, defineProperty, isClient ) {

		var defineProperties;
		try {
			try {
				Object.defineProperties( {}, {
					test: {
						value: 0
					}
				} );
			} catch ( err ) {
				// TODO how do we account for this? noMagic = true;
				throw err;
			}
			if ( isClient ) {
				Object.defineProperties( createElement( 'div' ), {
					test: {
						value: 0
					}
				} );
			}
			defineProperties = Object.defineProperties;
		} catch ( err ) {
			defineProperties = function( obj, props ) {
				var prop;
				for ( prop in props ) {
					if ( props.hasOwnProperty( prop ) ) {
						defineProperty( obj, prop, props[ prop ] );
					}
				}
			};
		}
		return defineProperties;
	}( createElement, defineProperty, isClient );

	/* Ractive/prototype/shared/add.js */
	var Ractive$shared_add = function( isNumeric ) {

		return function add( root, keypath, d ) {
			var value;
			if ( typeof keypath !== 'string' || !isNumeric( d ) ) {
				throw new Error( 'Bad arguments' );
			}
			value = +root.get( keypath ) || 0;
			if ( !isNumeric( value ) ) {
				throw new Error( 'Cannot add to a non-numeric value' );
			}
			return root.set( keypath, value + d );
		};
	}( isNumeric );

	/* Ractive/prototype/add.js */
	var Ractive$add = function( add ) {

		return function Ractive$add( keypath, d ) {
			return add( this, keypath, d === undefined ? 1 : +d );
		};
	}( Ractive$shared_add );

	/* utils/normaliseKeypath.js */
	var normaliseKeypath = function( normaliseRef ) {

		var leadingDot = /^\.+/;
		return function normaliseKeypath( keypath ) {
			return normaliseRef( keypath ).replace( leadingDot, '' );
		};
	}( normaliseRef );

	/* config/vendors.js */
	var vendors = [
		'o',
		'ms',
		'moz',
		'webkit'
	];

	/* utils/requestAnimationFrame.js */
	var requestAnimationFrame = function( vendors ) {

		var requestAnimationFrame;
		// If window doesn't exist, we don't need requestAnimationFrame
		if ( typeof window === 'undefined' ) {
			requestAnimationFrame = null;
		} else {
			// https://gist.github.com/paulirish/1579671
			( function( vendors, lastTime, window ) {
				var x, setTimeout;
				if ( window.requestAnimationFrame ) {
					return;
				}
				for ( x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {
					window.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];
				}
				if ( !window.requestAnimationFrame ) {
					setTimeout = window.setTimeout;
					window.requestAnimationFrame = function( callback ) {
						var currTime, timeToCall, id;
						currTime = Date.now();
						timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
						id = setTimeout( function() {
							callback( currTime + timeToCall );
						}, timeToCall );
						lastTime = currTime + timeToCall;
						return id;
					};
				}
			}( vendors, 0, window ) );
			requestAnimationFrame = window.requestAnimationFrame;
		}
		return requestAnimationFrame;
	}( vendors );

	/* utils/getTime.js */
	var getTime = function() {

		var getTime;
		if ( typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function' ) {
			getTime = function() {
				return window.performance.now();
			};
		} else {
			getTime = function() {
				return Date.now();
			};
		}
		return getTime;
	}();

	/* shared/animations.js */
	var animations = function( rAF, getTime, runloop ) {

		var queue = [];
		var animations = {
			tick: function() {
				var i, animation, now;
				now = getTime();
				runloop.start();
				for ( i = 0; i < queue.length; i += 1 ) {
					animation = queue[ i ];
					if ( !animation.tick( now ) ) {
						// animation is complete, remove it from the stack, and decrement i so we don't miss one
						queue.splice( i--, 1 );
					}
				}
				runloop.end();
				if ( queue.length ) {
					rAF( animations.tick );
				} else {
					animations.running = false;
				}
			},
			add: function( animation ) {
				queue.push( animation );
				if ( !animations.running ) {
					animations.running = true;
					rAF( animations.tick );
				}
			},
			// TODO optimise this
			abort: function( keypath, root ) {
				var i = queue.length,
					animation;
				while ( i-- ) {
					animation = queue[ i ];
					if ( animation.root === root && animation.keypath === keypath ) {
						animation.stop();
					}
				}
			}
		};
		return animations;
	}( requestAnimationFrame, getTime, runloop );

	/* config/options/css/transform.js */
	var transform = function() {

		var __export;
		var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g,
			commentsPattern = /\/\*.*?\*\//g,
			selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>\~:]))+)((?::[^\s\+\>\~]+)?\s*[\s\+\>\~]?)\s*/g,
			mediaQueryPattern = /^@media/,
			dataRvcGuidPattern = /\[data-rvcguid="[a-z0-9-]+"]/g;
		__export = function transformCss( css, guid ) {
			var transformed, addGuid;
			addGuid = function( selector ) {
				var selectorUnits, match, unit, dataAttr, base, prepended, appended, i, transformed = [];
				selectorUnits = [];
				while ( match = selectorUnitPattern.exec( selector ) ) {
					selectorUnits.push( {
						str: match[ 0 ],
						base: match[ 1 ],
						modifiers: match[ 2 ]
					} );
				}
				// For each simple selector within the selector, we need to create a version
				// that a) combines with the guid, and b) is inside the guid
				dataAttr = '[data-rvcguid="' + guid + '"]';
				base = selectorUnits.map( extractString );
				i = selectorUnits.length;
				while ( i-- ) {
					appended = base.slice();
					// Pseudo-selectors should go after the attribute selector
					unit = selectorUnits[ i ];
					appended[ i ] = unit.base + dataAttr + unit.modifiers || '';
					prepended = base.slice();
					prepended[ i ] = dataAttr + ' ' + prepended[ i ];
					transformed.push( appended.join( ' ' ), prepended.join( ' ' ) );
				}
				return transformed.join( ', ' );
			};
			if ( dataRvcGuidPattern.test( css ) ) {
				transformed = css.replace( dataRvcGuidPattern, '[data-rvcguid="' + guid + '"]' );
			} else {
				transformed = css.replace( commentsPattern, '' ).replace( selectorsPattern, function( match, $1 ) {
					var selectors, transformed;
					// don't transform media queries!
					if ( mediaQueryPattern.test( $1 ) )
						return match;
					selectors = $1.split( ',' ).map( trim );
					transformed = selectors.map( addGuid ).join( ', ' ) + ' ';
					return match.replace( $1, transformed );
				} );
			}
			return transformed;
		};

		function trim( str ) {
			if ( str.trim ) {
				return str.trim();
			}
			return str.replace( /^\s+/, '' ).replace( /\s+$/, '' );
		}

		function extractString( unit ) {
			return unit.str;
		}
		return __export;
	}();

	/* config/options/css/css.js */
	var css = function( transformCss ) {

		var cssConfig = {
			name: 'css',
			extend: extend,
			init: function() {}
		};

		function extend( Parent, proto, options ) {
			var guid = proto.constructor._guid,
				css;
			if ( css = getCss( options.css, options, guid ) || getCss( Parent.css, Parent, guid ) ) {
				proto.constructor.css = css;
			}
		}

		function getCss( css, target, guid ) {
			if ( !css ) {
				return;
			}
			return target.noCssTransform ? css : transformCss( css, guid );
		}
		return cssConfig;
	}( transform );

	/* utils/wrapMethod.js */
	var wrapMethod = function() {

		var __export;
		__export = function( method, superMethod, force ) {
			if ( force || needsSuper( method, superMethod ) ) {
				return function() {
					var hasSuper = '_super' in this,
						_super = this._super,
						result;
					this._super = superMethod;
					result = method.apply( this, arguments );
					if ( hasSuper ) {
						this._super = _super;
					}
					return result;
				};
			} else {
				return method;
			}
		};

		function needsSuper( method, superMethod ) {
			return typeof superMethod === 'function' && /_super/.test( method );
		}
		return __export;
	}();

	/* config/options/data.js */
	var data = function( wrap ) {

		var __export;
		var dataConfig = {
			name: 'data',
			extend: extend,
			init: init,
			reset: reset
		};
		__export = dataConfig;

		function combine( Parent, target, options ) {
			var value = options.data || {},
				parentValue = getAddedKeys( Parent.prototype.data );
			if ( typeof value !== 'object' && typeof value !== 'function' ) {
				throw new TypeError( 'data option must be an object or a function, "' + value + '" is not valid' );
			}
			return dispatch( parentValue, value );
		}

		function extend( Parent, proto, options ) {
			proto.data = combine( Parent, proto, options );
		}

		function init( Parent, ractive, options ) {
			var value = options.data,
				result = combine( Parent, ractive, options );
			if ( typeof result === 'function' ) {
				result = result.call( ractive, value ) || value;
			}
			return ractive.data = result || {};
		}

		function reset( ractive ) {
			var result = this.init( ractive.constructor, ractive, ractive );
			if ( result ) {
				ractive.data = result;
				return true;
			}
		}

		function getAddedKeys( parent ) {
			// only for functions that had keys added
			if ( typeof parent !== 'function' || !Object.keys( parent ).length ) {
				return parent;
			}
			// copy the added keys to temp 'object', otherwise
			// parent would be interpreted as 'function' by dispatch
			var temp = {};
			copy( parent, temp );
			// roll in added keys
			return dispatch( parent, temp );
		}

		function dispatch( parent, child ) {
			if ( typeof child === 'function' ) {
				return extendFn( child, parent );
			} else if ( typeof parent === 'function' ) {
				return fromFn( child, parent );
			} else {
				return fromProperties( child, parent );
			}
		}

		function copy( from, to, fillOnly ) {
			for ( var key in from ) {
				if ( fillOnly && key in to ) {
					continue;
				}
				to[ key ] = from[ key ];
			}
		}

		function fromProperties( child, parent ) {
			child = child || {};
			if ( !parent ) {
				return child;
			}
			copy( parent, child, true );
			return child;
		}

		function fromFn( child, parentFn ) {
			return function( data ) {
				var keys;
				if ( child ) {
					// Track the keys that our on the child,
					// but not on the data. We'll need to apply these
					// after the parent function returns.
					keys = [];
					for ( var key in child ) {
						if ( !data || !( key in data ) ) {
							keys.push( key );
						}
					}
				}
				// call the parent fn, use data if no return value
				data = parentFn.call( this, data ) || data;
				// Copy child keys back onto data. The child keys
				// should take precedence over whatever the
				// parent did with the data.
				if ( keys && keys.length ) {
					data = data || {};
					keys.forEach( function( key ) {
						data[ key ] = child[ key ];
					} );
				}
				return data;
			};
		}

		function extendFn( childFn, parent ) {
			var parentFn;
			if ( typeof parent !== 'function' ) {
				// copy props to data
				parentFn = function( data ) {
					fromProperties( data, parent );
				};
			} else {
				parentFn = function( data ) {
					// give parent function it's own this._super context,
					// otherwise this._super is from child and
					// causes infinite loop
					parent = wrap( parent, function() {}, true );
					return parent.call( this, data ) || data;
				};
			}
			return wrap( childFn, parentFn );
		}
		return __export;
	}( wrapMethod );

	/* config/types.js */
	var types = {
		TEXT: 1,
		INTERPOLATOR: 2,
		TRIPLE: 3,
		SECTION: 4,
		INVERTED: 5,
		CLOSING: 6,
		ELEMENT: 7,
		PARTIAL: 8,
		COMMENT: 9,
		DELIMCHANGE: 10,
		MUSTACHE: 11,
		TAG: 12,
		ATTRIBUTE: 13,
		CLOSING_TAG: 14,
		COMPONENT: 15,
		NUMBER_LITERAL: 20,
		STRING_LITERAL: 21,
		ARRAY_LITERAL: 22,
		OBJECT_LITERAL: 23,
		BOOLEAN_LITERAL: 24,
		GLOBAL: 26,
		KEY_VALUE_PAIR: 27,
		REFERENCE: 30,
		REFINEMENT: 31,
		MEMBER: 32,
		PREFIX_OPERATOR: 33,
		BRACKETED: 34,
		CONDITIONAL: 35,
		INFIX_OPERATOR: 36,
		INVOCATION: 40,
		SECTION_IF: 50,
		SECTION_UNLESS: 51,
		SECTION_EACH: 52,
		SECTION_WITH: 53,
		SECTION_IF_WITH: 54
	};

	/* utils/create.js */
	var create = function() {

		var create;
		try {
			Object.create( null );
			create = Object.create;
		} catch ( err ) {
			// sigh
			create = function() {
				var F = function() {};
				return function( proto, props ) {
					var obj;
					if ( proto === null ) {
						return {};
					}
					F.prototype = proto;
					obj = new F();
					if ( props ) {
						Object.defineProperties( obj, props );
					}
					return obj;
				};
			}();
		}
		return create;
	}();

	/* parse/Parser/expressions/shared/errors.js */
	var parse_Parser_expressions_shared_errors = {
		expectedExpression: 'Expected a JavaScript expression',
		expectedParen: 'Expected closing paren'
	};

	/* parse/Parser/expressions/primary/literal/numberLiteral.js */
	var numberLiteral = function( types ) {

		var numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
		return function( parser ) {
			var result;
			if ( result = parser.matchPattern( numberPattern ) ) {
				return {
					t: types.NUMBER_LITERAL,
					v: result
				};
			}
			return null;
		};
	}( types );

	/* parse/Parser/expressions/primary/literal/booleanLiteral.js */
	var booleanLiteral = function( types ) {

		return function( parser ) {
			var remaining = parser.remaining();
			if ( remaining.substr( 0, 4 ) === 'true' ) {
				parser.pos += 4;
				return {
					t: types.BOOLEAN_LITERAL,
					v: 'true'
				};
			}
			if ( remaining.substr( 0, 5 ) === 'false' ) {
				parser.pos += 5;
				return {
					t: types.BOOLEAN_LITERAL,
					v: 'false'
				};
			}
			return null;
		};
	}( types );

	/* parse/Parser/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js */
	var makeQuotedStringMatcher = function() {

		var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;
		// Match one or more characters until: ", ', \, or EOL/EOF.
		// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
		stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;
		// Match one escape sequence, including the backslash.
		escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;
		// Match one ES5 line continuation (backslash + line terminator).
		lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;
		// Helper for defining getDoubleQuotedString and getSingleQuotedString.
		return function( okQuote ) {
			return function( parser ) {
				var start, literal, done, next;
				start = parser.pos;
				literal = '"';
				done = false;
				while ( !done ) {
					next = parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) || parser.matchString( okQuote );
					if ( next ) {
						if ( next === '"' ) {
							literal += '\\"';
						} else if ( next === '\\\'' ) {
							literal += '\'';
						} else {
							literal += next;
						}
					} else {
						next = parser.matchPattern( lineContinuationPattern );
						if ( next ) {
							// convert \(newline-like) into a \u escape, which is allowed in JSON
							literal += '\\u' + ( '000' + next.charCodeAt( 1 ).toString( 16 ) ).slice( -4 );
						} else {
							done = true;
						}
					}
				}
				literal += '"';
				// use JSON.parse to interpret escapes
				return JSON.parse( literal );
			};
		};
	}();

	/* parse/Parser/expressions/primary/literal/stringLiteral/singleQuotedString.js */
	var singleQuotedString = function( makeQuotedStringMatcher ) {

		return makeQuotedStringMatcher( '"' );
	}( makeQuotedStringMatcher );

	/* parse/Parser/expressions/primary/literal/stringLiteral/doubleQuotedString.js */
	var doubleQuotedString = function( makeQuotedStringMatcher ) {

		return makeQuotedStringMatcher( '\'' );
	}( makeQuotedStringMatcher );

	/* parse/Parser/expressions/primary/literal/stringLiteral/_stringLiteral.js */
	var stringLiteral = function( types, getSingleQuotedString, getDoubleQuotedString ) {

		return function( parser ) {
			var start, string;
			start = parser.pos;
			if ( parser.matchString( '"' ) ) {
				string = getDoubleQuotedString( parser );
				if ( !parser.matchString( '"' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.STRING_LITERAL,
					v: string
				};
			}
			if ( parser.matchString( '\'' ) ) {
				string = getSingleQuotedString( parser );
				if ( !parser.matchString( '\'' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.STRING_LITERAL,
					v: string
				};
			}
			return null;
		};
	}( types, singleQuotedString, doubleQuotedString );

	/* parse/Parser/expressions/shared/patterns.js */
	var patterns = {
		name: /^[a-zA-Z_$][a-zA-Z_$0-9]*/
	};

	/* parse/Parser/expressions/shared/key.js */
	var key = function( getStringLiteral, getNumberLiteral, patterns ) {

		var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		// http://mathiasbynens.be/notes/javascript-properties
		// can be any name, string literal, or number literal
		return function( parser ) {
			var token;
			if ( token = getStringLiteral( parser ) ) {
				return identifier.test( token.v ) ? token.v : '"' + token.v.replace( /"/g, '\\"' ) + '"';
			}
			if ( token = getNumberLiteral( parser ) ) {
				return token.v;
			}
			if ( token = parser.matchPattern( patterns.name ) ) {
				return token;
			}
		};
	}( stringLiteral, numberLiteral, patterns );

	/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePair.js */
	var keyValuePair = function( types, getKey ) {

		return function( parser ) {
			var start, key, value;
			start = parser.pos;
			// allow whitespace between '{' and key
			parser.allowWhitespace();
			key = getKey( parser );
			if ( key === null ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace between key and ':'
			parser.allowWhitespace();
			// next character must be ':'
			if ( !parser.matchString( ':' ) ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace between ':' and value
			parser.allowWhitespace();
			// next expression must be a, well... expression
			value = parser.readExpression();
			if ( value === null ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.KEY_VALUE_PAIR,
				k: key,
				v: value
			};
		};
	}( types, key );

	/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePairs.js */
	var keyValuePairs = function( getKeyValuePair ) {

		return function getKeyValuePairs( parser ) {
			var start, pairs, pair, keyValuePairs;
			start = parser.pos;
			pair = getKeyValuePair( parser );
			if ( pair === null ) {
				return null;
			}
			pairs = [ pair ];
			if ( parser.matchString( ',' ) ) {
				keyValuePairs = getKeyValuePairs( parser );
				if ( !keyValuePairs ) {
					parser.pos = start;
					return null;
				}
				return pairs.concat( keyValuePairs );
			}
			return pairs;
		};
	}( keyValuePair );

	/* parse/Parser/expressions/primary/literal/objectLiteral/_objectLiteral.js */
	var objectLiteral = function( types, getKeyValuePairs ) {

		return function( parser ) {
			var start, keyValuePairs;
			start = parser.pos;
			// allow whitespace
			parser.allowWhitespace();
			if ( !parser.matchString( '{' ) ) {
				parser.pos = start;
				return null;
			}
			keyValuePairs = getKeyValuePairs( parser );
			// allow whitespace between final value and '}'
			parser.allowWhitespace();
			if ( !parser.matchString( '}' ) ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.OBJECT_LITERAL,
				m: keyValuePairs
			};
		};
	}( types, keyValuePairs );

	/* parse/Parser/expressions/shared/expressionList.js */
	var expressionList = function( errors ) {

		return function getExpressionList( parser ) {
			var start, expressions, expr, next;
			start = parser.pos;
			parser.allowWhitespace();
			expr = parser.readExpression();
			if ( expr === null ) {
				return null;
			}
			expressions = [ expr ];
			// allow whitespace between expression and ','
			parser.allowWhitespace();
			if ( parser.matchString( ',' ) ) {
				next = getExpressionList( parser );
				if ( next === null ) {
					parser.error( errors.expectedExpression );
				}
				next.forEach( append );
			}

			function append( expression ) {
				expressions.push( expression );
			}
			return expressions;
		};
	}( parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/primary/literal/arrayLiteral.js */
	var arrayLiteral = function( types, getExpressionList ) {

		return function( parser ) {
			var start, expressionList;
			start = parser.pos;
			// allow whitespace before '['
			parser.allowWhitespace();
			if ( !parser.matchString( '[' ) ) {
				parser.pos = start;
				return null;
			}
			expressionList = getExpressionList( parser );
			if ( !parser.matchString( ']' ) ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.ARRAY_LITERAL,
				m: expressionList
			};
		};
	}( types, expressionList );

	/* parse/Parser/expressions/primary/literal/_literal.js */
	var literal = function( getNumberLiteral, getBooleanLiteral, getStringLiteral, getObjectLiteral, getArrayLiteral ) {

		return function( parser ) {
			var literal = getNumberLiteral( parser ) || getBooleanLiteral( parser ) || getStringLiteral( parser ) || getObjectLiteral( parser ) || getArrayLiteral( parser );
			return literal;
		};
	}( numberLiteral, booleanLiteral, stringLiteral, objectLiteral, arrayLiteral );

	/* parse/Parser/expressions/primary/reference.js */
	var reference = function( types, patterns ) {

		var dotRefinementPattern, arrayMemberPattern, getArrayRefinement, globals, keywords;
		dotRefinementPattern = /^\.[a-zA-Z_$0-9]+/;
		getArrayRefinement = function( parser ) {
			var num = parser.matchPattern( arrayMemberPattern );
			if ( num ) {
				return '.' + num;
			}
			return null;
		};
		arrayMemberPattern = /^\[(0|[1-9][0-9]*)\]/;
		// if a reference is a browser global, we don't deference it later, so it needs special treatment
		globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)$/;
		// keywords are not valid references, with the exception of `this`
		keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;
		return function( parser ) {
			var startPos, ancestor, name, dot, combo, refinement, lastDotIndex;
			startPos = parser.pos;
			// we might have a root-level reference
			if ( parser.matchString( '~/' ) ) {
				ancestor = '~/';
			} else {
				// we might have ancestor refs...
				ancestor = '';
				while ( parser.matchString( '../' ) ) {
					ancestor += '../';
				}
			}
			if ( !ancestor ) {
				// we might have an implicit iterator or a restricted reference
				dot = parser.matchString( './' ) || parser.matchString( '.' ) || '';
			}
			name = parser.matchPattern( /^@(?:keypath|index|key)/ ) || parser.matchPattern( patterns.name ) || '';
			// bug out if it's a keyword
			if ( keywords.test( name ) ) {
				parser.pos = startPos;
				return null;
			}
			// if this is a browser global, stop here
			if ( !ancestor && !dot && globals.test( name ) ) {
				return {
					t: types.GLOBAL,
					v: name
				};
			}
			combo = ( ancestor || dot ) + name;
			if ( !combo ) {
				return null;
			}
			while ( refinement = parser.matchPattern( dotRefinementPattern ) || getArrayRefinement( parser ) ) {
				combo += refinement;
			}
			if ( parser.matchString( '(' ) ) {
				// if this is a method invocation (as opposed to a function) we need
				// to strip the method name from the reference combo, else the context
				// will be wrong
				lastDotIndex = combo.lastIndexOf( '.' );
				if ( lastDotIndex !== -1 ) {
					combo = combo.substr( 0, lastDotIndex );
					parser.pos = startPos + combo.length;
				} else {
					parser.pos -= 1;
				}
			}
			return {
				t: types.REFERENCE,
				n: combo.replace( /^this\./, './' ).replace( /^this$/, '.' )
			};
		};
	}( types, patterns );

	/* parse/Parser/expressions/primary/bracketedExpression.js */
	var bracketedExpression = function( types, errors ) {

		return function( parser ) {
			var start, expr;
			start = parser.pos;
			if ( !parser.matchString( '(' ) ) {
				return null;
			}
			parser.allowWhitespace();
			expr = parser.readExpression();
			if ( !expr ) {
				parser.error( errors.expectedExpression );
			}
			parser.allowWhitespace();
			if ( !parser.matchString( ')' ) ) {
				parser.error( errors.expectedParen );
			}
			return {
				t: types.BRACKETED,
				x: expr
			};
		};
	}( types, parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/primary/_primary.js */
	var primary = function( getLiteral, getReference, getBracketedExpression ) {

		return function( parser ) {
			return getLiteral( parser ) || getReference( parser ) || getBracketedExpression( parser );
		};
	}( literal, reference, bracketedExpression );

	/* parse/Parser/expressions/shared/refinement.js */
	var refinement = function( types, errors, patterns ) {

		return function getRefinement( parser ) {
			var start, name, expr;
			start = parser.pos;
			parser.allowWhitespace();
			// "." name
			if ( parser.matchString( '.' ) ) {
				parser.allowWhitespace();
				if ( name = parser.matchPattern( patterns.name ) ) {
					return {
						t: types.REFINEMENT,
						n: name
					};
				}
				parser.error( 'Expected a property name' );
			}
			// "[" expression "]"
			if ( parser.matchString( '[' ) ) {
				parser.allowWhitespace();
				expr = parser.readExpression();
				if ( !expr ) {
					parser.error( errors.expectedExpression );
				}
				parser.allowWhitespace();
				if ( !parser.matchString( ']' ) ) {
					parser.error( 'Expected \']\'' );
				}
				return {
					t: types.REFINEMENT,
					x: expr
				};
			}
			return null;
		};
	}( types, parse_Parser_expressions_shared_errors, patterns );

	/* parse/Parser/expressions/memberOrInvocation.js */
	var memberOrInvocation = function( types, getPrimary, getExpressionList, getRefinement, errors ) {

		return function( parser ) {
			var current, expression, refinement, expressionList;
			expression = getPrimary( parser );
			if ( !expression ) {
				return null;
			}
			while ( expression ) {
				current = parser.pos;
				if ( refinement = getRefinement( parser ) ) {
					expression = {
						t: types.MEMBER,
						x: expression,
						r: refinement
					};
				} else if ( parser.matchString( '(' ) ) {
					parser.allowWhitespace();
					expressionList = getExpressionList( parser );
					parser.allowWhitespace();
					if ( !parser.matchString( ')' ) ) {
						parser.error( errors.expectedParen );
					}
					expression = {
						t: types.INVOCATION,
						x: expression
					};
					if ( expressionList ) {
						expression.o = expressionList;
					}
				} else {
					break;
				}
			}
			return expression;
		};
	}( types, primary, expressionList, refinement, parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/typeof.js */
	var _typeof = function( types, errors, getMemberOrInvocation ) {

		var getTypeof, makePrefixSequenceMatcher;
		makePrefixSequenceMatcher = function( symbol, fallthrough ) {
			return function( parser ) {
				var expression;
				if ( expression = fallthrough( parser ) ) {
					return expression;
				}
				if ( !parser.matchString( symbol ) ) {
					return null;
				}
				parser.allowWhitespace();
				expression = parser.readExpression();
				if ( !expression ) {
					parser.error( errors.expectedExpression );
				}
				return {
					s: symbol,
					o: expression,
					t: types.PREFIX_OPERATOR
				};
			};
		};
		// create all prefix sequence matchers, return getTypeof
		( function() {
			var i, len, matcher, prefixOperators, fallthrough;
			prefixOperators = '! ~ + - typeof'.split( ' ' );
			fallthrough = getMemberOrInvocation;
			for ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {
				matcher = makePrefixSequenceMatcher( prefixOperators[ i ], fallthrough );
				fallthrough = matcher;
			}
			// typeof operator is higher precedence than multiplication, so provides the
			// fallthrough for the multiplication sequence matcher we're about to create
			// (we're skipping void and delete)
			getTypeof = fallthrough;
		}() );
		return getTypeof;
	}( types, parse_Parser_expressions_shared_errors, memberOrInvocation );

	/* parse/Parser/expressions/logicalOr.js */
	var logicalOr = function( types, getTypeof ) {

		var getLogicalOr, makeInfixSequenceMatcher;
		makeInfixSequenceMatcher = function( symbol, fallthrough ) {
			return function( parser ) {
				var start, left, right;
				left = fallthrough( parser );
				if ( !left ) {
					return null;
				}
				// Loop to handle left-recursion in a case like `a * b * c` and produce
				// left association, i.e. `(a * b) * c`.  The matcher can't call itself
				// to parse `left` because that would be infinite regress.
				while ( true ) {
					start = parser.pos;
					parser.allowWhitespace();
					if ( !parser.matchString( symbol ) ) {
						parser.pos = start;
						return left;
					}
					// special case - in operator must not be followed by [a-zA-Z_$0-9]
					if ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {
						parser.pos = start;
						return left;
					}
					parser.allowWhitespace();
					// right operand must also consist of only higher-precedence operators
					right = fallthrough( parser );
					if ( !right ) {
						parser.pos = start;
						return left;
					}
					left = {
						t: types.INFIX_OPERATOR,
						s: symbol,
						o: [
							left,
							right
						]
					};
				}
			};
		};
		// create all infix sequence matchers, and return getLogicalOr
		( function() {
			var i, len, matcher, infixOperators, fallthrough;
			// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
			// Each sequence matcher will initially fall through to its higher precedence
			// neighbour, and only attempt to match if one of the higher precedence operators
			// (or, ultimately, a literal, reference, or bracketed expression) already matched
			infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );
			// A typeof operator is higher precedence than multiplication
			fallthrough = getTypeof;
			for ( i = 0, len = infixOperators.length; i < len; i += 1 ) {
				matcher = makeInfixSequenceMatcher( infixOperators[ i ], fallthrough );
				fallthrough = matcher;
			}
			// Logical OR is the fallthrough for the conditional matcher
			getLogicalOr = fallthrough;
		}() );
		return getLogicalOr;
	}( types, _typeof );

	/* parse/Parser/expressions/conditional.js */
	var conditional = function( types, getLogicalOr, errors ) {

		return function( parser ) {
			var start, expression, ifTrue, ifFalse;
			expression = getLogicalOr( parser );
			if ( !expression ) {
				return null;
			}
			start = parser.pos;
			parser.allowWhitespace();
			if ( !parser.matchString( '?' ) ) {
				parser.pos = start;
				return expression;
			}
			parser.allowWhitespace();
			ifTrue = parser.readExpression();
			if ( !ifTrue ) {
				parser.error( errors.expectedExpression );
			}
			parser.allowWhitespace();
			if ( !parser.matchString( ':' ) ) {
				parser.error( 'Expected ":"' );
			}
			parser.allowWhitespace();
			ifFalse = parser.readExpression();
			if ( !ifFalse ) {
				parser.error( errors.expectedExpression );
			}
			return {
				t: types.CONDITIONAL,
				o: [
					expression,
					ifTrue,
					ifFalse
				]
			};
		};
	}( types, logicalOr, parse_Parser_expressions_shared_errors );

	/* parse/Parser/utils/flattenExpression.js */
	var flattenExpression = function( types, isObject ) {

		var __export;
		__export = function( expression ) {
			var refs = [],
				flattened;
			extractRefs( expression, refs );
			flattened = {
				r: refs,
				s: stringify( this, expression, refs )
			};
			return flattened;
		};

		function quoteStringLiteral( str ) {
			return JSON.stringify( String( str ) );
		}
		// TODO maybe refactor this?
		function extractRefs( node, refs ) {
			var i, list;
			if ( node.t === types.REFERENCE ) {
				if ( refs.indexOf( node.n ) === -1 ) {
					refs.unshift( node.n );
				}
			}
			list = node.o || node.m;
			if ( list ) {
				if ( isObject( list ) ) {
					extractRefs( list, refs );
				} else {
					i = list.length;
					while ( i-- ) {
						extractRefs( list[ i ], refs );
					}
				}
			}
			if ( node.x ) {
				extractRefs( node.x, refs );
			}
			if ( node.r ) {
				extractRefs( node.r, refs );
			}
			if ( node.v ) {
				extractRefs( node.v, refs );
			}
		}

		function stringify( parser, node, refs ) {
			var stringifyAll = function( item ) {
				return stringify( parser, item, refs );
			};
			switch ( node.t ) {
				case types.BOOLEAN_LITERAL:
				case types.GLOBAL:
				case types.NUMBER_LITERAL:
					return node.v;
				case types.STRING_LITERAL:
					return quoteStringLiteral( node.v );
				case types.ARRAY_LITERAL:
					return '[' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + ']';
				case types.OBJECT_LITERAL:
					return '{' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + '}';
				case types.KEY_VALUE_PAIR:
					return node.k + ':' + stringify( parser, node.v, refs );
				case types.PREFIX_OPERATOR:
					return ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( parser, node.o, refs );
				case types.INFIX_OPERATOR:
					return stringify( parser, node.o[ 0 ], refs ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( parser, node.o[ 1 ], refs );
				case types.INVOCATION:
					return stringify( parser, node.x, refs ) + '(' + ( node.o ? node.o.map( stringifyAll ).join( ',' ) : '' ) + ')';
				case types.BRACKETED:
					return '(' + stringify( parser, node.x, refs ) + ')';
				case types.MEMBER:
					return stringify( parser, node.x, refs ) + stringify( parser, node.r, refs );
				case types.REFINEMENT:
					return node.n ? '.' + node.n : '[' + stringify( parser, node.x, refs ) + ']';
				case types.CONDITIONAL:
					return stringify( parser, node.o[ 0 ], refs ) + '?' + stringify( parser, node.o[ 1 ], refs ) + ':' + stringify( parser, node.o[ 2 ], refs );
				case types.REFERENCE:
					return '_' + refs.indexOf( node.n );
				default:
					parser.error( 'Expected legal JavaScript' );
			}
		}
		return __export;
	}( types, isObject );

	/* parse/Parser/_Parser.js */
	var Parser = function( circular, create, hasOwnProperty, getConditional, flattenExpression ) {

		var Parser, ParseError, leadingWhitespace = /^\s+/;
		ParseError = function( message ) {
			this.name = 'ParseError';
			this.message = message;
			try {
				throw new Error( message );
			} catch ( e ) {
				this.stack = e.stack;
			}
		};
		ParseError.prototype = Error.prototype;
		Parser = function( str, options ) {
			var items, item, lineStart = 0;
			this.str = str;
			this.options = options || {};
			this.pos = 0;
			this.lines = this.str.split( '\n' );
			this.lineEnds = this.lines.map( function( line ) {
				var lineEnd = lineStart + line.length + 1;
				// +1 for the newline
				lineStart = lineEnd;
				return lineEnd;
			}, 0 );
			// Custom init logic
			if ( this.init )
				this.init( str, options );
			items = [];
			while ( this.pos < this.str.length && ( item = this.read() ) ) {
				items.push( item );
			}
			this.leftover = this.remaining();
			this.result = this.postProcess ? this.postProcess( items, options ) : items;
		};
		Parser.prototype = {
			read: function( converters ) {
				var pos, i, len, item;
				if ( !converters )
					converters = this.converters;
				pos = this.pos;
				len = converters.length;
				for ( i = 0; i < len; i += 1 ) {
					this.pos = pos;
					// reset for each attempt
					if ( item = converters[ i ]( this ) ) {
						return item;
					}
				}
				return null;
			},
			readExpression: function() {
				// The conditional operator is the lowest precedence operator (except yield,
				// assignment operators, and commas, none of which are supported), so we
				// start there. If it doesn't match, it 'falls through' to progressively
				// higher precedence operators, until it eventually matches (or fails to
				// match) a 'primary' - a literal or a reference. This way, the abstract syntax
				// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
				return getConditional( this );
			},
			flattenExpression: flattenExpression,
			getLinePos: function( char ) {
				var lineNum = 0,
					lineStart = 0,
					columnNum;
				while ( char >= this.lineEnds[ lineNum ] ) {
					lineStart = this.lineEnds[ lineNum ];
					lineNum += 1;
				}
				columnNum = char - lineStart;
				return [
					lineNum + 1,
					columnNum + 1,
					char
				];
			},
			error: function( message ) {
				var pos, lineNum, columnNum, line, annotation, error;
				pos = this.getLinePos( this.pos );
				lineNum = pos[ 0 ];
				columnNum = pos[ 1 ];
				line = this.lines[ pos[ 0 ] - 1 ];
				annotation = line + '\n' + new Array( pos[ 1 ] ).join( ' ' ) + '^----';
				error = new ParseError( message + ' at line ' + lineNum + ' character ' + columnNum + ':\n' + annotation );
				error.line = pos[ 0 ];
				error.character = pos[ 1 ];
				error.shortMessage = message;
				throw error;
			},
			matchString: function( string ) {
				if ( this.str.substr( this.pos, string.length ) === string ) {
					this.pos += string.length;
					return string;
				}
			},
			matchPattern: function( pattern ) {
				var match;
				if ( match = pattern.exec( this.remaining() ) ) {
					this.pos += match[ 0 ].length;
					return match[ 1 ] || match[ 0 ];
				}
			},
			allowWhitespace: function() {
				this.matchPattern( leadingWhitespace );
			},
			remaining: function() {
				return this.str.substring( this.pos );
			},
			nextChar: function() {
				return this.str.charAt( this.pos );
			}
		};
		Parser.extend = function( proto ) {
			var Parent = this,
				Child, key;
			Child = function( str, options ) {
				Parser.call( this, str, options );
			};
			Child.prototype = create( Parent.prototype );
			for ( key in proto ) {
				if ( hasOwnProperty.call( proto, key ) ) {
					Child.prototype[ key ] = proto[ key ];
				}
			}
			Child.extend = Parser.extend;
			return Child;
		};
		circular.Parser = Parser;
		return Parser;
	}( circular, create, hasOwn, conditional, flattenExpression );

	/* parse/converters/mustache/delimiterChange.js */
	var delimiterChange = function() {

		var delimiterChangePattern = /^[^\s=]+/,
			whitespacePattern = /^\s+/;
		return function( parser ) {
			var start, opening, closing;
			if ( !parser.matchString( '=' ) ) {
				return null;
			}
			start = parser.pos;
			// allow whitespace before new opening delimiter
			parser.allowWhitespace();
			opening = parser.matchPattern( delimiterChangePattern );
			if ( !opening ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace (in fact, it's necessary...)
			if ( !parser.matchPattern( whitespacePattern ) ) {
				return null;
			}
			closing = parser.matchPattern( delimiterChangePattern );
			if ( !closing ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace before closing '='
			parser.allowWhitespace();
			if ( !parser.matchString( '=' ) ) {
				parser.pos = start;
				return null;
			}
			return [
				opening,
				closing
			];
		};
	}();

	/* parse/converters/mustache/delimiterTypes.js */
	var delimiterTypes = [ {
		delimiters: 'delimiters',
		isTriple: false,
		isStatic: false
	}, {
		delimiters: 'tripleDelimiters',
		isTriple: true,
		isStatic: false
	}, {
		delimiters: 'staticDelimiters',
		isTriple: false,
		isStatic: true
	}, {
		delimiters: 'staticTripleDelimiters',
		isTriple: true,
		isStatic: true
	} ];

	/* parse/converters/mustache/type.js */
	var type = function( types ) {

		var mustacheTypes = {
			'#': types.SECTION,
			'^': types.INVERTED,
			'/': types.CLOSING,
			'>': types.PARTIAL,
			'!': types.COMMENT,
			'&': types.TRIPLE
		};
		return function( parser ) {
			var type = mustacheTypes[ parser.str.charAt( parser.pos ) ];
			if ( !type ) {
				return null;
			}
			parser.pos += 1;
			return type;
		};
	}( types );

	/* parse/converters/mustache/handlebarsBlockCodes.js */
	var handlebarsBlockCodes = function( types ) {

		return {
			'each': types.SECTION_EACH,
			'if': types.SECTION_IF,
			'if-with': types.SECTION_IF_WITH,
			'with': types.SECTION_WITH,
			'unless': types.SECTION_UNLESS
		};
	}( types );

	/* empty/legacy.js */
	var legacy = null;

	/* parse/converters/mustache/content.js */
	var content = function( types, mustacheType, handlebarsBlockCodes ) {

		var __export;
		var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
			arrayMemberPattern = /^[0-9][1-9]*$/,
			handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\b' ),
			legalReference;
		legalReference = /^[a-zA-Z$_0-9]+(?:(\.[a-zA-Z$_0-9]+)|(\[[a-zA-Z$_0-9]+\]))*$/;
		__export = function( parser, delimiterType ) {
			var start, pos, mustache, type, block, expression, i, remaining, index, delimiters;
			start = parser.pos;
			mustache = {};
			delimiters = parser[ delimiterType.delimiters ];
			if ( delimiterType.isStatic ) {
				mustache.s = true;
			}
			// Determine mustache type
			if ( delimiterType.isTriple ) {
				mustache.t = types.TRIPLE;
			} else {
				// We need to test for expressions before we test for mustache type, because
				// an expression that begins '!' looks a lot like a comment
				if ( parser.remaining()[ 0 ] === '!' ) {
					try {
						expression = parser.readExpression();
						// Was it actually an expression, or a comment block in disguise?
						parser.allowWhitespace();
						if ( parser.remaining().indexOf( delimiters[ 1 ] ) ) {
							expression = null;
						} else {
							mustache.t = types.INTERPOLATOR;
						}
					} catch ( err ) {}
					if ( !expression ) {
						index = parser.remaining().indexOf( delimiters[ 1 ] );
						if ( ~index ) {
							parser.pos += index;
						} else {
							parser.error( 'Expected closing delimiter (\'' + delimiters[ 1 ] + '\')' );
						}
						return {
							t: types.COMMENT
						};
					}
				}
				if ( !expression ) {
					type = mustacheType( parser );
					mustache.t = type || types.INTERPOLATOR;
					// default
					// See if there's an explicit section type e.g. {{#with}}...{{/with}}
					if ( type === types.SECTION ) {
						if ( block = parser.matchPattern( handlebarsBlockPattern ) ) {
							mustache.n = block;
						}
						parser.allowWhitespace();
					} else if ( type === types.COMMENT || type === types.CLOSING ) {
						remaining = parser.remaining();
						index = remaining.indexOf( delimiters[ 1 ] );
						if ( index !== -1 ) {
							mustache.r = remaining.substr( 0, index ).split( ' ' )[ 0 ];
							parser.pos += index;
							return mustache;
						}
					}
				}
			}
			if ( !expression ) {
				// allow whitespace
				parser.allowWhitespace();
				// get expression
				expression = parser.readExpression();
				// If this is a partial, it may have a context (e.g. `{{>item foo}}`). These
				// cases involve a bit of a hack - we want to turn it into the equivalent of
				// `{{#with foo}}{{>item}}{{/with}}`, but to get there we temporarily append
				// a 'contextPartialExpression' to the mustache, and process the context instead of
				// the reference
				var temp;
				if ( mustache.t === types.PARTIAL && expression && ( temp = parser.readExpression() ) ) {
					mustache = {
						contextPartialExpression: expression
					};
					expression = temp;
				}
				// With certain valid references that aren't valid expressions,
				// e.g. {{1.foo}}, we have a problem: it looks like we've got an
				// expression, but the expression didn't consume the entire
				// reference. So we need to check that the mustache delimiters
				// appear next, unless there's an index reference (i.e. a colon)
				remaining = parser.remaining();
				if ( remaining.substr( 0, delimiters[ 1 ].length ) !== delimiters[ 1 ] && remaining.charAt( 0 ) !== ':' ) {
					pos = parser.pos;
					parser.pos = start;
					remaining = parser.remaining();
					index = remaining.indexOf( delimiters[ 1 ] );
					if ( index !== -1 ) {
						mustache.r = remaining.substr( 0, index ).trim();
						// Check it's a legal reference
						if ( !legalReference.test( mustache.r ) ) {
							parser.error( 'Expected a legal Mustache reference' );
						}
						parser.pos += index;
						return mustache;
					}
					parser.pos = pos;
				}
			}
			refineExpression( parser, expression, mustache );
			// if there was context, process the expression now and save it for later
			if ( mustache.contextPartialExpression ) {
				mustache.contextPartialExpression = [ refineExpression( parser, mustache.contextPartialExpression, {
					t: types.PARTIAL
				} ) ];
			}
			// optional index reference
			if ( i = parser.matchPattern( indexRefPattern ) ) {
				mustache.i = i;
			}
			return mustache;
		};

		function refineExpression( parser, expression, mustache ) {
			var referenceExpression;
			if ( expression ) {
				while ( expression.t === types.BRACKETED && expression.x ) {
					expression = expression.x;
				}
				// special case - integers should be treated as array members references,
				// rather than as expressions in their own right
				if ( expression.t === types.REFERENCE ) {
					mustache.r = expression.n;
				} else {
					if ( expression.t === types.NUMBER_LITERAL && arrayMemberPattern.test( expression.v ) ) {
						mustache.r = expression.v;
					} else if ( referenceExpression = getReferenceExpression( parser, expression ) ) {
						mustache.rx = referenceExpression;
					} else {
						mustache.x = parser.flattenExpression( expression );
					}
				}
				return mustache;
			}
		}
		// TODO refactor this! it's bewildering
		function getReferenceExpression( parser, expression ) {
			var members = [],
				refinement;
			while ( expression.t === types.MEMBER && expression.r.t === types.REFINEMENT ) {
				refinement = expression.r;
				if ( refinement.x ) {
					if ( refinement.x.t === types.REFERENCE ) {
						members.unshift( refinement.x );
					} else {
						members.unshift( parser.flattenExpression( refinement.x ) );
					}
				} else {
					members.unshift( refinement.n );
				}
				expression = expression.x;
			}
			if ( expression.t !== types.REFERENCE ) {
				return null;
			}
			return {
				r: expression.n,
				m: members
			};
		}
		return __export;
	}( types, type, handlebarsBlockCodes, legacy );

	/* parse/converters/mustache.js */
	var mustache = function( types, delimiterChange, delimiterTypes, mustacheContent, handlebarsBlockCodes ) {

		var __export;
		var delimiterChangeToken = {
			t: types.DELIMCHANGE,
			exclude: true
		};
		__export = getMustache;

		function getMustache( parser ) {
			var types;
			// If we're inside a <script> or <style> tag, and we're not
			// interpolating, bug out
			if ( parser.interpolate[ parser.inside ] === false ) {
				return null;
			}
			types = delimiterTypes.slice().sort( function compare( a, b ) {
				// Sort in order of descending opening delimiter length (longer first),
				// to protect against opening delimiters being substrings of each other
				return parser[ b.delimiters ][ 0 ].length - parser[ a.delimiters ][ 0 ].length;
			} );
			return function r( type ) {
				if ( !type ) {
					return null;
				} else {
					return getMustacheOfType( parser, type ) || r( types.shift() );
				}
			}( types.shift() );
		}

		function getMustacheOfType( parser, delimiterType ) {
			var start, mustache, delimiters, children, expectedClose, elseChildren, currentChildren, child;
			start = parser.pos;
			delimiters = parser[ delimiterType.delimiters ];
			if ( !parser.matchString( delimiters[ 0 ] ) ) {
				return null;
			}
			// delimiter change?
			if ( mustache = delimiterChange( parser ) ) {
				// find closing delimiter or abort...
				if ( !parser.matchString( delimiters[ 1 ] ) ) {
					return null;
				}
				// ...then make the switch
				parser[ delimiterType.delimiters ] = mustache;
				return delimiterChangeToken;
			}
			parser.allowWhitespace();
			mustache = mustacheContent( parser, delimiterType );
			if ( mustache === null ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace before closing delimiter
			parser.allowWhitespace();
			if ( !parser.matchString( delimiters[ 1 ] ) ) {
				parser.error( 'Expected closing delimiter \'' + delimiters[ 1 ] + '\' after reference' );
			}
			if ( mustache.t === types.COMMENT ) {
				mustache.exclude = true;
			}
			if ( mustache.t === types.CLOSING ) {
				parser.sectionDepth -= 1;
				if ( parser.sectionDepth < 0 ) {
					parser.pos = start;
					parser.error( 'Attempted to close a section that wasn\'t open' );
				}
			}
			// partials with context
			if ( mustache.contextPartialExpression ) {
				mustache.f = mustache.contextPartialExpression;
				mustache.t = types.SECTION;
				mustache.n = 'with';
				delete mustache.contextPartialExpression;
			} else if ( isSection( mustache ) ) {
				parser.sectionDepth += 1;
				children = [];
				currentChildren = children;
				expectedClose = mustache.n;
				while ( child = parser.read() ) {
					if ( child.t === types.CLOSING ) {
						if ( expectedClose && child.r !== expectedClose ) {
							parser.error( 'Expected {{/' + expectedClose + '}}' );
						}
						break;
					}
					// {{else}} tags require special treatment
					if ( child.t === types.INTERPOLATOR && child.r === 'else' ) {
						// no {{else}} allowed in {{#unless}}
						if ( mustache.n === 'unless' ) {
							parser.error( '{{else}} not allowed in {{#unless}}' );
						} else {
							currentChildren = elseChildren = [];
							continue;
						}
					}
					currentChildren.push( child );
				}
				if ( children.length ) {
					mustache.f = children;
				}
				if ( elseChildren && elseChildren.length ) {
					mustache.l = elseChildren;
					if ( mustache.n === 'with' ) {
						mustache.n = 'if-with';
					}
				}
			}
			if ( parser.includeLinePositions ) {
				mustache.p = parser.getLinePos( start );
			}
			// Replace block name with code
			if ( mustache.n ) {
				mustache.n = handlebarsBlockCodes[ mustache.n ];
			} else if ( mustache.t === types.INVERTED ) {
				mustache.t = types.SECTION;
				mustache.n = types.SECTION_UNLESS;
			}
			return mustache;
		}

		function isSection( mustache ) {
			return mustache.t === types.SECTION || mustache.t === types.INVERTED;
		}
		return __export;
	}( types, delimiterChange, delimiterTypes, content, handlebarsBlockCodes );

	/* parse/converters/comment.js */
	var comment = function( types ) {

		var OPEN_COMMENT = '<!--',
			CLOSE_COMMENT = '-->';
		return function( parser ) {
			var start, content, remaining, endIndex, comment;
			start = parser.pos;
			if ( !parser.matchString( OPEN_COMMENT ) ) {
				return null;
			}
			remaining = parser.remaining();
			endIndex = remaining.indexOf( CLOSE_COMMENT );
			if ( endIndex === -1 ) {
				parser.error( 'Illegal HTML - expected closing comment sequence (\'-->\')' );
			}
			content = remaining.substr( 0, endIndex );
			parser.pos += endIndex + 3;
			comment = {
				t: types.COMMENT,
				c: content
			};
			if ( parser.includeLinePositions ) {
				comment.p = parser.getLinePos( start );
			}
			return comment;
		};
	}( types );

	/* config/voidElementNames.js */
	var voidElementNames = function() {

		var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;
		return voidElementNames;
	}();

	/* parse/converters/utils/getLowestIndex.js */
	var getLowestIndex = function( haystack, needles ) {
		var i, index, lowest;
		i = needles.length;
		while ( i-- ) {
			index = haystack.indexOf( needles[ i ] );
			// short circuit
			if ( !index ) {
				return 0;
			}
			if ( index === -1 ) {
				continue;
			}
			if ( !lowest || index < lowest ) {
				lowest = index;
			}
		}
		return lowest || -1;
	};

	/* shared/decodeCharacterReferences.js */
	var decodeCharacterReferences = function() {

		var __export;
		var htmlEntities, controlCharacters, entityPattern;
		htmlEntities = {
			quot: 34,
			amp: 38,
			apos: 39,
			lt: 60,
			gt: 62,
			nbsp: 160,
			iexcl: 161,
			cent: 162,
			pound: 163,
			curren: 164,
			yen: 165,
			brvbar: 166,
			sect: 167,
			uml: 168,
			copy: 169,
			ordf: 170,
			laquo: 171,
			not: 172,
			shy: 173,
			reg: 174,
			macr: 175,
			deg: 176,
			plusmn: 177,
			sup2: 178,
			sup3: 179,
			acute: 180,
			micro: 181,
			para: 182,
			middot: 183,
			cedil: 184,
			sup1: 185,
			ordm: 186,
			raquo: 187,
			frac14: 188,
			frac12: 189,
			frac34: 190,
			iquest: 191,
			Agrave: 192,
			Aacute: 193,
			Acirc: 194,
			Atilde: 195,
			Auml: 196,
			Aring: 197,
			AElig: 198,
			Ccedil: 199,
			Egrave: 200,
			Eacute: 201,
			Ecirc: 202,
			Euml: 203,
			Igrave: 204,
			Iacute: 205,
			Icirc: 206,
			Iuml: 207,
			ETH: 208,
			Ntilde: 209,
			Ograve: 210,
			Oacute: 211,
			Ocirc: 212,
			Otilde: 213,
			Ouml: 214,
			times: 215,
			Oslash: 216,
			Ugrave: 217,
			Uacute: 218,
			Ucirc: 219,
			Uuml: 220,
			Yacute: 221,
			THORN: 222,
			szlig: 223,
			agrave: 224,
			aacute: 225,
			acirc: 226,
			atilde: 227,
			auml: 228,
			aring: 229,
			aelig: 230,
			ccedil: 231,
			egrave: 232,
			eacute: 233,
			ecirc: 234,
			euml: 235,
			igrave: 236,
			iacute: 237,
			icirc: 238,
			iuml: 239,
			eth: 240,
			ntilde: 241,
			ograve: 242,
			oacute: 243,
			ocirc: 244,
			otilde: 245,
			ouml: 246,
			divide: 247,
			oslash: 248,
			ugrave: 249,
			uacute: 250,
			ucirc: 251,
			uuml: 252,
			yacute: 253,
			thorn: 254,
			yuml: 255,
			OElig: 338,
			oelig: 339,
			Scaron: 352,
			scaron: 353,
			Yuml: 376,
			fnof: 402,
			circ: 710,
			tilde: 732,
			Alpha: 913,
			Beta: 914,
			Gamma: 915,
			Delta: 916,
			Epsilon: 917,
			Zeta: 918,
			Eta: 919,
			Theta: 920,
			Iota: 921,
			Kappa: 922,
			Lambda: 923,
			Mu: 924,
			Nu: 925,
			Xi: 926,
			Omicron: 927,
			Pi: 928,
			Rho: 929,
			Sigma: 931,
			Tau: 932,
			Upsilon: 933,
			Phi: 934,
			Chi: 935,
			Psi: 936,
			Omega: 937,
			alpha: 945,
			beta: 946,
			gamma: 947,
			delta: 948,
			epsilon: 949,
			zeta: 950,
			eta: 951,
			theta: 952,
			iota: 953,
			kappa: 954,
			lambda: 955,
			mu: 956,
			nu: 957,
			xi: 958,
			omicron: 959,
			pi: 960,
			rho: 961,
			sigmaf: 962,
			sigma: 963,
			tau: 964,
			upsilon: 965,
			phi: 966,
			chi: 967,
			psi: 968,
			omega: 969,
			thetasym: 977,
			upsih: 978,
			piv: 982,
			ensp: 8194,
			emsp: 8195,
			thinsp: 8201,
			zwnj: 8204,
			zwj: 8205,
			lrm: 8206,
			rlm: 8207,
			ndash: 8211,
			mdash: 8212,
			lsquo: 8216,
			rsquo: 8217,
			sbquo: 8218,
			ldquo: 8220,
			rdquo: 8221,
			bdquo: 8222,
			dagger: 8224,
			Dagger: 8225,
			bull: 8226,
			hellip: 8230,
			permil: 8240,
			prime: 8242,
			Prime: 8243,
			lsaquo: 8249,
			rsaquo: 8250,
			oline: 8254,
			frasl: 8260,
			euro: 8364,
			image: 8465,
			weierp: 8472,
			real: 8476,
			trade: 8482,
			alefsym: 8501,
			larr: 8592,
			uarr: 8593,
			rarr: 8594,
			darr: 8595,
			harr: 8596,
			crarr: 8629,
			lArr: 8656,
			uArr: 8657,
			rArr: 8658,
			dArr: 8659,
			hArr: 8660,
			forall: 8704,
			part: 8706,
			exist: 8707,
			empty: 8709,
			nabla: 8711,
			isin: 8712,
			notin: 8713,
			ni: 8715,
			prod: 8719,
			sum: 8721,
			minus: 8722,
			lowast: 8727,
			radic: 8730,
			prop: 8733,
			infin: 8734,
			ang: 8736,
			and: 8743,
			or: 8744,
			cap: 8745,
			cup: 8746,
			'int': 8747,
			there4: 8756,
			sim: 8764,
			cong: 8773,
			asymp: 8776,
			ne: 8800,
			equiv: 8801,
			le: 8804,
			ge: 8805,
			sub: 8834,
			sup: 8835,
			nsub: 8836,
			sube: 8838,
			supe: 8839,
			oplus: 8853,
			otimes: 8855,
			perp: 8869,
			sdot: 8901,
			lceil: 8968,
			rceil: 8969,
			lfloor: 8970,
			rfloor: 8971,
			lang: 9001,
			rang: 9002,
			loz: 9674,
			spades: 9824,
			clubs: 9827,
			hearts: 9829,
			diams: 9830
		};
		controlCharacters = [
			8364,
			129,
			8218,
			402,
			8222,
			8230,
			8224,
			8225,
			710,
			8240,
			352,
			8249,
			338,
			141,
			381,
			143,
			144,
			8216,
			8217,
			8220,
			8221,
			8226,
			8211,
			8212,
			732,
			8482,
			353,
			8250,
			339,
			157,
			382,
			376
		];
		entityPattern = new RegExp( '&(#?(?:x[\\w\\d]+|\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );
		__export = function decodeCharacterReferences( html ) {
			return html.replace( entityPattern, function( match, entity ) {
				var code;
				// Handle named entities
				if ( entity[ 0 ] !== '#' ) {
					code = htmlEntities[ entity ];
				} else if ( entity[ 1 ] === 'x' ) {
					code = parseInt( entity.substring( 2 ), 16 );
				} else {
					code = parseInt( entity.substring( 1 ), 10 );
				}
				if ( !code ) {
					return match;
				}
				return String.fromCharCode( validateCode( code ) );
			} );
		};
		// some code points are verboten. If we were inserting HTML, the browser would replace the illegal
		// code points with alternatives in some cases - since we're bypassing that mechanism, we need
		// to replace them ourselves
		//
		// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
		function validateCode( code ) {
			if ( !code ) {
				return 65533;
			}
			// line feed becomes generic whitespace
			if ( code === 10 ) {
				return 32;
			}
			// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
			if ( code < 128 ) {
				return code;
			}
			// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
			// to correct the mistake or we'll end up with missing  signs and so on
			if ( code <= 159 ) {
				return controlCharacters[ code - 128 ];
			}
			// basic multilingual plane
			if ( code < 55296 ) {
				return code;
			}
			// UTF-16 surrogate halves
			if ( code <= 57343 ) {
				return 65533;
			}
			// rest of the basic multilingual plane
			if ( code <= 65535 ) {
				return code;
			}
			return 65533;
		}
		return __export;
	}( legacy );

	/* parse/converters/text.js */
	var text = function( getLowestIndex, decodeCharacterReferences ) {

		return function( parser ) {
			var index, remaining, disallowed, barrier;
			remaining = parser.remaining();
			barrier = parser.inside ? '</' + parser.inside : '<';
			if ( parser.inside && !parser.interpolate[ parser.inside ] ) {
				index = remaining.indexOf( barrier );
			} else {
				disallowed = [
					parser.delimiters[ 0 ],
					parser.tripleDelimiters[ 0 ],
					parser.staticDelimiters[ 0 ],
					parser.staticTripleDelimiters[ 0 ]
				];
				// http://developers.whatwg.org/syntax.html#syntax-attributes
				if ( parser.inAttribute === true ) {
					// we're inside an unquoted attribute value
					disallowed.push( '"', '\'', '=', '<', '>', '`' );
				} else if ( parser.inAttribute ) {
					// quoted attribute value
					disallowed.push( parser.inAttribute );
				} else {
					disallowed.push( barrier );
				}
				index = getLowestIndex( remaining, disallowed );
			}
			if ( !index ) {
				return null;
			}
			if ( index === -1 ) {
				index = remaining.length;
			}
			parser.pos += index;
			return parser.inside ? remaining.substr( 0, index ) : decodeCharacterReferences( remaining.substr( 0, index ) );
		};
	}( getLowestIndex, decodeCharacterReferences );

	/* parse/converters/element/closingTag.js */
	var closingTag = function( types ) {

		var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
		return function( parser ) {
			var tag;
			// are we looking at a closing tag?
			if ( !parser.matchString( '</' ) ) {
				return null;
			}
			if ( tag = parser.matchPattern( closingTagPattern ) ) {
				return {
					t: types.CLOSING_TAG,
					e: tag
				};
			}
			// We have an illegal closing tag, report it
			parser.pos -= 2;
			parser.error( 'Illegal closing tag' );
		};
	}( types );

	/* parse/converters/element/attribute.js */
	var attribute = function( getLowestIndex, getMustache, decodeCharacterReferences ) {

		var __export;
		var attributeNamePattern = /^[^\s"'>\/=]+/,
			unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
		__export = getAttribute;

		function getAttribute( parser ) {
			var attr, name, value;
			parser.allowWhitespace();
			name = parser.matchPattern( attributeNamePattern );
			if ( !name ) {
				return null;
			}
			attr = {
				name: name
			};
			value = getAttributeValue( parser );
			if ( value ) {
				attr.value = value;
			}
			return attr;
		}

		function getAttributeValue( parser ) {
			var start, valueStart, startDepth, value;
			start = parser.pos;
			parser.allowWhitespace();
			if ( !parser.matchString( '=' ) ) {
				parser.pos = start;
				return null;
			}
			parser.allowWhitespace();
			valueStart = parser.pos;
			startDepth = parser.sectionDepth;
			value = getQuotedAttributeValue( parser, '\'' ) || getQuotedAttributeValue( parser, '"' ) || getUnquotedAttributeValue( parser );
			if ( parser.sectionDepth !== startDepth ) {
				parser.pos = valueStart;
				parser.error( 'An attribute value must contain as many opening section tags as closing section tags' );
			}
			if ( value === null ) {
				parser.pos = start;
				return null;
			}
			if ( !value.length ) {
				return null;
			}
			if ( value.length === 1 && typeof value[ 0 ] === 'string' ) {
				return decodeCharacterReferences( value[ 0 ] );
			}
			return value;
		}

		function getUnquotedAttributeValueToken( parser ) {
			var start, text, haystack, needles, index;
			start = parser.pos;
			text = parser.matchPattern( unquotedAttributeValueTextPattern );
			if ( !text ) {
				return null;
			}
			haystack = text;
			needles = [
				parser.delimiters[ 0 ],
				parser.tripleDelimiters[ 0 ],
				parser.staticDelimiters[ 0 ],
				parser.staticTripleDelimiters[ 0 ]
			];
			if ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {
				text = text.substr( 0, index );
				parser.pos = start + text.length;
			}
			return text;
		}

		function getUnquotedAttributeValue( parser ) {
			var tokens, token;
			parser.inAttribute = true;
			tokens = [];
			token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
			while ( token !== null ) {
				tokens.push( token );
				token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
			}
			if ( !tokens.length ) {
				return null;
			}
			parser.inAttribute = false;
			return tokens;
		}

		function getQuotedAttributeValue( parser, quoteMark ) {
			var start, tokens, token;
			start = parser.pos;
			if ( !parser.matchString( quoteMark ) ) {
				return null;
			}
			parser.inAttribute = quoteMark;
			tokens = [];
			token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
			while ( token !== null ) {
				tokens.push( token );
				token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
			}
			if ( !parser.matchString( quoteMark ) ) {
				parser.pos = start;
				return null;
			}
			parser.inAttribute = false;
			return tokens;
		}

		function getQuotedStringToken( parser, quoteMark ) {
			var start, index, haystack, needles;
			start = parser.pos;
			haystack = parser.remaining();
			needles = [
				quoteMark,
				parser.delimiters[ 0 ],
				parser.tripleDelimiters[ 0 ],
				parser.staticDelimiters[ 0 ],
				parser.staticTripleDelimiters[ 0 ]
			];
			index = getLowestIndex( haystack, needles );
			if ( index === -1 ) {
				parser.error( 'Quoted attribute value must have a closing quote' );
			}
			if ( !index ) {
				return null;
			}
			parser.pos += index;
			return haystack.substr( 0, index );
		}
		return __export;
	}( getLowestIndex, mustache, decodeCharacterReferences );

	/* utils/parseJSON.js */
	var parseJSON = function( Parser, getStringLiteral, getKey ) {

		var JsonParser, specials, specialsPattern, numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;
		specials = {
			'true': true,
			'false': false,
			'undefined': undefined,
			'null': null
		};
		specialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );
		numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
		placeholderPattern = /\$\{([^\}]+)\}/g;
		placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
		onlyWhitespace = /^\s*$/;
		JsonParser = Parser.extend( {
			init: function( str, options ) {
				this.values = options.values;
				this.allowWhitespace();
			},
			postProcess: function( result ) {
				if ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {
					return null;
				}
				return {
					value: result[ 0 ].v
				};
			},
			converters: [

				function getPlaceholder( parser ) {
					var placeholder;
					if ( !parser.values ) {
						return null;
					}
					placeholder = parser.matchPattern( placeholderAtStartPattern );
					if ( placeholder && parser.values.hasOwnProperty( placeholder ) ) {
						return {
							v: parser.values[ placeholder ]
						};
					}
				},
				function getSpecial( parser ) {
					var special;
					if ( special = parser.matchPattern( specialsPattern ) ) {
						return {
							v: specials[ special ]
						};
					}
				},
				function getNumber( parser ) {
					var number;
					if ( number = parser.matchPattern( numberPattern ) ) {
						return {
							v: +number
						};
					}
				},
				function getString( parser ) {
					var stringLiteral = getStringLiteral( parser ),
						values;
					if ( stringLiteral && ( values = parser.values ) ) {
						return {
							v: stringLiteral.v.replace( placeholderPattern, function( match, $1 ) {
								return $1 in values ? values[ $1 ] : $1;
							} )
						};
					}
					return stringLiteral;
				},
				function getObject( parser ) {
					var result, pair;
					if ( !parser.matchString( '{' ) ) {
						return null;
					}
					result = {};
					parser.allowWhitespace();
					if ( parser.matchString( '}' ) ) {
						return {
							v: result
						};
					}
					while ( pair = getKeyValuePair( parser ) ) {
						result[ pair.key ] = pair.value;
						parser.allowWhitespace();
						if ( parser.matchString( '}' ) ) {
							return {
								v: result
							};
						}
						if ( !parser.matchString( ',' ) ) {
							return null;
						}
					}
					return null;
				},
				function getArray( parser ) {
					var result, valueToken;
					if ( !parser.matchString( '[' ) ) {
						return null;
					}
					result = [];
					parser.allowWhitespace();
					if ( parser.matchString( ']' ) ) {
						return {
							v: result
						};
					}
					while ( valueToken = parser.read() ) {
						result.push( valueToken.v );
						parser.allowWhitespace();
						if ( parser.matchString( ']' ) ) {
							return {
								v: result
							};
						}
						if ( !parser.matchString( ',' ) ) {
							return null;
						}
						parser.allowWhitespace();
					}
					return null;
				}
			]
		} );

		function getKeyValuePair( parser ) {
			var key, valueToken, pair;
			parser.allowWhitespace();
			key = getKey( parser );
			if ( !key ) {
				return null;
			}
			pair = {
				key: key
			};
			parser.allowWhitespace();
			if ( !parser.matchString( ':' ) ) {
				return null;
			}
			parser.allowWhitespace();
			valueToken = parser.read();
			if ( !valueToken ) {
				return null;
			}
			pair.value = valueToken.v;
			return pair;
		}
		return function( str, values ) {
			var parser = new JsonParser( str, {
				values: values
			} );
			return parser.result;
		};
	}( Parser, stringLiteral, key );

	/* parse/converters/element/processDirective.js */
	var processDirective = function( Parser, conditional, flattenExpression, parseJSON ) {

		var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\(/,
			ExpressionParser;
		ExpressionParser = Parser.extend( {
			converters: [ conditional ]
		} );
		// TODO clean this up, it's shocking
		return function( tokens ) {
			var result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;
			if ( typeof tokens === 'string' ) {
				if ( match = methodCallPattern.exec( tokens ) ) {
					result = {
						m: match[ 1 ]
					};
					args = '[' + tokens.slice( result.m.length + 1, -1 ) + ']';
					parser = new ExpressionParser( args );
					result.a = flattenExpression( parser.result[ 0 ] );
					return result;
				}
				if ( tokens.indexOf( ':' ) === -1 ) {
					return tokens.trim();
				}
				tokens = [ tokens ];
			}
			result = {};
			directiveName = [];
			directiveArgs = [];
			if ( tokens ) {
				while ( tokens.length ) {
					token = tokens.shift();
					if ( typeof token === 'string' ) {
						colonIndex = token.indexOf( ':' );
						if ( colonIndex === -1 ) {
							directiveName.push( token );
						} else {
							// is the colon the first character?
							if ( colonIndex ) {
								// no
								directiveName.push( token.substr( 0, colonIndex ) );
							}
							// if there is anything after the colon in this token, treat
							// it as the first token of the directiveArgs fragment
							if ( token.length > colonIndex + 1 ) {
								directiveArgs[ 0 ] = token.substring( colonIndex + 1 );
							}
							break;
						}
					} else {
						directiveName.push( token );
					}
				}
				directiveArgs = directiveArgs.concat( tokens );
			}
			if ( !directiveName.length ) {
				result = '';
			} else if ( directiveArgs.length || typeof directiveName !== 'string' ) {
				result = {
					// TODO is this really necessary? just use the array
					n: directiveName.length === 1 && typeof directiveName[ 0 ] === 'string' ? directiveName[ 0 ] : directiveName
				};
				if ( directiveArgs.length === 1 && typeof directiveArgs[ 0 ] === 'string' ) {
					parsed = parseJSON( '[' + directiveArgs[ 0 ] + ']' );
					result.a = parsed ? parsed.value : directiveArgs[ 0 ].trim();
				} else {
					result.d = directiveArgs;
				}
			} else {
				result = directiveName;
			}
			return result;
		};
	}( Parser, conditional, flattenExpression, parseJSON );

	/* parse/converters/element.js */
	var element = function( types, voidElementNames, getMustache, getComment, getText, getClosingTag, getAttribute, processDirective ) {

		var __export;
		var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/,
			validTagNameFollower = /^[\s\n\/>]/,
			onPattern = /^on/,
			proxyEventPattern = /^on-([a-zA-Z\\*\\.$_][a-zA-Z\\*\\.$_0-9\-]+)$/,
			reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,
			directives = {
				'intro-outro': 't0',
				intro: 't1',
				outro: 't2',
				decorator: 'o'
			},
			exclude = {
				exclude: true
			},
			converters, disallowedContents;
		// Different set of converters, because this time we're looking for closing tags
		converters = [
			getMustache,
			getComment,
			getElement,
			getText,
			getClosingTag
		];
		// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
		disallowedContents = {
			li: [ 'li' ],
			dt: [
				'dt',
				'dd'
			],
			dd: [
				'dt',
				'dd'
			],
			p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),
			rt: [
				'rt',
				'rp'
			],
			rp: [
				'rt',
				'rp'
			],
			optgroup: [ 'optgroup' ],
			option: [
				'option',
				'optgroup'
			],
			thead: [
				'tbody',
				'tfoot'
			],
			tbody: [
				'tbody',
				'tfoot'
			],
			tfoot: [ 'tbody' ],
			tr: [
				'tr',
				'tbody'
			],
			td: [
				'td',
				'th',
				'tr'
			],
			th: [
				'td',
				'th',
				'tr'
			]
		};
		__export = getElement;

		function getElement( parser ) {
			var start, element, lowerCaseName, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, child;
			start = parser.pos;
			if ( parser.inside || parser.inAttribute ) {
				return null;
			}
			if ( !parser.matchString( '<' ) ) {
				return null;
			}
			// if this is a closing tag, abort straight away
			if ( parser.nextChar() === '/' ) {
				return null;
			}
			element = {
				t: types.ELEMENT
			};
			if ( parser.includeLinePositions ) {
				element.p = parser.getLinePos( start );
			}
			if ( parser.matchString( '!' ) ) {
				element.y = 1;
			}
			// element name
			element.e = parser.matchPattern( tagNamePattern );
			if ( !element.e ) {
				return null;
			}
			// next character must be whitespace, closing solidus or '>'
			if ( !validTagNameFollower.test( parser.nextChar() ) ) {
				parser.error( 'Illegal tag name' );
			}
			addProxyEvent = function( name, directive ) {
				var directiveName = directive.n || directive;
				if ( reservedEventNames.test( directiveName ) ) {
					parser.pos -= directiveName.length;
					parser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );
				}
				element.v[ name ] = directive;
			};
			parser.allowWhitespace();
			// directives and attributes
			while ( attribute = getMustache( parser ) || getAttribute( parser ) ) {
				// regular attributes
				if ( attribute.name ) {
					// intro, outro, decorator
					if ( directiveName = directives[ attribute.name ] ) {
						element[ directiveName ] = processDirective( attribute.value );
					} else if ( match = proxyEventPattern.exec( attribute.name ) ) {
						if ( !element.v )
							element.v = {};
						directive = processDirective( attribute.value );
						addProxyEvent( match[ 1 ], directive );
					} else {
						if ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {
							if ( !element.a )
								element.a = {};
							element.a[ attribute.name ] = attribute.value || 0;
						}
					}
				} else {
					if ( !element.m )
						element.m = [];
					element.m.push( attribute );
				}
				parser.allowWhitespace();
			}
			// allow whitespace before closing solidus
			parser.allowWhitespace();
			// self-closing solidus?
			if ( parser.matchString( '/' ) ) {
				selfClosing = true;
			}
			// closing angle bracket
			if ( !parser.matchString( '>' ) ) {
				return null;
			}
			lowerCaseName = element.e.toLowerCase();
			if ( !selfClosing && !voidElementNames.test( element.e ) ) {
				// Special case - if we open a script element, further tags should
				// be ignored unless they're a closing script element
				if ( lowerCaseName === 'script' || lowerCaseName === 'style' ) {
					parser.inside = lowerCaseName;
				}
				children = [];
				while ( canContain( lowerCaseName, parser.remaining() ) && ( child = parser.read( converters ) ) ) {
					// Special case - closing section tag
					if ( child.t === types.CLOSING ) {
						break;
					}
					if ( child.t === types.CLOSING_TAG ) {
						break;
					}
					children.push( child );
				}
				if ( children.length ) {
					element.f = children;
				}
			}
			parser.inside = null;
			if ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {
				return exclude;
			}
			return element;
		}

		function canContain( name, remaining ) {
			var match, disallowed;
			match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );
			disallowed = disallowedContents[ name ];
			if ( !match || !disallowed ) {
				return true;
			}
			return !~disallowed.indexOf( match[ 1 ].toLowerCase() );
		}
		return __export;
	}( types, voidElementNames, mustache, comment, text, closingTag, attribute, processDirective );

	/* parse/utils/trimWhitespace.js */
	var trimWhitespace = function() {

		var leadingWhitespace = /^[ \t\f\r\n]+/,
			trailingWhitespace = /[ \t\f\r\n]+$/;
		return function( items, leading, trailing ) {
			var item;
			if ( leading ) {
				item = items[ 0 ];
				if ( typeof item === 'string' ) {
					item = item.replace( leadingWhitespace, '' );
					if ( !item ) {
						items.shift();
					} else {
						items[ 0 ] = item;
					}
				}
			}
			if ( trailing ) {
				item = items[ items.length - 1 ];
				if ( typeof item === 'string' ) {
					item = item.replace( trailingWhitespace, '' );
					if ( !item ) {
						items.pop();
					} else {
						items[ items.length - 1 ] = item;
					}
				}
			}
		};
	}();

	/* parse/utils/stripStandalones.js */
	var stripStandalones = function( types ) {

		var __export;
		var leadingLinebreak = /^\s*\r?\n/,
			trailingLinebreak = /\r?\n\s*$/;
		__export = function( items ) {
			var i, current, backOne, backTwo, lastSectionItem;
			for ( i = 1; i < items.length; i += 1 ) {
				current = items[ i ];
				backOne = items[ i - 1 ];
				backTwo = items[ i - 2 ];
				// if we're at the end of a [text][comment][text] sequence...
				if ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {
					// ... and the comment is a standalone (i.e. line breaks either side)...
					if ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {
						// ... then we want to remove the whitespace after the first line break
						items[ i - 2 ] = backTwo.replace( trailingLinebreak, '\n' );
						// and the leading line break of the second text token
						items[ i ] = current.replace( leadingLinebreak, '' );
					}
				}
				// if the current item is a section, and it is preceded by a linebreak, and
				// its first item is a linebreak...
				if ( isSection( current ) && isString( backOne ) ) {
					if ( trailingLinebreak.test( backOne ) && isString( current.f[ 0 ] ) && leadingLinebreak.test( current.f[ 0 ] ) ) {
						items[ i - 1 ] = backOne.replace( trailingLinebreak, '\n' );
						current.f[ 0 ] = current.f[ 0 ].replace( leadingLinebreak, '' );
					}
				}
				// if the last item was a section, and it is followed by a linebreak, and
				// its last item is a linebreak...
				if ( isString( current ) && isSection( backOne ) ) {
					lastSectionItem = backOne.f[ backOne.f.length - 1 ];
					if ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {
						backOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\n' );
						items[ i ] = current.replace( leadingLinebreak, '' );
					}
				}
			}
			return items;
		};

		function isString( item ) {
			return typeof item === 'string';
		}

		function isComment( item ) {
			return item.t === types.COMMENT || item.t === types.DELIMCHANGE;
		}

		function isSection( item ) {
			return ( item.t === types.SECTION || item.t === types.INVERTED ) && item.f;
		}
		return __export;
	}( types );

	/* utils/escapeRegExp.js */
	var escapeRegExp = function() {

		var pattern = /[-/\\^$*+?.()|[\]{}]/g;
		return function escapeRegExp( str ) {
			return str.replace( pattern, '\\$&' );
		};
	}();

	/* parse/_parse.js */
	var parse = function( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp ) {

		var __export;
		var StandardParser, parse, contiguousWhitespace = /[ \t\f\r\n]+/g,
			preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i,
			leadingWhitespace = /^\s+/,
			trailingWhitespace = /\s+$/;
		StandardParser = Parser.extend( {
			init: function( str, options ) {
				// config
				setDelimiters( options, this );
				this.sectionDepth = 0;
				this.interpolate = {
					script: !options.interpolate || options.interpolate.script !== false,
					style: !options.interpolate || options.interpolate.style !== false
				};
				if ( options.sanitize === true ) {
					options.sanitize = {
						// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
						elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),
						eventAttributes: true
					};
				}
				this.sanitizeElements = options.sanitize && options.sanitize.elements;
				this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
				this.includeLinePositions = options.includeLinePositions;
			},
			postProcess: function( items, options ) {
				if ( this.sectionDepth > 0 ) {
					this.error( 'A section was left open' );
				}
				cleanup( items, options.stripComments !== false, options.preserveWhitespace, !options.preserveWhitespace, !options.preserveWhitespace, options.rewriteElse !== false );
				return items;
			},
			converters: [
				mustache,
				comment,
				element,
				text
			]
		} );
		parse = function( template ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = {};
			var result, remaining, partials, name, startMatch, endMatch, inlinePartialStart, inlinePartialEnd;
			setDelimiters( options );
			inlinePartialStart = new RegExp( '<!--\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\s*>\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\s*-->' );
			inlinePartialEnd = new RegExp( '<!--\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\s*\\/\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\s*-->' );
			result = {
				v: 1
			};
			if ( inlinePartialStart.test( template ) ) {
				remaining = template;
				template = '';
				while ( startMatch = inlinePartialStart.exec( remaining ) ) {
					name = startMatch[ 1 ];
					template += remaining.substr( 0, startMatch.index );
					remaining = remaining.substring( startMatch.index + startMatch[ 0 ].length );
					endMatch = inlinePartialEnd.exec( remaining );
					if ( !endMatch || endMatch[ 1 ] !== name ) {
						throw new Error( 'Inline partials must have a closing delimiter, and cannot be nested. Expected closing for "' + name + '", but ' + ( endMatch ? 'instead found "' + endMatch[ 1 ] + '"' : ' no closing found' ) );
					}
					( partials || ( partials = {} ) )[ name ] = new StandardParser( remaining.substr( 0, endMatch.index ), options ).result;
					remaining = remaining.substring( endMatch.index + endMatch[ 0 ].length );
				}
				template += remaining;
				result.p = partials;
			}
			result.t = new StandardParser( template, options ).result;
			return result;
		};
		__export = parse;

		function cleanup( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace, rewriteElse ) {
			var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, unlessBlock, key;
			// First pass - remove standalones and comments etc
			stripStandalones( items );
			i = items.length;
			while ( i-- ) {
				item = items[ i ];
				// Remove delimiter changes, unsafe elements etc
				if ( item.exclude ) {
					items.splice( i, 1 );
				} else if ( stripComments && item.t === types.COMMENT ) {
					items.splice( i, 1 );
				}
			}
			// If necessary, remove leading and trailing whitespace
			trimWhitespace( items, removeLeadingWhitespace, removeTrailingWhitespace );
			i = items.length;
			while ( i-- ) {
				item = items[ i ];
				// Recurse
				if ( item.f ) {
					preserveWhitespaceInsideFragment = preserveWhitespace || item.t === types.ELEMENT && preserveWhitespaceElements.test( item.e );
					if ( !preserveWhitespaceInsideFragment ) {
						previousItem = items[ i - 1 ];
						nextItem = items[ i + 1 ];
						// if the previous item was a text item with trailing whitespace,
						// remove leading whitespace inside the fragment
						if ( !previousItem || typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) {
							removeLeadingWhitespaceInsideFragment = true;
						}
						// and vice versa
						if ( !nextItem || typeof nextItem === 'string' && leadingWhitespace.test( nextItem ) ) {
							removeTrailingWhitespaceInsideFragment = true;
						}
					}
					cleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
				}
				// Split if-else blocks into two (an if, and an unless)
				if ( item.l ) {
					cleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
					if ( rewriteElse ) {
						unlessBlock = {
							t: 4,
							n: types.SECTION_UNLESS,
							f: item.l
						};
						// copy the conditional based on its type
						if ( item.r ) {
							unlessBlock.r = item.r;
						}
						if ( item.x ) {
							unlessBlock.x = item.x;
						}
						if ( item.rx ) {
							unlessBlock.rx = item.rx;
						}
						items.splice( i + 1, 0, unlessBlock );
						delete item.l;
					}
				}
				// Clean up element attributes
				if ( item.a ) {
					for ( key in item.a ) {
						if ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {
							cleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
						}
					}
				}
			}
			// final pass - fuse text nodes together
			i = items.length;
			while ( i-- ) {
				if ( typeof items[ i ] === 'string' ) {
					if ( typeof items[ i + 1 ] === 'string' ) {
						items[ i ] = items[ i ] + items[ i + 1 ];
						items.splice( i + 1, 1 );
					}
					if ( !preserveWhitespace ) {
						items[ i ] = items[ i ].replace( contiguousWhitespace, ' ' );
					}
					if ( items[ i ] === '' ) {
						items.splice( i, 1 );
					}
				}
			}
		}

		function setDelimiters( source ) {
			var target = arguments[ 1 ];
			if ( target === void 0 )
				target = source;
			target.delimiters = source.delimiters || [
				'{{',
				'}}'
			];
			target.tripleDelimiters = source.tripleDelimiters || [
				'{{{',
				'}}}'
			];
			target.staticDelimiters = source.staticDelimiters || [
				'[[',
				']]'
			];
			target.staticTripleDelimiters = source.staticTripleDelimiters || [
				'[[[',
				']]]'
			];
		}
		return __export;
	}( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp );

	/* config/options/groups/optionGroup.js */
	var optionGroup = function() {

		return function createOptionGroup( keys, config ) {
			var group = keys.map( config );
			keys.forEach( function( key, i ) {
				group[ key ] = group[ i ];
			} );
			return group;
		};
	}( legacy );

	/* config/options/groups/parseOptions.js */
	var parseOptions = function( optionGroup ) {

		var keys, parseOptions;
		keys = [
			'preserveWhitespace',
			'sanitize',
			'stripComments',
			'delimiters',
			'tripleDelimiters',
			'interpolate'
		];
		parseOptions = optionGroup( keys, function( key ) {
			return key;
		} );
		return parseOptions;
	}( optionGroup );

	/* config/options/template/parser.js */
	var parser = function( errors, isClient, parse, create, parseOptions ) {

		var parser = {
			parse: doParse,
			fromId: fromId,
			isHashedId: isHashedId,
			isParsed: isParsed,
			getParseOptions: getParseOptions,
			createHelper: createHelper
		};

		function createHelper( parseOptions ) {
			var helper = create( parser );
			helper.parse = function( template, options ) {
				return doParse( template, options || parseOptions );
			};
			return helper;
		}

		function doParse( template, parseOptions ) {
			if ( !parse ) {
				throw new Error( errors.missingParser );
			}
			return parse( template, parseOptions || this.options );
		}

		function fromId( id, options ) {
			var template;
			if ( !isClient ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Cannot retrieve template #' + id + ' as Ractive is not running in a browser.' );
			}
			if ( isHashedId( id ) ) {
				id = id.substring( 1 );
			}
			if ( !( template = document.getElementById( id ) ) ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Could not find template element with id #' + id );
			}
			if ( template.tagName.toUpperCase() !== 'SCRIPT' ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Template element with id #' + id + ', must be a <script> element' );
			}
			return template.innerHTML;
		}

		function isHashedId( id ) {
			return id && id.charAt( 0 ) === '#';
		}

		function isParsed( template ) {
			return !( typeof template === 'string' );
		}

		function getParseOptions( ractive ) {
			// Could be Ractive or a Component
			if ( ractive.defaults ) {
				ractive = ractive.defaults;
			}
			return parseOptions.reduce( function( val, key ) {
				val[ key ] = ractive[ key ];
				return val;
			}, {} );
		}
		return parser;
	}( errors, isClient, parse, create, parseOptions );

	/* config/options/template/template.js */
	var template = function( parser, parse ) {

		var templateConfig = {
			name: 'template',
			extend: function extend( Parent, proto, options ) {
				var template;
				// only assign if exists
				if ( 'template' in options ) {
					template = options.template;
					if ( typeof template === 'function' ) {
						proto.template = template;
					} else {
						proto.template = parseIfString( template, proto );
					}
				}
			},
			init: function init( Parent, ractive, options ) {
				var template, fn;
				// TODO because of prototypal inheritance, we might just be able to use
				// ractive.template, and not bother passing through the Parent object.
				// At present that breaks the test mocks' expectations
				template = 'template' in options ? options.template : Parent.prototype.template;
				if ( typeof template === 'function' ) {
					fn = template;
					template = getDynamicTemplate( ractive, fn );
					ractive._config.template = {
						fn: fn,
						result: template
					};
				}
				template = parseIfString( template, ractive );
				// TODO the naming of this is confusing - ractive.template refers to [...],
				// but Component.prototype.template refers to {v:1,t:[],p:[]}...
				// it's unnecessary, because the developer never needs to access
				// ractive.template
				ractive.template = template.t;
				if ( template.p ) {
					extendPartials( ractive.partials, template.p );
				}
			},
			reset: function( ractive ) {
				var result = resetValue( ractive ),
					parsed;
				if ( result ) {
					parsed = parseIfString( result, ractive );
					ractive.template = parsed.t;
					extendPartials( ractive.partials, parsed.p, true );
					return true;
				}
			}
		};

		function resetValue( ractive ) {
			var initial = ractive._config.template,
				result;
			// If this isn't a dynamic template, there's nothing to do
			if ( !initial || !initial.fn ) {
				return;
			}
			result = getDynamicTemplate( ractive, initial.fn );
			// TODO deep equality check to prevent unnecessary re-rendering
			// in the case of already-parsed templates
			if ( result !== initial.result ) {
				initial.result = result;
				result = parseIfString( result, ractive );
				return result;
			}
		}

		function getDynamicTemplate( ractive, fn ) {
			var helper = parser.createHelper( parser.getParseOptions( ractive ) );
			return fn.call( ractive, ractive.data, helper );
		}

		function parseIfString( template, ractive ) {
			if ( typeof template === 'string' ) {
				// ID of an element containing the template?
				if ( template[ 0 ] === '#' ) {
					template = parser.fromId( template );
				}
				template = parse( template, parser.getParseOptions( ractive ) );
			} else if ( template.v !== 1 ) {
				throw new Error( 'Mismatched template version! Please ensure you are using the latest version of Ractive.js in your build process as well as in your app' );
			}
			return template;
		}

		function extendPartials( existingPartials, newPartials, overwrite ) {
			if ( !newPartials )
				return;
			// TODO there's an ambiguity here - we need to overwrite in the `reset()`
			// case, but not initially...
			for ( var key in newPartials ) {
				if ( overwrite || !existingPartials.hasOwnProperty( key ) ) {
					existingPartials[ key ] = newPartials[ key ];
				}
			}
		}
		return templateConfig;
	}( parser, parse );

	/* config/options/Registry.js */
	var Registry = function( create ) {

		function Registry( name, useDefaults ) {
			this.name = name;
			this.useDefaults = useDefaults;
		}
		Registry.prototype = {
			constructor: Registry,
			extend: function( Parent, proto, options ) {
				this.configure( this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options );
			},
			init: function( Parent, ractive, options ) {
				this.configure( this.useDefaults ? Parent.defaults : Parent, ractive, options );
			},
			configure: function( Parent, target, options ) {
				var name = this.name,
					option = options[ name ],
					registry;
				registry = create( Parent[ name ] );
				for ( var key in option ) {
					registry[ key ] = option[ key ];
				}
				target[ name ] = registry;
			},
			reset: function( ractive ) {
				var registry = ractive[ this.name ];
				var changed = false;
				Object.keys( registry ).forEach( function( key ) {
					var item = registry[ key ];
					if ( item._fn ) {
						if ( item._fn.isOwner ) {
							registry[ key ] = item._fn;
						} else {
							delete registry[ key ];
						}
						changed = true;
					}
				} );
				return changed;
			},
			findOwner: function( ractive, key ) {
				return ractive[ this.name ].hasOwnProperty( key ) ? ractive : this.findConstructor( ractive.constructor, key );
			},
			findConstructor: function( constructor, key ) {
				if ( !constructor ) {
					return;
				}
				return constructor[ this.name ].hasOwnProperty( key ) ? constructor : this.findConstructor( constructor._parent, key );
			},
			find: function( ractive, key ) {
				var this$0 = this;
				return recurseFind( ractive, function( r ) {
					return r[ this$0.name ][ key ];
				} );
			},
			findInstance: function( ractive, key ) {
				var this$0 = this;
				return recurseFind( ractive, function( r ) {
					return r[ this$0.name ][ key ] ? r : void 0;
				} );
			}
		};

		function recurseFind( ractive, fn ) {
			var find, parent;
			if ( find = fn( ractive ) ) {
				return find;
			}
			if ( !ractive.isolated && ( parent = ractive._parent ) ) {
				return recurseFind( parent, fn );
			}
		}
		return Registry;
	}( create, legacy );

	/* config/options/groups/registries.js */
	var registries = function( optionGroup, Registry ) {

		var keys = [
				'adaptors',
				'components',
				'computed',
				'decorators',
				'easing',
				'events',
				'interpolators',
				'partials',
				'transitions'
			],
			registries = optionGroup( keys, function( key ) {
				return new Registry( key, key === 'computed' );
			} );
		return registries;
	}( optionGroup, Registry );

	/* utils/noop.js */
	var noop = function() {};

	/* utils/wrapPrototypeMethod.js */
	var wrapPrototypeMethod = function( noop ) {

		var __export;
		__export = function wrap( parent, name, method ) {
			if ( !/_super/.test( method ) ) {
				return method;
			}
			var wrapper = function wrapSuper() {
				var superMethod = getSuperMethod( wrapper._parent, name ),
					hasSuper = '_super' in this,
					oldSuper = this._super,
					result;
				this._super = superMethod;
				result = method.apply( this, arguments );
				if ( hasSuper ) {
					this._super = oldSuper;
				} else {
					delete this._super;
				}
				return result;
			};
			wrapper._parent = parent;
			wrapper._method = method;
			return wrapper;
		};

		function getSuperMethod( parent, name ) {
			var method;
			if ( name in parent ) {
				var value = parent[ name ];
				if ( typeof value === 'function' ) {
					method = value;
				} else {
					method = function returnValue() {
						return value;
					};
				}
			} else {
				method = noop;
			}
			return method;
		}
		return __export;
	}( noop );

	/* config/deprecate.js */
	var deprecate = function( warn, isArray ) {

		function deprecate( options, deprecated, correct ) {
			if ( deprecated in options ) {
				if ( !( correct in options ) ) {
					warn( getMessage( deprecated, correct ) );
					options[ correct ] = options[ deprecated ];
				} else {
					throw new Error( getMessage( deprecated, correct, true ) );
				}
			}
		}

		function getMessage( deprecated, correct, isError ) {
			return 'options.' + deprecated + ' has been deprecated in favour of options.' + correct + '.' + ( isError ? ' You cannot specify both options, please use options.' + correct + '.' : '' );
		}

		function deprecateEventDefinitions( options ) {
			deprecate( options, 'eventDefinitions', 'events' );
		}

		function deprecateAdaptors( options ) {
			// Using extend with Component instead of options,
			// like Human.extend( Spider ) means adaptors as a registry
			// gets copied to options. So we have to check if actually an array
			if ( isArray( options.adaptors ) ) {
				deprecate( options, 'adaptors', 'adapt' );
			}
		}
		return function deprecateOptions( options ) {
			deprecate( options, 'beforeInit', 'onconstruct' );
			deprecate( options, 'init', 'onrender' );
			deprecate( options, 'complete', 'oncomplete' );
			deprecateEventDefinitions( options );
			deprecateAdaptors( options );
		};
	}( warn, isArray );

	/* config/config.js */
	var config = function( css, data, defaults, template, parseOptions, registries, wrapPrototype, deprecate ) {

		var custom, options, config, blacklisted;
		// would be nice to not have these here,
		// they get added during initialise, so for now we have
		// to make sure not to try and extend them.
		// Possibly, we could re-order and not add till later
		// in process.
		blacklisted = {
			'_parent': true,
			'_component': true
		};
		custom = {
			data: data,
			template: template,
			css: css
		};
		options = Object.keys( defaults ).filter( function( key ) {
			return !registries[ key ] && !custom[ key ] && !parseOptions[ key ];
		} );
		// this defines the order:
		config = [].concat( custom.data, parseOptions, options, registries, custom.template, custom.css );
		for ( var key in custom ) {
			config[ key ] = custom[ key ];
		}
		// for iteration
		config.keys = Object.keys( defaults ).concat( registries.map( function( r ) {
			return r.name;
		} ) ).concat( [ 'css' ] );
		// add these to blacklisted key's that we don't double extend
		config.keys.forEach( function( key ) {
			return blacklisted[ key ] = true;
		} );
		config.parseOptions = parseOptions;
		config.registries = registries;

		function customConfig( method, key, Parent, instance, options ) {
			custom[ key ][ method ]( Parent, instance, options );
		}
		config.extend = function( Parent, proto, options ) {
			configure( 'extend', Parent, proto, options );
		};
		config.init = function( Parent, ractive, options ) {
			configure( 'init', Parent, ractive, options );
		};

		function isStandardDefaultKey( key ) {
			return key in defaults && !( key in config.parseOptions ) && !( key in custom );
		}

		function configure( method, Parent, instance, options ) {
			deprecate( options );
			customConfig( method, 'data', Parent, instance, options );
			config.parseOptions.forEach( function( key ) {
				if ( key in options ) {
					instance[ key ] = options[ key ];
				}
			} );
			for ( var key in options ) {
				if ( isStandardDefaultKey( key ) ) {
					var value = options[ key ];
					instance[ key ] = typeof value === 'function' ? wrapPrototype( Parent.prototype, key, value ) : value;
				}
			}
			config.registries.forEach( function( registry ) {
				registry[ method ]( Parent, instance, options );
			} );
			customConfig( method, 'template', Parent, instance, options );
			customConfig( method, 'css', Parent, instance, options );
			extendOtherMethods( Parent.prototype, instance, options );
		}

		function extendOtherMethods( parent, instance, options ) {
			for ( var key in options ) {
				if ( !( key in blacklisted ) && options.hasOwnProperty( key ) ) {
					var member = options[ key ];
					// if this is a method that overwrites a method, wrap it:
					if ( typeof member === 'function' ) {
						member = wrapPrototype( parent, key, member );
					}
					instance[ key ] = member;
				}
			}
		}
		config.reset = function( ractive ) {
			return config.filter( function( c ) {
				return c.reset && c.reset( ractive );
			} ).map( function( c ) {
				return c.name;
			} );
		};
		config.getConstructTarget = function( ractive, options ) {
			if ( options.onconstruct ) {
				// pretend this object literal is the ractive instance
				return {
					onconstruct: wrapPrototype( ractive, 'onconstruct', options.onconstruct ).bind( ractive ),
					fire: ractive.fire.bind( ractive )
				};
			} else {
				return ractive;
			}
		};
		return config;
	}( css, data, options, template, parseOptions, registries, wrapPrototypeMethod, deprecate );

	/* shared/interpolate.js */
	var interpolate = function( circular, warn, interpolators, config ) {

		var __export;
		var interpolate = function( from, to, ractive, type ) {
			if ( from === to ) {
				return snap( to );
			}
			if ( type ) {
				var interpol = config.registries.interpolators.find( ractive, type );
				if ( interpol ) {
					return interpol( from, to ) || snap( to );
				}
				warn( 'Missing "' + type + '" interpolator. You may need to download a plugin from [TODO]' );
			}
			return interpolators.number( from, to ) || interpolators.array( from, to ) || interpolators.object( from, to ) || snap( to );
		};
		circular.interpolate = interpolate;
		__export = interpolate;

		function snap( to ) {
			return function() {
				return to;
			};
		}
		return __export;
	}( circular, warn, interpolators, config );

	/* Ractive/prototype/animate/Animation.js */
	var Ractive$animate_Animation = function( warn, runloop, interpolate ) {

		var Animation = function( options ) {
			var key;
			this.startTime = Date.now();
			// from and to
			for ( key in options ) {
				if ( options.hasOwnProperty( key ) ) {
					this[ key ] = options[ key ];
				}
			}
			this.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );
			this.running = true;
			this.tick();
		};
		Animation.prototype = {
			tick: function() {
				var elapsed, t, value, timeNow, index, keypath;
				keypath = this.keypath;
				if ( this.running ) {
					timeNow = Date.now();
					elapsed = timeNow - this.startTime;
					if ( elapsed >= this.duration ) {
						if ( keypath !== null ) {
							runloop.start( this.root );
							this.root.viewmodel.set( keypath, this.to );
							runloop.end();
						}
						if ( this.step ) {
							this.step( 1, this.to );
						}
						this.complete( this.to );
						index = this.root._animations.indexOf( this );
						// TODO investigate why this happens
						if ( index === -1 ) {
							warn( 'Animation was not found' );
						}
						this.root._animations.splice( index, 1 );
						this.running = false;
						return false;
					}
					t = this.easing ? this.easing( elapsed / this.duration ) : elapsed / this.duration;
					if ( keypath !== null ) {
						value = this.interpolator( t );
						runloop.start( this.root );
						this.root.viewmodel.set( keypath, value );
						runloop.end();
					}
					if ( this.step ) {
						this.step( t, value );
					}
					return true;
				}
				return false;
			},
			stop: function() {
				var index;
				this.running = false;
				index = this.root._animations.indexOf( this );
				// TODO investigate why this happens
				if ( index === -1 ) {
					warn( 'Animation was not found' );
				}
				this.root._animations.splice( index, 1 );
			}
		};
		return Animation;
	}( warn, runloop, interpolate );

	/* Ractive/prototype/animate.js */
	var Ractive$animate = function( isEqual, Promise, normaliseKeypath, animations, Animation ) {

		var __export;
		var noop = function() {},
			noAnimation = {
				stop: noop
			};
		__export = function Ractive$animate( keypath, to, options ) {
			var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;
			promise = new Promise( function( fulfil ) {
				fulfilPromise = fulfil;
			} );
			// animate multiple keypaths
			if ( typeof keypath === 'object' ) {
				options = to || {};
				easing = options.easing;
				duration = options.duration;
				animations = [];
				// we don't want to pass the `step` and `complete` handlers, as they will
				// run for each animation! So instead we'll store the handlers and create
				// our own...
				step = options.step;
				complete = options.complete;
				if ( step || complete ) {
					currentValues = {};
					options.step = null;
					options.complete = null;
					makeValueCollector = function( keypath ) {
						return function( t, value ) {
							currentValues[ keypath ] = value;
						};
					};
				}
				for ( k in keypath ) {
					if ( keypath.hasOwnProperty( k ) ) {
						if ( step || complete ) {
							collectValue = makeValueCollector( k );
							options = {
								easing: easing,
								duration: duration
							};
							if ( step ) {
								options.step = collectValue;
							}
						}
						options.complete = complete ? collectValue : noop;
						animations.push( animate( this, k, keypath[ k ], options ) );
					}
				}
				// Create a dummy animation, to facilitate step/complete
				// callbacks, and Promise fulfilment
				dummyOptions = {
					easing: easing,
					duration: duration
				};
				if ( step ) {
					dummyOptions.step = function( t ) {
						step( t, currentValues );
					};
				}
				if ( complete ) {
					promise.then( function( t ) {
						complete( t, currentValues );
					} );
				}
				dummyOptions.complete = fulfilPromise;
				dummy = animate( this, null, null, dummyOptions );
				animations.push( dummy );
				promise.stop = function() {
					var animation;
					while ( animation = animations.pop() ) {
						animation.stop();
					}
					if ( dummy ) {
						dummy.stop();
					}
				};
				return promise;
			}
			// animate a single keypath
			options = options || {};
			if ( options.complete ) {
				promise.then( options.complete );
			}
			options.complete = fulfilPromise;
			animation = animate( this, keypath, to, options );
			promise.stop = function() {
				animation.stop();
			};
			return promise;
		};

		function animate( root, keypath, to, options ) {
			var easing, duration, animation, from;
			if ( keypath ) {
				keypath = normaliseKeypath( keypath );
			}
			if ( keypath !== null ) {
				from = root.viewmodel.get( keypath );
			}
			// cancel any existing animation
			// TODO what about upstream/downstream keypaths?
			animations.abort( keypath, root );
			// don't bother animating values that stay the same
			if ( isEqual( from, to ) ) {
				if ( options.complete ) {
					options.complete( options.to );
				}
				return noAnimation;
			}
			// easing function
			if ( options.easing ) {
				if ( typeof options.easing === 'function' ) {
					easing = options.easing;
				} else {
					easing = root.easing[ options.easing ];
				}
				if ( typeof easing !== 'function' ) {
					easing = null;
				}
			}
			// duration
			duration = options.duration === undefined ? 400 : options.duration;
			// TODO store keys, use an internal set method
			animation = new Animation( {
				keypath: keypath,
				from: from,
				to: to,
				root: root,
				duration: duration,
				easing: easing,
				interpolator: options.interpolator,
				// TODO wrap callbacks if necessary, to use instance as context
				step: options.step,
				complete: options.complete
			} );
			animations.add( animation );
			root._animations.push( animation );
			return animation;
		}
		return __export;
	}( isEqual, Promise, normaliseKeypath, animations, Ractive$animate_Animation );

	/* Ractive/prototype/detach.js */
	var Ractive$detach = function( Hook, removeFromArray ) {

		var detachHook = new Hook( 'detach' );
		return function Ractive$detach() {
			if ( this.detached ) {
				return this.detached;
			}
			if ( this.el ) {
				removeFromArray( this.el.__ractive_instances__, this );
			}
			this.detached = this.fragment.detach();
			detachHook.fire( this );
			return this.detached;
		};
	}( Ractive$shared_hooks_Hook, removeFromArray );

	/* Ractive/prototype/find.js */
	var Ractive$find = function Ractive$find( selector ) {
		if ( !this.el ) {
			return null;
		}
		return this.fragment.find( selector );
	};

	/* utils/matches.js */
	var matches = function( isClient, vendors, createElement ) {

		var matches, div, methodNames, unprefixed, prefixed, i, j, makeFunction;
		if ( !isClient ) {
			matches = null;
		} else {
			div = createElement( 'div' );
			methodNames = [
				'matches',
				'matchesSelector'
			];
			makeFunction = function( methodName ) {
				return function( node, selector ) {
					return node[ methodName ]( selector );
				};
			};
			i = methodNames.length;
			while ( i-- && !matches ) {
				unprefixed = methodNames[ i ];
				if ( div[ unprefixed ] ) {
					matches = makeFunction( unprefixed );
				} else {
					j = vendors.length;
					while ( j-- ) {
						prefixed = vendors[ i ] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );
						if ( div[ prefixed ] ) {
							matches = makeFunction( prefixed );
							break;
						}
					}
				}
			}
			// IE8...
			if ( !matches ) {
				matches = function( node, selector ) {
					var nodes, parentNode, i;
					parentNode = node.parentNode;
					if ( !parentNode ) {
						// empty dummy <div>
						div.innerHTML = '';
						parentNode = div;
						node = node.cloneNode();
						div.appendChild( node );
					}
					nodes = parentNode.querySelectorAll( selector );
					i = nodes.length;
					while ( i-- ) {
						if ( nodes[ i ] === node ) {
							return true;
						}
					}
					return false;
				};
			}
		}
		return matches;
	}( isClient, vendors, createElement );

	/* Ractive/prototype/shared/makeQuery/test.js */
	var Ractive$shared_makeQuery_test = function( matches ) {

		return function( item, noDirty ) {
			var itemMatches = this._isComponentQuery ? !this.selector || item.name === this.selector : matches( item.node, this.selector );
			if ( itemMatches ) {
				this.push( item.node || item.instance );
				if ( !noDirty ) {
					this._makeDirty();
				}
				return true;
			}
		};
	}( matches );

	/* Ractive/prototype/shared/makeQuery/cancel.js */
	var Ractive$shared_makeQuery_cancel = function() {
		var liveQueries, selector, index;
		liveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];
		selector = this.selector;
		index = liveQueries.indexOf( selector );
		if ( index !== -1 ) {
			liveQueries.splice( index, 1 );
			liveQueries[ selector ] = null;
		}
	};

	/* Ractive/prototype/shared/makeQuery/sortByItemPosition.js */
	var Ractive$shared_makeQuery_sortByItemPosition = function() {

		var __export;
		__export = function( a, b ) {
			var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;
			ancestryA = getAncestry( a.component || a._ractive.proxy );
			ancestryB = getAncestry( b.component || b._ractive.proxy );
			oldestA = ancestryA[ ancestryA.length - 1 ];
			oldestB = ancestryB[ ancestryB.length - 1 ];
			// remove items from the end of both ancestries as long as they are identical
			// - the final one removed is the closest mutual ancestor
			while ( oldestA && oldestA === oldestB ) {
				ancestryA.pop();
				ancestryB.pop();
				mutualAncestor = oldestA;
				oldestA = ancestryA[ ancestryA.length - 1 ];
				oldestB = ancestryB[ ancestryB.length - 1 ];
			}
			// now that we have the mutual ancestor, we can find which is earliest
			oldestA = oldestA.component || oldestA;
			oldestB = oldestB.component || oldestB;
			fragmentA = oldestA.parentFragment;
			fragmentB = oldestB.parentFragment;
			// if both items share a parent fragment, our job is easy
			if ( fragmentA === fragmentB ) {
				indexA = fragmentA.items.indexOf( oldestA );
				indexB = fragmentB.items.indexOf( oldestB );
				// if it's the same index, it means one contains the other,
				// so we see which has the longest ancestry
				return indexA - indexB || ancestryA.length - ancestryB.length;
			}
			// if mutual ancestor is a section, we first test to see which section
			// fragment comes first
			if ( fragments = mutualAncestor.fragments ) {
				indexA = fragments.indexOf( fragmentA );
				indexB = fragments.indexOf( fragmentB );
				return indexA - indexB || ancestryA.length - ancestryB.length;
			}
			throw new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );
		};

		function getParent( item ) {
			var parentFragment;
			if ( parentFragment = item.parentFragment ) {
				return parentFragment.owner;
			}
			if ( item.component && ( parentFragment = item.component.parentFragment ) ) {
				return parentFragment.owner;
			}
		}

		function getAncestry( item ) {
			var ancestry, ancestor;
			ancestry = [ item ];
			ancestor = getParent( item );
			while ( ancestor ) {
				ancestry.push( ancestor );
				ancestor = getParent( ancestor );
			}
			return ancestry;
		}
		return __export;
	}();

	/* Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js */
	var Ractive$shared_makeQuery_sortByDocumentPosition = function( sortByItemPosition ) {

		return function( node, otherNode ) {
			var bitmask;
			if ( node.compareDocumentPosition ) {
				bitmask = node.compareDocumentPosition( otherNode );
				return bitmask & 2 ? 1 : -1;
			}
			// In old IE, we can piggy back on the mechanism for
			// comparing component positions
			return sortByItemPosition( node, otherNode );
		};
	}( Ractive$shared_makeQuery_sortByItemPosition );

	/* Ractive/prototype/shared/makeQuery/sort.js */
	var Ractive$shared_makeQuery_sort = function( sortByDocumentPosition, sortByItemPosition ) {

		return function() {
			this.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );
			this._dirty = false;
		};
	}( Ractive$shared_makeQuery_sortByDocumentPosition, Ractive$shared_makeQuery_sortByItemPosition );

	/* Ractive/prototype/shared/makeQuery/dirty.js */
	var Ractive$shared_makeQuery_dirty = function( runloop ) {

		return function() {
			var this$0 = this;
			if ( !this._dirty ) {
				this._dirty = true;
				// Once the DOM has been updated, ensure the query
				// is correctly ordered
				runloop.scheduleTask( function() {
					this$0._sort();
				} );
			}
		};
	}( runloop );

	/* Ractive/prototype/shared/makeQuery/remove.js */
	var Ractive$shared_makeQuery_remove = function( nodeOrComponent ) {
		var index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );
		if ( index !== -1 ) {
			this.splice( index, 1 );
		}
	};

	/* Ractive/prototype/shared/makeQuery/_makeQuery.js */
	var Ractive$shared_makeQuery__makeQuery = function( defineProperties, test, cancel, sort, dirty, remove ) {

		return function makeQuery( ractive, selector, live, isComponentQuery ) {
			var query = [];
			defineProperties( query, {
				selector: {
					value: selector
				},
				live: {
					value: live
				},
				_isComponentQuery: {
					value: isComponentQuery
				},
				_test: {
					value: test
				}
			} );
			if ( !live ) {
				return query;
			}
			defineProperties( query, {
				cancel: {
					value: cancel
				},
				_root: {
					value: ractive
				},
				_sort: {
					value: sort
				},
				_makeDirty: {
					value: dirty
				},
				_remove: {
					value: remove
				},
				_dirty: {
					value: false,
					writable: true
				}
			} );
			return query;
		};
	}( defineProperties, Ractive$shared_makeQuery_test, Ractive$shared_makeQuery_cancel, Ractive$shared_makeQuery_sort, Ractive$shared_makeQuery_dirty, Ractive$shared_makeQuery_remove );

	/* Ractive/prototype/findAll.js */
	var Ractive$findAll = function( makeQuery ) {

		return function Ractive$findAll( selector, options ) {
			var liveQueries, query;
			if ( !this.el ) {
				return [];
			}
			options = options || {};
			liveQueries = this._liveQueries;
			// Shortcut: if we're maintaining a live query with this
			// selector, we don't need to traverse the parallel DOM
			if ( query = liveQueries[ selector ] ) {
				// Either return the exact same query, or (if not live) a snapshot
				return options && options.live ? query : query.slice();
			}
			query = makeQuery( this, selector, !!options.live, false );
			// Add this to the list of live queries Ractive needs to maintain,
			// if applicable
			if ( query.live ) {
				liveQueries.push( selector );
				liveQueries[ '_' + selector ] = query;
			}
			this.fragment.findAll( selector, query );
			return query;
		};
	}( Ractive$shared_makeQuery__makeQuery );

	/* Ractive/prototype/findAllComponents.js */
	var Ractive$findAllComponents = function( makeQuery ) {

		return function Ractive$findAllComponents( selector, options ) {
			var liveQueries, query;
			options = options || {};
			liveQueries = this._liveComponentQueries;
			// Shortcut: if we're maintaining a live query with this
			// selector, we don't need to traverse the parallel DOM
			if ( query = liveQueries[ selector ] ) {
				// Either return the exact same query, or (if not live) a snapshot
				return options && options.live ? query : query.slice();
			}
			query = makeQuery( this, selector, !!options.live, true );
			// Add this to the list of live queries Ractive needs to maintain,
			// if applicable
			if ( query.live ) {
				liveQueries.push( selector );
				liveQueries[ '_' + selector ] = query;
			}
			this.fragment.findAllComponents( selector, query );
			return query;
		};
	}( Ractive$shared_makeQuery__makeQuery );

	/* Ractive/prototype/findComponent.js */
	var Ractive$findComponent = function Ractive$findComponent( selector ) {
		return this.fragment.findComponent( selector );
	};

	/* utils/getPotentialWildcardMatches.js */
	var getPotentialWildcardMatches = function() {

		var __export;
		var starMaps = {};
		// This function takes a keypath such as 'foo.bar.baz', and returns
		// all the variants of that keypath that include a wildcard in place
		// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
		// These are then checked against the dependants map (ractive.viewmodel.depsMap)
		// to see if any pattern observers are downstream of one or more of
		// these wildcard keypaths (e.g. 'foo.bar.*.status')
		__export = function getPotentialWildcardMatches( keypath ) {
			var keys, starMap, mapper, i, result, wildcardKeypath;
			keys = keypath.split( '.' );
			if ( !( starMap = starMaps[ keys.length ] ) ) {
				starMap = getStarMap( keys.length );
			}
			result = [];
			mapper = function( star, i ) {
				return star ? '*' : keys[ i ];
			};
			i = starMap.length;
			while ( i-- ) {
				wildcardKeypath = starMap[ i ].map( mapper ).join( '.' );
				if ( !result.hasOwnProperty( wildcardKeypath ) ) {
					result.push( wildcardKeypath );
					result[ wildcardKeypath ] = true;
				}
			}
			return result;
		};
		// This function returns all the possible true/false combinations for
		// a given number - e.g. for two, the possible combinations are
		// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
		// It does so by getting all the binary values between 0 and e.g. 11
		function getStarMap( num ) {
			var ones = '',
				max, binary, starMap, mapper, i;
			if ( !starMaps[ num ] ) {
				starMap = [];
				while ( ones.length < num ) {
					ones += 1;
				}
				max = parseInt( ones, 2 );
				mapper = function( digit ) {
					return digit === '1';
				};
				for ( i = 0; i <= max; i += 1 ) {
					binary = i.toString( 2 );
					while ( binary.length < num ) {
						binary = '0' + binary;
					}
					starMap[ i ] = Array.prototype.map.call( binary, mapper );
				}
				starMaps[ num ] = starMap;
			}
			return starMaps[ num ];
		}
		return __export;
	}();

	/* Ractive/prototype/shared/fireEvent.js */
	var Ractive$shared_fireEvent = function( getPotentialWildcardMatches ) {

		var __export;
		__export = function fireEvent( ractive, eventName ) {
			var options = arguments[ 2 ];
			if ( options === void 0 )
				options = {};
			if ( !eventName ) {
				return;
			}
			if ( !options.event ) {
				options.event = {
					name: eventName,
					context: ractive.data,
					keypath: '',
					// until event not included as argument default
					_noArg: true
				};
			} else {
				options.event.name = eventName;
			}
			var eventNames = getPotentialWildcardMatches( eventName );
			fireEventAs( ractive, eventNames, options.event, options.args, true );
		};

		function fireEventAs( ractive, eventNames, event, args ) {
			var initialFire = arguments[ 4 ];
			if ( initialFire === void 0 )
				initialFire = false;
			var subscribers, i, bubble = true;
			if ( event ) {
				ractive.event = event;
			}
			for ( i = eventNames.length; i >= 0; i-- ) {
				subscribers = ractive._subs[ eventNames[ i ] ];
				if ( subscribers ) {
					bubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;
				}
			}
			if ( event ) {
				delete ractive.event;
			}
			if ( ractive._parent && bubble ) {
				if ( initialFire && ractive.component ) {
					var fullName = ractive.component.name + '.' + eventNames[ eventNames.length - 1 ];
					eventNames = getPotentialWildcardMatches( fullName );
					if ( event ) {
						event.component = ractive;
					}
				}
				fireEventAs( ractive._parent, eventNames, event, args );
			}
		}

		function notifySubscribers( ractive, subscribers, event, args ) {
			var originalEvent = null,
				stopEvent = false;
			if ( event && !event._noArg ) {
				args = [ event ].concat( args );
			}
			for ( var i = 0, len = subscribers.length; i < len; i += 1 ) {
				if ( subscribers[ i ].apply( ractive, args ) === false ) {
					stopEvent = true;
				}
			}
			if ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {
				originalEvent.preventDefault && originalEvent.preventDefault();
				originalEvent.stopPropagation && originalEvent.stopPropagation();
			}
			return !stopEvent;
		}
		return __export;
	}( getPotentialWildcardMatches );

	/* Ractive/prototype/fire.js */
	var Ractive$fire = function( fireEvent ) {

		return function Ractive$fire( eventName ) {
			var options = {
				args: Array.prototype.slice.call( arguments, 1 )
			};
			fireEvent( this, eventName, options );
		};
	}( Ractive$shared_fireEvent );

	/* Ractive/prototype/get.js */
	var Ractive$get = function( normaliseKeypath, resolveRef ) {

		var options = {
			capture: true
		};
		// top-level calls should be intercepted
		return function Ractive$get( keypath ) {
			var value;
			keypath = normaliseKeypath( keypath );
			value = this.viewmodel.get( keypath, options );
			// Create inter-component binding, if necessary
			if ( value === undefined && this._parent && !this.isolated ) {
				if ( resolveRef( this, keypath, this.fragment ) ) {
					// creates binding as side-effect, if appropriate
					value = this.viewmodel.get( keypath );
				}
			}
			return value;
		};
	}( normaliseKeypath, resolveRef );

	/* utils/getElement.js */
	var getElement = function getElement( input ) {
		var output;
		if ( !input || typeof input === 'boolean' ) {
			return;
		}
		if ( typeof window === 'undefined' || !document || !input ) {
			return null;
		}
		// We already have a DOM node - no work to do. (Duck typing alert!)
		if ( input.nodeType ) {
			return input;
		}
		// Get node from string
		if ( typeof input === 'string' ) {
			// try ID first
			output = document.getElementById( input );
			// then as selector, if possible
			if ( !output && document.querySelector ) {
				output = document.querySelector( input );
			}
			// did it work?
			if ( output && output.nodeType ) {
				return output;
			}
		}
		// If we've been given a collection (jQuery, Zepto etc), extract the first item
		if ( input[ 0 ] && input[ 0 ].nodeType ) {
			return input[ 0 ];
		}
		return null;
	};

	/* Ractive/prototype/insert.js */
	var Ractive$insert = function( Hook, getElement ) {

		var __export;
		var insertHook = new Hook( 'insert' );
		__export = function Ractive$insert( target, anchor ) {
			if ( !this.fragment.rendered ) {
				// TODO create, and link to, documentation explaining this
				throw new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );
			}
			target = getElement( target );
			anchor = getElement( anchor ) || null;
			if ( !target ) {
				throw new Error( 'You must specify a valid target to insert into' );
			}
			target.insertBefore( this.detach(), anchor );
			this.el = target;
			( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );
			this.detached = null;
			fireInsertHook( this );
		};

		function fireInsertHook( ractive ) {
			insertHook.fire( ractive );
			ractive.findAllComponents( '*' ).forEach( function( child ) {
				fireInsertHook( child.instance );
			} );
		}
		return __export;
	}( Ractive$shared_hooks_Hook, getElement );

	/* Ractive/prototype/merge.js */
	var Ractive$merge = function( runloop, isArray, normaliseKeypath ) {

		return function Ractive$merge( keypath, array, options ) {
			var currentArray, promise;
			keypath = normaliseKeypath( keypath );
			currentArray = this.viewmodel.get( keypath );
			// If either the existing value or the new value isn't an
			// array, just do a regular set
			if ( !isArray( currentArray ) || !isArray( array ) ) {
				return this.set( keypath, array, options && options.complete );
			}
			// Manage transitions
			promise = runloop.start( this, true );
			this.viewmodel.merge( keypath, currentArray, array, options );
			runloop.end();
			// attach callback as fulfilment handler, if specified
			if ( options && options.complete ) {
				promise.then( options.complete );
			}
			return promise;
		};
	}( runloop, isArray, normaliseKeypath );

	/* Ractive/prototype/observe/Observer.js */
	var Ractive$observe_Observer = function( runloop, isEqual ) {

		var Observer = function( ractive, keypath, callback, options ) {
			this.root = ractive;
			this.keypath = keypath;
			this.callback = callback;
			this.defer = options.defer;
			// default to root as context, but allow it to be overridden
			this.context = options && options.context ? options.context : ractive;
		};
		Observer.prototype = {
			init: function( immediate ) {
				this.value = this.root.get( this.keypath );
				if ( immediate !== false ) {
					this.update();
				} else {
					this.oldValue = this.value;
				}
			},
			setValue: function( value ) {
				var this$0 = this;
				if ( !isEqual( value, this.value ) ) {
					this.value = value;
					if ( this.defer && this.ready ) {
						runloop.scheduleTask( function() {
							return this$0.update();
						} );
					} else {
						this.update();
					}
				}
			},
			update: function() {
				// Prevent infinite loops
				if ( this.updating ) {
					return;
				}
				this.updating = true;
				this.callback.call( this.context, this.value, this.oldValue, this.keypath );
				this.oldValue = this.value;
				this.updating = false;
			}
		};
		return Observer;
	}( runloop, isEqual );

	/* shared/getMatchingKeypaths.js */
	var getMatchingKeypaths = function( isArray ) {

		return function getMatchingKeypaths( ractive, pattern ) {
			var keys, key, matchingKeypaths;
			keys = pattern.split( '.' );
			matchingKeypaths = [ '' ];
			while ( key = keys.shift() ) {
				if ( key === '*' ) {
					// expand to find all valid child keypaths
					matchingKeypaths = matchingKeypaths.reduce( expand, [] );
				} else {
					if ( matchingKeypaths[ 0 ] === '' ) {
						// first key
						matchingKeypaths[ 0 ] = key;
					} else {
						matchingKeypaths = matchingKeypaths.map( concatenate( key ) );
					}
				}
			}
			return matchingKeypaths;

			function expand( matchingKeypaths, keypath ) {
				var value, key, childKeypath;
				value = ractive.viewmodel.wrapped[ keypath ] ? ractive.viewmodel.wrapped[ keypath ].get() : ractive.get( keypath );
				for ( key in value ) {
					if ( value.hasOwnProperty( key ) && ( key !== '_ractive' || !isArray( value ) ) ) {
						// for benefit of IE8
						childKeypath = keypath ? keypath + '.' + key : key;
						matchingKeypaths.push( childKeypath );
					}
				}
				return matchingKeypaths;
			}

			function concatenate( key ) {
				return function( keypath ) {
					return keypath ? keypath + '.' + key : key;
				};
			}
		};
	}( isArray );

	/* Ractive/prototype/observe/getPattern.js */
	var Ractive$observe_getPattern = function( getMatchingKeypaths ) {

		return function getPattern( ractive, pattern ) {
			var matchingKeypaths, values;
			matchingKeypaths = getMatchingKeypaths( ractive, pattern );
			values = {};
			matchingKeypaths.forEach( function( keypath ) {
				values[ keypath ] = ractive.get( keypath );
			} );
			return values;
		};
	}( getMatchingKeypaths );

	/* Ractive/prototype/observe/PatternObserver.js */
	var Ractive$observe_PatternObserver = function( runloop, isEqual, getPattern ) {

		var PatternObserver, wildcard = /\*/,
			slice = Array.prototype.slice;
		PatternObserver = function( ractive, keypath, callback, options ) {
			this.root = ractive;
			this.callback = callback;
			this.defer = options.defer;
			this.keypath = keypath;
			this.regex = new RegExp( '^' + keypath.replace( /\./g, '\\.' ).replace( /\*/g, '([^\\.]+)' ) + '$' );
			this.values = {};
			if ( this.defer ) {
				this.proxies = [];
			}
			// default to root as context, but allow it to be overridden
			this.context = options && options.context ? options.context : ractive;
		};
		PatternObserver.prototype = {
			init: function( immediate ) {
				var values, keypath;
				values = getPattern( this.root, this.keypath );
				if ( immediate !== false ) {
					for ( keypath in values ) {
						if ( values.hasOwnProperty( keypath ) ) {
							this.update( keypath );
						}
					}
				} else {
					this.values = values;
				}
			},
			update: function( keypath ) {
				var this$0 = this;
				var values;
				if ( wildcard.test( keypath ) ) {
					values = getPattern( this.root, keypath );
					for ( keypath in values ) {
						if ( values.hasOwnProperty( keypath ) ) {
							this.update( keypath );
						}
					}
					return;
				}
				// special case - array mutation should not trigger `array.*`
				// pattern observer with `array.length`
				if ( this.root.viewmodel.implicitChanges[ keypath ] ) {
					return;
				}
				if ( this.defer && this.ready ) {
					runloop.scheduleTask( function() {
						return this$0.getProxy( keypath ).update();
					} );
					return;
				}
				this.reallyUpdate( keypath );
			},
			reallyUpdate: function( keypath ) {
				var value, keys, args;
				value = this.root.viewmodel.get( keypath );
				// Prevent infinite loops
				if ( this.updating ) {
					this.values[ keypath ] = value;
					return;
				}
				this.updating = true;
				if ( !isEqual( value, this.values[ keypath ] ) || !this.ready ) {
					keys = slice.call( this.regex.exec( keypath ), 1 );
					args = [
						value,
						this.values[ keypath ],
						keypath
					].concat( keys );
					this.callback.apply( this.context, args );
					this.values[ keypath ] = value;
				}
				this.updating = false;
			},
			getProxy: function( keypath ) {
				var self = this;
				if ( !this.proxies[ keypath ] ) {
					this.proxies[ keypath ] = {
						update: function() {
							self.reallyUpdate( keypath );
						}
					};
				}
				return this.proxies[ keypath ];
			}
		};
		return PatternObserver;
	}( runloop, isEqual, Ractive$observe_getPattern );

	/* Ractive/prototype/observe/getObserverFacade.js */
	var Ractive$observe_getObserverFacade = function( normaliseKeypath, Observer, PatternObserver ) {

		var wildcard = /\*/,
			emptyObject = {};
		return function getObserverFacade( ractive, keypath, callback, options ) {
			var observer, isPatternObserver, cancelled;
			keypath = normaliseKeypath( keypath );
			options = options || emptyObject;
			// pattern observers are treated differently
			if ( wildcard.test( keypath ) ) {
				observer = new PatternObserver( ractive, keypath, callback, options );
				ractive.viewmodel.patternObservers.push( observer );
				isPatternObserver = true;
			} else {
				observer = new Observer( ractive, keypath, callback, options );
			}
			ractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );
			observer.init( options.init );
			// This flag allows observers to initialise even with undefined values
			observer.ready = true;
			return {
				cancel: function() {
					var index;
					if ( cancelled ) {
						return;
					}
					if ( isPatternObserver ) {
						index = ractive.viewmodel.patternObservers.indexOf( observer );
						ractive.viewmodel.patternObservers.splice( index, 1 );
						ractive.viewmodel.unregister( keypath, observer, 'patternObservers' );
					} else {
						ractive.viewmodel.unregister( keypath, observer, 'observers' );
					}
					cancelled = true;
				}
			};
		};
	}( normaliseKeypath, Ractive$observe_Observer, Ractive$observe_PatternObserver );

	/* Ractive/prototype/observe.js */
	var Ractive$observe = function( isObject, getObserverFacade ) {

		return function Ractive$observe( keypath, callback, options ) {
			var observers, map, keypaths, i;
			// Allow a map of keypaths to handlers
			if ( isObject( keypath ) ) {
				options = callback;
				map = keypath;
				observers = [];
				for ( keypath in map ) {
					if ( map.hasOwnProperty( keypath ) ) {
						callback = map[ keypath ];
						observers.push( this.observe( keypath, callback, options ) );
					}
				}
				return {
					cancel: function() {
						while ( observers.length ) {
							observers.pop().cancel();
						}
					}
				};
			}
			// Allow `ractive.observe( callback )` - i.e. observe entire model
			if ( typeof keypath === 'function' ) {
				options = callback;
				callback = keypath;
				keypath = '';
				return getObserverFacade( this, keypath, callback, options );
			}
			keypaths = keypath.split( ' ' );
			// Single keypath
			if ( keypaths.length === 1 ) {
				return getObserverFacade( this, keypath, callback, options );
			}
			// Multiple space-separated keypaths
			observers = [];
			i = keypaths.length;
			while ( i-- ) {
				keypath = keypaths[ i ];
				if ( keypath ) {
					observers.push( getObserverFacade( this, keypath, callback, options ) );
				}
			}
			return {
				cancel: function() {
					while ( observers.length ) {
						observers.pop().cancel();
					}
				}
			};
		};
	}( isObject, Ractive$observe_getObserverFacade );

	/* Ractive/prototype/shared/trim.js */
	var Ractive$shared_trim = function( str ) {
		return str.trim();
	};

	/* Ractive/prototype/shared/notEmptyString.js */
	var Ractive$shared_notEmptyString = function( str ) {
		return str !== '';
	};

	/* Ractive/prototype/off.js */
	var Ractive$off = function( trim, notEmptyString ) {

		return function Ractive$off( eventName, callback ) {
			var this$0 = this;
			var eventNames;
			// if no arguments specified, remove all callbacks
			if ( !eventName ) {
				// TODO use this code instead, once the following issue has been resolved
				// in PhantomJS (tests are unpassable otherwise!)
				// https://github.com/ariya/phantomjs/issues/11856
				// defineProperty( this, '_subs', { value: create( null ), configurable: true });
				for ( eventName in this._subs ) {
					delete this._subs[ eventName ];
				}
			} else {
				// Handle multiple space-separated event names
				eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
				eventNames.forEach( function( eventName ) {
					var subscribers, index;
					// If we have subscribers for this event...
					if ( subscribers = this$0._subs[ eventName ] ) {
						// ...if a callback was specified, only remove that
						if ( callback ) {
							index = subscribers.indexOf( callback );
							if ( index !== -1 ) {
								subscribers.splice( index, 1 );
							}
						} else {
							this$0._subs[ eventName ] = [];
						}
					}
				} );
			}
			return this;
		};
	}( Ractive$shared_trim, Ractive$shared_notEmptyString );

	/* Ractive/prototype/on.js */
	var Ractive$on = function( trim, notEmptyString ) {

		return function Ractive$on( eventName, callback ) {
			var this$0 = this;
			var self = this,
				listeners, n, eventNames;
			// allow mutliple listeners to be bound in one go
			if ( typeof eventName === 'object' ) {
				listeners = [];
				for ( n in eventName ) {
					if ( eventName.hasOwnProperty( n ) ) {
						listeners.push( this.on( n, eventName[ n ] ) );
					}
				}
				return {
					cancel: function() {
						var listener;
						while ( listener = listeners.pop() ) {
							listener.cancel();
						}
					}
				};
			}
			// Handle multiple space-separated event names
			eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
			eventNames.forEach( function( eventName ) {
				( this$0._subs[ eventName ] || ( this$0._subs[ eventName ] = [] ) ).push( callback );
			} );
			return {
				cancel: function() {
					self.off( eventName, callback );
				}
			};
		};
	}( Ractive$shared_trim, Ractive$shared_notEmptyString );

	/* shared/getNewIndices.js */
	var getNewIndices = function() {

		var __export;
		// This function takes an array, the name of a mutator method, and the
		// arguments to call that mutator method with, and returns an array that
		// maps the old indices to their new indices.
		// So if you had something like this...
		//
		//     array = [ 'a', 'b', 'c', 'd' ];
		//     array.push( 'e' );
		//
		// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
		// have changed. If you then did this...
		//
		//     array.unshift( 'z' );
		//
		// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
		// one higher to make room for the 'z'. If you removed an item, the new index
		// would be -1...
		//
		//     array.splice( 2, 2 );
		//
		// ...this would result in [ 0, 1, -1, -1, 2, 3 ].
		//
		// This information is used to enable fast, non-destructive shuffling of list
		// sections when you do e.g. `ractive.splice( 'items', 2, 2 );
		__export = function getNewIndices( array, methodName, args ) {
			var spliceArguments, len, newIndices = [],
				removeStart, removeEnd, balance, i;
			spliceArguments = getSpliceEquivalent( array, methodName, args );
			if ( !spliceArguments ) {
				return null;
			}
			len = array.length;
			balance = spliceArguments.length - 2 - spliceArguments[ 1 ];
			removeStart = Math.min( len, spliceArguments[ 0 ] );
			removeEnd = removeStart + spliceArguments[ 1 ];
			for ( i = 0; i < removeStart; i += 1 ) {
				newIndices.push( i );
			}
			for ( ; i < removeEnd; i += 1 ) {
				newIndices.push( -1 );
			}
			for ( ; i < len; i += 1 ) {
				newIndices.push( i + balance );
			}
			return newIndices;
		};
		// The pop, push, shift an unshift methods can all be represented
		// as an equivalent splice
		function getSpliceEquivalent( array, methodName, args ) {
			switch ( methodName ) {
				case 'splice':
					if ( args[ 0 ] !== undefined && args[ 0 ] < 0 ) {
						args[ 0 ] = array.length + Math.max( args[ 0 ], -array.length );
					}
					while ( args.length < 2 ) {
						args.push( 0 );
					}
					// ensure we only remove elements that exist
					args[ 1 ] = Math.min( args[ 1 ], array.length - args[ 0 ] );
					return args;
				case 'sort':
				case 'reverse':
					return null;
				case 'pop':
					if ( array.length ) {
						return [
							array.length - 1,
							1
						];
					}
					return null;
				case 'push':
					return [
						array.length,
						0
					].concat( args );
				case 'shift':
					return [
						0,
						1
					];
				case 'unshift':
					return [
						0,
						0
					].concat( args );
			}
		}
		return __export;
	}();

	/* Ractive/prototype/shared/makeArrayMethod.js */
	var Ractive$shared_makeArrayMethod = function( isArray, runloop, getNewIndices ) {

		var arrayProto = Array.prototype;
		return function( methodName ) {
			return function( keypath ) {
				var SLICE$0 = Array.prototype.slice;
				var args = SLICE$0.call( arguments, 1 );
				var array, newIndices = [],
					len, promise, result;
				array = this.get( keypath );
				len = array.length;
				if ( !isArray( array ) ) {
					throw new Error( 'Called ractive.' + methodName + '(\'' + keypath + '\'), but \'' + keypath + '\' does not refer to an array' );
				}
				newIndices = getNewIndices( array, methodName, args );
				result = arrayProto[ methodName ].apply( array, args );
				promise = runloop.start( this, true ).then( function() {
					return result;
				} );
				if ( !!newIndices ) {
					this.viewmodel.smartUpdate( keypath, array, newIndices );
				} else {
					this.viewmodel.mark( keypath );
				}
				runloop.end();
				return promise;
			};
		};
	}( isArray, runloop, getNewIndices );

	/* Ractive/prototype/pop.js */
	var Ractive$pop = function( makeArrayMethod ) {

		return makeArrayMethod( 'pop' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/push.js */
	var Ractive$push = function( makeArrayMethod ) {

		return makeArrayMethod( 'push' );
	}( Ractive$shared_makeArrayMethod );

	/* global/css.js */
	var global_css = function( circular, isClient, removeFromArray ) {

		var css, update, runloop, styleElement, head, styleSheet, inDom, prefix = '/* Ractive.js component styles */\n',
			componentsInPage = {},
			styles = [];
		if ( !isClient ) {
			css = null;
		} else {
			circular.push( function() {
				runloop = circular.runloop;
			} );
			styleElement = document.createElement( 'style' );
			styleElement.type = 'text/css';
			head = document.getElementsByTagName( 'head' )[ 0 ];
			inDom = false;
			// Internet Exploder won't let you use styleSheet.innerHTML - we have to
			// use styleSheet.cssText instead
			styleSheet = styleElement.styleSheet;
			update = function() {
				var css;
				if ( styles.length ) {
					css = prefix + styles.join( ' ' );
					if ( styleSheet ) {
						styleSheet.cssText = css;
					} else {
						styleElement.innerHTML = css;
					}
					if ( !inDom ) {
						head.appendChild( styleElement );
						inDom = true;
					}
				} else if ( inDom ) {
					head.removeChild( styleElement );
					inDom = false;
				}
			};
			css = {
				add: function( Component ) {
					if ( !Component.css ) {
						return;
					}
					if ( !componentsInPage[ Component._guid ] ) {
						// we create this counter so that we can in/decrement it as
						// instances are added and removed. When all components are
						// removed, the style is too
						componentsInPage[ Component._guid ] = 0;
						styles.push( Component.css );
						update();
					}
					componentsInPage[ Component._guid ] += 1;
				},
				remove: function( Component ) {
					if ( !Component.css ) {
						return;
					}
					componentsInPage[ Component._guid ] -= 1;
					if ( !componentsInPage[ Component._guid ] ) {
						removeFromArray( styles, Component.css );
						runloop.scheduleTask( update );
					}
				}
			};
		}
		return css;
	}( circular, isClient, removeFromArray );

	/* Ractive/prototype/render.js */
	var Ractive$render = function( css, Hook, getElement, runloop ) {

		var renderHook = new Hook( 'render' ),
			completeHook = new Hook( 'complete' );
		return function Ractive$render( target, anchor ) {
			var this$0 = this;
			var promise, instances, transitionsEnabled;
			// if `noIntro` is `true`, temporarily disable transitions
			transitionsEnabled = this.transitionsEnabled;
			if ( this.noIntro ) {
				this.transitionsEnabled = false;
			}
			promise = runloop.start( this, true );
			runloop.scheduleTask( function() {
				return renderHook.fire( this$0 );
			}, true );
			if ( this.fragment.rendered ) {
				throw new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );
			}
			target = getElement( target ) || this.el;
			anchor = getElement( anchor ) || this.anchor;
			this.el = target;
			this.anchor = anchor;
			// Add CSS, if applicable
			if ( this.constructor.css ) {
				css.add( this.constructor );
			}
			if ( target ) {
				if ( !( instances = target.__ractive_instances__ ) ) {
					target.__ractive_instances__ = [ this ];
				} else {
					instances.push( this );
				}
				if ( anchor ) {
					target.insertBefore( this.fragment.render(), anchor );
				} else {
					target.appendChild( this.fragment.render() );
				}
			}
			runloop.end();
			this.transitionsEnabled = transitionsEnabled;
			// It is now more problematic to know if the complete hook
			// would fire. Method checking is straight-forward, but would
			// also require preflighting event subscriptions. Which seems
			// like more work then just letting the promise happen.
			// But perhaps I'm wrong about that...
			promise.then( function() {
				return completeHook.fire( this$0 );
			} );
			return promise;
		};
	}( global_css, Ractive$shared_hooks_Hook, getElement, runloop );

	/* virtualdom/Fragment/prototype/bubble.js */
	var virtualdom_Fragment$bubble = function Fragment$bubble() {
		this.dirtyValue = this.dirtyArgs = true;
		if ( this.bound && typeof this.owner.bubble === 'function' ) {
			this.owner.bubble();
		}
	};

	/* virtualdom/Fragment/prototype/detach.js */
	var virtualdom_Fragment$detach = function Fragment$detach() {
		var docFrag;
		if ( this.items.length === 1 ) {
			return this.items[ 0 ].detach();
		}
		docFrag = document.createDocumentFragment();
		this.items.forEach( function( item ) {
			var node = item.detach();
			// TODO The if {...} wasn't previously required - it is now, because we're
			// forcibly detaching everything to reorder sections after an update. That's
			// a non-ideal brute force approach, implemented to get all the tests to pass
			// - as soon as it's replaced with something more elegant, this should
			// revert to `docFrag.appendChild( item.detach() )`
			if ( node ) {
				docFrag.appendChild( node );
			}
		} );
		return docFrag;
	};

	/* virtualdom/Fragment/prototype/find.js */
	var virtualdom_Fragment$find = function Fragment$find( selector ) {
		var i, len, item, queryResult;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.find && ( queryResult = item.find( selector ) ) ) {
					return queryResult;
				}
			}
			return null;
		}
	};

	/* virtualdom/Fragment/prototype/findAll.js */
	var virtualdom_Fragment$findAll = function Fragment$findAll( selector, query ) {
		var i, len, item;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findAll ) {
					item.findAll( selector, query );
				}
			}
		}
		return query;
	};

	/* virtualdom/Fragment/prototype/findAllComponents.js */
	var virtualdom_Fragment$findAllComponents = function Fragment$findAllComponents( selector, query ) {
		var i, len, item;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findAllComponents ) {
					item.findAllComponents( selector, query );
				}
			}
		}
		return query;
	};

	/* virtualdom/Fragment/prototype/findComponent.js */
	var virtualdom_Fragment$findComponent = function Fragment$findComponent( selector ) {
		var len, i, item, queryResult;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findComponent && ( queryResult = item.findComponent( selector ) ) ) {
					return queryResult;
				}
			}
			return null;
		}
	};

	/* virtualdom/Fragment/prototype/findNextNode.js */
	var virtualdom_Fragment$findNextNode = function Fragment$findNextNode( item ) {
		var index = item.index,
			node;
		if ( this.items[ index + 1 ] ) {
			node = this.items[ index + 1 ].firstNode();
		} else if ( this.owner === this.root ) {
			if ( !this.owner.component ) {
				// TODO but something else could have been appended to
				// this.root.el, no?
				node = null;
			} else {
				node = this.owner.component.findNextNode();
			}
		} else {
			node = this.owner.findNextNode( this );
		}
		return node;
	};

	/* virtualdom/Fragment/prototype/firstNode.js */
	var virtualdom_Fragment$firstNode = function Fragment$firstNode() {
		if ( this.items && this.items[ 0 ] ) {
			return this.items[ 0 ].firstNode();
		}
		return null;
	};

	/* virtualdom/Fragment/prototype/getNode.js */
	var virtualdom_Fragment$getNode = function Fragment$getNode() {
		var fragment = this;
		do {
			if ( fragment.pElement ) {
				return fragment.pElement.node;
			}
		} while ( fragment = fragment.parent );
		return this.root.detached || this.root.el;
	};

	/* virtualdom/Fragment/prototype/getValue.js */
	var virtualdom_Fragment$getValue = function( parseJSON ) {

		var __export;
		var empty = {};
		__export = function Fragment$getValue() {
			var options = arguments[ 0 ];
			if ( options === void 0 )
				options = empty;
			var asArgs, values, source, parsed, cachedResult, dirtyFlag, result;
			asArgs = options.args;
			cachedResult = asArgs ? 'argsList' : 'value';
			dirtyFlag = asArgs ? 'dirtyArgs' : 'dirtyValue';
			if ( this[ dirtyFlag ] ) {
				source = processItems( this.items, values = {}, this.root._guid );
				parsed = parseJSON( asArgs ? '[' + source + ']' : source, values );
				if ( !parsed ) {
					result = asArgs ? [ this.toString() ] : this.toString();
				} else {
					result = parsed.value;
				}
				this[ cachedResult ] = result;
				this[ dirtyFlag ] = false;
			}
			return this[ cachedResult ];
		};

		function processItems( items, values, guid, counter ) {
			counter = counter || 0;
			return items.map( function( item ) {
				var placeholderId, wrapped, value;
				if ( item.text ) {
					return item.text;
				}
				if ( item.fragments ) {
					return item.fragments.map( function( fragment ) {
						return processItems( fragment.items, values, guid, counter );
					} ).join( '' );
				}
				placeholderId = guid + '-' + counter++;
				if ( wrapped = item.root.viewmodel.wrapped[ item.keypath ] ) {
					value = wrapped.value;
				} else {
					value = item.getValue();
				}
				values[ placeholderId ] = value;
				return '${' + placeholderId + '}';
			} ).join( '' );
		}
		return __export;
	}( parseJSON );

	/* utils/escapeHtml.js */
	var escapeHtml = function() {

		var lessThan = /</g;
		var greaterThan = />/g;
		var amp = /&/g;
		return function escapeHtml( str ) {
			return str.replace( amp, '&amp;' ).replace( lessThan, '&lt;' ).replace( greaterThan, '&gt;' );
		};
	}();

	/* utils/detachNode.js */
	var detachNode = function detachNode( node ) {
		if ( node && node.parentNode ) {
			node.parentNode.removeChild( node );
		}
		return node;
	};

	/* virtualdom/items/shared/detach.js */
	var detach = function( detachNode ) {

		return function() {
			return detachNode( this.node );
		};
	}( detachNode );

	/* virtualdom/items/Text.js */
	var Text = function( types, escapeHtml, detach ) {

		var Text = function( options ) {
			this.type = types.TEXT;
			this.text = options.template;
		};
		Text.prototype = {
			detach: detach,
			firstNode: function() {
				return this.node;
			},
			render: function() {
				if ( !this.node ) {
					this.node = document.createTextNode( this.text );
				}
				return this.node;
			},
			toString: function( escape ) {
				return escape ? escapeHtml( this.text ) : this.text;
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					return this.detach();
				}
			}
		};
		return Text;
	}( types, escapeHtml, detach );

	/* virtualdom/items/shared/unbind.js */
	var unbind = function unbind() {
		if ( this.registered ) {
			// this was registered as a dependant
			this.root.viewmodel.unregister( this.keypath, this );
		}
		if ( this.resolver ) {
			this.resolver.unbind();
		}
	};

	/* virtualdom/items/shared/Mustache/getValue.js */
	var getValue = function Mustache$getValue() {
		return this.value;
	};

	/* virtualdom/items/shared/utils/startsWithKeypath.js */
	var startsWithKeypath = function startsWithKeypath( target, keypath ) {
		return target && keypath && target.substr( 0, keypath.length + 1 ) === keypath + '.';
	};

	/* virtualdom/items/shared/utils/getNewKeypath.js */
	var getNewKeypath = function( startsWithKeypath ) {

		return function getNewKeypath( targetKeypath, oldKeypath, newKeypath ) {
			// exact match
			if ( targetKeypath === oldKeypath ) {
				return newKeypath !== undefined ? newKeypath : null;
			}
			// partial match based on leading keypath segments
			if ( startsWithKeypath( targetKeypath, oldKeypath ) ) {
				return newKeypath === null ? newKeypath : targetKeypath.replace( oldKeypath + '.', newKeypath + '.' );
			}
		};
	}( startsWithKeypath );

	/* virtualdom/items/shared/Resolvers/ReferenceResolver.js */
	var ReferenceResolver = function( runloop, resolveRef, getNewKeypath ) {

		var ReferenceResolver = function( owner, ref, callback ) {
			var keypath;
			this.ref = ref;
			this.resolved = false;
			this.root = owner.root;
			this.parentFragment = owner.parentFragment;
			this.callback = callback;
			keypath = resolveRef( owner.root, ref, owner.parentFragment );
			if ( keypath !== undefined ) {
				this.resolve( keypath );
			} else {
				runloop.addUnresolved( this );
			}
		};
		ReferenceResolver.prototype = {
			resolve: function( keypath ) {
				this.resolved = true;
				this.keypath = keypath;
				this.callback( keypath );
			},
			forceResolution: function() {
				this.resolve( this.ref );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var keypath;
				if ( this.keypath !== undefined ) {
					keypath = getNewKeypath( this.keypath, oldKeypath, newKeypath );
					// was a new keypath created?
					if ( keypath !== undefined ) {
						// resolve it
						this.resolve( keypath );
					}
				}
			},
			unbind: function() {
				if ( !this.resolved ) {
					runloop.removeUnresolved( this );
				}
			}
		};
		return ReferenceResolver;
	}( runloop, resolveRef, getNewKeypath );

	/* virtualdom/items/shared/Resolvers/SpecialResolver.js */
	var SpecialResolver = function() {

		var SpecialResolver = function( owner, ref, callback ) {
			this.parentFragment = owner.parentFragment;
			this.ref = ref;
			this.callback = callback;
			this.rebind();
		};
		SpecialResolver.prototype = {
			rebind: function() {
				var ref = this.ref,
					fragment = this.parentFragment;
				if ( ref === '@keypath' ) {
					while ( fragment ) {
						if ( !!fragment.context ) {
							return this.callback( '@' + fragment.context );
						}
						fragment = fragment.parent;
					}
				}
				if ( ref === '@index' || ref === '@key' ) {
					while ( fragment ) {
						if ( fragment.index !== undefined ) {
							return this.callback( '@' + fragment.index );
						}
						fragment = fragment.parent;
					}
				}
				throw new Error( 'Unknown special reference "' + ref + '" - valid references are @index, @key and @keypath' );
			},
			unbind: function() {}
		};
		return SpecialResolver;
	}();

	/* virtualdom/items/shared/Resolvers/IndexResolver.js */
	var IndexResolver = function() {

		var IndexResolver = function( owner, ref, callback ) {
			this.parentFragment = owner.parentFragment;
			this.ref = ref;
			this.callback = callback;
			this.rebind();
		};
		IndexResolver.prototype = {
			rebind: function() {
				var ref = this.ref,
					indexRefs = this.parentFragment.indexRefs,
					index = indexRefs[ ref ];
				if ( index !== undefined ) {
					this.callback( '@' + index );
				}
			},
			unbind: function() {}
		};
		return IndexResolver;
	}();

	/* virtualdom/items/shared/Resolvers/createReferenceResolver.js */
	var createReferenceResolver = function( ReferenceResolver, SpecialResolver, IndexResolver ) {

		return function createReferenceResolver( owner, ref, callback ) {
			var indexRefs, index;
			if ( ref.charAt( 0 ) === '@' ) {
				return new SpecialResolver( owner, ref, callback );
			}
			indexRefs = owner.parentFragment.indexRefs;
			if ( indexRefs && ( index = indexRefs[ ref ] ) !== undefined ) {
				return new IndexResolver( owner, ref, callback );
			}
			return new ReferenceResolver( owner, ref, callback );
		};
	}( ReferenceResolver, SpecialResolver, IndexResolver );

	/* shared/getFunctionFromString.js */
	var getFunctionFromString = function() {

		var cache = {};
		return function getFunctionFromString( str, i ) {
			var fn, args;
			if ( cache[ str ] ) {
				return cache[ str ];
			}
			args = [];
			while ( i-- ) {
				args[ i ] = '_' + i;
			}
			fn = new Function( args.join( ',' ), 'return(' + str + ')' );
			cache[ str ] = fn;
			return fn;
		};
	}();

	/* virtualdom/items/shared/Resolvers/ExpressionResolver.js */
	var ExpressionResolver = function( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString ) {

		var __export;
		var ExpressionResolver, bind = Function.prototype.bind;
		ExpressionResolver = function( owner, parentFragment, expression, callback ) {
			var resolver = this,
				ractive, indexRefs;
			ractive = owner.root;
			resolver.root = ractive;
			resolver.parentFragment = parentFragment;
			resolver.callback = callback;
			resolver.owner = owner;
			resolver.str = expression.s;
			resolver.keypaths = [];
			indexRefs = parentFragment.indexRefs;
			// Create resolvers for each reference
			resolver.pending = expression.r.length;
			resolver.refResolvers = expression.r.map( function( ref, i ) {
				return createReferenceResolver( resolver, ref, function( keypath ) {
					resolver.resolve( i, keypath );
				} );
			} );
			resolver.ready = true;
			resolver.bubble();
		};
		ExpressionResolver.prototype = {
			bubble: function() {
				if ( !this.ready ) {
					return;
				}
				this.uniqueString = getUniqueString( this.str, this.keypaths );
				this.keypath = getKeypath( this.uniqueString );
				this.createEvaluator();
				this.callback( this.keypath );
			},
			unbind: function() {
				var resolver;
				while ( resolver = this.refResolvers.pop() ) {
					resolver.unbind();
				}
			},
			resolve: function( index, keypath ) {
				this.keypaths[ index ] = keypath;
				this.bubble();
			},
			createEvaluator: function() {
				var this$0 = this;
				var self = this,
					computation, valueGetters, signature, keypath, fn;
				computation = this.root.viewmodel.computations[ this.keypath ];
				// only if it doesn't exist yet!
				if ( !computation ) {
					fn = getFunctionFromString( this.str, this.refResolvers.length );
					valueGetters = this.keypaths.map( function( keypath ) {
						var value;
						if ( keypath === 'undefined' ) {
							return function() {
								return undefined;
							};
						}
						// 'special' keypaths encode a value
						if ( keypath[ 0 ] === '@' ) {
							value = keypath.slice( 1 );
							return isNumeric( value ) ? function() {
								return +value;
							} : function() {
								return value;
							};
						}
						return function() {
							var value = this$0.root.viewmodel.get( keypath );
							if ( typeof value === 'function' ) {
								value = wrapFunction( value, self.root );
							}
							return value;
						};
					} );
					signature = {
						deps: this.keypaths.filter( isValidDependency ),
						get: function() {
							var args = valueGetters.map( call );
							return fn.apply( null, args );
						}
					};
					computation = this.root.viewmodel.compute( this.keypath, signature );
				} else {
					this.root.viewmodel.mark( this.keypath );
				}
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				// TODO only bubble once, no matter how many references are affected by the rebind
				this.refResolvers.forEach( function( r ) {
					return r.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				} );
			}
		};
		__export = ExpressionResolver;

		function call( value ) {
			return value.call();
		}

		function getUniqueString( str, keypaths ) {
			// get string that is unique to this expression
			return str.replace( /_([0-9]+)/g, function( match, $1 ) {
				var keypath, value;
				keypath = keypaths[ $1 ];
				if ( keypath === undefined ) {
					return 'undefined';
				}
				if ( keypath[ 0 ] === '@' ) {
					value = keypath.slice( 1 );
					return isNumeric( value ) ? value : '"' + value + '"';
				}
				return keypath;
			} );
		}

		function getKeypath( uniqueString ) {
			// Sanitize by removing any periods or square brackets. Otherwise
			// we can't split the keypath into keys!
			return '${' + uniqueString.replace( /[\.\[\]]/g, '-' ) + '}';
		}

		function isValidDependency( keypath ) {
			return keypath !== undefined && keypath[ 0 ] !== '@';
		}

		function wrapFunction( fn, ractive ) {
			var wrapped, prop, key;
			if ( fn._noWrap ) {
				return fn;
			}
			prop = '__ractive_' + ractive._guid;
			wrapped = fn[ prop ];
			if ( wrapped ) {
				return wrapped;
			} else if ( /this/.test( fn.toString() ) ) {
				defineProperty( fn, prop, {
					value: bind.call( fn, ractive )
				} );
				// Add properties/methods to wrapped function
				for ( key in fn ) {
					if ( fn.hasOwnProperty( key ) ) {
						fn[ prop ][ key ] = fn[ key ];
					}
				}
				return fn[ prop ];
			}
			defineProperty( fn, '__ractive_nowrap', {
				value: fn
			} );
			return fn.__ractive_nowrap;
		}
		return __export;
	}( defineProperty, isNumeric, createReferenceResolver, getFunctionFromString, legacy );

	/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js */
	var MemberResolver = function( types, createReferenceResolver, ExpressionResolver ) {

		var MemberResolver = function( template, resolver, parentFragment ) {
			var member = this,
				keypath;
			member.resolver = resolver;
			member.root = resolver.root;
			member.parentFragment = parentFragment;
			member.viewmodel = resolver.root.viewmodel;
			if ( typeof template === 'string' ) {
				member.value = template;
			} else if ( template.t === types.REFERENCE ) {
				member.refResolver = createReferenceResolver( this, template.n, function( keypath ) {
					member.resolve( keypath );
				} );
			} else {
				new ExpressionResolver( resolver, parentFragment, template, function( keypath ) {
					member.resolve( keypath );
				} );
			}
		};
		MemberResolver.prototype = {
			resolve: function( keypath ) {
				if ( this.keypath ) {
					this.viewmodel.unregister( this.keypath, this );
				}
				this.keypath = keypath;
				this.value = this.viewmodel.get( keypath );
				this.bind();
				this.resolver.bubble();
			},
			bind: function() {
				this.viewmodel.register( this.keypath, this );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				if ( this.refResolver ) {
					this.refResolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			},
			setValue: function( value ) {
				this.value = value;
				this.resolver.bubble();
			},
			unbind: function() {
				if ( this.keypath ) {
					this.viewmodel.unregister( this.keypath, this );
				}
				if ( this.unresolved ) {
					this.unresolved.unbind();
				}
			},
			forceResolution: function() {
				if ( this.refResolver ) {
					this.refResolver.forceResolution();
				}
			}
		};
		return MemberResolver;
	}( types, createReferenceResolver, ExpressionResolver );

	/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js */
	var ReferenceExpressionResolver = function( resolveRef, ReferenceResolver, MemberResolver ) {

		var ReferenceExpressionResolver = function( mustache, template, callback ) {
			var this$0 = this;
			var resolver = this,
				ractive, ref, keypath, parentFragment;
			resolver.parentFragment = parentFragment = mustache.parentFragment;
			resolver.root = ractive = mustache.root;
			resolver.mustache = mustache;
			resolver.ref = ref = template.r;
			resolver.callback = callback;
			resolver.unresolved = [];
			// Find base keypath
			if ( keypath = resolveRef( ractive, ref, parentFragment ) ) {
				resolver.base = keypath;
			} else {
				resolver.baseResolver = new ReferenceResolver( this, ref, function( keypath ) {
					resolver.base = keypath;
					resolver.baseResolver = null;
					resolver.bubble();
				} );
			}
			// Find values for members, or mark them as unresolved
			resolver.members = template.m.map( function( template ) {
				return new MemberResolver( template, this$0, parentFragment );
			} );
			resolver.ready = true;
			resolver.bubble();
		};
		ReferenceExpressionResolver.prototype = {
			getKeypath: function() {
				var values = this.members.map( getValue );
				if ( !values.every( isDefined ) || this.baseResolver ) {
					return null;
				}
				return this.base + '.' + values.join( '.' );
			},
			bubble: function() {
				if ( !this.ready || this.baseResolver ) {
					return;
				}
				this.callback( this.getKeypath() );
			},
			unbind: function() {
				this.members.forEach( unbind );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var changed;
				this.members.forEach( function( members ) {
					if ( members.rebind( indexRef, newIndex, oldKeypath, newKeypath ) ) {
						changed = true;
					}
				} );
				if ( changed ) {
					this.bubble();
				}
			},
			forceResolution: function() {
				if ( this.baseResolver ) {
					this.base = this.ref;
					this.baseResolver.unbind();
					this.baseResolver = null;
				}
				this.members.forEach( function( m ) {
					return m.forceResolution();
				} );
				this.bubble();
			}
		};

		function getValue( member ) {
			return member.value;
		}

		function isDefined( value ) {
			return value != undefined;
		}

		function unbind( member ) {
			member.unbind();
		}
		return ReferenceExpressionResolver;
	}( resolveRef, ReferenceResolver, MemberResolver );

	/* virtualdom/items/shared/Mustache/initialise.js */
	var initialise = function( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver ) {

		return function Mustache$init( mustache, options ) {
			var ref, parentFragment, template;
			parentFragment = options.parentFragment;
			template = options.template;
			mustache.root = parentFragment.root;
			mustache.parentFragment = parentFragment;
			mustache.pElement = parentFragment.pElement;
			mustache.template = options.template;
			mustache.index = options.index || 0;
			mustache.isStatic = options.template.s;
			mustache.type = options.template.t;
			mustache.registered = false;
			// if this is a simple mustache, with a reference, we just need to resolve
			// the reference to a keypath
			if ( ref = template.r ) {
				mustache.resolver = new createReferenceResolver( mustache, ref, resolve );
			}
			// if it's an expression, we have a bit more work to do
			if ( options.template.x ) {
				mustache.resolver = new ExpressionResolver( mustache, parentFragment, options.template.x, resolveAndRebindChildren );
			}
			if ( options.template.rx ) {
				mustache.resolver = new ReferenceExpressionResolver( mustache, options.template.rx, resolveAndRebindChildren );
			}
			// Special case - inverted sections
			if ( mustache.template.n === types.SECTION_UNLESS && !mustache.hasOwnProperty( 'value' ) ) {
				mustache.setValue( undefined );
			}

			function resolve( keypath ) {
				mustache.resolve( keypath );
			}

			function resolveAndRebindChildren( newKeypath ) {
				var oldKeypath = mustache.keypath;
				if ( newKeypath !== oldKeypath ) {
					mustache.resolve( newKeypath );
					if ( oldKeypath !== undefined ) {
						mustache.fragments && mustache.fragments.forEach( function( f ) {
							f.rebind( null, null, oldKeypath, newKeypath );
						} );
					}
				}
			}
		};
	}( types, createReferenceResolver, ReferenceExpressionResolver, ExpressionResolver );

	/* virtualdom/items/shared/Mustache/resolve.js */
	var resolve = function( isNumeric ) {

		return function Mustache$resolve( keypath ) {
			var wasResolved, value, twowayBinding;
			// 'Special' keypaths, e.g. @foo or @7, encode a value
			if ( keypath && keypath[ 0 ] === '@' ) {
				value = keypath.slice( 1 );
				if ( isNumeric( value ) ) {
					value = +value;
				}
				this.keypath = keypath;
				this.setValue( value );
				return;
			}
			// If we resolved previously, we need to unregister
			if ( this.registered ) {
				// undefined or null
				this.root.viewmodel.unregister( this.keypath, this );
				this.registered = false;
				wasResolved = true;
			}
			this.keypath = keypath;
			// If the new keypath exists, we need to register
			// with the viewmodel
			if ( keypath != undefined ) {
				// undefined or null
				value = this.root.viewmodel.get( keypath );
				this.root.viewmodel.register( keypath, this );
				this.registered = true;
			}
			// Either way we need to queue up a render (`value`
			// will be `undefined` if there's no keypath)
			this.setValue( value );
			// Two-way bindings need to point to their new target keypath
			if ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {
				twowayBinding.rebound();
			}
		};
	}( isNumeric );

	/* virtualdom/items/shared/Mustache/rebind.js */
	var rebind = function Mustache$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		// Children first
		if ( this.fragments ) {
			this.fragments.forEach( function( f ) {
				return f.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			} );
		}
		// Expression mustache?
		if ( this.resolver ) {
			this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/shared/Mustache/_Mustache.js */
	var Mustache = function( getValue, init, resolve, rebind ) {

		return {
			getValue: getValue,
			init: init,
			resolve: resolve,
			rebind: rebind
		};
	}( getValue, initialise, resolve, rebind );

	/* virtualdom/items/Interpolator.js */
	var Interpolator = function( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach ) {

		var Interpolator = function( options ) {
			this.type = types.INTERPOLATOR;
			Mustache.init( this, options );
		};
		Interpolator.prototype = {
			update: function() {
				this.node.data = this.value == undefined ? '' : this.value;
			},
			resolve: Mustache.resolve,
			rebind: Mustache.rebind,
			detach: detach,
			unbind: unbind,
			render: function() {
				if ( !this.node ) {
					this.node = document.createTextNode( this.value != undefined ? this.value : '' );
				}
				return this.node;
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					detachNode( this.node );
				}
			},
			getValue: Mustache.getValue,
			// TEMP
			setValue: function( value ) {
				var wrapper;
				// TODO is there a better way to approach this?
				if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
					value = wrapper.get();
				}
				if ( !isEqual( value, this.value ) ) {
					this.value = value;
					this.parentFragment.bubble();
					if ( this.node ) {
						runloop.addView( this );
					}
				}
			},
			firstNode: function() {
				return this.node;
			},
			toString: function( escape ) {
				var string = this.value != undefined ? '' + this.value : '';
				return escape ? escapeHtml( string ) : string;
			}
		};
		return Interpolator;
	}( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach );

	/* virtualdom/items/Section/prototype/bubble.js */
	var virtualdom_items_Section$bubble = function Section$bubble() {
		this.parentFragment.bubble();
	};

	/* virtualdom/items/Section/prototype/detach.js */
	var virtualdom_items_Section$detach = function Section$detach() {
		var docFrag;
		if ( this.fragments.length === 1 ) {
			return this.fragments[ 0 ].detach();
		}
		docFrag = document.createDocumentFragment();
		this.fragments.forEach( function( item ) {
			docFrag.appendChild( item.detach() );
		} );
		return docFrag;
	};

	/* virtualdom/items/Section/prototype/find.js */
	var virtualdom_items_Section$find = function Section$find( selector ) {
		var i, len, queryResult;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			if ( queryResult = this.fragments[ i ].find( selector ) ) {
				return queryResult;
			}
		}
		return null;
	};

	/* virtualdom/items/Section/prototype/findAll.js */
	var virtualdom_items_Section$findAll = function Section$findAll( selector, query ) {
		var i, len;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			this.fragments[ i ].findAll( selector, query );
		}
	};

	/* virtualdom/items/Section/prototype/findAllComponents.js */
	var virtualdom_items_Section$findAllComponents = function Section$findAllComponents( selector, query ) {
		var i, len;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			this.fragments[ i ].findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Section/prototype/findComponent.js */
	var virtualdom_items_Section$findComponent = function Section$findComponent( selector ) {
		var i, len, queryResult;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			if ( queryResult = this.fragments[ i ].findComponent( selector ) ) {
				return queryResult;
			}
		}
		return null;
	};

	/* virtualdom/items/Section/prototype/findNextNode.js */
	var virtualdom_items_Section$findNextNode = function Section$findNextNode( fragment ) {
		if ( this.fragments[ fragment.index + 1 ] ) {
			return this.fragments[ fragment.index + 1 ].firstNode();
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Section/prototype/firstNode.js */
	var virtualdom_items_Section$firstNode = function Section$firstNode() {
		var len, i, node;
		if ( len = this.fragments.length ) {
			for ( i = 0; i < len; i += 1 ) {
				if ( node = this.fragments[ i ].firstNode() ) {
					return node;
				}
			}
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Section/prototype/shuffle.js */
	var virtualdom_items_Section$shuffle = function( types, runloop, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Section$shuffle( newIndices ) {
			var this$0 = this;
			var section = this,
				parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;
			// short circuit any double-updates, and ensure that this isn't applied to
			// non-list sections
			if ( this.shuffling || this.unbound || this.subtype && this.subtype !== types.SECTION_EACH ) {
				return;
			}
			this.shuffling = true;
			runloop.scheduleTask( function() {
				return this$0.shuffling = false;
			} );
			parentFragment = this.parentFragment;
			reboundFragments = [];
			// first, rebind existing fragments
			newIndices.forEach( function rebindIfNecessary( newIndex, oldIndex ) {
				var fragment, by, oldKeypath, newKeypath;
				if ( newIndex === oldIndex ) {
					reboundFragments[ newIndex ] = section.fragments[ oldIndex ];
					return;
				}
				fragment = section.fragments[ oldIndex ];
				if ( firstChange === undefined ) {
					firstChange = oldIndex;
				}
				// does this fragment need to be torn down?
				if ( newIndex === -1 ) {
					section.fragmentsToUnrender.push( fragment );
					fragment.unbind();
					return;
				}
				// Otherwise, it needs to be rebound to a new index
				by = newIndex - oldIndex;
				oldKeypath = section.keypath + '.' + oldIndex;
				newKeypath = section.keypath + '.' + newIndex;
				fragment.rebind( section.template.i, newIndex, oldKeypath, newKeypath );
				fragment.index = newIndex;
				reboundFragments[ newIndex ] = fragment;
			} );
			newLength = this.root.get( this.keypath ).length;
			// If nothing changed with the existing fragments, then we start adding
			// new fragments at the end...
			if ( firstChange === undefined ) {
				// ...unless there are no new fragments to add
				if ( this.length === newLength ) {
					return;
				}
				firstChange = this.length;
			}
			this.length = this.fragments.length = newLength;
			if ( this.rendered ) {
				runloop.addView( this );
			}
			// Prepare new fragment options
			fragmentOptions = {
				template: this.template.f,
				root: this.root,
				owner: this
			};
			if ( this.template.i ) {
				fragmentOptions.indexRef = this.template.i;
			}
			// Add as many new fragments as we need to, or add back existing
			// (detached) fragments
			for ( i = firstChange; i < newLength; i += 1 ) {
				fragment = reboundFragments[ i ];
				if ( !fragment ) {
					this.fragmentsToCreate.push( i );
				}
				this.fragments[ i ] = fragment;
			}
		};
	}( types, runloop, circular );

	/* virtualdom/items/Section/prototype/render.js */
	var virtualdom_items_Section$render = function Section$render() {
		var docFrag;
		docFrag = this.docFrag = document.createDocumentFragment();
		this.update();
		this.rendered = true;
		return docFrag;
	};

	/* utils/isArrayLike.js */
	var isArrayLike = function() {

		var pattern = /^\[object (?:Array|FileList)\]$/,
			toString = Object.prototype.toString;
		return function isArrayLike( obj ) {
			return pattern.test( toString.call( obj ) );
		};
	}();

	/* virtualdom/items/Section/prototype/setValue.js */
	var virtualdom_items_Section$setValue = function( types, isArrayLike, isObject, runloop, circular ) {

		var __export;
		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		__export = function Section$setValue( value ) {
			var this$0 = this;
			var wrapper, fragmentOptions;
			if ( this.updating ) {
				// If a child of this section causes a re-evaluation - for example, an
				// expression refers to a function that mutates the array that this
				// section depends on - we'll end up with a double rendering bug (see
				// https://github.com/ractivejs/ractive/issues/748). This prevents it.
				return;
			}
			this.updating = true;
			// with sections, we need to get the fake value if we have a wrapped object
			if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
				value = wrapper.get();
			}
			// If any fragments are awaiting creation after a splice,
			// this is the place to do it
			if ( this.fragmentsToCreate.length ) {
				fragmentOptions = {
					template: this.template.f,
					root: this.root,
					pElement: this.pElement,
					owner: this,
					indexRef: this.template.i
				};
				this.fragmentsToCreate.forEach( function( index ) {
					var fragment;
					fragmentOptions.context = this$0.keypath + '.' + index;
					fragmentOptions.index = index;
					fragment = new Fragment( fragmentOptions );
					this$0.fragmentsToRender.push( this$0.fragments[ index ] = fragment );
				} );
				this.fragmentsToCreate.length = 0;
			} else if ( reevaluateSection( this, value ) ) {
				this.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
			this.value = value;
			this.updating = false;
		};

		function reevaluateSection( section, value ) {
			var fragmentOptions = {
				template: section.template.f,
				root: section.root,
				pElement: section.parentFragment.pElement,
				owner: section
			};
			// If we already know the section type, great
			// TODO can this be optimised? i.e. pick an reevaluateSection function during init
			// and avoid doing this each time?
			if ( section.subtype ) {
				switch ( section.subtype ) {
					case types.SECTION_IF:
						return reevaluateConditionalSection( section, value, false, fragmentOptions );
					case types.SECTION_UNLESS:
						return reevaluateConditionalSection( section, value, true, fragmentOptions );
					case types.SECTION_WITH:
						return reevaluateContextSection( section, fragmentOptions );
					case types.SECTION_IF_WITH:
						return reevaluateConditionalContextSection( section, value, fragmentOptions );
					case types.SECTION_EACH:
						if ( isObject( value ) ) {
							return reevaluateListObjectSection( section, value, fragmentOptions );
						}
				}
			}
			// Otherwise we need to work out what sort of section we're dealing with
			section.ordered = !!isArrayLike( value );
			// Ordered list section
			if ( section.ordered ) {
				return reevaluateListSection( section, value, fragmentOptions );
			}
			// Unordered list, or context
			if ( isObject( value ) || typeof value === 'function' ) {
				// Index reference indicates section should be treated as a list
				if ( section.template.i ) {
					return reevaluateListObjectSection( section, value, fragmentOptions );
				}
				// Otherwise, object provides context for contents
				return reevaluateContextSection( section, fragmentOptions );
			}
			// Conditional section
			return reevaluateConditionalSection( section, value, false, fragmentOptions );
		}

		function reevaluateListSection( section, value, fragmentOptions ) {
			var i, length, fragment;
			length = value.length;
			if ( length === section.length ) {
				// Nothing to do
				return false;
			}
			// if the array is shorter than it was previously, remove items
			if ( length < section.length ) {
				section.fragmentsToUnrender = section.fragments.splice( length, section.length - length );
				section.fragmentsToUnrender.forEach( unbind );
			} else {
				if ( length > section.length ) {
					// add any new ones
					for ( i = section.length; i < length; i += 1 ) {
						// append list item to context stack
						fragmentOptions.context = section.keypath + '.' + i;
						fragmentOptions.index = i;
						if ( section.template.i ) {
							fragmentOptions.indexRef = section.template.i;
						}
						fragment = new Fragment( fragmentOptions );
						section.fragmentsToRender.push( section.fragments[ i ] = fragment );
					}
				}
			}
			section.length = length;
			return true;
		}

		function reevaluateListObjectSection( section, value, fragmentOptions ) {
			var id, i, hasKey, fragment, changed;
			hasKey = section.hasKey || ( section.hasKey = {} );
			// remove any fragments that should no longer exist
			i = section.fragments.length;
			while ( i-- ) {
				fragment = section.fragments[ i ];
				if ( !( fragment.index in value ) ) {
					changed = true;
					fragment.unbind();
					section.fragmentsToUnrender.push( fragment );
					section.fragments.splice( i, 1 );
					hasKey[ fragment.index ] = false;
				}
			}
			// add any that haven't been created yet
			for ( id in value ) {
				if ( !hasKey[ id ] ) {
					changed = true;
					fragmentOptions.context = section.keypath + '.' + id;
					fragmentOptions.index = id;
					if ( section.template.i ) {
						fragmentOptions.indexRef = section.template.i;
					}
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( fragment );
					section.fragments.push( fragment );
					hasKey[ id ] = true;
				}
			}
			section.length = section.fragments.length;
			return changed;
		}

		function reevaluateConditionalContextSection( section, value, fragmentOptions ) {
			if ( value ) {
				return reevaluateContextSection( section, fragmentOptions );
			} else {
				return removeSectionFragments( section );
			}
		}

		function reevaluateContextSection( section, fragmentOptions ) {
			var fragment;
			// ...then if it isn't rendered, render it, adding section.keypath to the context stack
			// (if it is already rendered, then any children dependent on the context stack
			// will update themselves without any prompting)
			if ( !section.length ) {
				// append this section to the context stack
				fragmentOptions.context = section.keypath;
				fragmentOptions.index = 0;
				fragment = new Fragment( fragmentOptions );
				section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
				section.length = 1;
				return true;
			}
		}

		function reevaluateConditionalSection( section, value, inverted, fragmentOptions ) {
			var doRender, emptyArray, emptyObject, fragment, name;
			emptyArray = isArrayLike( value ) && value.length === 0;
			emptyObject = false;
			if ( !isArrayLike( value ) && isObject( value ) ) {
				emptyObject = true;
				for ( name in value ) {
					emptyObject = false;
					break;
				}
			}
			if ( inverted ) {
				doRender = emptyArray || emptyObject || !value;
			} else {
				doRender = value && !emptyArray && !emptyObject;
			}
			if ( doRender ) {
				if ( !section.length ) {
					// no change to context stack
					fragmentOptions.index = 0;
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
					section.length = 1;
					return true;
				}
				if ( section.length > 1 ) {
					section.fragmentsToUnrender = section.fragments.splice( 1 );
					section.fragmentsToUnrender.forEach( unbind );
					return true;
				}
			} else {
				return removeSectionFragments( section );
			}
		}

		function removeSectionFragments( section ) {
			if ( section.length ) {
				section.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length ).filter( isRendered );
				section.fragmentsToUnrender.forEach( unbind );
				section.length = section.fragmentsToRender.length = 0;
				return true;
			}
		}

		function unbind( fragment ) {
			fragment.unbind();
		}

		function isRendered( fragment ) {
			return fragment.rendered;
		}
		return __export;
	}( types, isArrayLike, isObject, runloop, circular );

	/* virtualdom/items/Section/prototype/toString.js */
	var virtualdom_items_Section$toString = function Section$toString( escape ) {
		var str, i, len;
		str = '';
		i = 0;
		len = this.length;
		for ( i = 0; i < len; i += 1 ) {
			str += this.fragments[ i ].toString( escape );
		}
		return str;
	};

	/* virtualdom/items/Section/prototype/unbind.js */
	var virtualdom_items_Section$unbind = function( unbind ) {

		var __export;
		__export = function Section$unbind() {
			this.fragments.forEach( unbindFragment );
			unbind.call( this );
			this.length = 0;
			this.unbound = true;
		};

		function unbindFragment( fragment ) {
			fragment.unbind();
		}
		return __export;
	}( unbind );

	/* virtualdom/items/Section/prototype/unrender.js */
	var virtualdom_items_Section$unrender = function() {

		var __export;
		__export = function Section$unrender( shouldDestroy ) {
			this.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );
		};

		function unrenderAndDestroy( fragment ) {
			fragment.unrender( true );
		}

		function unrender( fragment ) {
			fragment.unrender( false );
		}
		return __export;
	}();

	/* virtualdom/items/Section/prototype/update.js */
	var virtualdom_items_Section$update = function Section$update() {
		var fragment, renderIndex, renderedFragments, anchor, target, i, len;
		// `this.renderedFragments` is in the order of the previous render.
		// If fragments have shuffled about, this allows us to quickly
		// reinsert them in the correct place
		renderedFragments = this.renderedFragments;
		// Remove fragments that have been marked for destruction
		while ( fragment = this.fragmentsToUnrender.pop() ) {
			fragment.unrender( true );
			renderedFragments.splice( renderedFragments.indexOf( fragment ), 1 );
		}
		// Render new fragments (but don't insert them yet)
		while ( fragment = this.fragmentsToRender.shift() ) {
			fragment.render();
		}
		if ( this.rendered ) {
			target = this.parentFragment.getNode();
		}
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			fragment = this.fragments[ i ];
			renderIndex = renderedFragments.indexOf( fragment, i );
			// search from current index - it's guaranteed to be the same or higher
			if ( renderIndex === i ) {
				// already in the right place. insert accumulated nodes (if any) and carry on
				if ( this.docFrag.childNodes.length ) {
					anchor = fragment.firstNode();
					target.insertBefore( this.docFrag, anchor );
				}
				continue;
			}
			this.docFrag.appendChild( fragment.detach() );
			// update renderedFragments
			if ( renderIndex !== -1 ) {
				renderedFragments.splice( renderIndex, 1 );
			}
			renderedFragments.splice( i, 0, fragment );
		}
		if ( this.rendered && this.docFrag.childNodes.length ) {
			anchor = this.parentFragment.findNextNode( this );
			target.insertBefore( this.docFrag, anchor );
		}
		// Save the rendering order for next time
		this.renderedFragments = this.fragments.slice();
	};

	/* virtualdom/items/Section/_Section.js */
	var Section = function( types, Mustache, bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, shuffle, render, setValue, toString, unbind, unrender, update ) {

		var Section = function( options ) {
			this.type = types.SECTION;
			this.subtype = options.template.n;
			this.inverted = this.subtype === types.SECTION_UNLESS;
			this.pElement = options.pElement;
			this.fragments = [];
			this.fragmentsToCreate = [];
			this.fragmentsToRender = [];
			this.fragmentsToUnrender = [];
			this.renderedFragments = [];
			this.length = 0;
			// number of times this section is rendered
			Mustache.init( this, options );
		};
		Section.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getValue: Mustache.getValue,
			shuffle: shuffle,
			rebind: Mustache.rebind,
			render: render,
			resolve: Mustache.resolve,
			setValue: setValue,
			toString: toString,
			unbind: unbind,
			unrender: unrender,
			update: update
		};
		return Section;
	}( types, Mustache, virtualdom_items_Section$bubble, virtualdom_items_Section$detach, virtualdom_items_Section$find, virtualdom_items_Section$findAll, virtualdom_items_Section$findAllComponents, virtualdom_items_Section$findComponent, virtualdom_items_Section$findNextNode, virtualdom_items_Section$firstNode, virtualdom_items_Section$shuffle, virtualdom_items_Section$render, virtualdom_items_Section$setValue, virtualdom_items_Section$toString, virtualdom_items_Section$unbind, virtualdom_items_Section$unrender, virtualdom_items_Section$update );

	/* virtualdom/items/Triple/prototype/detach.js */
	var virtualdom_items_Triple$detach = function Triple$detach() {
		var len, i;
		if ( this.docFrag ) {
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				this.docFrag.appendChild( this.nodes[ i ] );
			}
			return this.docFrag;
		}
	};

	/* virtualdom/items/Triple/prototype/find.js */
	var virtualdom_items_Triple$find = function( matches ) {

		return function Triple$find( selector ) {
			var i, len, node, queryResult;
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				node = this.nodes[ i ];
				if ( node.nodeType !== 1 ) {
					continue;
				}
				if ( matches( node, selector ) ) {
					return node;
				}
				if ( queryResult = node.querySelector( selector ) ) {
					return queryResult;
				}
			}
			return null;
		};
	}( matches );

	/* virtualdom/items/Triple/prototype/findAll.js */
	var virtualdom_items_Triple$findAll = function( matches ) {

		return function Triple$findAll( selector, queryResult ) {
			var i, len, node, queryAllResult, numNodes, j;
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				node = this.nodes[ i ];
				if ( node.nodeType !== 1 ) {
					continue;
				}
				if ( matches( node, selector ) ) {
					queryResult.push( node );
				}
				if ( queryAllResult = node.querySelectorAll( selector ) ) {
					numNodes = queryAllResult.length;
					for ( j = 0; j < numNodes; j += 1 ) {
						queryResult.push( queryAllResult[ j ] );
					}
				}
			}
		};
	}( matches );

	/* virtualdom/items/Triple/prototype/firstNode.js */
	var virtualdom_items_Triple$firstNode = function Triple$firstNode() {
		if ( this.rendered && this.nodes[ 0 ] ) {
			return this.nodes[ 0 ];
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Triple/helpers/insertHtml.js */
	var insertHtml = function( namespaces, createElement ) {

		var __export;
		var elementCache = {},
			ieBug, ieBlacklist;
		try {
			createElement( 'table' ).innerHTML = 'foo';
		} catch ( err ) {
			ieBug = true;
			ieBlacklist = {
				TABLE: [
					'<table class="x">',
					'</table>'
				],
				THEAD: [
					'<table><thead class="x">',
					'</thead></table>'
				],
				TBODY: [
					'<table><tbody class="x">',
					'</tbody></table>'
				],
				TR: [
					'<table><tr class="x">',
					'</tr></table>'
				],
				SELECT: [
					'<select class="x">',
					'</select>'
				]
			};
		}
		__export = function( html, node, docFrag ) {
			var container, nodes = [],
				wrapper, selectedOption, child, i;
			// render 0 and false
			if ( html != null && html !== '' ) {
				if ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {
					container = element( 'DIV' );
					container.innerHTML = wrapper[ 0 ] + html + wrapper[ 1 ];
					container = container.querySelector( '.x' );
					if ( container.tagName === 'SELECT' ) {
						selectedOption = container.options[ container.selectedIndex ];
					}
				} else if ( node.namespaceURI === namespaces.svg ) {
					container = element( 'DIV' );
					container.innerHTML = '<svg class="x">' + html + '</svg>';
					container = container.querySelector( '.x' );
				} else {
					container = element( node.tagName );
					container.innerHTML = html;
					if ( container.tagName === 'SELECT' ) {
						selectedOption = container.options[ container.selectedIndex ];
					}
				}
				while ( child = container.firstChild ) {
					nodes.push( child );
					docFrag.appendChild( child );
				}
				// This is really annoying. Extracting <option> nodes from the
				// temporary container <select> causes the remaining ones to
				// become selected. So now we have to deselect them. IE8, you
				// amaze me. You really do
				// ...and now Chrome too
				if ( node.tagName === 'SELECT' ) {
					i = nodes.length;
					while ( i-- ) {
						if ( nodes[ i ] !== selectedOption ) {
							nodes[ i ].selected = false;
						}
					}
				}
			}
			return nodes;
		};

		function element( tagName ) {
			return elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );
		}
		return __export;
	}( namespaces, createElement );

	/* utils/toArray.js */
	var toArray = function toArray( arrayLike ) {
		var array = [],
			i = arrayLike.length;
		while ( i-- ) {
			array[ i ] = arrayLike[ i ];
		}
		return array;
	};

	/* virtualdom/items/Triple/helpers/updateSelect.js */
	var updateSelect = function( toArray ) {

		var __export;
		__export = function updateSelect( parentElement ) {
			var selectedOptions, option, value;
			if ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {
				return;
			}
			selectedOptions = toArray( parentElement.node.options ).filter( isSelected );
			// If one of them had a `selected` attribute, we need to sync
			// the model to the view
			if ( parentElement.getAttribute( 'multiple' ) ) {
				value = selectedOptions.map( function( o ) {
					return o.value;
				} );
			} else if ( option = selectedOptions[ 0 ] ) {
				value = option.value;
			}
			if ( value !== undefined ) {
				parentElement.binding.setValue( value );
			}
			parentElement.bubble();
		};

		function isSelected( option ) {
			return option.selected;
		}
		return __export;
	}( toArray );

	/* virtualdom/items/Triple/prototype/render.js */
	var virtualdom_items_Triple$render = function( insertHtml, updateSelect ) {

		return function Triple$render() {
			if ( this.rendered ) {
				throw new Error( 'Attempted to render an item that was already rendered' );
			}
			this.docFrag = document.createDocumentFragment();
			this.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );
			// Special case - we're inserting the contents of a <select>
			updateSelect( this.pElement );
			this.rendered = true;
			return this.docFrag;
		};
	}( insertHtml, updateSelect );

	/* virtualdom/items/Triple/prototype/setValue.js */
	var virtualdom_items_Triple$setValue = function( runloop ) {

		return function Triple$setValue( value ) {
			var wrapper;
			// TODO is there a better way to approach this?
			if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
				value = wrapper.get();
			}
			if ( value !== this.value ) {
				this.value = value;
				this.parentFragment.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Triple/prototype/toString.js */
	var virtualdom_items_Triple$toString = function( decodeCharacterReferences ) {

		return function Triple$toString() {
			return this.value != undefined ? decodeCharacterReferences( '' + this.value ) : '';
		};
	}( decodeCharacterReferences );

	/* virtualdom/items/Triple/prototype/unrender.js */
	var virtualdom_items_Triple$unrender = function( detachNode ) {

		return function Triple$unrender( shouldDestroy ) {
			if ( this.rendered && shouldDestroy ) {
				this.nodes.forEach( detachNode );
				this.rendered = false;
			}
		};
	}( detachNode );

	/* virtualdom/items/Triple/prototype/update.js */
	var virtualdom_items_Triple$update = function( insertHtml, updateSelect ) {

		return function Triple$update() {
			var node, parentNode;
			if ( !this.rendered ) {
				return;
			}
			// Remove existing nodes
			while ( this.nodes && this.nodes.length ) {
				node = this.nodes.pop();
				node.parentNode.removeChild( node );
			}
			// Insert new nodes
			parentNode = this.parentFragment.getNode();
			this.nodes = insertHtml( this.value, parentNode, this.docFrag );
			parentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );
			// Special case - we're inserting the contents of a <select>
			updateSelect( this.pElement );
		};
	}( insertHtml, updateSelect );

	/* virtualdom/items/Triple/_Triple.js */
	var Triple = function( types, Mustache, detach, find, findAll, firstNode, render, setValue, toString, unrender, update, unbind ) {

		var Triple = function( options ) {
			this.type = types.TRIPLE;
			Mustache.init( this, options );
		};
		Triple.prototype = {
			detach: detach,
			find: find,
			findAll: findAll,
			firstNode: firstNode,
			getValue: Mustache.getValue,
			rebind: Mustache.rebind,
			render: render,
			resolve: Mustache.resolve,
			setValue: setValue,
			toString: toString,
			unbind: unbind,
			unrender: unrender,
			update: update
		};
		return Triple;
	}( types, Mustache, virtualdom_items_Triple$detach, virtualdom_items_Triple$find, virtualdom_items_Triple$findAll, virtualdom_items_Triple$firstNode, virtualdom_items_Triple$render, virtualdom_items_Triple$setValue, virtualdom_items_Triple$toString, virtualdom_items_Triple$unrender, virtualdom_items_Triple$update, unbind );

	/* virtualdom/items/Element/prototype/bubble.js */
	var virtualdom_items_Element$bubble = function() {
		this.parentFragment.bubble();
	};

	/* virtualdom/items/Element/prototype/detach.js */
	var virtualdom_items_Element$detach = function Element$detach() {
		var node = this.node,
			parentNode;
		if ( node ) {
			// need to check for parent node - DOM may have been altered
			// by something other than Ractive! e.g. jQuery UI...
			if ( parentNode = node.parentNode ) {
				parentNode.removeChild( node );
			}
			return node;
		}
	};

	/* virtualdom/items/Element/prototype/find.js */
	var virtualdom_items_Element$find = function( matches ) {

		return function( selector ) {
			if ( matches( this.node, selector ) ) {
				return this.node;
			}
			if ( this.fragment && this.fragment.find ) {
				return this.fragment.find( selector );
			}
		};
	}( matches );

	/* virtualdom/items/Element/prototype/findAll.js */
	var virtualdom_items_Element$findAll = function( selector, query ) {
		// Add this node to the query, if applicable, and register the
		// query on this element
		if ( query._test( this, true ) && query.live ) {
			( this.liveQueries || ( this.liveQueries = [] ) ).push( query );
		}
		if ( this.fragment ) {
			this.fragment.findAll( selector, query );
		}
	};

	/* virtualdom/items/Element/prototype/findAllComponents.js */
	var virtualdom_items_Element$findAllComponents = function( selector, query ) {
		if ( this.fragment ) {
			this.fragment.findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Element/prototype/findComponent.js */
	var virtualdom_items_Element$findComponent = function( selector ) {
		if ( this.fragment ) {
			return this.fragment.findComponent( selector );
		}
	};

	/* virtualdom/items/Element/prototype/findNextNode.js */
	var virtualdom_items_Element$findNextNode = function Element$findNextNode() {
		return null;
	};

	/* virtualdom/items/Element/prototype/firstNode.js */
	var virtualdom_items_Element$firstNode = function Element$firstNode() {
		return this.node;
	};

	/* virtualdom/items/Element/prototype/getAttribute.js */
	var virtualdom_items_Element$getAttribute = function Element$getAttribute( name ) {
		if ( !this.attributes || !this.attributes[ name ] ) {
			return;
		}
		return this.attributes[ name ].value;
	};

	/* virtualdom/items/Element/shared/enforceCase.js */
	var enforceCase = function() {

		var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;
		svgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );
		svgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );
		createMap = function( items ) {
			var map = {},
				i = items.length;
			while ( i-- ) {
				map[ items[ i ].toLowerCase() ] = items[ i ];
			}
			return map;
		};
		map = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );
		return function( elementName ) {
			var lowerCaseElementName = elementName.toLowerCase();
			return map[ lowerCaseElementName ] || lowerCaseElementName;
		};
	}();

	/* virtualdom/items/Element/Attribute/prototype/bubble.js */
	var virtualdom_items_Element_Attribute$bubble = function( runloop, isEqual ) {

		return function Attribute$bubble() {
			var value = this.fragment.getValue();
			// TODO this can register the attribute multiple times (see render test
			// 'Attribute with nested mustaches')
			if ( !isEqual( value, this.value ) ) {
				// Need to clear old id from ractive.nodes
				if ( this.name === 'id' && this.value ) {
					delete this.root.nodes[ this.value ];
				}
				this.value = value;
				if ( this.name === 'value' && this.node ) {
					// We need to store the value on the DOM like this so we
					// can retrieve it later without it being coerced to a string
					this.node._ractive.value = value;
				}
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
		};
	}( runloop, isEqual );

	/* config/booleanAttributes.js */
	var booleanAttributes = function() {

		// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316
		var booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|draggable|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
		return booleanAttributes;
	}();

	/* virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js */
	var determineNameAndNamespace = function( namespaces, enforceCase ) {

		return function( attribute, name ) {
			var colonIndex, namespacePrefix;
			// are we dealing with a namespaced attribute, e.g. xlink:href?
			colonIndex = name.indexOf( ':' );
			if ( colonIndex !== -1 ) {
				// looks like we are, yes...
				namespacePrefix = name.substr( 0, colonIndex );
				// ...unless it's a namespace *declaration*, which we ignore (on the assumption
				// that only valid namespaces will be used)
				if ( namespacePrefix !== 'xmlns' ) {
					name = name.substring( colonIndex + 1 );
					attribute.name = enforceCase( name );
					attribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];
					attribute.namespacePrefix = namespacePrefix;
					if ( !attribute.namespace ) {
						throw 'Unknown namespace ("' + namespacePrefix + '")';
					}
					return;
				}
			}
			// SVG attribute names are case sensitive
			attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name;
		};
	}( namespaces, enforceCase );

	/* virtualdom/items/Element/Attribute/helpers/getInterpolator.js */
	var getInterpolator = function( types ) {

		return function getInterpolator( attribute ) {
			var items = attribute.fragment.items;
			if ( items.length !== 1 ) {
				return;
			}
			if ( items[ 0 ].type === types.INTERPOLATOR ) {
				return items[ 0 ];
			}
		};
	}( types );

	/* virtualdom/items/Element/Attribute/helpers/determinePropertyName.js */
	var determinePropertyName = function( namespaces, booleanAttributes ) {

		var propertyNames = {
			'accept-charset': 'acceptCharset',
			accesskey: 'accessKey',
			bgcolor: 'bgColor',
			'class': 'className',
			codebase: 'codeBase',
			colspan: 'colSpan',
			contenteditable: 'contentEditable',
			datetime: 'dateTime',
			dirname: 'dirName',
			'for': 'htmlFor',
			'http-equiv': 'httpEquiv',
			ismap: 'isMap',
			maxlength: 'maxLength',
			novalidate: 'noValidate',
			pubdate: 'pubDate',
			readonly: 'readOnly',
			rowspan: 'rowSpan',
			tabindex: 'tabIndex',
			usemap: 'useMap'
		};
		return function( attribute, options ) {
			var propertyName;
			if ( attribute.pNode && !attribute.namespace && ( !options.pNode.namespaceURI || options.pNode.namespaceURI === namespaces.html ) ) {
				propertyName = propertyNames[ attribute.name ] || attribute.name;
				if ( options.pNode[ propertyName ] !== undefined ) {
					attribute.propertyName = propertyName;
				}
				// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
				// node.selected = true rather than node.setAttribute( 'selected', '' )
				if ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {
					attribute.useProperty = true;
				}
			}
		};
	}( namespaces, booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/init.js */
	var virtualdom_items_Element_Attribute$init = function( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Attribute$init( options ) {
			this.type = types.ATTRIBUTE;
			this.element = options.element;
			this.root = options.root;
			determineNameAndNamespace( this, options.name );
			// if it's an empty attribute, or just a straight key-value pair, with no
			// mustache shenanigans, set the attribute accordingly and go home
			if ( !options.value || typeof options.value === 'string' ) {
				this.value = booleanAttributes.test( this.name ) ? true : options.value || '';
				return;
			}
			// otherwise we need to do some work
			// share parentFragment with parent element
			this.parentFragment = this.element.parentFragment;
			this.fragment = new Fragment( {
				template: options.value,
				root: this.root,
				owner: this
			} );
			this.value = this.fragment.getValue();
			// Store a reference to this attribute's interpolator, if its fragment
			// takes the form `{{foo}}`. This is necessary for two-way binding and
			// for correctly rendering HTML later
			this.interpolator = getInterpolator( this );
			this.isBindable = !!this.interpolator && !this.interpolator.isStatic;
			// can we establish this attribute's property name equivalent?
			determinePropertyName( this, options );
			// mark as ready
			this.ready = true;
		};
	}( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular );

	/* virtualdom/items/Element/Attribute/prototype/rebind.js */
	var virtualdom_items_Element_Attribute$rebind = function Attribute$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		if ( this.fragment ) {
			this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/render.js */
	var virtualdom_items_Element_Attribute$render = function( namespaces, booleanAttributes ) {

		var propertyNames = {
			'accept-charset': 'acceptCharset',
			'accesskey': 'accessKey',
			'bgcolor': 'bgColor',
			'class': 'className',
			'codebase': 'codeBase',
			'colspan': 'colSpan',
			'contenteditable': 'contentEditable',
			'datetime': 'dateTime',
			'dirname': 'dirName',
			'for': 'htmlFor',
			'http-equiv': 'httpEquiv',
			'ismap': 'isMap',
			'maxlength': 'maxLength',
			'novalidate': 'noValidate',
			'pubdate': 'pubDate',
			'readonly': 'readOnly',
			'rowspan': 'rowSpan',
			'tabindex': 'tabIndex',
			'usemap': 'useMap'
		};
		return function Attribute$render( node ) {
			var propertyName;
			this.node = node;
			// should we use direct property access, or setAttribute?
			if ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {
				propertyName = propertyNames[ this.name ] || this.name;
				if ( node[ propertyName ] !== undefined ) {
					this.propertyName = propertyName;
				}
				// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
				// node.selected = true rather than node.setAttribute( 'selected', '' )
				if ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {
					this.useProperty = true;
				}
				if ( propertyName === 'value' ) {
					this.useProperty = true;
					node._ractive.value = this.value;
				}
			}
			this.rendered = true;
			this.update();
		};
	}( namespaces, booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/toString.js */
	var virtualdom_items_Element_Attribute$toString = function( booleanAttributes ) {

		var __export;
		__export = function Attribute$toString() {
			var name = ( fragment = this ).name,
				namespacePrefix = fragment.namespacePrefix,
				value = fragment.value,
				interpolator = fragment.interpolator,
				fragment = fragment.fragment;
			// Special case - select and textarea values (should not be stringified)
			if ( name === 'value' && ( this.element.name === 'select' || this.element.name === 'textarea' ) ) {
				return;
			}
			// Special case - content editable
			if ( name === 'value' && this.element.getAttribute( 'contenteditable' ) !== undefined ) {
				return;
			}
			// Special case - radio names
			if ( name === 'name' && this.element.name === 'input' && interpolator ) {
				return 'name={{' + ( interpolator.keypath || interpolator.ref ) + '}}';
			}
			// Boolean attributes
			if ( booleanAttributes.test( name ) ) {
				return value ? name : '';
			}
			if ( fragment ) {
				value = fragment.toString();
			}
			if ( namespacePrefix ) {
				name = namespacePrefix + ':' + name;
			}
			return value ? name + '="' + escape( value ) + '"' : name;
		};

		function escape( value ) {
			return value.replace( /&/g, '&amp;' ).replace( /"/g, '&quot;' ).replace( /'/g, '&#39;' );
		}
		return __export;
	}( booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/unbind.js */
	var virtualdom_items_Element_Attribute$unbind = function Attribute$unbind() {
		// ignore non-dynamic attributes
		if ( this.fragment ) {
			this.fragment.unbind();
		}
		if ( this.name === 'id' ) {
			delete this.root.nodes[ this.value ];
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js */
	var virtualdom_items_Element_Attribute$update_updateSelectValue = function Attribute$updateSelect() {
		var value = this.value,
			options, option, optionValue, i;
		if ( !this.locked ) {
			this.node._ractive.value = value;
			options = this.node.options;
			i = options.length;
			while ( i-- ) {
				option = options[ i ];
				optionValue = option._ractive ? option._ractive.value : option.value;
				// options inserted via a triple don't have _ractive
				if ( optionValue == value ) {
					// double equals as we may be comparing numbers with strings
					option.selected = true;
					break;
				}
			}
		}
	};

	/* utils/arrayContains.js */
	var arrayContains = function arrayContains( array, value ) {
		for ( var i = 0, c = array.length; i < c; i++ ) {
			if ( array[ i ] == value ) {
				return true;
			}
		}
		return false;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js */
	var virtualdom_items_Element_Attribute$update_updateMultipleSelectValue = function( arrayContains, isArray ) {

		return function Attribute$updateMultipleSelect() {
			var value = this.value,
				options, i, option, optionValue;
			if ( !isArray( value ) ) {
				value = [ value ];
			}
			options = this.node.options;
			i = options.length;
			while ( i-- ) {
				option = options[ i ];
				optionValue = option._ractive ? option._ractive.value : option.value;
				// options inserted via a triple don't have _ractive
				option.selected = arrayContains( value, optionValue );
			}
		};
	}( arrayContains, isArray );

	/* virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js */
	var virtualdom_items_Element_Attribute$update_updateRadioName = function Attribute$updateRadioName() {
		var node = ( value = this ).node,
			value = value.value;
		node.checked = value == node._ractive.value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js */
	var virtualdom_items_Element_Attribute$update_updateRadioValue = function( runloop ) {

		return function Attribute$updateRadioValue() {
			var wasChecked, node = this.node,
				binding, bindings, i;
			wasChecked = node.checked;
			node.value = this.element.getAttribute( 'value' );
			node.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );
			// This is a special case - if the input was checked, and the value
			// changed so that it's no longer checked, the twoway binding is
			// most likely out of date. To fix it we have to jump through some
			// hoops... this is a little kludgy but it works
			if ( wasChecked && !node.checked && this.element.binding ) {
				bindings = this.element.binding.siblings;
				if ( i = bindings.length ) {
					while ( i-- ) {
						binding = bindings[ i ];
						if ( !binding.element.node ) {
							// this is the initial render, siblings are still rendering!
							// we'll come back later...
							return;
						}
						if ( binding.element.node.checked ) {
							runloop.addViewmodel( binding.root.viewmodel );
							return binding.handleChange();
						}
					}
					runloop.addViewmodel( binding.root.viewmodel );
					this.root.viewmodel.set( binding.keypath, undefined );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js */
	var virtualdom_items_Element_Attribute$update_updateCheckboxName = function( isArray ) {

		return function Attribute$updateCheckboxName() {
			var element = ( value = this ).element,
				node = value.node,
				value = value.value,
				valueAttribute, i;
			valueAttribute = element.getAttribute( 'value' );
			if ( !isArray( value ) ) {
				node.checked = value == valueAttribute;
			} else {
				i = value.length;
				while ( i-- ) {
					if ( valueAttribute == value[ i ] ) {
						node.checked = true;
						return;
					}
				}
				node.checked = false;
			}
		};
	}( isArray );

	/* virtualdom/items/Element/Attribute/prototype/update/updateClassName.js */
	var virtualdom_items_Element_Attribute$update_updateClassName = function Attribute$updateClassName() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		node.className = value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js */
	var virtualdom_items_Element_Attribute$update_updateIdAttribute = function Attribute$updateIdAttribute() {
		var node = ( value = this ).node,
			value = value.value;
		this.root.nodes[ value ] = node;
		node.id = value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js */
	var virtualdom_items_Element_Attribute$update_updateIEStyleAttribute = function Attribute$updateIEStyleAttribute() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		node.style.setAttribute( 'cssText', value );
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js */
	var virtualdom_items_Element_Attribute$update_updateContentEditableValue = function Attribute$updateContentEditableValue() {
		var value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		if ( !this.locked ) {
			this.node.innerHTML = value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateValue.js */
	var virtualdom_items_Element_Attribute$update_updateValue = function Attribute$updateValue() {
		var node = ( value = this ).node,
			value = value.value;
		// store actual value, so it doesn't get coerced to a string
		node._ractive.value = value;
		// with two-way binding, only update if the change wasn't initiated by the user
		// otherwise the cursor will often be sent to the wrong place
		if ( !this.locked ) {
			node.value = value == undefined ? '' : value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js */
	var virtualdom_items_Element_Attribute$update_updateBoolean = function Attribute$updateBooleanAttribute() {
		// with two-way binding, only update if the change wasn't initiated by the user
		// otherwise the cursor will often be sent to the wrong place
		if ( !this.locked ) {
			this.node[ this.propertyName ] = this.value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js */
	var virtualdom_items_Element_Attribute$update_updateEverythingElse = function( booleanAttributes ) {

		return function Attribute$updateEverythingElse() {
			var node = ( fragment = this ).node,
				namespace = fragment.namespace,
				name = fragment.name,
				value = fragment.value,
				fragment = fragment.fragment;
			if ( namespace ) {
				node.setAttributeNS( namespace, name, ( fragment || value ).toString() );
			} else if ( !booleanAttributes.test( name ) ) {
				node.setAttribute( name, ( fragment || value ).toString() );
			} else {
				if ( value ) {
					node.setAttribute( name, '' );
				} else {
					node.removeAttribute( name );
				}
			}
		};
	}( booleanAttributes );

	/* virtualdom/items/Element/Attribute/prototype/update.js */
	var virtualdom_items_Element_Attribute$update = function( namespaces, noop, updateSelectValue, updateMultipleSelectValue, updateRadioName, updateRadioValue, updateCheckboxName, updateClassName, updateIdAttribute, updateIEStyleAttribute, updateContentEditableValue, updateValue, updateBoolean, updateEverythingElse ) {

		return function Attribute$update() {
			var name = ( node = this ).name,
				element = node.element,
				node = node.node,
				type, updateMethod;
			if ( name === 'id' ) {
				updateMethod = updateIdAttribute;
			} else if ( name === 'value' ) {
				// special case - selects
				if ( element.name === 'select' && name === 'value' ) {
					updateMethod = element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;
				} else if ( element.name === 'textarea' ) {
					updateMethod = updateValue;
				} else if ( element.getAttribute( 'contenteditable' ) != null ) {
					updateMethod = updateContentEditableValue;
				} else if ( element.name === 'input' ) {
					type = element.getAttribute( 'type' );
					// type='file' value='{{fileList}}'>
					if ( type === 'file' ) {
						updateMethod = noop;
					} else if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {
						updateMethod = updateRadioValue;
					} else {
						updateMethod = updateValue;
					}
				}
			} else if ( this.twoway && name === 'name' ) {
				if ( node.type === 'radio' ) {
					updateMethod = updateRadioName;
				} else if ( node.type === 'checkbox' ) {
					updateMethod = updateCheckboxName;
				}
			} else if ( name === 'style' && node.style.setAttribute ) {
				updateMethod = updateIEStyleAttribute;
			} else if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {
				updateMethod = updateClassName;
			} else if ( this.useProperty ) {
				updateMethod = updateBoolean;
			}
			if ( !updateMethod ) {
				updateMethod = updateEverythingElse;
			}
			this.update = updateMethod;
			this.update();
		};
	}( namespaces, noop, virtualdom_items_Element_Attribute$update_updateSelectValue, virtualdom_items_Element_Attribute$update_updateMultipleSelectValue, virtualdom_items_Element_Attribute$update_updateRadioName, virtualdom_items_Element_Attribute$update_updateRadioValue, virtualdom_items_Element_Attribute$update_updateCheckboxName, virtualdom_items_Element_Attribute$update_updateClassName, virtualdom_items_Element_Attribute$update_updateIdAttribute, virtualdom_items_Element_Attribute$update_updateIEStyleAttribute, virtualdom_items_Element_Attribute$update_updateContentEditableValue, virtualdom_items_Element_Attribute$update_updateValue, virtualdom_items_Element_Attribute$update_updateBoolean, virtualdom_items_Element_Attribute$update_updateEverythingElse );

	/* virtualdom/items/Element/Attribute/_Attribute.js */
	var Attribute = function( bubble, init, rebind, render, toString, unbind, update ) {

		var Attribute = function( options ) {
			this.init( options );
		};
		Attribute.prototype = {
			bubble: bubble,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			update: update
		};
		return Attribute;
	}( virtualdom_items_Element_Attribute$bubble, virtualdom_items_Element_Attribute$init, virtualdom_items_Element_Attribute$rebind, virtualdom_items_Element_Attribute$render, virtualdom_items_Element_Attribute$toString, virtualdom_items_Element_Attribute$unbind, virtualdom_items_Element_Attribute$update );

	/* virtualdom/items/Element/prototype/init/createAttributes.js */
	var virtualdom_items_Element$init_createAttributes = function( Attribute ) {

		return function( element, attributes ) {
			var name, attribute, result = [];
			for ( name in attributes ) {
				if ( attributes.hasOwnProperty( name ) ) {
					attribute = new Attribute( {
						element: element,
						name: name,
						value: attributes[ name ],
						root: element.root
					} );
					result.push( result[ name ] = attribute );
				}
			}
			return result;
		};
	}( Attribute );

	/* virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js */
	var ConditionalAttribute = function( circular, namespaces, createElement, toArray ) {

		var __export;
		var Fragment, div;
		if ( typeof document !== 'undefined' ) {
			div = createElement( 'div' );
		}
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		var ConditionalAttribute = function( element, template ) {
			this.element = element;
			this.root = element.root;
			this.parentFragment = element.parentFragment;
			this.attributes = [];
			this.fragment = new Fragment( {
				root: element.root,
				owner: this,
				template: [ template ]
			} );
		};
		ConditionalAttribute.prototype = {
			bubble: function() {
				if ( this.node ) {
					this.update();
				}
				this.element.bubble();
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			render: function( node ) {
				this.node = node;
				this.isSvg = node.namespaceURI === namespaces.svg;
				this.update();
			},
			unbind: function() {
				this.fragment.unbind();
			},
			update: function() {
				var this$0 = this;
				var str, attrs;
				str = this.fragment.toString();
				attrs = parseAttributes( str, this.isSvg );
				// any attributes that previously existed but no longer do
				// must be removed
				this.attributes.filter( function( a ) {
					return notIn( attrs, a );
				} ).forEach( function( a ) {
					this$0.node.removeAttribute( a.name );
				} );
				attrs.forEach( function( a ) {
					this$0.node.setAttribute( a.name, a.value );
				} );
				this.attributes = attrs;
			},
			toString: function() {
				return this.fragment.toString();
			}
		};
		__export = ConditionalAttribute;

		function parseAttributes( str, isSvg ) {
			var tag = isSvg ? 'svg' : 'div';
			div.innerHTML = '<' + tag + ' ' + str + '></' + tag + '>';
			return toArray( div.childNodes[ 0 ].attributes );
		}

		function notIn( haystack, needle ) {
			var i = haystack.length;
			while ( i-- ) {
				if ( haystack[ i ].name === needle.name ) {
					return false;
				}
			}
			return true;
		}
		return __export;
	}( circular, namespaces, createElement, toArray );

	/* virtualdom/items/Element/prototype/init/createConditionalAttributes.js */
	var virtualdom_items_Element$init_createConditionalAttributes = function( ConditionalAttribute ) {

		return function( element, attributes ) {
			if ( !attributes ) {
				return [];
			}
			return attributes.map( function( a ) {
				return new ConditionalAttribute( element, a );
			} );
		};
	}( ConditionalAttribute );

	/* utils/extend.js */
	var extend = function( target ) {
		var SLICE$0 = Array.prototype.slice;
		var sources = SLICE$0.call( arguments, 1 );
		var prop, source;
		while ( source = sources.shift() ) {
			for ( prop in source ) {
				if ( source.hasOwnProperty( prop ) ) {
					target[ prop ] = source[ prop ];
				}
			}
		}
		return target;
	};

	/* virtualdom/items/Element/Binding/Binding.js */
	var Binding = function( runloop, warn, create, extend, removeFromArray ) {

		var Binding = function( element ) {
			var interpolator, keypath, value;
			this.element = element;
			this.root = element.root;
			this.attribute = element.attributes[ this.name || 'value' ];
			interpolator = this.attribute.interpolator;
			interpolator.twowayBinding = this;
			if ( interpolator.keypath && interpolator.keypath.substr( 0, 2 ) === '${' ) {
				warn( 'Two-way binding does not work with expressions (`' + interpolator.keypath.slice( 2, -1 ) + '`)' );
				return false;
			}
			// A mustache may be *ambiguous*. Let's say we were given
			// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`
			// *wasn't* `undefined`, the keypath would be `foo.bar`.
			// Then, any user input would result in `foo.bar` being updated.
			//
			// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be
			// left with an unresolved partial keypath - so we are forced to make an
			// assumption. That assumption is that the input in question should
			// be forced to resolve to `bar`, and any user input would affect `bar`
			// and not `foo.bar`.
			//
			// Did that make any sense? No? Oh. Sorry. Well the moral of the story is
			// be explicit when using two-way data-binding about what keypath you're
			// updating. Using it in lists is probably a recipe for confusion...
			if ( !interpolator.keypath ) {
				interpolator.resolver.forceResolution();
			}
			this.keypath = keypath = interpolator.keypath;
			// initialise value, if it's undefined
			if ( this.root.viewmodel.get( keypath ) === undefined && this.getInitialValue ) {
				value = this.getInitialValue();
				if ( value !== undefined ) {
					this.root.viewmodel.set( keypath, value );
				}
			}
		};
		Binding.prototype = {
			handleChange: function() {
				var this$0 = this;
				runloop.start( this.root );
				this.attribute.locked = true;
				this.root.viewmodel.set( this.keypath, this.getValue() );
				runloop.scheduleTask( function() {
					return this$0.attribute.locked = false;
				} );
				runloop.end();
			},
			rebound: function() {
				var bindings, oldKeypath, newKeypath;
				oldKeypath = this.keypath;
				newKeypath = this.attribute.interpolator.keypath;
				// The attribute this binding is linked to has already done the work
				if ( oldKeypath === newKeypath ) {
					return;
				}
				removeFromArray( this.root._twowayBindings[ oldKeypath ], this );
				this.keypath = newKeypath;
				bindings = this.root._twowayBindings[ newKeypath ] || ( this.root._twowayBindings[ newKeypath ] = [] );
				bindings.push( this );
			},
			unbind: function() {}
		};
		Binding.extend = function( properties ) {
			var Parent = this,
				SpecialisedBinding;
			SpecialisedBinding = function( element ) {
				Binding.call( this, element );
				if ( this.init ) {
					this.init();
				}
			};
			SpecialisedBinding.prototype = create( Parent.prototype );
			extend( SpecialisedBinding.prototype, properties );
			SpecialisedBinding.extend = Binding.extend;
			return SpecialisedBinding;
		};
		return Binding;
	}( runloop, warn, create, extend, removeFromArray );

	/* virtualdom/items/Element/Binding/shared/handleDomEvent.js */
	var handleDomEvent = function handleChange() {
		this._ractive.binding.handleChange();
	};

	/* virtualdom/items/Element/Binding/ContentEditableBinding.js */
	var ContentEditableBinding = function( Binding, handleDomEvent ) {

		var ContentEditableBinding = Binding.extend( {
			getInitialValue: function() {
				return this.element.fragment ? this.element.fragment.toString() : '';
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( !this.root.lazy ) {
					node.addEventListener( 'input', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'keyup', handleDomEvent, false );
					}
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'input', handleDomEvent, false );
				node.removeEventListener( 'keyup', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.innerHTML;
			}
		} );
		return ContentEditableBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/shared/getSiblings.js */
	var getSiblings = function() {

		var sets = {};
		return function getSiblings( id, group, keypath ) {
			var hash = id + group + keypath;
			return sets[ hash ] || ( sets[ hash ] = [] );
		};
	}();

	/* virtualdom/items/Element/Binding/RadioBinding.js */
	var RadioBinding = function( runloop, removeFromArray, Binding, getSiblings, handleDomEvent ) {

		var RadioBinding = Binding.extend( {
			name: 'checked',
			init: function() {
				this.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );
				this.siblings.push( this );
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			handleChange: function() {
				runloop.start( this.root );
				this.siblings.forEach( function( binding ) {
					binding.root.viewmodel.set( binding.keypath, binding.getValue() );
				} );
				runloop.end();
			},
			getValue: function() {
				return this.element.node.checked;
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			}
		} );
		return RadioBinding;
	}( runloop, removeFromArray, Binding, getSiblings, handleDomEvent );

	/* virtualdom/items/Element/Binding/RadioNameBinding.js */
	var RadioNameBinding = function( removeFromArray, Binding, handleDomEvent, getSiblings ) {

		var RadioNameBinding = Binding.extend( {
			name: 'name',
			init: function() {
				this.siblings = getSiblings( this.root._guid, 'radioname', this.keypath );
				this.siblings.push( this );
				this.radioName = true;
				// so that ractive.updateModel() knows what to do with this
				this.attribute.twoway = true;
			},
			getInitialValue: function() {
				if ( this.element.getAttribute( 'checked' ) ) {
					return this.element.getAttribute( 'value' );
				}
			},
			render: function() {
				var node = this.element.node;
				node.name = '{{' + this.keypath + '}}';
				node.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			getValue: function() {
				var node = this.element.node;
				return node._ractive ? node._ractive.value : node.value;
			},
			handleChange: function() {
				// If this <input> is the one that's checked, then the value of its
				// `name` keypath gets set to its value
				if ( this.element.node.checked ) {
					Binding.prototype.handleChange.call( this );
				}
			},
			rebound: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var node;
				Binding.prototype.rebound.call( this, indexRef, newIndex, oldKeypath, newKeypath );
				if ( node = this.element.node ) {
					node.name = '{{' + this.keypath + '}}';
				}
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			}
		} );
		return RadioNameBinding;
	}( removeFromArray, Binding, handleDomEvent, getSiblings );

	/* virtualdom/items/Element/Binding/CheckboxNameBinding.js */
	var CheckboxNameBinding = function( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent ) {

		var CheckboxNameBinding = Binding.extend( {
			name: 'name',
			getInitialValue: function() {
				// This only gets called once per group (of inputs that
				// share a name), because it only gets called if there
				// isn't an initial value. By the same token, we can make
				// a note of that fact that there was no initial value,
				// and populate it using any `checked` attributes that
				// exist (which users should avoid, but which we should
				// support anyway to avoid breaking expectations)
				this.noInitialValue = true;
				return [];
			},
			init: function() {
				var existingValue, bindingValue;
				this.checkboxName = true;
				// so that ractive.updateModel() knows what to do with this
				this.attribute.twoway = true;
				// we set this property so that the attribute gets the correct update method
				// Each input has a reference to an array containing it and its
				// siblings, as two-way binding depends on being able to ascertain
				// the status of all inputs within the group
				this.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath );
				this.siblings.push( this );
				if ( this.noInitialValue ) {
					this.siblings.noInitialValue = true;
				}
				// If no initial value was set, and this input is checked, we
				// update the model
				if ( this.siblings.noInitialValue && this.element.getAttribute( 'checked' ) ) {
					existingValue = this.root.viewmodel.get( this.keypath );
					bindingValue = this.element.getAttribute( 'value' );
					existingValue.push( bindingValue );
				}
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			},
			render: function() {
				var node = this.element.node,
					existingValue, bindingValue;
				existingValue = this.root.viewmodel.get( this.keypath );
				bindingValue = this.element.getAttribute( 'value' );
				if ( isArray( existingValue ) ) {
					this.isChecked = arrayContains( existingValue, bindingValue );
				} else {
					this.isChecked = existingValue == bindingValue;
				}
				node.name = '{{' + this.keypath + '}}';
				node.checked = this.isChecked;
				node.addEventListener( 'change', handleDomEvent, false );
				// in case of IE emergency, bind to click event as well
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			changed: function() {
				var wasChecked = !!this.isChecked;
				this.isChecked = this.element.node.checked;
				return this.isChecked === wasChecked;
			},
			handleChange: function() {
				this.isChecked = this.element.node.checked;
				Binding.prototype.handleChange.call( this );
			},
			getValue: function() {
				return this.siblings.filter( isChecked ).map( getValue );
			}
		} );

		function isChecked( binding ) {
			return binding.isChecked;
		}

		function getValue( binding ) {
			return binding.element.getAttribute( 'value' );
		}
		return CheckboxNameBinding;
	}( isArray, arrayContains, removeFromArray, Binding, getSiblings, handleDomEvent );

	/* virtualdom/items/Element/Binding/CheckboxBinding.js */
	var CheckboxBinding = function( Binding, handleDomEvent ) {

		var CheckboxBinding = Binding.extend( {
			name: 'checked',
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.checked;
			}
		} );
		return CheckboxBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/SelectBinding.js */
	var SelectBinding = function( runloop, Binding, handleDomEvent ) {

		var SelectBinding = Binding.extend( {
			getInitialValue: function() {
				var options = this.element.options,
					len, i, value, optionWasSelected;
				if ( this.element.getAttribute( 'value' ) !== undefined ) {
					return;
				}
				i = len = options.length;
				if ( !len ) {
					return;
				}
				// take the final selected option...
				while ( i-- ) {
					if ( options[ i ].getAttribute( 'selected' ) ) {
						value = options[ i ].getAttribute( 'value' );
						optionWasSelected = true;
						break;
					}
				}
				// or the first non-disabled option, if none are selected
				if ( !optionWasSelected ) {
					while ( ++i < len ) {
						if ( !options[ i ].getAttribute( 'disabled' ) ) {
							value = options[ i ].getAttribute( 'value' );
							break;
						}
					}
				}
				// This is an optimisation (aka hack) that allows us to forgo some
				// other more expensive work
				if ( value !== undefined ) {
					this.element.attributes.value.value = value;
				}
				return value;
			},
			render: function() {
				this.element.node.addEventListener( 'change', handleDomEvent, false );
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			// TODO this method is an anomaly... is it necessary?
			setValue: function( value ) {
				runloop.addViewmodel( this.root.viewmodel );
				this.root.viewmodel.set( this.keypath, value );
			},
			getValue: function() {
				var options, i, len, option, optionValue;
				options = this.element.node.options;
				len = options.length;
				for ( i = 0; i < len; i += 1 ) {
					option = options[ i ];
					if ( options[ i ].selected ) {
						optionValue = option._ractive ? option._ractive.value : option.value;
						return optionValue;
					}
				}
			},
			forceUpdate: function() {
				var this$0 = this;
				var value = this.getValue();
				if ( value !== undefined ) {
					this.attribute.locked = true;
					runloop.addViewmodel( this.root.viewmodel );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					this.root.viewmodel.set( this.keypath, value );
				}
			}
		} );
		return SelectBinding;
	}( runloop, Binding, handleDomEvent );

	/* utils/arrayContentsMatch.js */
	var arrayContentsMatch = function( isArray ) {

		return function( a, b ) {
			var i;
			if ( !isArray( a ) || !isArray( b ) ) {
				return false;
			}
			if ( a.length !== b.length ) {
				return false;
			}
			i = a.length;
			while ( i-- ) {
				if ( a[ i ] !== b[ i ] ) {
					return false;
				}
			}
			return true;
		};
	}( isArray );

	/* virtualdom/items/Element/Binding/MultipleSelectBinding.js */
	var MultipleSelectBinding = function( runloop, arrayContentsMatch, SelectBinding, handleDomEvent ) {

		var MultipleSelectBinding = SelectBinding.extend( {
			getInitialValue: function() {
				return this.element.options.filter( function( option ) {
					return option.getAttribute( 'selected' );
				} ).map( function( option ) {
					return option.getAttribute( 'value' );
				} );
			},
			render: function() {
				var valueFromModel;
				this.element.node.addEventListener( 'change', handleDomEvent, false );
				valueFromModel = this.root.viewmodel.get( this.keypath );
				if ( valueFromModel === undefined ) {
					// get value from DOM, if possible
					this.handleChange();
				}
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			setValue: function() {
				throw new Error( 'TODO not implemented yet' );
			},
			getValue: function() {
				var selectedValues, options, i, len, option, optionValue;
				selectedValues = [];
				options = this.element.node.options;
				len = options.length;
				for ( i = 0; i < len; i += 1 ) {
					option = options[ i ];
					if ( option.selected ) {
						optionValue = option._ractive ? option._ractive.value : option.value;
						selectedValues.push( optionValue );
					}
				}
				return selectedValues;
			},
			handleChange: function() {
				var attribute, previousValue, value;
				attribute = this.attribute;
				previousValue = attribute.value;
				value = this.getValue();
				if ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {
					SelectBinding.prototype.handleChange.call( this );
				}
				return this;
			},
			forceUpdate: function() {
				var this$0 = this;
				var value = this.getValue();
				if ( value !== undefined ) {
					this.attribute.locked = true;
					runloop.addViewmodel( this.root.viewmodel );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					this.root.viewmodel.set( this.keypath, value );
				}
			},
			updateModel: function() {
				if ( this.attribute.value === undefined || !this.attribute.value.length ) {
					this.root.viewmodel.set( this.keypath, this.initialValue );
				}
			}
		} );
		return MultipleSelectBinding;
	}( runloop, arrayContentsMatch, SelectBinding, handleDomEvent );

	/* virtualdom/items/Element/Binding/FileListBinding.js */
	var FileListBinding = function( Binding, handleDomEvent ) {

		var FileListBinding = Binding.extend( {
			render: function() {
				this.element.node.addEventListener( 'change', handleDomEvent, false );
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.files;
			}
		} );
		return FileListBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/GenericBinding.js */
	var GenericBinding = function( Binding, handleDomEvent ) {

		var __export;
		var GenericBinding, getOptions;
		getOptions = {
			evaluateWrapped: true
		};
		GenericBinding = Binding.extend( {
			getInitialValue: function() {
				return '';
			},
			getValue: function() {
				return this.element.node.value;
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( !this.root.lazy ) {
					node.addEventListener( 'input', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'keyup', handleDomEvent, false );
					}
				}
				node.addEventListener( 'blur', handleBlur, false );
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'input', handleDomEvent, false );
				node.removeEventListener( 'keyup', handleDomEvent, false );
				node.removeEventListener( 'blur', handleBlur, false );
			}
		} );
		__export = GenericBinding;

		function handleBlur() {
			var value;
			handleDomEvent.call( this );
			value = this._ractive.root.viewmodel.get( this._ractive.binding.keypath, getOptions );
			this.value = value == undefined ? '' : value;
		}
		return __export;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/NumericBinding.js */
	var NumericBinding = function( GenericBinding ) {

		return GenericBinding.extend( {
			getInitialValue: function() {
				return undefined;
			},
			getValue: function() {
				var value = parseFloat( this.element.node.value );
				return isNaN( value ) ? undefined : value;
			}
		} );
	}( GenericBinding );

	/* virtualdom/items/Element/prototype/init/createTwowayBinding.js */
	var virtualdom_items_Element$init_createTwowayBinding = function( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding ) {

		var __export;
		__export = function createTwowayBinding( element ) {
			var attributes = element.attributes,
				type, Binding, bindName, bindChecked;
			// if this is a late binding, and there's already one, it
			// needs to be torn down
			if ( element.binding ) {
				element.binding.teardown();
				element.binding = null;
			}
			// contenteditable
			if ( // if the contenteditable attribute is true or is bindable and may thus become true
				( element.getAttribute( 'contenteditable' ) || !!attributes.contenteditable && isBindable( attributes.contenteditable ) ) && isBindable( attributes.value ) ) {
				Binding = ContentEditableBinding;
			} else if ( element.name === 'input' ) {
				type = element.getAttribute( 'type' );
				if ( type === 'radio' || type === 'checkbox' ) {
					bindName = isBindable( attributes.name );
					bindChecked = isBindable( attributes.checked );
					// we can either bind the name attribute, or the checked attribute - not both
					if ( bindName && bindChecked ) {
						log.error( {
							message: 'badRadioInputBinding'
						} );
					}
					if ( bindName ) {
						Binding = type === 'radio' ? RadioNameBinding : CheckboxNameBinding;
					} else if ( bindChecked ) {
						Binding = type === 'radio' ? RadioBinding : CheckboxBinding;
					}
				} else if ( type === 'file' && isBindable( attributes.value ) ) {
					Binding = FileListBinding;
				} else if ( isBindable( attributes.value ) ) {
					Binding = type === 'number' || type === 'range' ? NumericBinding : GenericBinding;
				}
			} else if ( element.name === 'select' && isBindable( attributes.value ) ) {
				Binding = element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding;
			} else if ( element.name === 'textarea' && isBindable( attributes.value ) ) {
				Binding = GenericBinding;
			}
			if ( Binding ) {
				return new Binding( element );
			}
		};

		function isBindable( attribute ) {
			return attribute && attribute.isBindable;
		}
		return __export;
	}( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding );

	/* virtualdom/items/Element/EventHandler/prototype/bubble.js */
	var virtualdom_items_Element_EventHandler$bubble = function EventHandler$bubble() {
		var hasAction = this.getAction();
		if ( hasAction && !this.hasListener ) {
			this.listen();
		} else if ( !hasAction && this.hasListener ) {
			this.unrender();
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/fire.js */
	var virtualdom_items_Element_EventHandler$fire = function( fireEvent ) {

		return function EventHandler$fire( event ) {
			fireEvent( this.root, this.getAction(), {
				event: event
			} );
		};
	}( Ractive$shared_fireEvent );

	/* virtualdom/items/Element/EventHandler/prototype/getAction.js */
	var virtualdom_items_Element_EventHandler$getAction = function EventHandler$getAction() {
		return this.action.toString().trim();
	};

	/* virtualdom/items/Element/EventHandler/prototype/init.js */
	var virtualdom_items_Element_EventHandler$init = function( getFunctionFromString, createReferenceResolver, circular, fireEvent, log ) {

		var __export;
		var Fragment, getValueOptions = {
				args: true
			},
			eventPattern = /^event(?:\.(.+))?/;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		__export = function EventHandler$init( element, name, template ) {
			var handler = this,
				action, refs, ractive;
			handler.element = element;
			handler.root = element.root;
			handler.name = name;
			if ( name.indexOf( '*' ) !== -1 ) {
				log.error( {
					debug: this.root.debug,
					message: 'noElementProxyEventWildcards',
					args: {
						element: element.tagName,
						event: name
					}
				} );
				this.invalid = true;
			}
			if ( template.m ) {
				refs = template.a.r;
				// This is a method call
				handler.method = template.m;
				handler.keypaths = [];
				handler.fn = getFunctionFromString( template.a.s, refs.length );
				handler.parentFragment = element.parentFragment;
				ractive = handler.root;
				// Create resolvers for each reference
				handler.refResolvers = refs.map( function( ref, i ) {
					var match;
					// special case - the `event` object
					if ( match = eventPattern.exec( ref ) ) {
						handler.keypaths[ i ] = {
							eventObject: true,
							refinements: match[ 1 ] ? match[ 1 ].split( '.' ) : []
						};
						return null;
					}
					return createReferenceResolver( handler, ref, function( keypath ) {
						handler.resolve( i, keypath );
					} );
				} );
				this.fire = fireMethodCall;
			} else {
				// Get action ('foo' in 'on-click='foo')
				action = template.n || template;
				if ( typeof action !== 'string' ) {
					action = new Fragment( {
						template: action,
						root: this.root,
						owner: this
					} );
				}
				this.action = action;
				// Get parameters
				if ( template.d ) {
					this.dynamicParams = new Fragment( {
						template: template.d,
						root: this.root,
						owner: this.element
					} );
					this.fire = fireEventWithDynamicParams;
				} else if ( template.a ) {
					this.params = template.a;
					this.fire = fireEventWithParams;
				}
			}
		};

		function fireMethodCall( event ) {
			var ractive, values, args;
			ractive = this.root;
			if ( typeof ractive[ this.method ] !== 'function' ) {
				throw new Error( 'Attempted to call a non-existent method ("' + this.method + '")' );
			}
			values = this.keypaths.map( function( keypath ) {
				var value, len, i;
				if ( keypath === undefined ) {
					// not yet resolved
					return undefined;
				}
				// TODO the refinements stuff would be better handled at parse time
				if ( keypath.eventObject ) {
					value = event;
					if ( len = keypath.refinements.length ) {
						for ( i = 0; i < len; i += 1 ) {
							value = value[ keypath.refinements[ i ] ];
						}
					}
				} else {
					value = ractive.viewmodel.get( keypath );
				}
				return value;
			} );
			ractive.event = event;
			args = this.fn.apply( null, values );
			ractive[ this.method ].apply( ractive, args );
			delete ractive.event;
		}

		function fireEventWithParams( event ) {
			fireEvent( this.root, this.getAction(), {
				event: event,
				args: this.params
			} );
		}

		function fireEventWithDynamicParams( event ) {
			var args = this.dynamicParams.getValue( getValueOptions );
			// need to strip [] from ends if a string!
			if ( typeof args === 'string' ) {
				args = args.substr( 1, args.length - 2 );
			}
			fireEvent( this.root, this.getAction(), {
				event: event,
				args: args
			} );
		}
		return __export;
	}( getFunctionFromString, createReferenceResolver, circular, Ractive$shared_fireEvent, log );

	/* virtualdom/items/Element/EventHandler/shared/genericHandler.js */
	var genericHandler = function genericHandler( event ) {
		var storage, handler;
		storage = this._ractive;
		handler = storage.events[ event.type ];
		handler.fire( {
			node: this,
			original: event,
			index: storage.index,
			keypath: storage.keypath,
			context: storage.root.get( storage.keypath )
		} );
	};

	/* virtualdom/items/Element/EventHandler/prototype/listen.js */
	var virtualdom_items_Element_EventHandler$listen = function( config, genericHandler, log ) {

		var __export;
		var customHandlers = {},
			touchEvents = {
				touchstart: true,
				touchmove: true,
				touchend: true,
				touchcancel: true,
				//not w3c, but supported in some browsers
				touchleave: true
			};
		__export = function EventHandler$listen() {
			var definition, name = this.name;
			if ( this.invalid ) {
				return;
			}
			if ( definition = config.registries.events.find( this.root, name ) ) {
				this.custom = definition( this.node, getCustomHandler( name ) );
			} else {
				// Looks like we're dealing with a standard DOM event... but let's check
				if ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) ) {
					// okay to use touch events if this browser doesn't support them
					if ( !touchEvents[ name ] ) {
						log.error( {
							debug: this.root.debug,
							message: 'missingPlugin',
							args: {
								plugin: 'event',
								name: name
							}
						} );
					}
					return;
				}
				this.node.addEventListener( name, genericHandler, false );
			}
			this.hasListener = true;
		};

		function getCustomHandler( name ) {
			if ( !customHandlers[ name ] ) {
				customHandlers[ name ] = function( event ) {
					var storage = event.node._ractive;
					event.index = storage.index;
					event.keypath = storage.keypath;
					event.context = storage.root.get( storage.keypath );
					storage.events[ name ].fire( event );
				};
			}
			return customHandlers[ name ];
		}
		return __export;
	}( config, genericHandler, log );

	/* virtualdom/items/Element/EventHandler/prototype/rebind.js */
	var virtualdom_items_Element_EventHandler$rebind = function EventHandler$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		var fragment;
		if ( this.method ) {
			fragment = this.element.parentFragment;
			this.refResolvers.forEach( rebind );
			return;
		}
		if ( typeof this.action !== 'string' ) {
			rebind( this.action );
		}
		if ( this.dynamicParams ) {
			rebind( this.dynamicParams );
		}

		function rebind( thing ) {
			thing && thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/render.js */
	var virtualdom_items_Element_EventHandler$render = function EventHandler$render() {
		this.node = this.element.node;
		// store this on the node itself, so it can be retrieved by a
		// universal handler
		this.node._ractive.events[ this.name ] = this;
		if ( this.method || this.getAction() ) {
			this.listen();
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/resolve.js */
	var virtualdom_items_Element_EventHandler$resolve = function EventHandler$resolve( index, keypath ) {
		this.keypaths[ index ] = keypath;
	};

	/* virtualdom/items/Element/EventHandler/prototype/unbind.js */
	var virtualdom_items_Element_EventHandler$unbind = function() {

		var __export;
		__export = function EventHandler$unbind() {
			if ( this.method ) {
				this.refResolvers.forEach( unbind );
				return;
			}
			// Tear down dynamic name
			if ( typeof this.action !== 'string' ) {
				this.action.unbind();
			}
			// Tear down dynamic parameters
			if ( this.dynamicParams ) {
				this.dynamicParams.unbind();
			}
		};

		function unbind( x ) {
			x.unbind();
		}
		return __export;
	}();

	/* virtualdom/items/Element/EventHandler/prototype/unrender.js */
	var virtualdom_items_Element_EventHandler$unrender = function( genericHandler ) {

		return function EventHandler$unrender() {
			if ( this.custom ) {
				this.custom.teardown();
			} else {
				this.node.removeEventListener( this.name, genericHandler, false );
			}
			this.hasListener = false;
		};
	}( genericHandler );

	/* virtualdom/items/Element/EventHandler/_EventHandler.js */
	var EventHandler = function( bubble, fire, getAction, init, listen, rebind, render, resolve, unbind, unrender ) {

		var EventHandler = function( element, name, template ) {
			this.init( element, name, template );
		};
		EventHandler.prototype = {
			bubble: bubble,
			fire: fire,
			getAction: getAction,
			init: init,
			listen: listen,
			rebind: rebind,
			render: render,
			resolve: resolve,
			unbind: unbind,
			unrender: unrender
		};
		return EventHandler;
	}( virtualdom_items_Element_EventHandler$bubble, virtualdom_items_Element_EventHandler$fire, virtualdom_items_Element_EventHandler$getAction, virtualdom_items_Element_EventHandler$init, virtualdom_items_Element_EventHandler$listen, virtualdom_items_Element_EventHandler$rebind, virtualdom_items_Element_EventHandler$render, virtualdom_items_Element_EventHandler$resolve, virtualdom_items_Element_EventHandler$unbind, virtualdom_items_Element_EventHandler$unrender );

	/* virtualdom/items/Element/prototype/init/createEventHandlers.js */
	var virtualdom_items_Element$init_createEventHandlers = function( EventHandler ) {

		return function( element, template ) {
			var i, name, names, handler, result = [];
			for ( name in template ) {
				if ( template.hasOwnProperty( name ) ) {
					names = name.split( '-' );
					i = names.length;
					while ( i-- ) {
						handler = new EventHandler( element, names[ i ], template[ name ] );
						result.push( handler );
					}
				}
			}
			return result;
		};
	}( EventHandler );

	/* virtualdom/items/Element/Decorator/_Decorator.js */
	var Decorator = function( log, circular, config ) {

		var Fragment, getValueOptions, Decorator;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		getValueOptions = {
			args: true
		};
		Decorator = function( element, template ) {
			var decorator = this,
				ractive, name, fragment;
			decorator.element = element;
			decorator.root = ractive = element.root;
			name = template.n || template;
			if ( typeof name !== 'string' ) {
				fragment = new Fragment( {
					template: name,
					root: ractive,
					owner: element
				} );
				name = fragment.toString();
				fragment.unbind();
			}
			if ( template.a ) {
				decorator.params = template.a;
			} else if ( template.d ) {
				decorator.fragment = new Fragment( {
					template: template.d,
					root: ractive,
					owner: element
				} );
				decorator.params = decorator.fragment.getValue( getValueOptions );
				decorator.fragment.bubble = function() {
					this.dirtyArgs = this.dirtyValue = true;
					decorator.params = this.getValue( getValueOptions );
					if ( decorator.ready ) {
						decorator.update();
					}
				};
			}
			decorator.fn = config.registries.decorators.find( ractive, name );
			if ( !decorator.fn ) {
				log.error( {
					debug: ractive.debug,
					message: 'missingPlugin',
					args: {
						plugin: 'decorator',
						name: name
					}
				} );
			}
		};
		Decorator.prototype = {
			init: function() {
				var decorator = this,
					node, result, args;
				node = decorator.element.node;
				if ( decorator.params ) {
					args = [ node ].concat( decorator.params );
					result = decorator.fn.apply( decorator.root, args );
				} else {
					result = decorator.fn.call( decorator.root, node );
				}
				if ( !result || !result.teardown ) {
					throw new Error( 'Decorator definition must return an object with a teardown method' );
				}
				// TODO does this make sense?
				decorator.actual = result;
				decorator.ready = true;
			},
			update: function() {
				if ( this.actual.update ) {
					this.actual.update.apply( this.root, this.params );
				} else {
					this.actual.teardown( true );
					this.init();
				}
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				if ( this.fragment ) {
					this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			},
			teardown: function( updating ) {
				this.actual.teardown();
				if ( !updating && this.fragment ) {
					this.fragment.unbind();
				}
			}
		};
		return Decorator;
	}( log, circular, config );

	/* virtualdom/items/Element/special/select/sync.js */
	var sync = function( toArray ) {

		var __export;
		__export = function syncSelect( selectElement ) {
			var selectNode, selectValue, isMultiple, options, optionWasSelected;
			selectNode = selectElement.node;
			if ( !selectNode ) {
				return;
			}
			options = toArray( selectNode.options );
			selectValue = selectElement.getAttribute( 'value' );
			isMultiple = selectElement.getAttribute( 'multiple' );
			// If the <select> has a specified value, that should override
			// these options
			if ( selectValue !== undefined ) {
				options.forEach( function( o ) {
					var optionValue, shouldSelect;
					optionValue = o._ractive ? o._ractive.value : o.value;
					shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;
					if ( shouldSelect ) {
						optionWasSelected = true;
					}
					o.selected = shouldSelect;
				} );
				if ( !optionWasSelected ) {
					if ( options[ 0 ] ) {
						options[ 0 ].selected = true;
					}
					if ( selectElement.binding ) {
						selectElement.binding.forceUpdate();
					}
				}
			} else if ( selectElement.binding ) {
				selectElement.binding.forceUpdate();
			}
		};

		function valueContains( selectValue, optionValue ) {
			var i = selectValue.length;
			while ( i-- ) {
				if ( selectValue[ i ] == optionValue ) {
					return true;
				}
			}
		}
		return __export;
	}( toArray );

	/* virtualdom/items/Element/special/select/bubble.js */
	var bubble = function( runloop, syncSelect ) {

		return function bubbleSelect() {
			var this$0 = this;
			if ( !this.dirty ) {
				this.dirty = true;
				runloop.scheduleTask( function() {
					syncSelect( this$0 );
					this$0.dirty = false;
				} );
			}
			this.parentFragment.bubble();
		};
	}( runloop, sync );

	/* virtualdom/items/Element/special/option/findParentSelect.js */
	var findParentSelect = function findParentSelect( element ) {
		do {
			if ( element.name === 'select' ) {
				return element;
			}
		} while ( element = element.parent );
	};

	/* virtualdom/items/Element/special/option/init.js */
	var init = function( findParentSelect ) {

		return function initOption( option, template ) {
			option.select = findParentSelect( option.parent );
			// we might be inside a <datalist> element
			if ( !option.select ) {
				return;
			}
			option.select.options.push( option );
			// If the value attribute is missing, use the element's content
			if ( !template.a ) {
				template.a = {};
			}
			// ...as long as it isn't disabled
			if ( template.a.value === undefined && !template.a.hasOwnProperty( 'disabled' ) ) {
				template.a.value = template.f;
			}
			// If there is a `selected` attribute, but the <select>
			// already has a value, delete it
			if ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {
				delete template.a.selected;
			}
		};
	}( findParentSelect );

	/* virtualdom/items/Element/prototype/init.js */
	var virtualdom_items_Element$init = function( types, enforceCase, createAttributes, createConditionalAttributes, createTwowayBinding, createEventHandlers, Decorator, bubbleSelect, initOption, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Element$init( options ) {
			var parentFragment, template, ractive, binding, bindings;
			this.type = types.ELEMENT;
			// stuff we'll need later
			parentFragment = this.parentFragment = options.parentFragment;
			template = this.template = options.template;
			this.parent = options.pElement || parentFragment.pElement;
			this.root = ractive = parentFragment.root;
			this.index = options.index;
			this.name = enforceCase( template.e );
			// Special case - <option> elements
			if ( this.name === 'option' ) {
				initOption( this, template );
			}
			// Special case - <select> elements
			if ( this.name === 'select' ) {
				this.options = [];
				this.bubble = bubbleSelect;
			}
			// create attributes
			this.attributes = createAttributes( this, template.a );
			this.conditionalAttributes = createConditionalAttributes( this, template.m );
			// append children, if there are any
			if ( template.f ) {
				this.fragment = new Fragment( {
					template: template.f,
					root: ractive,
					owner: this,
					pElement: this
				} );
			}
			// create twoway binding
			if ( ractive.twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {
				this.binding = binding;
				// register this with the root, so that we can do ractive.updateModel()
				bindings = this.root._twowayBindings[ binding.keypath ] || ( this.root._twowayBindings[ binding.keypath ] = [] );
				bindings.push( binding );
			}
			// create event proxies
			if ( template.v ) {
				this.eventHandlers = createEventHandlers( this, template.v );
			}
			// create decorator
			if ( template.o ) {
				this.decorator = new Decorator( this, template.o );
			}
			// create transitions
			this.intro = template.t0 || template.t1;
			this.outro = template.t0 || template.t2;
		};
	}( types, enforceCase, virtualdom_items_Element$init_createAttributes, virtualdom_items_Element$init_createConditionalAttributes, virtualdom_items_Element$init_createTwowayBinding, virtualdom_items_Element$init_createEventHandlers, Decorator, bubble, init, circular );

	/* virtualdom/items/shared/utils/startsWith.js */
	var startsWith = function( startsWithKeypath ) {

		return function startsWith( target, keypath ) {
			return target === keypath || startsWithKeypath( target, keypath );
		};
	}( startsWithKeypath );

	/* virtualdom/items/shared/utils/assignNewKeypath.js */
	var assignNewKeypath = function( startsWith, getNewKeypath ) {

		return function assignNewKeypath( target, property, oldKeypath, newKeypath ) {
			var existingKeypath = target[ property ];
			if ( !existingKeypath || startsWith( existingKeypath, newKeypath ) || !startsWith( existingKeypath, oldKeypath ) ) {
				return;
			}
			target[ property ] = getNewKeypath( existingKeypath, oldKeypath, newKeypath );
		};
	}( startsWith, getNewKeypath );

	/* virtualdom/items/Element/prototype/rebind.js */
	var virtualdom_items_Element$rebind = function( assignNewKeypath ) {

		return function Element$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var i, storage, liveQueries, ractive;
			if ( this.attributes ) {
				this.attributes.forEach( rebind );
			}
			if ( this.conditionalAttributes ) {
				this.conditionalAttributes.forEach( rebind );
			}
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( rebind );
			}
			if ( this.decorator ) {
				rebind( this.decorator );
			}
			// rebind children
			if ( this.fragment ) {
				rebind( this.fragment );
			}
			// Update live queries, if necessary
			if ( liveQueries = this.liveQueries ) {
				ractive = this.root;
				i = liveQueries.length;
				while ( i-- ) {
					liveQueries[ i ]._makeDirty();
				}
			}
			if ( this.node && ( storage = this.node._ractive ) ) {
				// adjust keypath if needed
				assignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );
				if ( indexRef != undefined ) {
					storage.index[ indexRef ] = newIndex;
				}
			}

			function rebind( thing ) {
				thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};
	}( assignNewKeypath );

	/* virtualdom/items/Element/special/img/render.js */
	var render = function renderImage( img ) {
		var loadHandler;
		// if this is an <img>, and we're in a crap browser, we may need to prevent it
		// from overriding width and height when it loads the src
		if ( img.attributes.width || img.attributes.height ) {
			img.node.addEventListener( 'load', loadHandler = function() {
				var width = img.getAttribute( 'width' ),
					height = img.getAttribute( 'height' );
				if ( width !== undefined ) {
					img.node.setAttribute( 'width', width );
				}
				if ( height !== undefined ) {
					img.node.setAttribute( 'height', height );
				}
				img.node.removeEventListener( 'load', loadHandler, false );
			}, false );
		}
	};

	/* virtualdom/items/Element/Transition/prototype/init.js */
	var virtualdom_items_Element_Transition$init = function( log, config, circular ) {

		var Fragment, getValueOptions = {};
		// TODO what are the options?
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Transition$init( element, template, isIntro ) {
			var t = this,
				ractive, name, fragment;
			t.element = element;
			t.root = ractive = element.root;
			t.isIntro = isIntro;
			name = template.n || template;
			if ( typeof name !== 'string' ) {
				fragment = new Fragment( {
					template: name,
					root: ractive,
					owner: element
				} );
				name = fragment.toString();
				fragment.unbind();
			}
			t.name = name;
			if ( template.a ) {
				t.params = template.a;
			} else if ( template.d ) {
				// TODO is there a way to interpret dynamic arguments without all the
				// 'dependency thrashing'?
				fragment = new Fragment( {
					template: template.d,
					root: ractive,
					owner: element
				} );
				t.params = fragment.getValue( getValueOptions );
				fragment.unbind();
			}
			t._fn = config.registries.transitions.find( ractive, name );
			if ( !t._fn ) {
				log.error( {
					debug: ractive.debug,
					message: 'missingPlugin',
					args: {
						plugin: 'transition',
						name: name
					}
				} );
				return;
			}
		};
	}( log, config, circular );

	/* utils/camelCase.js */
	var camelCase = function( hyphenatedStr ) {
		return hyphenatedStr.replace( /-([a-zA-Z])/g, function( match, $1 ) {
			return $1.toUpperCase();
		} );
	};

	/* virtualdom/items/Element/Transition/helpers/prefix.js */
	var prefix = function( isClient, vendors, createElement, camelCase ) {

		var prefix, prefixCache, testStyle;
		if ( !isClient ) {
			prefix = null;
		} else {
			prefixCache = {};
			testStyle = createElement( 'div' ).style;
			prefix = function( prop ) {
				var i, vendor, capped;
				prop = camelCase( prop );
				if ( !prefixCache[ prop ] ) {
					if ( testStyle[ prop ] !== undefined ) {
						prefixCache[ prop ] = prop;
					} else {
						// test vendors...
						capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );
						i = vendors.length;
						while ( i-- ) {
							vendor = vendors[ i ];
							if ( testStyle[ vendor + capped ] !== undefined ) {
								prefixCache[ prop ] = vendor + capped;
								break;
							}
						}
					}
				}
				return prefixCache[ prop ];
			};
		}
		return prefix;
	}( isClient, vendors, createElement, camelCase );

	/* virtualdom/items/Element/Transition/prototype/getStyle.js */
	var virtualdom_items_Element_Transition$getStyle = function( legacy, isClient, isArray, prefix ) {

		var getStyle, getComputedStyle;
		if ( !isClient ) {
			getStyle = null;
		} else {
			getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
			getStyle = function( props ) {
				var computedStyle, styles, i, prop, value;
				computedStyle = getComputedStyle( this.node );
				if ( typeof props === 'string' ) {
					value = computedStyle[ prefix( props ) ];
					if ( value === '0px' ) {
						value = 0;
					}
					return value;
				}
				if ( !isArray( props ) ) {
					throw new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );
				}
				styles = {};
				i = props.length;
				while ( i-- ) {
					prop = props[ i ];
					value = computedStyle[ prefix( prop ) ];
					if ( value === '0px' ) {
						value = 0;
					}
					styles[ prop ] = value;
				}
				return styles;
			};
		}
		return getStyle;
	}( legacy, isClient, isArray, prefix );

	/* virtualdom/items/Element/Transition/prototype/setStyle.js */
	var virtualdom_items_Element_Transition$setStyle = function( prefix ) {

		return function( style, value ) {
			var prop;
			if ( typeof style === 'string' ) {
				this.node.style[ prefix( style ) ] = value;
			} else {
				for ( prop in style ) {
					if ( style.hasOwnProperty( prop ) ) {
						this.node.style[ prefix( prop ) ] = style[ prop ];
					}
				}
			}
			return this;
		};
	}( prefix );

	/* shared/Ticker.js */
	var Ticker = function( warn, getTime, animations ) {

		var __export;
		var Ticker = function( options ) {
			var easing;
			this.duration = options.duration;
			this.step = options.step;
			this.complete = options.complete;
			// easing
			if ( typeof options.easing === 'string' ) {
				easing = options.root.easing[ options.easing ];
				if ( !easing ) {
					warn( 'Missing easing function ("' + options.easing + '"). You may need to download a plugin from [TODO]' );
					easing = linear;
				}
			} else if ( typeof options.easing === 'function' ) {
				easing = options.easing;
			} else {
				easing = linear;
			}
			this.easing = easing;
			this.start = getTime();
			this.end = this.start + this.duration;
			this.running = true;
			animations.add( this );
		};
		Ticker.prototype = {
			tick: function( now ) {
				var elapsed, eased;
				if ( !this.running ) {
					return false;
				}
				if ( now > this.end ) {
					if ( this.step ) {
						this.step( 1 );
					}
					if ( this.complete ) {
						this.complete( 1 );
					}
					return false;
				}
				elapsed = now - this.start;
				eased = this.easing( elapsed / this.duration );
				if ( this.step ) {
					this.step( eased );
				}
				return true;
			},
			stop: function() {
				if ( this.abort ) {
					this.abort();
				}
				this.running = false;
			}
		};
		__export = Ticker;

		function linear( t ) {
			return t;
		}
		return __export;
	}( warn, getTime, animations );

	/* virtualdom/items/Element/Transition/helpers/unprefix.js */
	var unprefix = function( vendors ) {

		var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );
		return function( prop ) {
			return prop.replace( unprefixPattern, '' );
		};
	}( vendors );

	/* virtualdom/items/Element/Transition/helpers/hyphenate.js */
	var hyphenate = function( vendors ) {

		var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );
		return function( str ) {
			var hyphenated;
			if ( !str ) {
				return '';
			}
			if ( vendorPattern.test( str ) ) {
				str = '-' + str;
			}
			hyphenated = str.replace( /[A-Z]/g, function( match ) {
				return '-' + match.toLowerCase();
			} );
			return hyphenated;
		};
	}( vendors );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js */
	var virtualdom_items_Element_Transition$animateStyle_createTransitions = function( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate ) {

		var createTransitions, testStyle, TRANSITION, TRANSITIONEND, CSS_TRANSITIONS_ENABLED, TRANSITION_DURATION, TRANSITION_PROPERTY, TRANSITION_TIMING_FUNCTION, canUseCssTransitions = {},
			cannotUseCssTransitions = {};
		if ( !isClient ) {
			createTransitions = null;
		} else {
			testStyle = createElement( 'div' ).style;
			// determine some facts about our environment
			( function() {
				if ( testStyle.transition !== undefined ) {
					TRANSITION = 'transition';
					TRANSITIONEND = 'transitionend';
					CSS_TRANSITIONS_ENABLED = true;
				} else if ( testStyle.webkitTransition !== undefined ) {
					TRANSITION = 'webkitTransition';
					TRANSITIONEND = 'webkitTransitionEnd';
					CSS_TRANSITIONS_ENABLED = true;
				} else {
					CSS_TRANSITIONS_ENABLED = false;
				}
			}() );
			if ( TRANSITION ) {
				TRANSITION_DURATION = TRANSITION + 'Duration';
				TRANSITION_PROPERTY = TRANSITION + 'Property';
				TRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';
			}
			createTransitions = function( t, to, options, changedProperties, resolve ) {
				// Wait a beat (otherwise the target styles will be applied immediately)
				// TODO use a fastdom-style mechanism?
				setTimeout( function() {
					var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;
					checkComplete = function() {
						if ( jsTransitionsComplete && cssTransitionsComplete ) {
							// will changes to events and fire have an unexpected consequence here?
							t.root.fire( t.name + ':end', t.node, t.isIntro );
							resolve();
						}
					};
					// this is used to keep track of which elements can use CSS to animate
					// which properties
					hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;
					t.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );
					t.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );
					t.node.style[ TRANSITION_DURATION ] = options.duration / 1000 + 's';
					transitionEndHandler = function( event ) {
						var index;
						index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );
						if ( index !== -1 ) {
							changedProperties.splice( index, 1 );
						}
						if ( changedProperties.length ) {
							// still transitioning...
							return;
						}
						t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
						cssTransitionsComplete = true;
						checkComplete();
					};
					t.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );
					setTimeout( function() {
						var i = changedProperties.length,
							hash, originalValue, index, propertiesToTransitionInJs = [],
							prop, suffix;
						while ( i-- ) {
							prop = changedProperties[ i ];
							hash = hashPrefix + prop;
							if ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {
								t.node.style[ prefix( prop ) ] = to[ prop ];
								// If we're not sure if CSS transitions are supported for
								// this tag/property combo, find out now
								if ( !canUseCssTransitions[ hash ] ) {
									originalValue = t.getStyle( prop );
									// if this property is transitionable in this browser,
									// the current style will be different from the target style
									canUseCssTransitions[ hash ] = t.getStyle( prop ) != to[ prop ];
									cannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];
									// Reset, if we're going to use timers after all
									if ( cannotUseCssTransitions[ hash ] ) {
										t.node.style[ prefix( prop ) ] = originalValue;
									}
								}
							}
							if ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {
								// we need to fall back to timer-based stuff
								if ( originalValue === undefined ) {
									originalValue = t.getStyle( prop );
								}
								// need to remove this from changedProperties, otherwise transitionEndHandler
								// will get confused
								index = changedProperties.indexOf( prop );
								if ( index === -1 ) {
									warn( 'Something very strange happened with transitions. If you see this message, please let @RactiveJS know. Thanks!' );
								} else {
									changedProperties.splice( index, 1 );
								}
								// TODO Determine whether this property is animatable at all
								suffix = /[^\d]*$/.exec( to[ prop ] )[ 0 ];
								// ...then kick off a timer-based transition
								propertiesToTransitionInJs.push( {
									name: prefix( prop ),
									interpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),
									suffix: suffix
								} );
							}
						}
						// javascript transitions
						if ( propertiesToTransitionInJs.length ) {
							new Ticker( {
								root: t.root,
								duration: options.duration,
								easing: camelCase( options.easing || '' ),
								step: function( pos ) {
									var prop, i;
									i = propertiesToTransitionInJs.length;
									while ( i-- ) {
										prop = propertiesToTransitionInJs[ i ];
										t.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;
									}
								},
								complete: function() {
									jsTransitionsComplete = true;
									checkComplete();
								}
							} );
						} else {
							jsTransitionsComplete = true;
						}
						if ( !changedProperties.length ) {
							// We need to cancel the transitionEndHandler, and deal with
							// the fact that it will never fire
							t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
							cssTransitionsComplete = true;
							checkComplete();
						}
					}, 0 );
				}, options.delay || 0 );
			};
		}
		return createTransitions;
	}( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js */
	var virtualdom_items_Element_Transition$animateStyle_visibility = function( vendors ) {

		var hidden, vendor, prefix, i, visibility;
		if ( typeof document !== 'undefined' ) {
			hidden = 'hidden';
			visibility = {};
			if ( hidden in document ) {
				prefix = '';
			} else {
				i = vendors.length;
				while ( i-- ) {
					vendor = vendors[ i ];
					hidden = vendor + 'Hidden';
					if ( hidden in document ) {
						prefix = vendor;
					}
				}
			}
			if ( prefix !== undefined ) {
				document.addEventListener( prefix + 'visibilitychange', onChange );
				// initialise
				onChange();
			} else {
				// gah, we're in an old browser
				if ( 'onfocusout' in document ) {
					document.addEventListener( 'focusout', onHide );
					document.addEventListener( 'focusin', onShow );
				} else {
					window.addEventListener( 'pagehide', onHide );
					window.addEventListener( 'blur', onHide );
					window.addEventListener( 'pageshow', onShow );
					window.addEventListener( 'focus', onShow );
				}
				visibility.hidden = false;
			}
		}

		function onChange() {
			visibility.hidden = document[ hidden ];
		}

		function onHide() {
			visibility.hidden = true;
		}

		function onShow() {
			visibility.hidden = false;
		}
		return visibility;
	}( vendors );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js */
	var virtualdom_items_Element_Transition$animateStyle__animateStyle = function( legacy, isClient, warn, Promise, prefix, createTransitions, visibility ) {

		var animateStyle, getComputedStyle, resolved;
		if ( !isClient ) {
			animateStyle = null;
		} else {
			getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
			animateStyle = function( style, value, options, complete ) {
				var t = this,
					to;
				// Special case - page isn't visible. Don't animate anything, because
				// that way you'll never get CSS transitionend events
				if ( visibility.hidden ) {
					this.setStyle( style, value );
					return resolved || ( resolved = Promise.resolve() );
				}
				if ( typeof style === 'string' ) {
					to = {};
					to[ style ] = value;
				} else {
					to = style;
					// shuffle arguments
					complete = options;
					options = value;
				}
				// As of 0.3.9, transition authors should supply an `option` object with
				// `duration` and `easing` properties (and optional `delay`), plus a
				// callback function that gets called after the animation completes
				// TODO remove this check in a future version
				if ( !options ) {
					warn( 'The "' + t.name + '" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340' );
					options = t;
					complete = t.complete;
				}
				var promise = new Promise( function( resolve ) {
					var propertyNames, changedProperties, computedStyle, current, from, i, prop;
					// Edge case - if duration is zero, set style synchronously and complete
					if ( !options.duration ) {
						t.setStyle( to );
						resolve();
						return;
					}
					// Get a list of the properties we're animating
					propertyNames = Object.keys( to );
					changedProperties = [];
					// Store the current styles
					computedStyle = getComputedStyle( t.node );
					from = {};
					i = propertyNames.length;
					while ( i-- ) {
						prop = propertyNames[ i ];
						current = computedStyle[ prefix( prop ) ];
						if ( current === '0px' ) {
							current = 0;
						}
						// we need to know if we're actually changing anything
						if ( current != to[ prop ] ) {
							// use != instead of !==, so we can compare strings with numbers
							changedProperties.push( prop );
							// make the computed style explicit, so we can animate where
							// e.g. height='auto'
							t.node.style[ prefix( prop ) ] = current;
						}
					}
					// If we're not actually changing anything, the transitionend event
					// will never fire! So we complete early
					if ( !changedProperties.length ) {
						resolve();
						return;
					}
					createTransitions( t, to, options, changedProperties, resolve );
				} );
				// If a callback was supplied, do the honours
				// TODO remove this check in future
				if ( complete ) {
					warn( 't.animateStyle returns a Promise as of 0.4.0. Transition authors should do t.animateStyle(...).then(callback)' );
					promise.then( complete );
				}
				return promise;
			};
		}
		return animateStyle;
	}( legacy, isClient, warn, Promise, prefix, virtualdom_items_Element_Transition$animateStyle_createTransitions, virtualdom_items_Element_Transition$animateStyle_visibility );

	/* utils/fillGaps.js */
	var fillGaps = function( target ) {
		var SLICE$0 = Array.prototype.slice;
		var sources = SLICE$0.call( arguments, 1 );
		sources.forEach( function( s ) {
			for ( var key in s ) {
				if ( s.hasOwnProperty( key ) && !( key in target ) ) {
					target[ key ] = s[ key ];
				}
			}
		} );
		return target;
	};

	/* virtualdom/items/Element/Transition/prototype/processParams.js */
	var virtualdom_items_Element_Transition$processParams = function( fillGaps ) {

		return function( params, defaults ) {
			if ( typeof params === 'number' ) {
				params = {
					duration: params
				};
			} else if ( typeof params === 'string' ) {
				if ( params === 'slow' ) {
					params = {
						duration: 600
					};
				} else if ( params === 'fast' ) {
					params = {
						duration: 200
					};
				} else {
					params = {
						duration: 400
					};
				}
			} else if ( !params ) {
				params = {};
			}
			return fillGaps( {}, params, defaults );
		};
	}( fillGaps );

	/* virtualdom/items/Element/Transition/prototype/start.js */
	var virtualdom_items_Element_Transition$start = function() {

		var __export;
		__export = function Transition$start() {
			var t = this,
				node, originalStyle, completed;
			node = t.node = t.element.node;
			originalStyle = node.getAttribute( 'style' );
			// create t.complete() - we don't want this on the prototype,
			// because we don't want `this` silliness when passing it as
			// an argument
			t.complete = function( noReset ) {
				if ( completed ) {
					return;
				}
				if ( !noReset && t.isIntro ) {
					resetStyle( node, originalStyle );
				}
				node._ractive.transition = null;
				t._manager.remove( t );
				completed = true;
			};
			// If the transition function doesn't exist, abort
			if ( !t._fn ) {
				t.complete();
				return;
			}
			t._fn.apply( t.root, [ t ].concat( t.params ) );
		};

		function resetStyle( node, style ) {
			if ( style ) {
				node.setAttribute( 'style', style );
			} else {
				// Next line is necessary, to remove empty style attribute!
				// See http://stackoverflow.com/a/7167553
				node.getAttribute( 'style' );
				node.removeAttribute( 'style' );
			}
		}
		return __export;
	}();

	/* virtualdom/items/Element/Transition/_Transition.js */
	var Transition = function( init, getStyle, setStyle, animateStyle, processParams, start, circular ) {

		var Fragment, Transition;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		Transition = function( owner, template, isIntro ) {
			this.init( owner, template, isIntro );
		};
		Transition.prototype = {
			init: init,
			start: start,
			getStyle: getStyle,
			setStyle: setStyle,
			animateStyle: animateStyle,
			processParams: processParams
		};
		return Transition;
	}( virtualdom_items_Element_Transition$init, virtualdom_items_Element_Transition$getStyle, virtualdom_items_Element_Transition$setStyle, virtualdom_items_Element_Transition$animateStyle__animateStyle, virtualdom_items_Element_Transition$processParams, virtualdom_items_Element_Transition$start, circular );

	/* virtualdom/items/Element/prototype/render.js */
	var virtualdom_items_Element$render = function( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, renderImage, Transition ) {

		var __export;
		var updateCss, updateScript;
		updateCss = function() {
			var node = this.node,
				content = this.fragment.toString( false );
			// IE8 has no styleSheet unless there's a type text/css
			if ( window && window.appearsToBeIELessEqual8 ) {
				node.type = 'text/css';
			}
			if ( node.styleSheet ) {
				node.styleSheet.cssText = content;
			} else {
				while ( node.hasChildNodes() ) {
					node.removeChild( node.firstChild );
				}
				node.appendChild( document.createTextNode( content ) );
			}
		};
		updateScript = function() {
			if ( !this.node.type || this.node.type === 'text/javascript' ) {
				warn( 'Script tag was updated. This does not cause the code to be re-evaluated!' );
			}
			this.node.text = this.fragment.toString( false );
		};
		__export = function Element$render() {
			var this$0 = this;
			var root = this.root,
				namespace, node;
			namespace = getNamespace( this );
			node = this.node = createElement( this.name, namespace );
			// Is this a top-level node of a component? If so, we may need to add
			// a data-rvcguid attribute, for CSS encapsulation
			// NOTE: css no longer copied to instance, so we check constructor.css -
			// we can enhance to handle instance, but this is more "correct" with current
			// functionality
			if ( root.constructor.css && this.parentFragment.getNode() === root.el ) {
				this.node.setAttribute( 'data-rvcguid', root.constructor._guid );
			}
			// Add _ractive property to the node - we use this object to store stuff
			// related to proxy events, two-way bindings etc
			defineProperty( this.node, '_ractive', {
				value: {
					proxy: this,
					keypath: getInnerContext( this.parentFragment ),
					index: this.parentFragment.indexRefs,
					events: create( null ),
					root: root
				}
			} );
			// Render attributes
			this.attributes.forEach( function( a ) {
				return a.render( node );
			} );
			this.conditionalAttributes.forEach( function( a ) {
				return a.render( node );
			} );
			// Render children
			if ( this.fragment ) {
				// Special case - <script> element
				if ( this.name === 'script' ) {
					this.bubble = updateScript;
					this.node.text = this.fragment.toString( false );
					// bypass warning initially
					this.fragment.unrender = noop;
				} else if ( this.name === 'style' ) {
					this.bubble = updateCss;
					this.bubble();
					this.fragment.unrender = noop;
				} else if ( this.binding && this.getAttribute( 'contenteditable' ) ) {
					this.fragment.unrender = noop;
				} else {
					this.node.appendChild( this.fragment.render() );
				}
			}
			// Add proxy event handlers
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( function( h ) {
					return h.render();
				} );
			}
			// deal with two-way bindings
			if ( this.binding ) {
				this.binding.render();
				this.node._ractive.binding = this.binding;
			}
			// Special case: if this is an <img>, and we're in a crap browser, we may
			// need to prevent it from overriding width and height when it loads the src
			if ( this.name === 'img' ) {
				renderImage( this );
			}
			// apply decorator(s)
			if ( this.decorator && this.decorator.fn ) {
				runloop.scheduleTask( function() {
					return this$0.decorator.init();
				}, true );
			}
			// trigger intro transition
			if ( root.transitionsEnabled && this.intro ) {
				var transition = new Transition( this, this.intro, true );
				runloop.registerTransition( transition );
				runloop.scheduleTask( function() {
					return transition.start();
				}, true );
				this.transition = transition;
			}
			if ( this.name === 'option' ) {
				processOption( this );
			}
			if ( this.node.autofocus ) {
				// Special case. Some browsers (*cough* Firefix *cough*) have a problem
				// with dynamically-generated elements having autofocus, and they won't
				// allow you to programmatically focus the element until it's in the DOM
				runloop.scheduleTask( function() {
					return this$0.node.focus();
				}, true );
			}
			updateLiveQueries( this );
			return this.node;
		};

		function getNamespace( element ) {
			var namespace, xmlns, parent;
			// Use specified namespace...
			if ( xmlns = element.getAttribute( 'xmlns' ) ) {
				namespace = xmlns;
			} else if ( element.name === 'svg' ) {
				namespace = namespaces.svg;
			} else if ( parent = element.parent ) {
				// ...or HTML, if the parent is a <foreignObject>
				if ( parent.name === 'foreignObject' ) {
					namespace = namespaces.html;
				} else {
					namespace = parent.node.namespaceURI;
				}
			} else {
				namespace = element.root.el.namespaceURI;
			}
			return namespace;
		}

		function processOption( option ) {
			var optionValue, selectValue, i;
			if ( !option.select ) {
				return;
			}
			selectValue = option.select.getAttribute( 'value' );
			if ( selectValue === undefined ) {
				return;
			}
			optionValue = option.getAttribute( 'value' );
			if ( option.select.node.multiple && isArray( selectValue ) ) {
				i = selectValue.length;
				while ( i-- ) {
					if ( optionValue == selectValue[ i ] ) {
						option.node.selected = true;
						break;
					}
				}
			} else {
				option.node.selected = optionValue == selectValue;
			}
		}

		function updateLiveQueries( element ) {
			var instance, liveQueries, i, selector, query;
			// Does this need to be added to any live queries?
			instance = element.root;
			do {
				liveQueries = instance._liveQueries;
				i = liveQueries.length;
				while ( i-- ) {
					selector = liveQueries[ i ];
					query = liveQueries[ '_' + selector ];
					if ( query._test( element ) ) {
						// keep register of applicable selectors, for when we teardown
						( element.liveQueries || ( element.liveQueries = [] ) ).push( query );
					}
				}
			} while ( instance = instance._parent );
		}
		return __export;
	}( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, render, Transition );

	/* virtualdom/items/Element/prototype/toString.js */
	var virtualdom_items_Element$toString = function( voidElementNames, isArray, escapeHtml ) {

		var __export;
		__export = function() {
			var str, escape;
			str = '<' + ( this.template.y ? '!DOCTYPE' : this.template.e );
			str += this.attributes.map( stringifyAttribute ).join( '' ) + this.conditionalAttributes.map( stringifyAttribute ).join( '' );
			// Special case - selected options
			if ( this.name === 'option' && optionIsSelected( this ) ) {
				str += ' selected';
			}
			// Special case - two-way radio name bindings
			if ( this.name === 'input' && inputIsCheckedRadio( this ) ) {
				str += ' checked';
			}
			str += '>';
			// Special case - textarea
			if ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {
				str += escapeHtml( this.getAttribute( 'value' ) );
			} else if ( this.getAttribute( 'contenteditable' ) !== undefined ) {
				str += this.getAttribute( 'value' );
			}
			if ( this.fragment ) {
				escape = this.name !== 'script' && this.name !== 'style';
				str += this.fragment.toString( escape );
			}
			// add a closing tag if this isn't a void element
			if ( !voidElementNames.test( this.template.e ) ) {
				str += '</' + this.template.e + '>';
			}
			return str;
		};

		function optionIsSelected( element ) {
			var optionValue, selectValue, i;
			optionValue = element.getAttribute( 'value' );
			if ( optionValue === undefined || !element.select ) {
				return false;
			}
			selectValue = element.select.getAttribute( 'value' );
			if ( selectValue == optionValue ) {
				return true;
			}
			if ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {
				i = selectValue.length;
				while ( i-- ) {
					if ( selectValue[ i ] == optionValue ) {
						return true;
					}
				}
			}
		}

		function inputIsCheckedRadio( element ) {
			var attributes, typeAttribute, valueAttribute, nameAttribute;
			attributes = element.attributes;
			typeAttribute = attributes.type;
			valueAttribute = attributes.value;
			nameAttribute = attributes.name;
			if ( !typeAttribute || typeAttribute.value !== 'radio' || !valueAttribute || !nameAttribute.interpolator ) {
				return;
			}
			if ( valueAttribute.value === nameAttribute.interpolator.value ) {
				return true;
			}
		}

		function stringifyAttribute( attribute ) {
			var str = attribute.toString();
			return str ? ' ' + str : '';
		}
		return __export;
	}( voidElementNames, isArray, escapeHtml );

	/* virtualdom/items/Element/special/option/unbind.js */
	var virtualdom_items_Element_special_option_unbind = function( removeFromArray ) {

		return function unbindOption( option ) {
			if ( option.select ) {
				removeFromArray( option.select.options, option );
			}
		};
	}( removeFromArray );

	/* virtualdom/items/Element/prototype/unbind.js */
	var virtualdom_items_Element$unbind = function( unbindOption ) {

		var __export;
		__export = function Element$unbind() {
			if ( this.fragment ) {
				this.fragment.unbind();
			}
			if ( this.binding ) {
				this.binding.unbind();
			}
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( unbind );
			}
			// Special case - <option>
			if ( this.name === 'option' ) {
				unbindOption( this );
			}
			this.attributes.forEach( unbind );
			this.conditionalAttributes.forEach( unbind );
		};

		function unbind( x ) {
			x.unbind();
		}
		return __export;
	}( virtualdom_items_Element_special_option_unbind );

	/* virtualdom/items/Element/prototype/unrender.js */
	var virtualdom_items_Element$unrender = function( runloop, Transition ) {

		var __export;
		__export = function Element$unrender( shouldDestroy ) {
			var binding, bindings;
			if ( this.transition ) {
				this.transition.complete();
			}
			// Detach as soon as we can
			if ( this.name === 'option' ) {
				// <option> elements detach immediately, so that
				// their parent <select> element syncs correctly, and
				// since option elements can't have transitions anyway
				this.detach();
			} else if ( shouldDestroy ) {
				runloop.detachWhenReady( this );
			}
			// Children first. that way, any transitions on child elements will be
			// handled by the current transitionManager
			if ( this.fragment ) {
				this.fragment.unrender( false );
			}
			if ( binding = this.binding ) {
				this.binding.unrender();
				this.node._ractive.binding = null;
				bindings = this.root._twowayBindings[ binding.keypath ];
				bindings.splice( bindings.indexOf( binding ), 1 );
			}
			// Remove event handlers
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( function( h ) {
					return h.unrender();
				} );
			}
			if ( this.decorator ) {
				this.decorator.teardown();
			}
			// trigger outro transition if necessary
			if ( this.root.transitionsEnabled && this.outro ) {
				var transition = new Transition( this, this.outro, false );
				runloop.registerTransition( transition );
				runloop.scheduleTask( function() {
					return transition.start();
				} );
			}
			// Remove this node from any live queries
			if ( this.liveQueries ) {
				removeFromLiveQueries( this );
			}
		};

		function removeFromLiveQueries( element ) {
			var query, selector, i;
			i = element.liveQueries.length;
			while ( i-- ) {
				query = element.liveQueries[ i ];
				selector = query.selector;
				query._remove( element.node );
			}
		}
		return __export;
	}( runloop, Transition );

	/* virtualdom/items/Element/_Element.js */
	var Element = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getAttribute, init, rebind, render, toString, unbind, unrender ) {

		var Element = function( options ) {
			this.init( options );
		};
		Element.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getAttribute: getAttribute,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		return Element;
	}( virtualdom_items_Element$bubble, virtualdom_items_Element$detach, virtualdom_items_Element$find, virtualdom_items_Element$findAll, virtualdom_items_Element$findAllComponents, virtualdom_items_Element$findComponent, virtualdom_items_Element$findNextNode, virtualdom_items_Element$firstNode, virtualdom_items_Element$getAttribute, virtualdom_items_Element$init, virtualdom_items_Element$rebind, virtualdom_items_Element$render, virtualdom_items_Element$toString, virtualdom_items_Element$unbind, virtualdom_items_Element$unrender );

	/* virtualdom/items/Partial/deIndent.js */
	var deIndent = function() {

		var __export;
		var empty = /^\s*$/,
			leadingWhitespace = /^\s*/;
		__export = function( str ) {
			var lines, firstLine, lastLine, minIndent;
			lines = str.split( '\n' );
			// remove first and last line, if they only contain whitespace
			firstLine = lines[ 0 ];
			if ( firstLine !== undefined && empty.test( firstLine ) ) {
				lines.shift();
			}
			lastLine = lines[ lines.length - 1 ];
			if ( lastLine !== undefined && empty.test( lastLine ) ) {
				lines.pop();
			}
			minIndent = lines.reduce( reducer, null );
			if ( minIndent ) {
				str = lines.map( function( line ) {
					return line.replace( minIndent, '' );
				} ).join( '\n' );
			}
			return str;
		};

		function reducer( previous, line ) {
			var lineIndent = leadingWhitespace.exec( line )[ 0 ];
			if ( previous === null || lineIndent.length < previous.length ) {
				return lineIndent;
			}
			return previous;
		}
		return __export;
	}();

	/* virtualdom/items/Partial/getPartialTemplate.js */
	var getPartialTemplate = function( log, config, parser, deIndent ) {

		var __export;
		__export = function getPartialTemplate( ractive, name ) {
			var partial;
			// If the partial in instance or view heirarchy instances, great
			if ( partial = getPartialFromRegistry( ractive, name ) ) {
				return partial;
			}
			// Does it exist on the page as a script tag?
			partial = parser.fromId( name, {
				noThrow: true
			} );
			if ( partial ) {
				// is this necessary?
				partial = deIndent( partial );
				// parse and register to this ractive instance
				var parsed = parser.parse( partial, parser.getParseOptions( ractive ) );
				// register (and return main partial if there are others in the template)
				return ractive.partials[ name ] = parsed.t;
			}
		};

		function getPartialFromRegistry( ractive, name ) {
			var partials = config.registries.partials;
			// find first instance in the ractive or view hierarchy that has this partial
			var instance = partials.findInstance( ractive, name );
			if ( !instance ) {
				return;
			}
			var partial = instance.partials[ name ],
				fn;
			// partial is a function?
			if ( typeof partial === 'function' ) {
				fn = partial.bind( instance );
				fn.isOwner = instance.partials.hasOwnProperty( name );
				partial = fn( instance.data, parser );
			}
			if ( !partial ) {
				log.warn( {
					debug: ractive.debug,
					message: 'noRegistryFunctionReturn',
					args: {
						registry: 'partial',
						name: name
					}
				} );
				return;
			}
			// If this was added manually to the registry,
			// but hasn't been parsed, parse it now
			if ( !parser.isParsed( partial ) ) {
				// use the parseOptions of the ractive instance on which it was found
				var parsed = parser.parse( partial, parser.getParseOptions( instance ) );
				// Partials cannot contain nested partials!
				// TODO add a test for this
				if ( parsed.p ) {
					log.warn( {
						debug: ractive.debug,
						message: 'noNestedPartials',
						args: {
							rname: name
						}
					} );
				}
				// if fn, use instance to store result, otherwise needs to go
				// in the correct point in prototype chain on instance or constructor
				var target = fn ? instance : partials.findOwner( instance, name );
				// may be a template with partials, which need to be registered and main template extracted
				target.partials[ name ] = partial = parsed.t;
			}
			// store for reset
			if ( fn ) {
				partial._fn = fn;
			}
			return partial.v ? partial.t : partial;
		}
		return __export;
	}( log, config, parser, deIndent );

	/* virtualdom/items/Partial/applyIndent.js */
	var applyIndent = function( string, indent ) {
		var indented;
		if ( !indent ) {
			return string;
		}
		indented = string.split( '\n' ).map( function( line, notFirstLine ) {
			return notFirstLine ? indent + line : line;
		} ).join( '\n' );
		return indented;
	};

	/* virtualdom/items/Partial/_Partial.js */
	var Partial = function( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind ) {

		var Partial, Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		Partial = function( options ) {
			var parentFragment, template;
			parentFragment = this.parentFragment = options.parentFragment;
			this.root = parentFragment.root;
			this.type = types.PARTIAL;
			this.index = options.index;
			this.name = options.template.r;
			this.fragment = this.fragmentToRender = this.fragmentToUnrender = null;
			Mustache.init( this, options );
			// If this didn't resolve, it most likely means we have a named partial
			// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial
			// whose name is the value of `foo`')
			if ( !this.keypath && ( template = getPartialTemplate( this.root, this.name ) ) ) {
				unbind.call( this );
				// prevent any further changes
				this.isNamed = true;
				this.setTemplate( template );
			}
		};
		Partial.prototype = {
			bubble: function() {
				this.parentFragment.bubble();
			},
			detach: function() {
				return this.fragment.detach();
			},
			find: function( selector ) {
				return this.fragment.find( selector );
			},
			findAll: function( selector, query ) {
				return this.fragment.findAll( selector, query );
			},
			findComponent: function( selector ) {
				return this.fragment.findComponent( selector );
			},
			findAllComponents: function( selector, query ) {
				return this.fragment.findAllComponents( selector, query );
			},
			firstNode: function() {
				return this.fragment.firstNode();
			},
			findNextNode: function() {
				return this.parentFragment.findNextNode( this );
			},
			getValue: function() {
				return this.fragment.getValue();
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				rebind.call( this, indexRef, newIndex, oldKeypath, newKeypath );
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			render: function() {
				this.docFrag = document.createDocumentFragment();
				this.update();
				this.rendered = true;
				return this.docFrag;
			},
			resolve: Mustache.resolve,
			setValue: function( value ) {
				var template;
				if ( value !== undefined && value === this.value ) {
					// nothing has changed, so no work to be done
					return;
				}
				template = getPartialTemplate( this.root, '' + value );
				// we may be here if we have a partial like `{{>foo}}` and `foo` is the
				// name of both a data property (whose value ISN'T the name of a partial)
				// and a partial. In those cases, this becomes a named partial
				if ( !template && this.name && ( template = getPartialTemplate( this.root, this.name ) ) ) {
					unbind.call( this );
					this.isNamed = true;
				}
				if ( !template ) {
					log.error( {
						debug: this.root.debug,
						message: 'noTemplateForPartial',
						args: {
							name: this.name
						}
					} );
				}
				this.setTemplate( template || [] );
				this.value = value;
				this.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			},
			setTemplate: function( template ) {
				if ( this.fragment ) {
					this.fragment.unbind();
					this.fragmentToUnrender = this.fragment;
				}
				this.fragment = new Fragment( {
					template: template,
					root: this.root,
					owner: this,
					pElement: this.parentFragment.pElement
				} );
				this.fragmentToRender = this.fragment;
			},
			toString: function( toString ) {
				var string, previousItem, lastLine, match;
				string = this.fragment.toString( toString );
				previousItem = this.parentFragment.items[ this.index - 1 ];
				if ( !previousItem || previousItem.type !== types.TEXT ) {
					return string;
				}
				lastLine = previousItem.text.split( '\n' ).pop();
				if ( match = /^\s+$/.exec( lastLine ) ) {
					return applyIndent( string, match[ 0 ] );
				}
				return string;
			},
			unbind: function() {
				if ( !this.isNamed ) {
					// dynamic partial - need to unbind self
					unbind.call( this );
				}
				if ( this.fragment ) {
					this.fragment.unbind();
				}
			},
			unrender: function( shouldDestroy ) {
				if ( this.rendered ) {
					if ( this.fragment ) {
						this.fragment.unrender( shouldDestroy );
					}
					this.rendered = false;
				}
			},
			update: function() {
				var target, anchor;
				if ( this.fragmentToUnrender ) {
					this.fragmentToUnrender.unrender( true );
					this.fragmentToUnrender = null;
				}
				if ( this.fragmentToRender ) {
					this.docFrag.appendChild( this.fragmentToRender.render() );
					this.fragmentToRender = null;
				}
				if ( this.rendered ) {
					target = this.parentFragment.getNode();
					anchor = this.parentFragment.findNextNode( this );
					target.insertBefore( this.docFrag, anchor );
				}
			}
		};
		return Partial;
	}( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind );

	/* virtualdom/items/Component/getComponent.js */
	var getComponent = function( config, log, circular ) {

		var Ractive;
		circular.push( function() {
			Ractive = circular.Ractive;
		} );
		// finds the component constructor in the registry or view hierarchy registries
		return function getComponent( ractive, name ) {
			var component, instance = config.registries.components.findInstance( ractive, name );
			if ( instance ) {
				component = instance.components[ name ];
				// best test we have for not Ractive.extend
				if ( !component._parent ) {
					// function option, execute and store for reset
					var fn = component.bind( instance );
					fn.isOwner = instance.components.hasOwnProperty( name );
					component = fn( instance.data );
					if ( !component ) {
						log.warn( {
							debug: ractive.debug,
							message: 'noRegistryFunctionReturn',
							args: {
								registry: 'component',
								name: name
							}
						} );
						return;
					}
					if ( typeof component === 'string' ) {
						//allow string lookup
						component = getComponent( ractive, component );
					}
					component._fn = fn;
					instance.components[ name ] = component;
				}
			}
			return component;
		};
	}( config, log, circular );

	/* virtualdom/items/Component/prototype/detach.js */
	var virtualdom_items_Component$detach = function( Hook ) {

		var detachHook = new Hook( 'detach' );
		return function Component$detach() {
			var detached = this.instance.fragment.detach();
			detachHook.fire( this.instance );
			return detached;
		};
	}( Ractive$shared_hooks_Hook );

	/* virtualdom/items/Component/prototype/find.js */
	var virtualdom_items_Component$find = function Component$find( selector ) {
		return this.instance.fragment.find( selector );
	};

	/* virtualdom/items/Component/prototype/findAll.js */
	var virtualdom_items_Component$findAll = function Component$findAll( selector, query ) {
		return this.instance.fragment.findAll( selector, query );
	};

	/* virtualdom/items/Component/prototype/findAllComponents.js */
	var virtualdom_items_Component$findAllComponents = function Component$findAllComponents( selector, query ) {
		query._test( this, true );
		if ( this.instance.fragment ) {
			this.instance.fragment.findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Component/prototype/findComponent.js */
	var virtualdom_items_Component$findComponent = function Component$findComponent( selector ) {
		if ( !selector || selector === this.name ) {
			return this.instance;
		}
		if ( this.instance.fragment ) {
			return this.instance.fragment.findComponent( selector );
		}
		return null;
	};

	/* virtualdom/items/Component/prototype/findNextNode.js */
	var virtualdom_items_Component$findNextNode = function Component$findNextNode() {
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Component/prototype/firstNode.js */
	var virtualdom_items_Component$firstNode = function Component$firstNode() {
		if ( this.rendered ) {
			return this.instance.fragment.firstNode();
		}
		return null;
	};

	/* virtualdom/items/Component/initialise/createModel/ComponentParameter.js */
	var ComponentParameter = function( runloop, circular ) {

		var Fragment, ComponentParameter;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		ComponentParameter = function( component, key, value ) {
			this.parentFragment = component.parentFragment;
			this.component = component;
			this.key = key;
			this.fragment = new Fragment( {
				template: value,
				root: component.root,
				owner: this
			} );
			this.value = this.fragment.getValue();
		};
		ComponentParameter.prototype = {
			bubble: function() {
				if ( !this.dirty ) {
					this.dirty = true;
					runloop.addView( this );
				}
			},
			update: function() {
				var value = this.fragment.getValue();
				this.component.instance.viewmodel.set( this.key, value );
				runloop.addViewmodel( this.component.instance.viewmodel );
				this.value = value;
				this.dirty = false;
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			unbind: function() {
				this.fragment.unbind();
			}
		};
		return ComponentParameter;
	}( runloop, circular );

	/* virtualdom/items/Component/initialise/createModel/ReferenceExpressionParameter.js */
	var ReferenceExpressionParameter = function( ReferenceExpressionResolver, createComponentBinding ) {

		var ReferenceExpressionParameter = function( component, childKeypath, template, toBind ) {
			var this$0 = this;
			this.root = component.root;
			this.parentFragment = component.parentFragment;
			this.ready = false;
			this.hash = null;
			this.resolver = new ReferenceExpressionResolver( this, template, function( keypath ) {
				// Are we updating an existing binding?
				if ( this$0.binding || ( this$0.binding = component.bindings[ this$0.hash ] ) ) {
					component.bindings[ this$0.hash ] = null;
					this$0.binding.rebind( keypath );
					this$0.hash = keypath + '=' + childKeypath;
					component.bindings[ this$0.hash ];
				} else {
					if ( !this$0.ready ) {
						// The child instance isn't created yet, we need to create the binding later
						toBind.push( {
							childKeypath: childKeypath,
							parentKeypath: keypath
						} );
					} else {
						createComponentBinding( component, component.root, keypath, childKeypath );
					}
				}
				this$0.value = component.root.viewmodel.get( keypath );
			} );
		};
		ReferenceExpressionParameter.prototype = {
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			unbind: function() {
				this.resolver.unbind();
			}
		};
		return ReferenceExpressionParameter;
	}( ReferenceExpressionResolver, createComponentBinding );

	/* virtualdom/items/Component/initialise/createModel/_createModel.js */
	var createModel = function( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter ) {

		var __export;
		__export = function( component, defaultData, attributes, toBind ) {
			var data = {},
				key, value;
			// some parameters, e.g. foo="The value is {{bar}}", are 'complex' - in
			// other words, we need to construct a string fragment to watch
			// when they change. We store these so they can be torn down later
			component.complexParameters = [];
			for ( key in attributes ) {
				if ( attributes.hasOwnProperty( key ) ) {
					value = getValue( component, key, attributes[ key ], toBind );
					if ( value !== undefined || defaultData[ key ] === undefined ) {
						data[ key ] = value;
					}
				}
			}
			return data;
		};

		function getValue( component, key, template, toBind ) {
			var parameter, parsed, parentInstance, parentFragment, keypath, indexRef;
			parentInstance = component.root;
			parentFragment = component.parentFragment;
			// If this is a static value, great
			if ( typeof template === 'string' ) {
				parsed = parseJSON( template );
				if ( !parsed ) {
					return template;
				}
				return parsed.value;
			}
			// If null, we treat it as a boolean attribute (i.e. true)
			if ( template === null ) {
				return true;
			}
			// Single interpolator?
			if ( template.length === 1 && template[ 0 ].t === types.INTERPOLATOR ) {
				// If it's a regular interpolator, we bind to it
				if ( template[ 0 ].r ) {
					// Is it an index reference?
					if ( parentFragment.indexRefs && parentFragment.indexRefs[ indexRef = template[ 0 ].r ] !== undefined ) {
						component.indexRefBindings[ indexRef ] = key;
						return parentFragment.indexRefs[ indexRef ];
					}
					// TODO what about references that resolve late? Should these be considered?
					keypath = resolveRef( parentInstance, template[ 0 ].r, parentFragment ) || template[ 0 ].r;
					// We need to set up bindings between parent and child, but
					// we can't do it yet because the child instance doesn't exist
					// yet - so we make a note instead
					toBind.push( {
						childKeypath: key,
						parentKeypath: keypath
					} );
					return parentInstance.viewmodel.get( keypath );
				}
				// If it's a reference expression (e.g. `{{foo[bar]}}`), we need
				// to watch the keypath and create/destroy bindings
				if ( template[ 0 ].rx ) {
					parameter = new ReferenceExpressionParameter( component, key, template[ 0 ].rx, toBind );
					component.complexParameters.push( parameter );
					parameter.ready = true;
					return parameter.value;
				}
			}
			// We have a 'complex parameter' - we need to create a full-blown string
			// fragment in order to evaluate and observe its value
			parameter = new ComponentParameter( component, key, template );
			component.complexParameters.push( parameter );
			return parameter.value;
		}
		return __export;
	}( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter );

	/* virtualdom/items/Component/initialise/createInstance.js */
	var createInstance = function( log ) {

		return function( component, Component, data, contentDescriptor ) {
			var instance, parentFragment, partials, ractive;
			parentFragment = component.parentFragment;
			ractive = component.root;
			// Make contents available as a {{>content}} partial
			partials = {
				content: contentDescriptor || []
			};
			if ( Component.defaults.el ) {
				log.warn( {
					debug: ractive.debug,
					message: 'defaultElSpecified',
					args: {
						name: component.name
					}
				} );
			}
			instance = new Component( {
				el: null,
				append: true,
				data: data,
				partials: partials,
				magic: ractive.magic || Component.defaults.magic,
				modifyArrays: ractive.modifyArrays,
				_parent: ractive,
				_component: component,
				// need to inherit runtime parent adaptors
				adapt: ractive.adapt,
				yield: {
					template: contentDescriptor,
					instance: ractive
				}
			} );
			return instance;
		};
	}( log );

	/* virtualdom/items/Component/initialise/createBindings.js */
	var createBindings = function( createComponentBinding ) {

		return function createInitialComponentBindings( component, toBind ) {
			toBind.forEach( function createInitialComponentBinding( pair ) {
				var childValue, parentValue;
				createComponentBinding( component, component.root, pair.parentKeypath, pair.childKeypath );
				childValue = component.instance.viewmodel.get( pair.childKeypath );
				parentValue = component.root.viewmodel.get( pair.parentKeypath );
				if ( childValue !== undefined && parentValue === undefined ) {
					component.root.viewmodel.set( pair.parentKeypath, childValue );
				}
			} );
		};
	}( createComponentBinding );

	/* virtualdom/items/Component/initialise/propagateEvents.js */
	var propagateEvents = function( circular, fireEvent, log ) {

		var __export;
		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		__export = function propagateEvents( component, eventsDescriptor ) {
			var eventName;
			for ( eventName in eventsDescriptor ) {
				if ( eventsDescriptor.hasOwnProperty( eventName ) ) {
					propagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );
				}
			}
		};

		function propagateEvent( childInstance, parentInstance, eventName, proxyEventName ) {
			if ( typeof proxyEventName !== 'string' ) {
				log.error( {
					debug: parentInstance.debug,
					message: 'noComponentEventArguments'
				} );
			}
			childInstance.on( eventName, function() {
				var event, args;
				// semi-weak test, but what else? tag the event obj ._isEvent ?
				if ( arguments.length && arguments[ 0 ] && arguments[ 0 ].node ) {
					event = Array.prototype.shift.call( arguments );
				}
				args = Array.prototype.slice.call( arguments );
				fireEvent( parentInstance, proxyEventName, {
					event: event,
					args: args
				} );
				// cancel bubbling
				return false;
			} );
		}
		return __export;
	}( circular, Ractive$shared_fireEvent, log );

	/* virtualdom/items/Component/initialise/updateLiveQueries.js */
	var updateLiveQueries = function( component ) {
		var ancestor, query;
		// If there's a live query for this component type, add it
		ancestor = component.root;
		while ( ancestor ) {
			if ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {
				query.push( component.instance );
			}
			ancestor = ancestor._parent;
		}
	};

	/* virtualdom/items/Component/prototype/init.js */
	var virtualdom_items_Component$init = function( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries ) {

		return function Component$init( options, Component ) {
			var parentFragment, root, data, toBind;
			parentFragment = this.parentFragment = options.parentFragment;
			root = parentFragment.root;
			this.root = root;
			this.type = types.COMPONENT;
			this.name = options.template.e;
			this.index = options.index;
			this.indexRefBindings = {};
			this.bindings = [];
			// even though only one yielder is allowed, we need to have an array of them
			// as it's possible to cause a yielder to be created before the last one
			// was destroyed in the same turn of the runloop
			this.yielders = [];
			if ( !Component ) {
				throw new Error( 'Component "' + this.name + '" not found' );
			}
			// First, we need to create a model for the component - e.g. if we
			// encounter <widget foo='bar'/> then we need to create a widget
			// with `data: { foo: 'bar' }`.
			//
			// This may involve setting up some bindings, but we can't do it
			// yet so we take some notes instead
			toBind = [];
			data = createModel( this, Component.defaults.data || {}, options.template.a, toBind );
			createInstance( this, Component, data, options.template.f );
			createBindings( this, toBind );
			propagateEvents( this, options.template.v );
			// intro, outro and decorator directives have no effect
			if ( options.template.t1 || options.template.t2 || options.template.o ) {
				warn( 'The "intro", "outro" and "decorator" directives have no effect on components' );
			}
			updateLiveQueries( this );
		};
	}( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries );

	/* virtualdom/items/Component/prototype/rebind.js */
	var virtualdom_items_Component$rebind = function( runloop, getNewKeypath ) {

		return function Component$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var childInstance = this.instance,
				parentInstance = childInstance._parent,
				indexRefAlias, query;
			this.bindings.forEach( function( binding ) {
				var updated;
				if ( binding.root !== parentInstance ) {
					return;
				}
				if ( updated = getNewKeypath( binding.keypath, oldKeypath, newKeypath ) ) {
					binding.rebind( updated );
				}
			} );
			this.complexParameters.forEach( rebind );
			if ( this.yielders[ 0 ] ) {
				rebind( this.yielders[ 0 ] );
			}
			if ( indexRefAlias = this.indexRefBindings[ indexRef ] ) {
				runloop.addViewmodel( childInstance.viewmodel );
				childInstance.viewmodel.set( indexRefAlias, newIndex );
			}
			if ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {
				query._makeDirty();
			}

			function rebind( x ) {
				x.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};
	}( runloop, getNewKeypath );

	/* virtualdom/items/Component/prototype/render.js */
	var virtualdom_items_Component$render = function Component$render() {
		var instance = this.instance;
		instance.render( this.parentFragment.getNode() );
		this.rendered = true;
		return instance.fragment.detach();
	};

	/* virtualdom/items/Component/prototype/toString.js */
	var virtualdom_items_Component$toString = function Component$toString() {
		return this.instance.fragment.toString();
	};

	/* virtualdom/items/Component/prototype/unbind.js */
	var virtualdom_items_Component$unbind = function( Hook, removeFromArray ) {

		var __export;
		var teardownHook = new Hook( 'teardown' );
		__export = function Component$unbind() {
			var instance = this.instance;
			this.complexParameters.forEach( unbind );
			this.bindings.forEach( unbind );
			removeFromLiveComponentQueries( this );
			// teardown the instance
			instance.fragment.unbind();
			instance.viewmodel.teardown();
			if ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {
				removeFromArray( instance.el.__ractive_instances__, instance );
			}
			teardownHook.fire( instance );
		};

		function unbind( thing ) {
			thing.unbind();
		}

		function removeFromLiveComponentQueries( component ) {
			var instance, query;
			instance = component.root;
			do {
				if ( query = instance._liveComponentQueries[ '_' + component.name ] ) {
					query._remove( component );
				}
			} while ( instance = instance._parent );
		}
		return __export;
	}( Ractive$shared_hooks_Hook, removeFromArray );

	/* virtualdom/items/Component/prototype/unrender.js */
	var virtualdom_items_Component$unrender = function Component$unrender( shouldDestroy ) {
		this.shouldDestroy = shouldDestroy;
		this.instance.unrender();
	};

	/* virtualdom/items/Component/_Component.js */
	var Component = function( detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, init, rebind, render, toString, unbind, unrender ) {

		var Component = function( options, Constructor ) {
			this.init( options, Constructor );
		};
		Component.prototype = {
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		return Component;
	}( virtualdom_items_Component$detach, virtualdom_items_Component$find, virtualdom_items_Component$findAll, virtualdom_items_Component$findAllComponents, virtualdom_items_Component$findComponent, virtualdom_items_Component$findNextNode, virtualdom_items_Component$firstNode, virtualdom_items_Component$init, virtualdom_items_Component$rebind, virtualdom_items_Component$render, virtualdom_items_Component$toString, virtualdom_items_Component$unbind, virtualdom_items_Component$unrender );

	/* virtualdom/items/Comment.js */
	var Comment = function( types, detach ) {

		var Comment = function( options ) {
			this.type = types.COMMENT;
			this.value = options.template.c;
		};
		Comment.prototype = {
			detach: detach,
			firstNode: function() {
				return this.node;
			},
			render: function() {
				if ( !this.node ) {
					this.node = document.createComment( this.value );
				}
				return this.node;
			},
			toString: function() {
				return '<!--' + this.value + '-->';
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					this.node.parentNode.removeChild( this.node );
				}
			}
		};
		return Comment;
	}( types, detach );

	/* virtualdom/items/Yielder.js */
	var Yielder = function( runloop, removeFromArray, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		var Yielder = function( options ) {
			var componentInstance, component;
			componentInstance = options.parentFragment.root;
			this.component = component = componentInstance.component;
			this.surrogateParent = options.parentFragment;
			this.parentFragment = component.parentFragment;
			this.fragment = new Fragment( {
				owner: this,
				root: componentInstance.yield.instance,
				template: componentInstance.yield.template,
				pElement: this.surrogateParent.pElement
			} );
			component.yielders.push( this );
			runloop.scheduleTask( function() {
				if ( component.yielders.length > 1 ) {
					throw new Error( 'A component template can only have one {{yield}} declaration at a time' );
				}
			} );
		};
		Yielder.prototype = {
			detach: function() {
				return this.fragment.detach();
			},
			find: function( selector ) {
				return this.fragment.find( selector );
			},
			findAll: function( selector, query ) {
				return this.fragment.findAll( selector, query );
			},
			findComponent: function( selector ) {
				return this.fragment.findComponent( selector );
			},
			findAllComponents: function( selector, query ) {
				return this.fragment.findAllComponents( selector, query );
			},
			findNextNode: function() {
				return this.surrogateParent.findNextNode( this );
			},
			firstNode: function() {
				return this.fragment.firstNode();
			},
			getValue: function( options ) {
				return this.fragment.getValue( options );
			},
			render: function() {
				return this.fragment.render();
			},
			unbind: function() {
				this.fragment.unbind();
			},
			unrender: function( shouldDestroy ) {
				this.fragment.unrender( shouldDestroy );
				removeFromArray( this.component.yielders, this );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			toString: function() {
				return this.fragment.toString();
			}
		};
		return Yielder;
	}( runloop, removeFromArray, circular );

	/* virtualdom/Fragment/prototype/init/createItem.js */
	var virtualdom_Fragment$init_createItem = function( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder ) {

		return function createItem( options ) {
			if ( typeof options.template === 'string' ) {
				return new Text( options );
			}
			switch ( options.template.t ) {
				case types.INTERPOLATOR:
					if ( options.template.r === 'yield' ) {
						return new Yielder( options );
					}
					return new Interpolator( options );
				case types.SECTION:
					return new Section( options );
				case types.TRIPLE:
					return new Triple( options );
				case types.ELEMENT:
					var constructor;
					if ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {
						return new Component( options, constructor );
					}
					return new Element( options );
				case types.PARTIAL:
					return new Partial( options );
				case types.COMMENT:
					return new Comment( options );
				default:
					throw new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );
			}
		};
	}( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder );

	/* virtualdom/Fragment/prototype/init.js */
	var virtualdom_Fragment$init = function( types, create, createItem ) {

		return function Fragment$init( options ) {
			var this$0 = this;
			var parentFragment, parentRefs, ref;
			// The item that owns this fragment - an element, section, partial, or attribute
			this.owner = options.owner;
			parentFragment = this.parent = this.owner.parentFragment;
			// inherited properties
			this.root = options.root;
			this.pElement = options.pElement;
			this.context = options.context;
			// If parent item is a section, this may not be the only fragment
			// that belongs to it - we need to make a note of the index
			if ( this.owner.type === types.SECTION ) {
				this.index = options.index;
			}
			// index references (the 'i' in {{#section:i}}...{{/section}}) need to cascade
			// down the tree
			if ( parentFragment ) {
				parentRefs = parentFragment.indexRefs;
				if ( parentRefs ) {
					this.indexRefs = create( null );
					// avoids need for hasOwnProperty
					for ( ref in parentRefs ) {
						this.indexRefs[ ref ] = parentRefs[ ref ];
					}
				}
			}
			if ( options.indexRef ) {
				if ( !this.indexRefs ) {
					this.indexRefs = {};
				}
				this.indexRefs[ options.indexRef ] = options.index;
			}
			// Time to create this fragment's child items
			// TEMP should this be happening?
			if ( typeof options.template === 'string' ) {
				options.template = [ options.template ];
			} else if ( !options.template ) {
				options.template = [];
			}
			this.items = options.template.map( function( template, i ) {
				return createItem( {
					parentFragment: this$0,
					pElement: options.pElement,
					template: template,
					index: i
				} );
			} );
			this.value = this.argsList = null;
			this.dirtyArgs = this.dirtyValue = true;
			this.bound = true;
		};
	}( types, create, virtualdom_Fragment$init_createItem );

	/* virtualdom/Fragment/prototype/rebind.js */
	var virtualdom_Fragment$rebind = function( assignNewKeypath ) {

		return function Fragment$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			this.index = newIndex;
			// assign new context keypath if needed
			assignNewKeypath( this, 'context', oldKeypath, newKeypath );
			if ( this.indexRefs && this.indexRefs[ indexRef ] !== undefined ) {
				this.indexRefs[ indexRef ] = newIndex;
			}
			this.items.forEach( function( item ) {
				if ( item.rebind ) {
					item.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			} );
		};
	}( assignNewKeypath );

	/* virtualdom/Fragment/prototype/render.js */
	var virtualdom_Fragment$render = function Fragment$render() {
		var result;
		if ( this.items.length === 1 ) {
			result = this.items[ 0 ].render();
		} else {
			result = document.createDocumentFragment();
			this.items.forEach( function( item ) {
				result.appendChild( item.render() );
			} );
		}
		this.rendered = true;
		return result;
	};

	/* virtualdom/Fragment/prototype/toString.js */
	var virtualdom_Fragment$toString = function Fragment$toString( escape ) {
		if ( !this.items ) {
			return '';
		}
		return this.items.map( function( item ) {
			return item.toString( escape );
		} ).join( '' );
	};

	/* virtualdom/Fragment/prototype/unbind.js */
	var virtualdom_Fragment$unbind = function() {

		var __export;
		__export = function Fragment$unbind() {
			if ( !this.bound ) {
				return;
			}
			this.items.forEach( unbindItem );
			this.bound = false;
		};

		function unbindItem( item ) {
			if ( item.unbind ) {
				item.unbind();
			}
		}
		return __export;
	}();

	/* virtualdom/Fragment/prototype/unrender.js */
	var virtualdom_Fragment$unrender = function Fragment$unrender( shouldDestroy ) {
		if ( !this.rendered ) {
			throw new Error( 'Attempted to unrender a fragment that was not rendered' );
		}
		this.items.forEach( function( i ) {
			return i.unrender( shouldDestroy );
		} );
		this.rendered = false;
	};

	/* virtualdom/Fragment.js */
	var Fragment = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getNode, getValue, init, rebind, render, toString, unbind, unrender, circular ) {

		var Fragment = function( options ) {
			this.init( options );
		};
		Fragment.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getNode: getNode,
			getValue: getValue,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		circular.Fragment = Fragment;
		return Fragment;
	}( virtualdom_Fragment$bubble, virtualdom_Fragment$detach, virtualdom_Fragment$find, virtualdom_Fragment$findAll, virtualdom_Fragment$findAllComponents, virtualdom_Fragment$findComponent, virtualdom_Fragment$findNextNode, virtualdom_Fragment$firstNode, virtualdom_Fragment$getNode, virtualdom_Fragment$getValue, virtualdom_Fragment$init, virtualdom_Fragment$rebind, virtualdom_Fragment$render, virtualdom_Fragment$toString, virtualdom_Fragment$unbind, virtualdom_Fragment$unrender, circular );

	/* Ractive/prototype/reset.js */
	var Ractive$reset = function( Hook, runloop, Fragment, config ) {

		var shouldRerender = [
				'template',
				'partials',
				'components',
				'decorators',
				'events'
			],
			resetHook = new Hook( 'reset' );
		return function Ractive$reset( data, callback ) {
			var promise, wrapper, changes, i, rerender;
			if ( typeof data === 'function' && !callback ) {
				callback = data;
				data = {};
			} else {
				data = data || {};
			}
			if ( typeof data !== 'object' ) {
				throw new Error( 'The reset method takes either no arguments, or an object containing new data' );
			}
			// If the root object is wrapped, try and use the wrapper's reset value
			if ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {
				if ( wrapper.reset( data ) === false ) {
					// reset was rejected, we need to replace the object
					this.data = data;
				}
			} else {
				this.data = data;
			}
			// reset config items and track if need to rerender
			changes = config.reset( this );
			i = changes.length;
			while ( i-- ) {
				if ( shouldRerender.indexOf( changes[ i ] ) > -1 ) {
					rerender = true;
					break;
				}
			}
			if ( rerender ) {
				var component;
				this.viewmodel.mark( '' );
				// Is this is a component, we need to set the `shouldDestroy`
				// flag, otherwise it will assume by default that a parent node
				// will be detached, and therefore it doesn't need to bother
				// detaching its own nodes
				if ( component = this.component ) {
					component.shouldDestroy = true;
				}
				this.unrender();
				if ( component ) {
					component.shouldDestroy = false;
				}
				// If the template changed, we need to destroy the parallel DOM
				// TODO if we're here, presumably it did?
				if ( this.fragment.template !== this.template ) {
					this.fragment.unbind();
					this.fragment = new Fragment( {
						template: this.template,
						root: this,
						owner: this
					} );
				}
				promise = this.render( this.el, this.anchor );
			} else {
				promise = runloop.start( this, true );
				this.viewmodel.mark( '' );
				runloop.end();
			}
			resetHook.fire( this, data );
			if ( callback ) {
				promise.then( callback );
			}
			return promise;
		};
	}( Ractive$shared_hooks_Hook, runloop, Fragment, config );

	/* Ractive/prototype/resetTemplate.js */
	var Ractive$resetTemplate = function( config, Fragment ) {

		return function Ractive$resetTemplate( template ) {
			var transitionsEnabled, component;
			config.template.init( null, this, {
				template: template
			} );
			transitionsEnabled = this.transitionsEnabled;
			this.transitionsEnabled = false;
			// Is this is a component, we need to set the `shouldDestroy`
			// flag, otherwise it will assume by default that a parent node
			// will be detached, and therefore it doesn't need to bother
			// detaching its own nodes
			if ( component = this.component ) {
				component.shouldDestroy = true;
			}
			this.unrender();
			if ( component ) {
				component.shouldDestroy = false;
			}
			// remove existing fragment and create new one
			this.fragment.unbind();
			this.fragment = new Fragment( {
				template: this.template,
				root: this,
				owner: this
			} );
			this.render( this.el, this.anchor );
			this.transitionsEnabled = transitionsEnabled;
		};
	}( config, Fragment );

	/* Ractive/prototype/reverse.js */
	var Ractive$reverse = function( makeArrayMethod ) {

		return makeArrayMethod( 'reverse' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/set.js */
	var Ractive$set = function( runloop, isObject, normaliseKeypath, getMatchingKeypaths ) {

		var wildcard = /\*/;
		return function Ractive$set( keypath, value, callback ) {
			var this$0 = this;
			var map, promise;
			promise = runloop.start( this, true );
			// Set multiple keypaths in one go
			if ( isObject( keypath ) ) {
				map = keypath;
				callback = value;
				for ( keypath in map ) {
					if ( map.hasOwnProperty( keypath ) ) {
						value = map[ keypath ];
						keypath = normaliseKeypath( keypath );
						this.viewmodel.set( keypath, value );
					}
				}
			} else {
				keypath = normaliseKeypath( keypath );
				if ( wildcard.test( keypath ) ) {
					getMatchingKeypaths( this, keypath ).forEach( function( keypath ) {
						this$0.viewmodel.set( keypath, value );
					} );
				} else {
					this.viewmodel.set( keypath, value );
				}
			}
			runloop.end();
			if ( callback ) {
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( runloop, isObject, normaliseKeypath, getMatchingKeypaths );

	/* Ractive/prototype/shift.js */
	var Ractive$shift = function( makeArrayMethod ) {

		return makeArrayMethod( 'shift' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/sort.js */
	var Ractive$sort = function( makeArrayMethod ) {

		return makeArrayMethod( 'sort' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/splice.js */
	var Ractive$splice = function( makeArrayMethod ) {

		return makeArrayMethod( 'splice' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/subtract.js */
	var Ractive$subtract = function( add ) {

		return function Ractive$subtract( keypath, d ) {
			return add( this, keypath, d === undefined ? -1 : -d );
		};
	}( Ractive$shared_add );

	/* Ractive/prototype/teardown.js */
	var Ractive$teardown = function( Hook, Promise, removeFromArray ) {

		var teardownHook = new Hook( 'teardown' );
		// Teardown. This goes through the root fragment and all its children, removing observers
		// and generally cleaning up after itself
		return function Ractive$teardown( callback ) {
			var promise;
			this.fragment.unbind();
			this.viewmodel.teardown();
			if ( this.fragment.rendered && this.el.__ractive_instances__ ) {
				removeFromArray( this.el.__ractive_instances__, this );
			}
			this.shouldDestroy = true;
			promise = this.fragment.rendered ? this.unrender() : Promise.resolve();
			teardownHook.fire( this );
			if ( callback ) {
				// TODO deprecate this?
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( Ractive$shared_hooks_Hook, Promise, removeFromArray );

	/* Ractive/prototype/toggle.js */
	var Ractive$toggle = function( log ) {

		return function Ractive$toggle( keypath, callback ) {
			var value;
			if ( typeof keypath !== 'string' ) {
				log.errorOnly( {
					debug: this.debug,
					messsage: 'badArguments',
					arg: {
						arguments: keypath
					}
				} );
			}
			value = this.get( keypath );
			return this.set( keypath, !value, callback );
		};
	}( log );

	/* Ractive/prototype/toHTML.js */
	var Ractive$toHTML = function Ractive$toHTML() {
		return this.fragment.toString( true );
	};

	/* Ractive/prototype/unrender.js */
	var Ractive$unrender = function( css, Hook, log, Promise, removeFromArray, runloop ) {

		var unrenderHook = new Hook( 'unrender' );
		return function Ractive$unrender() {
			var this$0 = this;
			var promise, shouldDestroy;
			if ( !this.fragment.rendered ) {
				log.warn( {
					debug: this.debug,
					message: 'ractive.unrender() was called on a Ractive instance that was not rendered'
				} );
				return Promise.resolve();
			}
			promise = runloop.start( this, true );
			// If this is a component, and the component isn't marked for destruction,
			// don't detach nodes from the DOM unnecessarily
			shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;
			if ( this.constructor.css ) {
				promise.then( function() {
					css.remove( this$0.constructor );
				} );
			}
			// Cancel any animations in progress
			while ( this._animations[ 0 ] ) {
				this._animations[ 0 ].stop();
			}
			this.fragment.unrender( shouldDestroy );
			removeFromArray( this.el.__ractive_instances__, this );
			unrenderHook.fire( this );
			runloop.end();
			return promise;
		};
	}( global_css, Ractive$shared_hooks_Hook, log, Promise, removeFromArray, runloop );

	/* Ractive/prototype/unshift.js */
	var Ractive$unshift = function( makeArrayMethod ) {

		return makeArrayMethod( 'unshift' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/update.js */
	var Ractive$update = function( Hook, runloop ) {

		var updateHook = new Hook( 'update' );
		return function Ractive$update( keypath, callback ) {
			var promise;
			if ( typeof keypath === 'function' ) {
				callback = keypath;
				keypath = '';
			} else {
				keypath = keypath || '';
			}
			promise = runloop.start( this, true );
			this.viewmodel.mark( keypath );
			runloop.end();
			updateHook.fire( this, keypath );
			if ( callback ) {
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( Ractive$shared_hooks_Hook, runloop );

	/* Ractive/prototype/updateModel.js */
	var Ractive$updateModel = function( arrayContentsMatch, isEqual ) {

		var __export;
		__export = function Ractive$updateModel( keypath, cascade ) {
			var values;
			if ( typeof keypath !== 'string' ) {
				keypath = '';
				cascade = true;
			}
			consolidateChangedValues( this, keypath, values = {}, cascade );
			return this.set( values );
		};

		function consolidateChangedValues( ractive, keypath, values, cascade ) {
			var bindings, childDeps, i, binding, oldValue, newValue, checkboxGroups = [];
			bindings = ractive._twowayBindings[ keypath ];
			if ( bindings && ( i = bindings.length ) ) {
				while ( i-- ) {
					binding = bindings[ i ];
					// special case - radio name bindings
					if ( binding.radioName && !binding.element.node.checked ) {
						continue;
					}
					// special case - checkbox name bindings come in groups, so
					// we want to get the value once at most
					if ( binding.checkboxName ) {
						if ( !checkboxGroups[ binding.keypath ] && !binding.changed() ) {
							checkboxGroups.push( binding.keypath );
							checkboxGroups[ binding.keypath ] = binding;
						}
						continue;
					}
					oldValue = binding.attribute.value;
					newValue = binding.getValue();
					if ( arrayContentsMatch( oldValue, newValue ) ) {
						continue;
					}
					if ( !isEqual( oldValue, newValue ) ) {
						values[ keypath ] = newValue;
					}
				}
			}
			// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`
			if ( checkboxGroups.length ) {
				checkboxGroups.forEach( function( keypath ) {
					var binding, oldValue, newValue;
					binding = checkboxGroups[ keypath ];
					// one to represent the entire group
					oldValue = binding.attribute.value;
					newValue = binding.getValue();
					if ( !arrayContentsMatch( oldValue, newValue ) ) {
						values[ keypath ] = newValue;
					}
				} );
			}
			if ( !cascade ) {
				return;
			}
			// cascade
			childDeps = ractive.viewmodel.depsMap[ 'default' ][ keypath ];
			if ( childDeps ) {
				i = childDeps.length;
				while ( i-- ) {
					consolidateChangedValues( ractive, childDeps[ i ], values, cascade );
				}
			}
		}
		return __export;
	}( arrayContentsMatch, isEqual );

	/* Ractive/prototype.js */
	var prototype = function( add, animate, detach, find, findAll, findAllComponents, findComponent, fire, get, insert, merge, observe, off, on, pop, push, render, reset, resetTemplate, reverse, set, shift, sort, splice, subtract, teardown, toggle, toHTML, unrender, unshift, update, updateModel ) {

		return {
			add: add,
			animate: animate,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			fire: fire,
			get: get,
			insert: insert,
			merge: merge,
			observe: observe,
			off: off,
			on: on,
			pop: pop,
			push: push,
			render: render,
			reset: reset,
			resetTemplate: resetTemplate,
			reverse: reverse,
			set: set,
			shift: shift,
			sort: sort,
			splice: splice,
			subtract: subtract,
			teardown: teardown,
			toggle: toggle,
			toHTML: toHTML,
			unrender: unrender,
			unshift: unshift,
			update: update,
			updateModel: updateModel
		};
	}( Ractive$add, Ractive$animate, Ractive$detach, Ractive$find, Ractive$findAll, Ractive$findAllComponents, Ractive$findComponent, Ractive$fire, Ractive$get, Ractive$insert, Ractive$merge, Ractive$observe, Ractive$off, Ractive$on, Ractive$pop, Ractive$push, Ractive$render, Ractive$reset, Ractive$resetTemplate, Ractive$reverse, Ractive$set, Ractive$shift, Ractive$sort, Ractive$splice, Ractive$subtract, Ractive$teardown, Ractive$toggle, Ractive$toHTML, Ractive$unrender, Ractive$unshift, Ractive$update, Ractive$updateModel );

	/* utils/getGuid.js */
	var getGuid = function() {
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g, function( c ) {
			var r, v;
			r = Math.random() * 16 | 0;
			v = c == 'x' ? r : r & 3 | 8;
			return v.toString( 16 );
		} );
	};

	/* utils/getNextNumber.js */
	var getNextNumber = function() {

		var i = 0;
		return function() {
			return 'r-' + i++;
		};
	}();

	/* Ractive/prototype/shared/hooks/HookQueue.js */
	var Ractive$shared_hooks_HookQueue = function( Hook ) {

		function HookQueue( event ) {
			this.hook = new Hook( event );
			this.inProcess = {};
			this.queue = {};
		}
		HookQueue.prototype = {
			constructor: HookQueue,
			begin: function( ractive ) {
				this.inProcess[ ractive._guid ] = true;
			},
			end: function( ractive ) {
				var parent = ractive._parent;
				// If this is *isn't* a child of a component that's in process,
				// it should call methods or fire at this point
				if ( !parent || !this.inProcess[ parent._guid ] ) {
					fire( this, ractive );
				} else {
					getChildQueue( this.queue, parent ).push( ractive );
				}
				delete this.inProcess[ ractive._guid ];
			}
		};

		function getChildQueue( queue, ractive ) {
			return queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );
		}

		function fire( hookQueue, ractive ) {
			var childQueue = getChildQueue( hookQueue.queue, ractive );
			hookQueue.hook.fire( ractive );
			// queue is "live" because components can end up being
			// added while hooks fire on parents that modify data values.
			while ( childQueue.length ) {
				fire( hookQueue, childQueue.shift() );
			}
			delete hookQueue.queue[ ractive._guid ];
		}
		return HookQueue;
	}( Ractive$shared_hooks_Hook );

	/* viewmodel/prototype/get/arrayAdaptor/processWrapper.js */
	var viewmodel$get_arrayAdaptor_processWrapper = function( wrapper, array, methodName, newIndices ) {
		var root = wrapper.root,
			keypath = wrapper.keypath;
		// If this is a sort or reverse, we just do root.set()...
		// TODO use merge logic?
		if ( methodName === 'sort' || methodName === 'reverse' ) {
			root.viewmodel.set( keypath, array );
			return;
		}
		root.viewmodel.smartUpdate( keypath, array, newIndices );
	};

	/* viewmodel/prototype/get/arrayAdaptor/patch.js */
	var viewmodel$get_arrayAdaptor_patch = function( runloop, defineProperty, getNewIndices, processWrapper ) {

		var patchedArrayProto = [],
			mutatorMethods = [
				'pop',
				'push',
				'reverse',
				'shift',
				'sort',
				'splice',
				'unshift'
			],
			testObj, patchArrayMethods, unpatchArrayMethods;
		mutatorMethods.forEach( function( methodName ) {
			var method = function() {
				var SLICE$0 = Array.prototype.slice;
				var args = SLICE$0.call( arguments, 0 );
				var newIndices, result, wrapper, i;
				newIndices = getNewIndices( this, methodName, args );
				// apply the underlying method
				result = Array.prototype[ methodName ].apply( this, arguments );
				// trigger changes
				runloop.start();
				this._ractive.setting = true;
				i = this._ractive.wrappers.length;
				while ( i-- ) {
					wrapper = this._ractive.wrappers[ i ];
					runloop.addViewmodel( wrapper.root.viewmodel );
					processWrapper( wrapper, this, methodName, newIndices );
				}
				runloop.end();
				this._ractive.setting = false;
				return result;
			};
			defineProperty( patchedArrayProto, methodName, {
				value: method
			} );
		} );
		// can we use prototype chain injection?
		// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
		testObj = {};
		if ( testObj.__proto__ ) {
			// yes, we can
			patchArrayMethods = function( array ) {
				array.__proto__ = patchedArrayProto;
			};
			unpatchArrayMethods = function( array ) {
				array.__proto__ = Array.prototype;
			};
		} else {
			// no, we can't
			patchArrayMethods = function( array ) {
				var i, methodName;
				i = mutatorMethods.length;
				while ( i-- ) {
					methodName = mutatorMethods[ i ];
					defineProperty( array, methodName, {
						value: patchedArrayProto[ methodName ],
						configurable: true
					} );
				}
			};
			unpatchArrayMethods = function( array ) {
				var i;
				i = mutatorMethods.length;
				while ( i-- ) {
					delete array[ mutatorMethods[ i ] ];
				}
			};
		}
		patchArrayMethods.unpatch = unpatchArrayMethods;
		return patchArrayMethods;
	}( runloop, defineProperty, getNewIndices, viewmodel$get_arrayAdaptor_processWrapper );

	/* viewmodel/prototype/get/arrayAdaptor.js */
	var viewmodel$get_arrayAdaptor = function( defineProperty, isArray, patch ) {

		var arrayAdaptor,
			// helpers
			ArrayWrapper, errorMessage;
		arrayAdaptor = {
			filter: function( object ) {
				// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
				// or the array didn't trigger the get() itself
				return isArray( object ) && ( !object._ractive || !object._ractive.setting );
			},
			wrap: function( ractive, array, keypath ) {
				return new ArrayWrapper( ractive, array, keypath );
			}
		};
		ArrayWrapper = function( ractive, array, keypath ) {
			this.root = ractive;
			this.value = array;
			this.keypath = keypath;
			// if this array hasn't already been ractified, ractify it
			if ( !array._ractive ) {
				// define a non-enumerable _ractive property to store the wrappers
				defineProperty( array, '_ractive', {
					value: {
						wrappers: [],
						instances: [],
						setting: false
					},
					configurable: true
				} );
				patch( array );
			}
			// store the ractive instance, so we can handle transitions later
			if ( !array._ractive.instances[ ractive._guid ] ) {
				array._ractive.instances[ ractive._guid ] = 0;
				array._ractive.instances.push( ractive );
			}
			array._ractive.instances[ ractive._guid ] += 1;
			array._ractive.wrappers.push( this );
		};
		ArrayWrapper.prototype = {
			get: function() {
				return this.value;
			},
			teardown: function() {
				var array, storage, wrappers, instances, index;
				array = this.value;
				storage = array._ractive;
				wrappers = storage.wrappers;
				instances = storage.instances;
				// if teardown() was invoked because we're clearing the cache as a result of
				// a change that the array itself triggered, we can save ourselves the teardown
				// and immediate setup
				if ( storage.setting ) {
					return false;
				}
				index = wrappers.indexOf( this );
				if ( index === -1 ) {
					throw new Error( errorMessage );
				}
				wrappers.splice( index, 1 );
				// if nothing else depends on this array, we can revert it to its
				// natural state
				if ( !wrappers.length ) {
					delete array._ractive;
					patch.unpatch( this.value );
				} else {
					// remove ractive instance if possible
					instances[ this.root._guid ] -= 1;
					if ( !instances[ this.root._guid ] ) {
						index = instances.indexOf( this.root );
						if ( index === -1 ) {
							throw new Error( errorMessage );
						}
						instances.splice( index, 1 );
					}
				}
			}
		};
		errorMessage = 'Something went wrong in a rather interesting way';
		return arrayAdaptor;
	}( defineProperty, isArray, viewmodel$get_arrayAdaptor_patch );

	/* viewmodel/prototype/get/magicArrayAdaptor.js */
	var viewmodel$get_magicArrayAdaptor = function( magicAdaptor, arrayAdaptor ) {

		var magicArrayAdaptor, MagicArrayWrapper;
		if ( magicAdaptor ) {
			magicArrayAdaptor = {
				filter: function( object, keypath, ractive ) {
					return magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );
				},
				wrap: function( ractive, array, keypath ) {
					return new MagicArrayWrapper( ractive, array, keypath );
				}
			};
			MagicArrayWrapper = function( ractive, array, keypath ) {
				this.value = array;
				this.magic = true;
				this.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );
				this.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );
			};
			MagicArrayWrapper.prototype = {
				get: function() {
					return this.value;
				},
				teardown: function() {
					this.arrayWrapper.teardown();
					this.magicWrapper.teardown();
				},
				reset: function( value ) {
					return this.magicWrapper.reset( value );
				}
			};
		}
		return magicArrayAdaptor;
	}( viewmodel$get_magicAdaptor, viewmodel$get_arrayAdaptor );

	/* viewmodel/prototype/adapt.js */
	var viewmodel$adapt = function( config, arrayAdaptor, log, magicAdaptor, magicArrayAdaptor ) {

		var __export;
		var prefixers = {};
		__export = function Viewmodel$adapt( keypath, value ) {
			var ractive = this.ractive,
				len, i, adaptor, wrapped;
			// Do we have an adaptor for this value?
			len = ractive.adapt.length;
			for ( i = 0; i < len; i += 1 ) {
				adaptor = ractive.adapt[ i ];
				// Adaptors can be specified as e.g. [ 'Backbone.Model', 'Backbone.Collection' ] -
				// we need to get the actual adaptor if that's the case
				if ( typeof adaptor === 'string' ) {
					var found = config.registries.adaptors.find( ractive, adaptor );
					if ( !found ) {
						// will throw. "return" for safety, if we downgrade :)
						return log.critical( {
							debug: ractive.debug,
							message: 'missingPlugin',
							args: {
								plugin: 'adaptor',
								name: adaptor
							}
						} );
					}
					adaptor = ractive.adapt[ i ] = found;
				}
				if ( adaptor.filter( value, keypath, ractive ) ) {
					wrapped = this.wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );
					wrapped.value = value;
					return value;
				}
			}
			if ( ractive.magic ) {
				if ( magicArrayAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = magicArrayAdaptor.wrap( ractive, value, keypath );
				} else if ( magicAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = magicAdaptor.wrap( ractive, value, keypath );
				}
			} else if ( ractive.modifyArrays && arrayAdaptor.filter( value, keypath, ractive ) ) {
				this.wrapped[ keypath ] = arrayAdaptor.wrap( ractive, value, keypath );
			}
			return value;
		};

		function prefixKeypath( obj, prefix ) {
			var prefixed = {},
				key;
			if ( !prefix ) {
				return obj;
			}
			prefix += '.';
			for ( key in obj ) {
				if ( obj.hasOwnProperty( key ) ) {
					prefixed[ prefix + key ] = obj[ key ];
				}
			}
			return prefixed;
		}

		function getPrefixer( rootKeypath ) {
			var rootDot;
			if ( !prefixers[ rootKeypath ] ) {
				rootDot = rootKeypath ? rootKeypath + '.' : '';
				prefixers[ rootKeypath ] = function( relativeKeypath, value ) {
					var obj;
					if ( typeof relativeKeypath === 'string' ) {
						obj = {};
						obj[ rootDot + relativeKeypath ] = value;
						return obj;
					}
					if ( typeof relativeKeypath === 'object' ) {
						// 'relativeKeypath' is in fact a hash, not a keypath
						return rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;
					}
				};
			}
			return prefixers[ rootKeypath ];
		}
		return __export;
	}( config, viewmodel$get_arrayAdaptor, log, viewmodel$get_magicAdaptor, viewmodel$get_magicArrayAdaptor );

	/* viewmodel/helpers/getUpstreamChanges.js */
	var getUpstreamChanges = function getUpstreamChanges( changes ) {
		var upstreamChanges = [ '' ],
			i, keypath, keys, upstreamKeypath;
		i = changes.length;
		while ( i-- ) {
			keypath = changes[ i ];
			keys = keypath.split( '.' );
			while ( keys.length > 1 ) {
				keys.pop();
				upstreamKeypath = keys.join( '.' );
				if ( upstreamChanges.indexOf( upstreamKeypath ) === -1 ) {
					upstreamChanges.push( upstreamKeypath );
				}
			}
		}
		return upstreamChanges;
	};

	/* viewmodel/prototype/applyChanges/getPotentialWildcardMatches.js */
	var viewmodel$applyChanges_getPotentialWildcardMatches = function() {

		var __export;
		var starMaps = {};
		// This function takes a keypath such as 'foo.bar.baz', and returns
		// all the variants of that keypath that include a wildcard in place
		// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
		// These are then checked against the dependants map (ractive.viewmodel.depsMap)
		// to see if any pattern observers are downstream of one or more of
		// these wildcard keypaths (e.g. 'foo.bar.*.status')
		__export = function getPotentialWildcardMatches( keypath ) {
			var keys, starMap, mapper, result;
			keys = keypath.split( '.' );
			starMap = getStarMap( keys.length );
			mapper = function( star, i ) {
				return star ? '*' : keys[ i ];
			};
			result = starMap.map( function( mask ) {
				return mask.map( mapper ).join( '.' );
			} );
			return result;
		};
		// This function returns all the possible true/false combinations for
		// a given number - e.g. for two, the possible combinations are
		// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
		// It does so by getting all the binary values between 0 and e.g. 11
		function getStarMap( length ) {
			var ones = '',
				max, binary, starMap, mapper, i;
			if ( !starMaps[ length ] ) {
				starMap = [];
				while ( ones.length < length ) {
					ones += 1;
				}
				max = parseInt( ones, 2 );
				mapper = function( digit ) {
					return digit === '1';
				};
				for ( i = 0; i <= max; i += 1 ) {
					binary = i.toString( 2 );
					while ( binary.length < length ) {
						binary = '0' + binary;
					}
					starMap[ i ] = Array.prototype.map.call( binary, mapper );
				}
				starMaps[ length ] = starMap;
			}
			return starMaps[ length ];
		}
		return __export;
	}();

	/* viewmodel/prototype/applyChanges/notifyPatternObservers.js */
	var viewmodel$applyChanges_notifyPatternObservers = function( getPotentialWildcardMatches ) {

		var __export;
		var lastKey = /[^\.]+$/;
		__export = notifyPatternObservers;

		function notifyPatternObservers( viewmodel, keypath, onlyDirect ) {
			var potentialWildcardMatches;
			updateMatchingPatternObservers( viewmodel, keypath );
			if ( onlyDirect ) {
				return;
			}
			potentialWildcardMatches = getPotentialWildcardMatches( keypath );
			potentialWildcardMatches.forEach( function( upstreamPattern ) {
				cascade( viewmodel, upstreamPattern, keypath );
			} );
		}

		function cascade( viewmodel, upstreamPattern, keypath ) {
			var group, map, actualChildKeypath;
			group = viewmodel.depsMap.patternObservers;
			map = group[ upstreamPattern ];
			if ( map ) {
				map.forEach( function( childKeypath ) {
					var key = lastKey.exec( childKeypath )[ 0 ];
					// 'baz'
					actualChildKeypath = keypath ? keypath + '.' + key : key;
					// 'foo.bar.baz'
					updateMatchingPatternObservers( viewmodel, actualChildKeypath );
					cascade( viewmodel, childKeypath, actualChildKeypath );
				} );
			}
		}

		function updateMatchingPatternObservers( viewmodel, keypath ) {
			viewmodel.patternObservers.forEach( function( observer ) {
				if ( observer.regex.test( keypath ) ) {
					observer.update( keypath );
				}
			} );
		}
		return __export;
	}( viewmodel$applyChanges_getPotentialWildcardMatches );

	/* viewmodel/prototype/applyChanges.js */
	var viewmodel$applyChanges = function( getUpstreamChanges, notifyPatternObservers ) {

		var __export;
		__export = function Viewmodel$applyChanges() {
			var this$0 = this;
			var self = this,
				changes, upstreamChanges, hash = {};
			changes = this.changes;
			if ( !changes.length ) {
				// TODO we end up here on initial render. Perhaps we shouldn't?
				return;
			}

			function cascade( keypath ) {
				var map, dependants, keys;
				if ( self.noCascade.hasOwnProperty( keypath ) ) {
					return;
				}
				if ( dependants = self.deps.computed[ keypath ] ) {
					dependants.forEach( invalidate );
					keys = dependants.map( getKey );
					keys.forEach( mark );
					keys.forEach( cascade );
				}
				if ( map = self.depsMap.computed[ keypath ] ) {
					map.forEach( cascade );
				}
			}

			function mark( keypath ) {
				self.mark( keypath );
			}
			changes.forEach( cascade );
			upstreamChanges = getUpstreamChanges( changes );
			upstreamChanges.forEach( function( keypath ) {
				var dependants, keys;
				if ( dependants = self.deps.computed[ keypath ] ) {
					dependants.forEach( invalidate );
					keys = dependants.map( getKey );
					keys.forEach( mark );
					keys.forEach( cascade );
				}
			} );
			this.changes = [];
			// Pattern observers are a weird special case
			if ( this.patternObservers.length ) {
				upstreamChanges.forEach( function( keypath ) {
					return notifyPatternObservers( this$0, keypath, true );
				} );
				changes.forEach( function( keypath ) {
					return notifyPatternObservers( this$0, keypath );
				} );
			}
			if ( this.deps.observers ) {
				upstreamChanges.forEach( function( keypath ) {
					return notifyUpstreamDependants( this$0, null, keypath, 'observers' );
				} );
				notifyAllDependants( this, changes, 'observers' );
			}
			if ( this.deps[ 'default' ] ) {
				var bindings = [];
				upstreamChanges.forEach( function( keypath ) {
					return notifyUpstreamDependants( this$0, bindings, keypath, 'default' );
				} );
				if ( bindings.length ) {
					notifyBindings( this, bindings, changes );
				}
				notifyAllDependants( this, changes, 'default' );
			}
			// Return a hash of keypaths to updated values
			changes.forEach( function( keypath ) {
				hash[ keypath ] = this$0.get( keypath );
			} );
			this.implicitChanges = {};
			this.noCascade = {};
			return hash;
		};

		function invalidate( computation ) {
			computation.invalidate();
		}

		function getKey( computation ) {
			return computation.key;
		}

		function notifyUpstreamDependants( viewmodel, bindings, keypath, groupName ) {
			var dependants, value;
			if ( dependants = findDependants( viewmodel, keypath, groupName ) ) {
				value = viewmodel.get( keypath );
				dependants.forEach( function( d ) {
					// don't "set" the parent value, refine it
					// i.e. not data = value, but data[foo] = fooValue
					if ( bindings && d.refineValue ) {
						bindings.push( d );
					} else {
						d.setValue( value );
					}
				} );
			}
		}

		function notifyBindings( viewmodel, bindings, changes ) {
			bindings.forEach( function( binding ) {
				var useSet = false,
					i = 0,
					length = changes.length,
					refinements = [];
				while ( i < length ) {
					var keypath = changes[ i ];
					if ( keypath === binding.keypath ) {
						useSet = true;
						break;
					}
					if ( keypath.slice( 0, binding.keypath.length ) === binding.keypath ) {
						refinements.push( keypath );
					}
					i++;
				}
				if ( useSet ) {
					binding.setValue( viewmodel.get( binding.keypath ) );
				}
				if ( refinements.length ) {
					binding.refineValue( refinements );
				}
			} );
		}

		function notifyAllDependants( viewmodel, keypaths, groupName ) {
			var queue = [];
			addKeypaths( keypaths );
			queue.forEach( dispatch );

			function addKeypaths( keypaths ) {
				keypaths.forEach( addKeypath );
				keypaths.forEach( cascade );
			}

			function addKeypath( keypath ) {
				var deps = findDependants( viewmodel, keypath, groupName );
				if ( deps ) {
					queue.push( {
						keypath: keypath,
						deps: deps
					} );
				}
			}

			function cascade( keypath ) {
				var childDeps;
				if ( childDeps = viewmodel.depsMap[ groupName ][ keypath ] ) {
					addKeypaths( childDeps );
				}
			}

			function dispatch( set ) {
				var value = viewmodel.get( set.keypath );
				set.deps.forEach( function( d ) {
					return d.setValue( value );
				} );
			}
		}

		function findDependants( viewmodel, keypath, groupName ) {
			var group = viewmodel.deps[ groupName ];
			return group ? group[ keypath ] : null;
		}
		return __export;
	}( getUpstreamChanges, viewmodel$applyChanges_notifyPatternObservers );

	/* viewmodel/prototype/capture.js */
	var viewmodel$capture = function Viewmodel$capture() {
		this.captureGroups.push( [] );
	};

	/* viewmodel/prototype/clearCache.js */
	var viewmodel$clearCache = function Viewmodel$clearCache( keypath, dontTeardownWrapper ) {
		var cacheMap, wrapper;
		if ( !dontTeardownWrapper ) {
			// Is there a wrapped property at this keypath?
			if ( wrapper = this.wrapped[ keypath ] ) {
				// Did we unwrap it?
				if ( wrapper.teardown() !== false ) {
					// Is this right?
					// What's the meaning of returning false from teardown?
					// Could there be a GC ramification if this is a "real" ractive.teardown()?
					this.wrapped[ keypath ] = null;
				}
			}
		}
		this.cache[ keypath ] = undefined;
		if ( cacheMap = this.cacheMap[ keypath ] ) {
			while ( cacheMap.length ) {
				this.clearCache( cacheMap.pop() );
			}
		}
	};

	/* viewmodel/Computation/getComputationSignature.js */
	var getComputationSignature = function() {

		var __export;
		var pattern = /\$\{([^\}]+)\}/g;
		__export = function( signature ) {
			if ( typeof signature === 'function' ) {
				return {
					get: signature
				};
			}
			if ( typeof signature === 'string' ) {
				return {
					get: createFunctionFromString( signature )
				};
			}
			if ( typeof signature === 'object' && typeof signature.get === 'string' ) {
				signature = {
					get: createFunctionFromString( signature.get ),
					set: signature.set
				};
			}
			return signature;
		};

		function createFunctionFromString( signature ) {
			var functionBody = 'var __ractive=this;return(' + signature.replace( pattern, function( match, keypath ) {
				return '__ractive.get("' + keypath + '")';
			} ) + ')';
			return new Function( functionBody );
		}
		return __export;
	}();

	/* viewmodel/Computation/Computation.js */
	var Computation = function( log, isEqual ) {

		var Computation = function( ractive, key, signature ) {
			var this$0 = this;
			this.ractive = ractive;
			this.viewmodel = ractive.viewmodel;
			this.key = key;
			this.getter = signature.get;
			this.setter = signature.set;
			this.hardDeps = signature.deps || [];
			this.softDeps = [];
			this.depValues = {};
			if ( this.hardDeps ) {
				this.hardDeps.forEach( function( d ) {
					return ractive.viewmodel.register( d, this$0, 'computed' );
				} );
			}
			this._dirty = this._firstRun = true;
		};
		Computation.prototype = {
			constructor: Computation,
			init: function() {
				var initial;
				this.bypass = true;
				initial = this.ractive.viewmodel.get( this.key );
				this.ractive.viewmodel.clearCache( this.key );
				this.bypass = false;
				if ( this.setter && initial !== undefined ) {
					this.set( initial );
				}
			},
			invalidate: function() {
				this._dirty = true;
			},
			get: function() {
				var this$0 = this;
				var ractive, newDeps, dependenciesChanged, dependencyValuesChanged = false;
				if ( this.getting ) {
					// prevent double-computation (e.g. caused by array mutation inside computation)
					return;
				}
				this.getting = true;
				if ( this._dirty ) {
					ractive = this.ractive;
					// determine whether the inputs have changed, in case this depends on
					// other computed values
					if ( this._firstRun || !this.hardDeps.length && !this.softDeps.length ) {
						dependencyValuesChanged = true;
					} else {
						[
							this.hardDeps,
							this.softDeps
						].forEach( function( deps ) {
							var keypath, value, i;
							if ( dependencyValuesChanged ) {
								return;
							}
							i = deps.length;
							while ( i-- ) {
								keypath = deps[ i ];
								value = ractive.viewmodel.get( keypath );
								if ( !isEqual( value, this$0.depValues[ keypath ] ) ) {
									this$0.depValues[ keypath ] = value;
									dependencyValuesChanged = true;
									return;
								}
							}
						} );
					}
					if ( dependencyValuesChanged ) {
						ractive.viewmodel.capture();
						try {
							this.value = this.getter.call( ractive );
						} catch ( err ) {
							log.warn( {
								debug: ractive.debug,
								message: 'failedComputation',
								args: {
									key: this.key,
									err: err.message || err
								}
							} );
							this.value = void 0;
						}
						newDeps = ractive.viewmodel.release();
						dependenciesChanged = this.updateDependencies( newDeps );
						if ( dependenciesChanged ) {
							[
								this.hardDeps,
								this.softDeps
							].forEach( function( deps ) {
								deps.forEach( function( keypath ) {
									this$0.depValues[ keypath ] = ractive.viewmodel.get( keypath );
								} );
							} );
						}
					}
					this._dirty = false;
				}
				this.getting = this._firstRun = false;
				return this.value;
			},
			set: function( value ) {
				if ( this.setting ) {
					this.value = value;
					return;
				}
				if ( !this.setter ) {
					throw new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );
				}
				this.setter.call( this.ractive, value );
			},
			updateDependencies: function( newDeps ) {
				var i, oldDeps, keypath, dependenciesChanged;
				oldDeps = this.softDeps;
				// remove dependencies that are no longer used
				i = oldDeps.length;
				while ( i-- ) {
					keypath = oldDeps[ i ];
					if ( newDeps.indexOf( keypath ) === -1 ) {
						dependenciesChanged = true;
						this.viewmodel.unregister( keypath, this, 'computed' );
					}
				}
				// create references for any new dependencies
				i = newDeps.length;
				while ( i-- ) {
					keypath = newDeps[ i ];
					if ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {
						dependenciesChanged = true;
						this.viewmodel.register( keypath, this, 'computed' );
					}
				}
				if ( dependenciesChanged ) {
					this.softDeps = newDeps.slice();
				}
				return dependenciesChanged;
			}
		};
		return Computation;
	}( log, isEqual );

	/* viewmodel/prototype/compute.js */
	var viewmodel$compute = function( getComputationSignature, Computation ) {

		return function Viewmodel$compute( key, signature ) {
			signature = getComputationSignature( signature );
			return this.computations[ key ] = new Computation( this.ractive, key, signature );
		};
	}( getComputationSignature, Computation );

	/* viewmodel/prototype/get/FAILED_LOOKUP.js */
	var viewmodel$get_FAILED_LOOKUP = {
		FAILED_LOOKUP: true
	};

	/* viewmodel/prototype/get/UnresolvedImplicitDependency.js */
	var viewmodel$get_UnresolvedImplicitDependency = function( removeFromArray, runloop ) {

		var empty = {};
		var UnresolvedImplicitDependency = function( viewmodel, keypath ) {
			this.viewmodel = viewmodel;
			this.root = viewmodel.ractive;
			// TODO eliminate this
			this.ref = keypath;
			this.parentFragment = empty;
			viewmodel.unresolvedImplicitDependencies[ keypath ] = true;
			viewmodel.unresolvedImplicitDependencies.push( this );
			runloop.addUnresolved( this );
		};
		UnresolvedImplicitDependency.prototype = {
			resolve: function() {
				this.viewmodel.mark( this.ref );
				this.viewmodel.unresolvedImplicitDependencies[ this.ref ] = false;
				removeFromArray( this.viewmodel.unresolvedImplicitDependencies, this );
			},
			teardown: function() {
				runloop.removeUnresolved( this );
			}
		};
		return UnresolvedImplicitDependency;
	}( removeFromArray, runloop );

	/* viewmodel/prototype/get.js */
	var viewmodel$get = function( isNumeric, FAILED_LOOKUP, UnresolvedImplicitDependency ) {

		var __export;
		var empty = {};
		__export = function Viewmodel$get( keypath ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = empty;
			var ractive = this.ractive,
				cache = this.cache,
				value, computation, wrapped, captureGroup;
			if ( keypath[ 0 ] === '@' ) {
				value = keypath.slice( 1 );
				return isNumeric( value ) ? +value : value;
			}
			if ( cache[ keypath ] === undefined ) {
				// Is this a computed property?
				if ( ( computation = this.computations[ keypath ] ) && !computation.bypass ) {
					value = computation.get();
					this.adapt( keypath, value );
				} else if ( wrapped = this.wrapped[ keypath ] ) {
					value = wrapped.value;
				} else if ( !keypath ) {
					this.adapt( '', ractive.data );
					value = ractive.data;
				} else {
					value = retrieve( this, keypath );
				}
				cache[ keypath ] = value;
			} else {
				value = cache[ keypath ];
			}
			if ( options.evaluateWrapped && ( wrapped = this.wrapped[ keypath ] ) ) {
				value = wrapped.get();
			}
			// capture the keypath, if we're inside a computation
			if ( options.capture && ( captureGroup = this.captureGroups[ this.captureGroups.length - 1 ] ) ) {
				if ( !~captureGroup.indexOf( keypath ) ) {
					captureGroup.push( keypath );
					// if we couldn't resolve the keypath, we need to make it as a failed
					// lookup, so that the computation updates correctly once we CAN
					// resolve the keypath
					if ( value === FAILED_LOOKUP && this.unresolvedImplicitDependencies[ keypath ] !== true ) {
						new UnresolvedImplicitDependency( this, keypath );
					}
				}
			}
			return value === FAILED_LOOKUP ? void 0 : value;
		};

		function retrieve( viewmodel, keypath ) {
			var keys, key, parentKeypath, parentValue, cacheMap, value, wrapped;
			keys = keypath.split( '.' );
			key = keys.pop();
			parentKeypath = keys.join( '.' );
			parentValue = viewmodel.get( parentKeypath );
			if ( wrapped = viewmodel.wrapped[ parentKeypath ] ) {
				parentValue = wrapped.get();
			}
			if ( parentValue === null || parentValue === undefined ) {
				return;
			}
			// update cache map
			if ( !( cacheMap = viewmodel.cacheMap[ parentKeypath ] ) ) {
				viewmodel.cacheMap[ parentKeypath ] = [ keypath ];
			} else {
				if ( cacheMap.indexOf( keypath ) === -1 ) {
					cacheMap.push( keypath );
				}
			}
			// If this property doesn't exist, we return a sentinel value
			// so that we know to query parent scope (if such there be)
			if ( typeof parentValue === 'object' && !( key in parentValue ) ) {
				return viewmodel.cache[ keypath ] = FAILED_LOOKUP;
			}
			value = parentValue[ key ];
			// Do we have an adaptor for this value?
			viewmodel.adapt( keypath, value, false );
			// Update cache
			viewmodel.cache[ keypath ] = value;
			return value;
		}
		return __export;
	}( isNumeric, viewmodel$get_FAILED_LOOKUP, viewmodel$get_UnresolvedImplicitDependency );

	/* viewmodel/prototype/init.js */
	var viewmodel$init = function() {

		var __export;
		__export = function Viewmodel$init() {
			var key, computation, computations = [];
			for ( key in this.ractive.computed ) {
				computation = this.compute( key, this.ractive.computed[ key ] );
				computations.push( computation );
			}
			computations.forEach( init );
		};

		function init( computation ) {
			computation.init();
		}
		return __export;
	}();

	/* viewmodel/prototype/mark.js */
	var viewmodel$mark = function Viewmodel$mark( keypath, options ) {
		var computation;
		// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)
		// should not be picked up by pattern observers
		if ( options ) {
			if ( options.implicit ) {
				this.implicitChanges[ keypath ] = true;
			}
			if ( options.noCascade ) {
				this.noCascade[ keypath ] = true;
			}
		}
		if ( computation = this.computations[ keypath ] ) {
			computation.invalidate();
		}
		if ( this.changes.indexOf( keypath ) === -1 ) {
			this.changes.push( keypath );
		}
		this.clearCache( keypath );
	};

	/* viewmodel/prototype/merge/mapOldToNewIndex.js */
	var viewmodel$merge_mapOldToNewIndex = function( oldArray, newArray ) {
		var usedIndices, firstUnusedIndex, newIndices, changed;
		usedIndices = {};
		firstUnusedIndex = 0;
		newIndices = oldArray.map( function( item, i ) {
			var index, start, len;
			start = firstUnusedIndex;
			len = newArray.length;
			do {
				index = newArray.indexOf( item, start );
				if ( index === -1 ) {
					changed = true;
					return -1;
				}
				start = index + 1;
			} while ( usedIndices[ index ] && start < len );
			// keep track of the first unused index, so we don't search
			// the whole of newArray for each item in oldArray unnecessarily
			if ( index === firstUnusedIndex ) {
				firstUnusedIndex += 1;
			}
			if ( index !== i ) {
				changed = true;
			}
			usedIndices[ index ] = true;
			return index;
		} );
		return newIndices;
	};

	/* viewmodel/prototype/merge.js */
	var viewmodel$merge = function( warn, mapOldToNewIndex ) {

		var __export;
		var comparators = {};
		__export = function Viewmodel$merge( keypath, currentArray, array, options ) {
			var oldArray, newArray, comparator, newIndices;
			this.mark( keypath );
			if ( options && options.compare ) {
				comparator = getComparatorFunction( options.compare );
				try {
					oldArray = currentArray.map( comparator );
					newArray = array.map( comparator );
				} catch ( err ) {
					// fallback to an identity check - worst case scenario we have
					// to do more DOM manipulation than we thought...
					// ...unless we're in debug mode of course
					if ( this.debug ) {
						throw err;
					} else {
						warn( 'Merge operation: comparison failed. Falling back to identity checking' );
					}
					oldArray = currentArray;
					newArray = array;
				}
			} else {
				oldArray = currentArray;
				newArray = array;
			}
			// find new indices for members of oldArray
			newIndices = mapOldToNewIndex( oldArray, newArray );
			this.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );
		};

		function stringify( item ) {
			return JSON.stringify( item );
		}

		function getComparatorFunction( comparator ) {
			// If `compare` is `true`, we use JSON.stringify to compare
			// objects that are the same shape, but non-identical - i.e.
			// { foo: 'bar' } !== { foo: 'bar' }
			if ( comparator === true ) {
				return stringify;
			}
			if ( typeof comparator === 'string' ) {
				if ( !comparators[ comparator ] ) {
					comparators[ comparator ] = function( item ) {
						return item[ comparator ];
					};
				}
				return comparators[ comparator ];
			}
			if ( typeof comparator === 'function' ) {
				return comparator;
			}
			throw new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );
		}
		return __export;
	}( warn, viewmodel$merge_mapOldToNewIndex );

	/* viewmodel/prototype/register.js */
	var viewmodel$register = function() {

		var __export;
		__export = function Viewmodel$register( keypath, dependant ) {
			var group = arguments[ 2 ];
			if ( group === void 0 )
				group = 'default';
			var depsByKeypath, deps;
			if ( dependant.isStatic ) {
				return;
			}
			depsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );
			deps = depsByKeypath[ keypath ] || ( depsByKeypath[ keypath ] = [] );
			deps.push( dependant );
			if ( !keypath ) {
				return;
			}
			updateDependantsMap( this, keypath, group );
		};

		function updateDependantsMap( viewmodel, keypath, group ) {
			var keys, parentKeypath, map, parent;
			// update dependants map
			keys = keypath.split( '.' );
			while ( keys.length ) {
				keys.pop();
				parentKeypath = keys.join( '.' );
				map = viewmodel.depsMap[ group ] || ( viewmodel.depsMap[ group ] = {} );
				parent = map[ parentKeypath ] || ( map[ parentKeypath ] = [] );
				if ( parent[ keypath ] === undefined ) {
					parent[ keypath ] = 0;
					parent.push( keypath );
				}
				parent[ keypath ] += 1;
				keypath = parentKeypath;
			}
		}
		return __export;
	}();

	/* viewmodel/prototype/release.js */
	var viewmodel$release = function Viewmodel$release() {
		return this.captureGroups.pop();
	};

	/* viewmodel/prototype/set.js */
	var viewmodel$set = function( isEqual, createBranch ) {

		var __export;
		__export = function Viewmodel$set( keypath, value, silent ) {
			var computation, wrapper, dontTeardownWrapper;
			computation = this.computations[ keypath ];
			if ( computation ) {
				if ( computation.setting ) {
					// let the other computation set() handle things...
					return;
				}
				computation.set( value );
				value = computation.get();
			}
			if ( isEqual( this.cache[ keypath ], value ) ) {
				return;
			}
			wrapper = this.wrapped[ keypath ];
			// If we have a wrapper with a `reset()` method, we try and use it. If the
			// `reset()` method returns false, the wrapper should be torn down, and
			// (most likely) a new one should be created later
			if ( wrapper && wrapper.reset ) {
				dontTeardownWrapper = wrapper.reset( value ) !== false;
				if ( dontTeardownWrapper ) {
					value = wrapper.get();
				}
			}
			if ( !computation && !dontTeardownWrapper ) {
				resolveSet( this, keypath, value );
			}
			if ( !silent ) {
				this.mark( keypath );
			} else {
				// We're setting a parent of the original target keypath (i.e.
				// creating a fresh branch) - we need to clear the cache, but
				// not mark it as a change
				this.clearCache( keypath );
			}
		};

		function resolveSet( viewmodel, keypath, value ) {
			var keys, lastKey, parentKeypath, wrapper, parentValue, wrapperSet, valueSet;
			wrapperSet = function() {
				if ( wrapper.set ) {
					wrapper.set( lastKey, value );
				} else {
					parentValue = wrapper.get();
					valueSet();
				}
			};
			valueSet = function() {
				if ( !parentValue ) {
					parentValue = createBranch( lastKey );
					viewmodel.set( parentKeypath, parentValue, true );
				}
				parentValue[ lastKey ] = value;
			};
			keys = keypath.split( '.' );
			lastKey = keys.pop();
			parentKeypath = keys.join( '.' );
			wrapper = viewmodel.wrapped[ parentKeypath ];
			if ( wrapper ) {
				wrapperSet();
			} else {
				parentValue = viewmodel.get( parentKeypath );
				// may have been wrapped via the above .get()
				// call on viewmodel if this is first access via .set()!
				if ( wrapper = viewmodel.wrapped[ parentKeypath ] ) {
					wrapperSet();
				} else {
					valueSet();
				}
			}
		}
		return __export;
	}( isEqual, createBranch );

	/* viewmodel/prototype/smartUpdate.js */
	var viewmodel$smartUpdate = function() {

		var __export;
		var implicitOption = {
				implicit: true
			},
			noCascadeOption = {
				noCascade: true
			};
		__export = function Viewmodel$smartUpdate( keypath, array, newIndices ) {
			var this$0 = this;
			var dependants, oldLength;
			oldLength = newIndices.length;
			// Indices that are being removed should be marked as dirty
			newIndices.forEach( function( newIndex, oldIndex ) {
				if ( newIndex === -1 ) {
					this$0.mark( keypath + '.' + oldIndex, noCascadeOption );
				}
			} );
			// Update the model
			// TODO allow existing array to be updated in place, rather than replaced?
			this.set( keypath, array, true );
			if ( dependants = this.deps[ 'default' ][ keypath ] ) {
				dependants.filter( canShuffle ).forEach( function( d ) {
					return d.shuffle( newIndices, array );
				} );
			}
			if ( oldLength !== array.length ) {
				this.mark( keypath + '.length', implicitOption );
				for ( var i = oldLength; i < array.length; i += 1 ) {
					this.mark( keypath + '.' + i );
				}
				// don't allow removed indexes beyond end of new array to trigger recomputations
				for ( var i$0 = array.length; i$0 < oldLength; i$0 += 1 ) {
					this.mark( keypath + '.' + i$0, noCascadeOption );
				}
			}
		};

		function canShuffle( dependant ) {
			return typeof dependant.shuffle === 'function';
		}
		return __export;
	}();

	/* viewmodel/prototype/teardown.js */
	var viewmodel$teardown = function Viewmodel$teardown() {
		var this$0 = this;
		var unresolvedImplicitDependency;
		// Clear entire cache - this has the desired side-effect
		// of unwrapping adapted values (e.g. arrays)
		Object.keys( this.cache ).forEach( function( keypath ) {
			return this$0.clearCache( keypath );
		} );
		// Teardown any failed lookups - we don't need them to resolve any more
		while ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {
			unresolvedImplicitDependency.teardown();
		}
	};

	/* viewmodel/prototype/unregister.js */
	var viewmodel$unregister = function() {

		var __export;
		__export = function Viewmodel$unregister( keypath, dependant ) {
			var group = arguments[ 2 ];
			if ( group === void 0 )
				group = 'default';
			var deps, index;
			if ( dependant.isStatic ) {
				return;
			}
			deps = this.deps[ group ][ keypath ];
			index = deps.indexOf( dependant );
			if ( index === -1 ) {
				throw new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );
			}
			deps.splice( index, 1 );
			if ( !keypath ) {
				return;
			}
			updateDependantsMap( this, keypath, group );
		};

		function updateDependantsMap( viewmodel, keypath, group ) {
			var keys, parentKeypath, map, parent;
			// update dependants map
			keys = keypath.split( '.' );
			while ( keys.length ) {
				keys.pop();
				parentKeypath = keys.join( '.' );
				map = viewmodel.depsMap[ group ];
				parent = map[ parentKeypath ];
				parent[ keypath ] -= 1;
				if ( !parent[ keypath ] ) {
					// remove from parent deps map
					parent.splice( parent.indexOf( keypath ), 1 );
					parent[ keypath ] = undefined;
				}
				keypath = parentKeypath;
			}
		}
		return __export;
	}();

	/* viewmodel/adaptConfig.js */
	var adaptConfig = function() {

		// should this be combined with prototype/adapt.js?
		var configure = {
			lookup: function( target, adaptors ) {
				var i, adapt = target.adapt;
				if ( !adapt || !adapt.length ) {
					return adapt;
				}
				if ( adaptors && Object.keys( adaptors ).length && ( i = adapt.length ) ) {
					while ( i-- ) {
						var adaptor = adapt[ i ];
						if ( typeof adaptor === 'string' ) {
							adapt[ i ] = adaptors[ adaptor ] || adaptor;
						}
					}
				}
				return adapt;
			},
			combine: function( parent, adapt ) {
				// normalize 'Foo' to [ 'Foo' ]
				parent = arrayIfString( parent );
				adapt = arrayIfString( adapt );
				// no parent? return adapt
				if ( !parent || !parent.length ) {
					return adapt;
				}
				// no adapt? return 'copy' of parent
				if ( !adapt || !adapt.length ) {
					return parent.slice();
				}
				// add parent adaptors to options
				parent.forEach( function( a ) {
					// don't put in duplicates
					if ( adapt.indexOf( a ) === -1 ) {
						adapt.push( a );
					}
				} );
				return adapt;
			}
		};

		function arrayIfString( adapt ) {
			if ( typeof adapt === 'string' ) {
				adapt = [ adapt ];
			}
			return adapt;
		}
		return configure;
	}();

	/* viewmodel/Viewmodel.js */
	var Viewmodel = function( create, adapt, applyChanges, capture, clearCache, compute, get, init, mark, merge, register, release, set, smartUpdate, teardown, unregister, adaptConfig ) {

		var noMagic;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
		} catch ( err ) {
			noMagic = true;
		}
		var Viewmodel = function( ractive ) {
			this.ractive = ractive;
			// TODO eventually, we shouldn't need this reference
			Viewmodel.extend( ractive.constructor, ractive );
			this.cache = {};
			// we need to be able to use hasOwnProperty, so can't inherit from null
			this.cacheMap = create( null );
			this.deps = {
				computed: {},
				'default': {}
			};
			this.depsMap = {
				computed: {},
				'default': {}
			};
			this.patternObservers = [];
			this.wrapped = create( null );
			this.computations = create( null );
			this.captureGroups = [];
			this.unresolvedImplicitDependencies = [];
			this.changes = [];
			this.implicitChanges = {};
			this.noCascade = {};
		};
		Viewmodel.extend = function( Parent, instance ) {
			if ( instance.magic && noMagic ) {
				throw new Error( 'Getters and setters (magic mode) are not supported in this browser' );
			}
			instance.adapt = adaptConfig.combine( Parent.prototype.adapt, instance.adapt ) || [];
			instance.adapt = adaptConfig.lookup( instance, instance.adaptors );
		};
		Viewmodel.prototype = {
			adapt: adapt,
			applyChanges: applyChanges,
			capture: capture,
			clearCache: clearCache,
			compute: compute,
			get: get,
			init: init,
			mark: mark,
			merge: merge,
			register: register,
			release: release,
			set: set,
			smartUpdate: smartUpdate,
			teardown: teardown,
			unregister: unregister
		};
		return Viewmodel;
	}( create, viewmodel$adapt, viewmodel$applyChanges, viewmodel$capture, viewmodel$clearCache, viewmodel$compute, viewmodel$get, viewmodel$init, viewmodel$mark, viewmodel$merge, viewmodel$register, viewmodel$release, viewmodel$set, viewmodel$smartUpdate, viewmodel$teardown, viewmodel$unregister, adaptConfig );

	/* Ractive/initialise.js */
	var Ractive_initialise = function( config, create, Fragment, getElement, getNextNumber, Hook, HookQueue, Viewmodel ) {

		var __export;
		var constructHook = new Hook( 'construct' ),
			configHook = new Hook( 'config' ),
			initHook = new HookQueue( 'init' );
		__export = function initialiseRactiveInstance( ractive ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = {};
			var el;
			initialiseProperties( ractive, options );
			// make this option do what would be expected if someone
			// did include it on a new Ractive() or new Component() call.
			// Silly to do so (put a hook on the very options being used),
			// but handle it correctly, consistent with the intent.
			constructHook.fire( config.getConstructTarget( ractive, options ), options );
			// init config from Parent and options
			config.init( ractive.constructor, ractive, options );
			configHook.fire( ractive );
			// Teardown any existing instances *before* trying to set up the new one -
			// avoids certain weird bugs
			if ( el = getElement( ractive.el ) ) {
				if ( !ractive.append ) {
					if ( el.__ractive_instances__ ) {
						try {
							el.__ractive_instances__.splice( 0, el.__ractive_instances__.length ).forEach( function( r ) {
								return r.teardown();
							} );
						} catch ( err ) {}
					}
					el.innerHTML = '';
				}
			}
			initHook.begin( ractive );
			// TEMPORARY. This is so we can implement Viewmodel gradually
			ractive.viewmodel = new Viewmodel( ractive );
			// hacky circular problem until we get this sorted out
			// if viewmodel immediately processes computed properties,
			// they may call ractive.get, which calls ractive.viewmodel,
			// which hasn't been set till line above finishes.
			ractive.viewmodel.init();
			// Render our *root fragment*
			if ( ractive.template ) {
				ractive.fragment = new Fragment( {
					template: ractive.template,
					root: ractive,
					owner: ractive
				} );
			}
			initHook.end( ractive );
			// render automatically ( if `el` is specified )
			if ( el ) {
				ractive.render( el, ractive.append );
			}
		};

		function initialiseProperties( ractive, options ) {
			// Generate a unique identifier, for places where you'd use a weak map if it
			// existed
			ractive._guid = getNextNumber();
			// events
			ractive._subs = create( null );
			// storage for item configuration from instantiation to reset,
			// like dynamic functions or original values
			ractive._config = {};
			// two-way bindings
			ractive._twowayBindings = create( null );
			// animations (so we can stop any in progress at teardown)
			ractive._animations = [];
			// nodes registry
			ractive.nodes = {};
			// live queries
			ractive._liveQueries = [];
			ractive._liveComponentQueries = [];
			// If this is a component, store a reference to the parent
			if ( options._parent && options._component ) {
				ractive._parent = options._parent;
				ractive.component = options._component;
				// And store a reference to the instance on the component
				options._component.instance = ractive;
			}
		}
		return __export;
	}( config, create, Fragment, getElement, getNextNumber, Ractive$shared_hooks_Hook, Ractive$shared_hooks_HookQueue, Viewmodel );

	/* extend/unwrapExtended.js */
	var unwrapExtended = function( wrap, config, circular ) {

		var __export;
		var Ractive;
		circular.push( function() {
			Ractive = circular.Ractive;
		} );
		__export = function unwrapExtended( Child ) {
			if ( !( Child.prototype instanceof Ractive ) ) {
				return Child;
			}
			var options = {};
			while ( Child ) {
				config.registries.forEach( function( r ) {
					addRegistry( r.useDefaults ? Child.prototype : Child, options, r.name );
				} );
				Object.keys( Child.prototype ).forEach( function( key ) {
					if ( key === 'computed' ) {
						return;
					}
					var value = Child.prototype[ key ];
					if ( !( key in options ) ) {
						options[ key ] = value._method ? value._method : value;
					} else if ( typeof options[ key ] === 'function' && typeof value === 'function' && options[ key ]._method ) {
						var result, needsSuper = value._method;
						if ( needsSuper ) {
							value = value._method;
						}
						// rewrap bound directly to parent fn
						result = wrap( options[ key ]._method, value );
						if ( needsSuper ) {
							result._method = result;
						}
						options[ key ] = result;
					}
				} );
				if ( Child._parent !== Ractive ) {
					Child = Child._parent;
				} else {
					Child = false;
				}
			}
			return options;
		};

		function addRegistry( target, options, name ) {
			var registry, keys = Object.keys( target[ name ] );
			if ( !keys.length ) {
				return;
			}
			if ( !( registry = options[ name ] ) ) {
				registry = options[ name ] = {};
			}
			keys.filter( function( key ) {
				return !( key in registry );
			} ).forEach( function( key ) {
				return registry[ key ] = target[ name ][ key ];
			} );
		}
		return __export;
	}( wrapMethod, config, circular );

	/* extend/_extend.js */
	var Ractive_extend = function( create, defineProperties, getGuid, config, initialise, Viewmodel, unwrap ) {

		return function extend() {
			var options = arguments[ 0 ];
			if ( options === void 0 )
				options = {};
			var Parent = this,
				Child, proto, staticProperties;
			// if we're extending with another Ractive instance, inherit its
			// prototype methods and default options as well
			options = unwrap( options );
			// create Child constructor
			Child = function( options ) {
				initialise( this, options );
			};
			proto = create( Parent.prototype );
			proto.constructor = Child;
			staticProperties = {
				// each component needs a guid, for managing CSS etc
				_guid: {
					value: getGuid()
				},
				// alias prototype as defaults
				defaults: {
					value: proto
				},
				// extendable
				extend: {
					value: extend,
					writable: true,
					configurable: true
				},
				// Parent - for IE8, can't use Object.getPrototypeOf
				_parent: {
					value: Parent
				}
			};
			defineProperties( Child, staticProperties );
			// extend configuration
			config.extend( Parent, proto, options );
			Viewmodel.extend( Parent, proto );
			Child.prototype = proto;
			return Child;
		};
	}( create, defineProperties, getGuid, config, Ractive_initialise, Viewmodel, unwrapExtended );

	/* Ractive.js */
	var Ractive = function( defaults, easing, interpolators, svg, magic, defineProperties, proto, Promise, extendObj, extend, parse, initialise, circular ) {

		var Ractive, properties;
		// Main Ractive required object
		Ractive = function( options ) {
			initialise( this, options );
		};
		// Ractive properties
		properties = {
			// static methods:
			extend: {
				value: extend
			},
			parse: {
				value: parse
			},
			// Namespaced constructors
			Promise: {
				value: Promise
			},
			// support
			svg: {
				value: svg
			},
			magic: {
				value: magic
			},
			// version
			VERSION: {
				value: '0.6.1'
			},
			// Plugins
			adaptors: {
				writable: true,
				value: {}
			},
			components: {
				writable: true,
				value: {}
			},
			decorators: {
				writable: true,
				value: {}
			},
			easing: {
				writable: true,
				value: easing
			},
			events: {
				writable: true,
				value: {}
			},
			interpolators: {
				writable: true,
				value: interpolators
			},
			partials: {
				writable: true,
				value: {}
			},
			transitions: {
				writable: true,
				value: {}
			}
		};
		// Ractive properties
		defineProperties( Ractive, properties );
		Ractive.prototype = extendObj( proto, defaults );
		Ractive.prototype.constructor = Ractive;
		// alias prototype as defaults
		Ractive.defaults = Ractive.prototype;
		// Certain modules have circular dependencies. If we were bundling a
		// module loader, e.g. almond.js, this wouldn't be a problem, but we're
		// not - we're using amdclean as part of the build process. Because of
		// this, we need to wait until all modules have loaded before those
		// circular dependencies can be required.
		circular.Ractive = Ractive;
		while ( circular.length ) {
			circular.pop()();
		}
		// Ractive.js makes liberal use of things like Array.prototype.indexOf. In
		// older browsers, these are made available via a shim - here, we do a quick
		// pre-flight check to make sure that either a) we're not in a shit browser,
		// or b) we're using a Ractive-legacy.js build
		var FUNCTION = 'function';
		if ( typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION ) {
			throw new Error( 'It looks like you\'re attempting to use Ractive.js in an older browser. You\'ll need to use one of the \'legacy builds\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );
		}
		return Ractive;
	}( options, easing, interpolators, svg, magic, defineProperties, prototype, Promise, extend, Ractive_extend, parse, Ractive_initialise, circular );


	// export as Common JS module...
	if ( typeof module !== "undefined" && module.exports ) {
		module.exports = Ractive;
	}

	// ... or as AMD module
	else if ( typeof define === "function" && define.amd ) {
		define( function() {
			return Ractive;
		} );
	}

	// ... or as browser global
	global.Ractive = Ractive;

	Ractive.noConflict = function() {
		global.Ractive = noConflict;
		return Ractive;
	};

}( typeof window !== 'undefined' ? window : this ) );

},{}]},{},["./source/js/app.coffee"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvbHVrZS9kZXYvMDQwNzE1L3NvdXJjZS9qcy9hcHAuY29mZmVlIiwibm9kZV9tb2R1bGVzL2RhdC1ndWkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGF0LWd1aS92ZW5kb3IvZGF0LmNvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2RhdC1ndWkvdmVuZG9yL2RhdC5ndWkuanMiLCJub2RlX21vZHVsZXMvZmlyZWJhc2UvbGliL2ZpcmViYXNlLXdlYi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvYXBwZW5kLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvY29sbGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2NvbWJpbmUuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9jb21wYWN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvY29udGFpbnMuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9kaWZmZXJlbmNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZXF1YWxzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZXZlcnkuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9maW5kLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZmluZEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZmluZExhc3QuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9maW5kTGFzdEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvZmxhdHRlbi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2ZvckVhY2guanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9ncm91cEJ5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvaW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2luc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2ludGVyc2VjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2ludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L2pvaW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9sYXN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvbGFzdEluZGV4T2YuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9tYXAuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9tYXguanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9taW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9waWNrLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvcGx1Y2suanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9yYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3JlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3JlZHVjZVJpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvcmVqZWN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvcmVtb3ZlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvcmVtb3ZlQWxsLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvc2h1ZmZsZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3NsaWNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvc29tZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3NvcnQuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9zb3J0QnkuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS9zcGxpdC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3Rha2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9hcnJheS90b0xvb2t1cC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2FycmF5L3VuaW9uLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvdW5pcXVlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkveG9yLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvYXJyYXkvemlwLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2NvbGxlY3Rpb24vY29udGFpbnMuanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL2V2ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL2ZpbmQuanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL2ZvckVhY2guanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL21ha2VfLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9tYXAuanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL21heC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2NvbGxlY3Rpb24vbWluLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9wbHVjay5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2NvbGxlY3Rpb24vcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvY29sbGVjdGlvbi9yZWplY3QuanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL3NpemUuanMiLCJub2RlX21vZHVsZXMvbW91dC9jb2xsZWN0aW9uL3NvbWUuanMiLCJub2RlX21vZHVsZXMvbW91dC9kYXRlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9kYXlPZlRoZVllYXIuanMiLCJub2RlX21vZHVsZXMvbW91dC9kYXRlL2RpZmYuanMiLCJub2RlX21vZHVsZXMvbW91dC9kYXRlL2kxOG4vZW4tVVMuanMiLCJub2RlX21vZHVsZXMvbW91dC9kYXRlL2kxOG5fLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9pc0xlYXBZZWFyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9pc1NhbWUuanMiLCJub2RlX21vZHVsZXMvbW91dC9kYXRlL3BhcnNlSXNvLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9xdWFydGVyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9zdGFydE9mLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS9zdHJmdGltZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2RhdGUvdGltZXpvbmVBYmJyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS90aW1lem9uZU9mZnNldC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2RhdGUvdG90YWxEYXlzSW5Nb250aC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2RhdGUvdG90YWxEYXlzSW5ZZWFyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZGF0ZS93ZWVrT2ZUaGVZZWFyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbW91dC9mdW5jdGlvbi9hd2FpdERlbGF5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uL2NvbXBvc2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9mdW5jdGlvbi9jb25zdGFudC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uL2RlYm91bmNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vZnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uL2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2Z1bmN0aW9uL3BhcnRpYWwuanMiLCJub2RlX21vZHVsZXMvbW91dC9mdW5jdGlvbi9wcm9wLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vc2VyaWVzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vdGhyb3R0bGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9mdW5jdGlvbi90aW1lb3V0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvZnVuY3Rpb24vdGltZXMuanMiLCJub2RlX21vZHVsZXMvbW91dC9mdW5jdGlvbi93cmFwLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9HTE9CQUwuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2Nsb25lLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9jcmVhdGVPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2N0b3JBcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvZGVlcENsb25lLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9kZWVwRXF1YWxzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9kZWZhdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaW5oZXJpdFByb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXMuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc0Jvb2xlYW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzRGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNFbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNGaW5pdGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzSW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNLaW5kLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc05hTi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNOdWxsLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc051bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzUGxhaW5PYmplY3QuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzUHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc1JlZ0V4cC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L2xhbmcvaXNTdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzVW5kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc250LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy9raW5kT2YuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL3RvQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbW91dC9sYW5nL3RvTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbGFuZy90b1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L21hdGguanMiLCJub2RlX21vZHVsZXMvbW91dC9tYXRoL2NlaWwuanMiLCJub2RlX21vZHVsZXMvbW91dC9tYXRoL2NsYW1wLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbWF0aC9jb3VudFN0ZXBzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbWF0aC9mbG9vci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L21hdGgvaW5SYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L21hdGgvaXNOZWFyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbWF0aC9sZXJwLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbWF0aC9sb29wLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbWF0aC9tYXAuanMiLCJub2RlX21vZHVsZXMvbW91dC9tYXRoL25vcm0uanMiLCJub2RlX21vZHVsZXMvbW91dC9tYXRoL3JvdW5kLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL01BWF9JTlQuanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvTUFYX1NBRkVfSU5URUdFUi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9NQVhfVUlOVC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9NSU5fSU5ULmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL2FiYnJldmlhdGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvY3VycmVuY3lGb3JtYXQuanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvZW5mb3JjZVByZWNpc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9pc05hTi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9udGguanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvb3JkaW5hbC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9wYWQuanMiLCJub2RlX21vZHVsZXMvbW91dC9udW1iZXIvcm9sLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL3Jvci5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci9zaWduLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL3RvSW50LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvbnVtYmVyL3RvVUludC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L251bWJlci90b1VJbnQzMS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9iaW5kQWxsLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2NvbnRhaW5zLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2RlZXBGaWxsSW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvZGVlcE1hdGNoZXMuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvZGVlcE1peEluLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2VxdWFscy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9ldmVyeS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9maWxsSW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2ZpbmQuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvZm9ySW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvZm9yT3duLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2Z1bmN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9nZXQuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvaGFzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2hhc093bi5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L21hcC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9tYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L21heC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9tZXJnZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9taW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvbWl4SW4uanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvbmFtZXNwYWNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L29taXQuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvcGljay5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9wbHVjay5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9yZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3QvcmVqZWN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L3Jlc3VsdC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9zZXQuanMiLCJub2RlX21vZHVsZXMvbW91dC9vYmplY3Qvc2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9zb21lLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L3Vuc2V0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L3ZhbHVlcy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3F1ZXJ5U3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcXVlcnlTdHJpbmcvY29udGFpbnMuanMiLCJub2RlX21vZHVsZXMvbW91dC9xdWVyeVN0cmluZy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9xdWVyeVN0cmluZy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9xdWVyeVN0cmluZy9nZXRQYXJhbS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3F1ZXJ5U3RyaW5nL2dldFF1ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcXVlcnlTdHJpbmcvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9xdWVyeVN0cmluZy9zZXRQYXJhbS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3JhbmRvbS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3JhbmRvbS9jaG9pY2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9yYW5kb20vZ3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3JhbmRvbS9yYW5kLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcmFuZG9tL3JhbmRCaXQuanMiLCJub2RlX21vZHVsZXMvbW91dC9yYW5kb20vcmFuZEJvb2wuanMiLCJub2RlX21vZHVsZXMvbW91dC9yYW5kb20vcmFuZEhleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3JhbmRvbS9yYW5kSW50LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcmFuZG9tL3JhbmRTaWduLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvcmFuZG9tL3JhbmRTdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbW91dC9yYW5kb20vcmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL1dISVRFX1NQQUNFUy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9jYW1lbENhc2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvY29udGFpbnMuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvY3JvcC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9lbmRzV2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9lc2NhcGVIdG1sLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL2VzY2FwZVJlZ0V4cC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9lc2NhcGVVbmljb2RlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL2h5cGhlbmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9pbnNlcnQuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvaW50ZXJwb2xhdGUuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvbG93ZXJDYXNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL2xwYWQuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvbHRyaW0uanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvbWFrZVBhdGguanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvbm9ybWFsaXplTGluZUJyZWFrcy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9wYXNjYWxDYXNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3Byb3BlckNhc2UuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvcmVtb3ZlTm9uQVNDSUkuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvcmVtb3ZlTm9uV29yZC5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvcmVwbGFjZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9yZXBsYWNlQWNjZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9ycGFkLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3J0cmltLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3NlbnRlbmNlQ2FzZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy9zbHVnaWZ5LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3N0YXJ0c1dpdGguanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvc3RyaXBIdG1sVGFncy5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy90cmltLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3RydW5jYXRlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3R5cGVjYXN0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3VuQ2FtZWxDYXNlLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3VuZGVyc2NvcmUuanMiLCJub2RlX21vZHVsZXMvbW91dC9zdHJpbmcvdW5lc2NhcGVIdG1sLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvc3RyaW5nL3VuZXNjYXBlVW5pY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy91bmh5cGhlbmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb3V0L3N0cmluZy91cHBlckNhc2UuanMiLCJub2RlX21vZHVsZXMvbW91dC90aW1lLmpzIiwibm9kZV9tb2R1bGVzL21vdXQvdGltZS9jb252ZXJ0LmpzIiwibm9kZV9tb2R1bGVzL21vdXQvdGltZS9ub3cuanMiLCJub2RlX21vZHVsZXMvbW91dC90aW1lL3BhcnNlTXMuanMiLCJub2RlX21vZHVsZXMvbW91dC90aW1lL3RvVGltZVN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIi9Vc2Vycy9sdWtlL2Rldi8wNDA3MTUvc291cmNlL2pzL2FwcC1kZWJ1Zy5jb2ZmZWUiLCIvVXNlcnMvbHVrZS9kZXYvMDQwNzE1L3NvdXJjZS9qcy9jb25maWcuY29mZmVlIiwiL1VzZXJzL2x1a2UvZGV2LzA0MDcxNS9zb3VyY2UvanMvbW9kdWxlL2Fic3RyYWN0LW1vZHVsZS5jb2ZmZWUiLCIvVXNlcnMvbHVrZS9kZXYvMDQwNzE1L3NvdXJjZS9qcy9tb2R1bGUvYWJzdHJhY3Qtc2NlbmUuY29mZmVlIiwiL1VzZXJzL2x1a2UvZGV2LzA0MDcxNS9zb3VyY2UvanMvbW9kdWxlL2luZGV4LmNvZmZlZSIsIi9Vc2Vycy9sdWtlL2Rldi8wNDA3MTUvc291cmNlL2pzL21vZHVsZS9zY2VuZS1kYXkuY29mZmVlIiwiL1VzZXJzL2x1a2UvZGV2LzA0MDcxNS9zb3VyY2UvanMvbW9kdWxlL3NjZW5lLW1vcm5pbmcuY29mZmVlIiwiL1VzZXJzL2x1a2UvZGV2LzA0MDcxNS9zb3VyY2UvanMvbW9kdWxlL3NjZW5lLW5pZ2h0LmNvZmZlZSIsIi9Vc2Vycy9sdWtlL2Rldi8wNDA3MTUvc291cmNlL2pzL21vZHVsZS9zdGFnZS5jb2ZmZWUiLCIvVXNlcnMvbHVrZS9kZXYvMDQwNzE1L3NvdXJjZS9qcy91dGlsL2FkZENsYXNzLmNvZmZlZSIsIi9Vc2Vycy9sdWtlL2Rldi8wNDA3MTUvc291cmNlL2pzL3V0aWwvc3VwcG9ydGVkLmNvZmZlZSIsIi9Vc2Vycy9sdWtlL2Rldi8wNDA3MTUvc291cmNlL2pzL3ZpZXcvbWFpbi12aWV3LmNvZmZlZSIsInNvdXJjZS90ZW1wbGF0ZS9tYWluLXZpZXcuaHRtbCIsInNvdXJjZS90ZW1wbGF0ZS9tb2R1bGUvYWJzdHJhY3Qtc2NlbmUuaHRtbCIsInNvdXJjZS90ZW1wbGF0ZS9tb2R1bGUvc2NlbmUtZGF5Lmh0bWwiLCJzb3VyY2UvdGVtcGxhdGUvbW9kdWxlL3NjZW5lLW1vcm5pbmcuaHRtbCIsInNvdXJjZS90ZW1wbGF0ZS9tb2R1bGUvc2NlbmUtbmlnaHQuaHRtbCIsInNvdXJjZS90ZW1wbGF0ZS9tb2R1bGUvc3RhZ2UuaHRtbCIsInNvdXJjZS90ZW1wbGF0ZS9wYXJ0aWFscy9mYXJtLmh0bWwiLCJzb3VyY2UvdGVtcGxhdGUvcGFydGlhbHMvbG9hZGVyLmh0bWwiLCJzb3VyY2UvdGVtcGxhdGUvcGFydGlhbHMvc2xpZGUtY29udHJvbHMuaHRtbCIsInNvdXJjZS90ZW1wbGF0ZS9wYXJ0aWFscy9zdGFnZS1jb250cm9scy5odG1sIiwic291cmNlL3RlbXBsYXRlL3BhcnRpYWxzL3N1bi5odG1sIiwidmVuZG9yL2RvbXJlYWR5L3JlYWR5LmpzIiwidmVuZG9yL2dzYXAvc3JjL3VuY29tcHJlc3NlZC9Ud2Vlbk1heC5qcyIsInZlbmRvci9oYW1tZXJqcy9oYW1tZXIuanMiLCJ2ZW5kb3IvcGFnZS9wYWdlLmpzIiwidmVuZG9yL3BsYXRmb3JtL3BsYXRmb3JtLmpzIiwidmVuZG9yL3JhY3RpdmUtZXZlbnRzLXRhcC9yYWN0aXZlLWV2ZW50cy10YXAuanMiLCJ2ZW5kb3IvcmFjdGl2ZS10b3VjaC9pbmRleC5qcyIsInZlbmRvci9yYWN0aXZlLXRyYW5zaXRpb25zLWZhZGUvcmFjdGl2ZS10cmFuc2l0aW9ucy1mYWRlLmpzIiwidmVuZG9yL3JhY3RpdmUtdHJhbnNpdGlvbnMtZmx5L3JhY3RpdmUtdHJhbnNpdGlvbnMtZmx5LmpzIiwidmVuZG9yL3JhY3RpdmUtdHJhbnNpdGlvbnMtc2xpZGUvcmFjdGl2ZS10cmFuc2l0aW9ucy1zbGlkZS5qcyIsInZlbmRvci9yYWN0aXZlL3JhY3RpdmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNDQSxPQUFBLENBQVEsZ0JBQVIsQ0FBQSxDQUFBOztBQUFBLE9BR0EsQ0FBUSxNQUFSLENBSEEsQ0FBQTs7QUFBQSxPQU1BLENBQVEsb0JBQVIsQ0FOQSxDQUFBOztBQUFBLE9BT0EsQ0FBUSxlQUFSLENBUEEsQ0FBQTs7QUFBQSxPQVFBLENBQVEsMEJBQVIsQ0FSQSxDQUFBOztBQUFBLE9BU0EsQ0FBUSx5QkFBUixDQVRBLENBQUE7O0FBQUEsT0FVQSxDQUFRLDJCQUFSLENBVkEsQ0FBQTs7QUFBQSxPQWFBLENBQVEsVUFBUixDQUFBLENBQW9CLFNBQUEsR0FBQTtBQUNuQixNQUFBLElBQUE7QUFBQSxFQUFBLElBQTRCLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBWixLQUF3QixhQUFwRDtBQUFBLElBQUEsT0FBQSxDQUFRLGFBQVIsQ0FBQSxDQUFBLENBQUEsQ0FBQTtHQUFBO0FBQUEsRUFFQSxJQUFBLEdBQU8sT0FBQSxDQUFRLGtCQUFSLENBRlAsQ0FBQTtTQUdBLE1BQU0sQ0FBQyxLQUFQLEdBQW1CLElBQUEsSUFBQSxDQUFBLEVBSkE7QUFBQSxDQUFwQixDQWJBLENBQUE7Ozs7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNrSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEEsSUFBQSx1QkFBQTs7QUFBQSxHQUFBLEdBQU0sT0FBQSxDQUFRLFNBQVIsQ0FBTixDQUFBOztBQUFBLElBQ0EsR0FBTyxPQUFBLENBQVEsTUFBUixDQURQLENBQUE7O0FBQUEsR0FJQSxHQUFNLE1BQU0sQ0FBQyxJQUFQLEdBQWtCLElBQUEsR0FBRyxDQUFDLEdBQUosQ0FBQSxDQUp4QixDQUFBOztBQUFBLE9BTUEsR0FDQztBQUFBLEVBQUEsT0FBQSxFQUFTLEtBQVQ7QUFBQSxFQUNBLE9BQUEsRUFBUyxTQUFBLEdBQUE7V0FBRyxJQUFBLENBQUssUUFBTCxFQUFIO0VBQUEsQ0FEVDtBQUFBLEVBRUEsU0FBQSxFQUFXLFNBQUEsR0FBQTtXQUFHLElBQUEsQ0FBSyxnQkFBTCxFQUFIO0VBQUEsQ0FGWDtBQUFBLEVBR0EsS0FBQSxFQUFPLFNBQUEsR0FBQTtXQUFHLElBQUEsQ0FBSyxZQUFMLEVBQUg7RUFBQSxDQUhQO0FBQUEsRUFJQSxPQUFBLEVBQVMsU0FBQSxHQUFBO1dBQUcsSUFBQSxDQUFLLGNBQUwsRUFBSDtFQUFBLENBSlQ7Q0FQRCxDQUFBOztBQUFBLE1BYU0sQ0FBQyxPQUFQLEdBQWlCLFNBQUEsR0FBQTtBQUVoQixNQUFBLGFBQUE7QUFBQSxFQUFBLEtBQUEsR0FBUSxHQUFHLENBQUMsR0FBSixDQUFRLE9BQVIsRUFBaUIsT0FBakIsQ0FBUixDQUFBO0FBQUEsRUFHQSxNQUFBLEdBQVMsR0FBRyxDQUFDLFNBQUosQ0FBYyxZQUFkLENBSFQsQ0FBQTtBQUFBLEVBSUEsTUFBTSxDQUFDLEdBQVAsQ0FBVyxPQUFYLEVBQW9CLE9BQXBCLENBQTRCLENBQUMsSUFBN0IsQ0FBa0MsUUFBbEMsQ0FKQSxDQUFBO0FBQUEsRUFLQSxNQUFNLENBQUMsR0FBUCxDQUFXLE9BQVgsRUFBb0IsU0FBcEIsQ0FBOEIsQ0FBQyxJQUEvQixDQUFvQyxVQUFwQyxDQUxBLENBQUE7QUFBQSxFQU1BLE1BQU0sQ0FBQyxHQUFQLENBQVcsT0FBWCxFQUFvQixLQUFwQixDQUEwQixDQUFDLElBQTNCLENBQWdDLE1BQWhDLENBTkEsQ0FBQTtBQUFBLEVBT0EsTUFBTSxDQUFDLEdBQVAsQ0FBVyxPQUFYLEVBQW9CLE9BQXBCLENBQTRCLENBQUMsSUFBN0IsQ0FBa0MsUUFBbEMsQ0FQQSxDQUFBO1NBUUEsTUFBTSxDQUFDLElBQVAsQ0FBQSxFQVZnQjtBQUFBLENBYmpCLENBQUE7Ozs7O0FDQUEsTUFBTSxDQUFDLE9BQVAsR0FFSTtBQUFBLEVBQUEsUUFBQSxFQUFVLFdBQVY7Q0FGSixDQUFBOzs7OztBQ0FBLElBQUEsT0FBQTs7QUFBQSxPQUFBLEdBQVUsT0FBQSxDQUFRLFNBQVIsQ0FBVixDQUFBOztBQUFBLE1BR00sQ0FBQyxPQUFQLEdBQWlCLE9BQU8sQ0FBQyxNQUFSLENBRWhCO0FBQUEsRUFBQSxRQUFBLEVBQVUsSUFBVjtDQUZnQixDQUhqQixDQUFBOzs7OztBQ0FBO0FBQUE7Ozs7O0dBQUE7QUFBQSxJQUFBLE1BQUE7O0FBQUEsTUFRQSxHQUFTLE9BQUEsQ0FBUSxtQkFBUixDQVJULENBQUE7O0FBQUEsTUFVTSxDQUFDLE9BQVAsR0FBaUIsTUFBTSxDQUFDLE1BQVAsQ0FFaEI7QUFBQSxFQUFBLFFBQUEsRUFBVSxPQUFBLENBQVEsNEJBQVIsQ0FBVjtBQUFBLEVBRUEsTUFBQSxFQUFRLFNBQUEsR0FBQSxDQUZSO0NBRmdCLENBVmpCLENBQUE7Ozs7O0FDQUE7QUFBQTs7O0dBQUE7QUFBQSxJQUFBLGlCQUFBOztBQUFBLE9BSUEsR0FBVSxPQUFBLENBQVEsU0FBUixDQUpWLENBQUE7O0FBQUEsUUFNQSxHQUFXLFNBQUEsR0FBQTtBQUNWLEVBQUEsT0FBTyxDQUFDLFVBQVcsQ0FBQSxtQkFBQSxDQUFuQixHQUEwQyxPQUFBLENBQVEsa0JBQVIsQ0FBMUMsQ0FBQTtBQUFBLEVBQ0EsT0FBTyxDQUFDLFVBQVcsQ0FBQSxjQUFBLENBQW5CLEdBQXFDLE9BQUEsQ0FBUSxhQUFSLENBRHJDLENBQUE7QUFBQSxFQUVBLE9BQU8sQ0FBQyxVQUFXLENBQUEsa0JBQUEsQ0FBbkIsR0FBeUMsT0FBQSxDQUFRLGlCQUFSLENBRnpDLENBQUE7QUFBQSxFQUdBLE9BQU8sQ0FBQyxVQUFXLENBQUEsZ0JBQUEsQ0FBbkIsR0FBdUMsT0FBQSxDQUFRLGVBQVIsQ0FIdkMsQ0FBQTtBQUFBLEVBSUEsT0FBTyxDQUFDLFVBQVcsQ0FBQSxVQUFBLENBQW5CLEdBQWlDLE9BQUEsQ0FBUSxTQUFSLENBSmpDLENBQUE7U0FNQSxLQVBVO0FBQUEsQ0FOWCxDQUFBOztBQUFBLE1BZU0sQ0FBQyxPQUFQLEdBQWlCLFFBQUEsQ0FBQSxDQWZqQixDQUFBOzs7OztBQ0FBO0FBQUE7Ozs7O0dBQUE7QUFBQSxJQUFBLGtCQUFBOztBQUFBLE1BUUEsR0FBUyxPQUFBLENBQVEsa0JBQVIsQ0FSVCxDQUFBOztBQUFBLElBU0EsR0FBTyxPQUFBLENBQVEsTUFBUixDQUFlLENBQUMsTUFBTSxDQUFDLElBVDlCLENBQUE7O0FBQUEsSUFVQSxHQUFPLE9BQUEsQ0FBUSxNQUFSLENBQWUsQ0FBQyxLQUFLLENBQUMsSUFWN0IsQ0FBQTs7QUFBQSxNQVlNLENBQUMsT0FBUCxHQUFpQixNQUFNLENBQUMsTUFBUCxDQUVoQjtBQUFBLEVBQUEsUUFBQSxFQUFVLE9BQUEsQ0FBUSx1QkFBUixDQUFWO0FBQUEsRUFFQSxRQUFBLEVBQ0M7QUFBQSxJQUFBLGFBQUEsRUFBZSxPQUFBLENBQVEsOEJBQVIsQ0FBZjtHQUhEO0FBQUEsRUFLQSxJQUFBLEVBQ0M7QUFBQSxJQUFBLE9BQUEsRUFBUyxDQUFUO0FBQUEsSUFDQSxDQUFBLEVBQUcsQ0FBQyxNQUFELEVBQVMsT0FBVCxDQURIO0dBTkQ7QUFBQSxFQVNBLE1BQUEsRUFBUSxTQUFBLEdBQUE7V0FBRyxJQUFDLENBQUEsTUFBRCxDQUFBLEVBQUg7RUFBQSxDQVRSO0FBQUEsRUFXQSxVQUFBLEVBQVksU0FBQSxHQUFBO0FBQ1gsSUFBQSxJQUFDLENBQUEsU0FBRCxDQUFBLENBQUEsQ0FBQTtXQUVBLElBQUMsQ0FBQSxHQUFELENBQUssaUJBQUwsRUFBd0IsS0FBeEIsRUFIVztFQUFBLENBWFo7QUFBQSxFQWdCQSxRQUFBLEVBQVUsU0FBQSxHQUFBO0FBQ1QsSUFBQSxJQUFDLENBQUEsRUFBRCxDQUFJLGFBQUosRUFBbUIsU0FBQSxHQUFBO2FBQUcsSUFBQyxDQUFBLFNBQUQsQ0FBQSxFQUFIO0lBQUEsQ0FBbkIsQ0FBQSxDQUFBO0FBQUEsSUFDQSxJQUFDLENBQUEsRUFBRCxDQUFJLGFBQUosRUFBbUIsU0FBQSxHQUFBO2FBQUcsSUFBQyxDQUFBLFNBQUQsQ0FBQSxFQUFIO0lBQUEsQ0FBbkIsQ0FEQSxDQUFBO1dBR0EsSUFBQyxDQUFBLFNBQUQsQ0FBQSxFQUpTO0VBQUEsQ0FoQlY7QUFBQSxFQXNCQSxTQUFBLEVBQVcsU0FBQSxHQUFBO0FBQ1YsUUFBQSxhQUFBO0FBQUEsSUFBQSxPQUFBLEdBQVUsSUFBQyxDQUFBLEdBQUQsQ0FBSyxTQUFMLENBQVYsQ0FBQTtBQUFBLElBQ0EsSUFBQSxHQUFVLE9BQUEsS0FBVyxJQUFBLENBQUssSUFBQyxDQUFBLEdBQUQsQ0FBSyxRQUFMLENBQUwsQ0FBb0IsQ0FBQyxNQUFuQyxHQUErQyxDQUEvQyxHQUFzRCxPQUFBLElBQVMsQ0FEdEUsQ0FBQTtBQUVBLElBQUEsSUFBb0QsSUFBQyxDQUFBLEdBQUQsQ0FBSyxTQUFMLENBQUEsS0FBcUIsQ0FBekU7QUFBQSxNQUFBLElBQUMsQ0FBQSxHQUFELENBQUssU0FBQSxHQUFTLENBQUMsSUFBQyxDQUFBLEdBQUQsQ0FBSyxTQUFMLENBQUQsQ0FBVCxHQUEwQixJQUEvQixFQUFvQyxJQUFDLENBQUEsR0FBRCxDQUFLLE1BQUwsQ0FBcEMsQ0FBQSxDQUFBO0tBRkE7QUFBQSxJQUdBLElBQUMsQ0FBQSxHQUFELENBQUssU0FBQSxHQUFVLElBQVYsR0FBZSxJQUFwQixFQUF5QixJQUFDLENBQUEsR0FBRCxDQUFLLE1BQUwsQ0FBekIsQ0FIQSxDQUFBO1dBSUEsSUFBQyxDQUFBLFFBQUQsQ0FBVSxJQUFWLEVBTFU7RUFBQSxDQXRCWDtBQUFBLEVBNkJBLFNBQUEsRUFBVyxTQUFBLEdBQUE7QUFDVixRQUFBLGFBQUE7QUFBQSxJQUFBLE9BQUEsR0FBVSxJQUFDLENBQUEsR0FBRCxDQUFLLFNBQUwsQ0FBVixDQUFBO0FBQUEsSUFDQSxJQUFBLEdBQVUsT0FBQSxLQUFXLENBQWQsR0FBcUIsSUFBQSxDQUFLLElBQUMsQ0FBQSxHQUFELENBQUssUUFBTCxDQUFMLENBQW9CLENBQUMsTUFBMUMsR0FBc0QsT0FBQSxJQUFTLENBRHRFLENBQUE7QUFFQSxJQUFBLElBQW9ELElBQUMsQ0FBQSxHQUFELENBQUssU0FBTCxDQUFBLEtBQXFCLENBQXpFO0FBQUEsTUFBQSxJQUFDLENBQUEsR0FBRCxDQUFLLFNBQUEsR0FBUyxDQUFDLElBQUMsQ0FBQSxHQUFELENBQUssU0FBTCxDQUFELENBQVQsR0FBMEIsSUFBL0IsRUFBb0MsSUFBQyxDQUFBLEdBQUQsQ0FBSyxNQUFMLENBQXBDLENBQUEsQ0FBQTtLQUZBO0FBQUEsSUFHQSxJQUFDLENBQUEsR0FBRCxDQUFLLFNBQUEsR0FBVSxJQUFWLEdBQWUsSUFBcEIsRUFBeUIsSUFBQyxDQUFBLEdBQUQsQ0FBSyxNQUFMLENBQXpCLENBSEEsQ0FBQTtXQUlBLElBQUMsQ0FBQSxRQUFELENBQVUsSUFBVixFQUxVO0VBQUEsQ0E3Qlg7QUFBQSxFQW9DQSxRQUFBLEVBQVUsU0FBQyxLQUFELEdBQUE7QUFDVCxJQUFBLElBQWtELElBQUMsQ0FBQSxHQUFELENBQUssU0FBTCxDQUFBLEtBQXFCLENBQXZFO0FBQUEsTUFBQSxJQUFDLENBQUEsR0FBRCxDQUFLLFNBQUEsR0FBUyxDQUFDLElBQUMsQ0FBQSxHQUFELENBQUssU0FBTCxDQUFELENBQVQsR0FBMEIsU0FBL0IsRUFBeUMsS0FBekMsQ0FBQSxDQUFBO0tBQUE7QUFBQSxJQUNBLElBQUMsQ0FBQSxHQUFELENBQUssU0FBQSxHQUFVLEtBQVYsR0FBZ0IsU0FBckIsRUFBK0IsSUFBL0IsQ0FEQSxDQUFBO1dBRUEsSUFBQyxDQUFBLEdBQUQsQ0FBSztBQUFBLE1BQUEsT0FBQSxFQUFTLEtBQVQ7S0FBTCxFQUhTO0VBQUEsQ0FwQ1Y7Q0FGZ0IsQ0FaakIsQ0FBQTs7Ozs7QUNBQTtBQUFBOzs7OztHQUFBO0FBQUEsSUFBQSxNQUFBOztBQUFBLE1BUUEsR0FBUyxPQUFBLENBQVEsa0JBQVIsQ0FSVCxDQUFBOztBQUFBLE1BV00sQ0FBQyxPQUFQLEdBQWlCLE1BQU0sQ0FBQyxNQUFQLENBRWhCO0FBQUEsRUFBQSxRQUFBLEVBQVUsT0FBQSxDQUFRLDJCQUFSLENBQVY7QUFBQSxFQUVBLE1BQUEsRUFBUSxTQUFBLEdBQUE7V0FBRyxJQUFDLENBQUEsTUFBRCxDQUFBLEVBQUg7RUFBQSxDQUZSO0FBQUEsRUFJQSxRQUFBLEVBQVUsU0FBQSxHQUFBLENBSlY7Q0FGZ0IsQ0FYakIsQ0FBQTs7Ozs7QUNBQTtBQUFBOzs7OztHQUFBO0FBQUEsSUFBQSxnQkFBQTs7QUFBQSxNQVFBLEdBQVMsT0FBQSxDQUFRLGtCQUFSLENBUlQsQ0FBQTs7QUFBQSxRQVVBLEdBQVcsT0FBQSxDQUFRLGtCQUFSLENBVlgsQ0FBQTs7QUFBQSxNQVlNLENBQUMsT0FBUCxHQUFpQixNQUFNLENBQUMsTUFBUCxDQUVoQjtBQUFBLEVBQUEsUUFBQSxFQUFVLE9BQUEsQ0FBUSx5QkFBUixDQUFWO0FBQUEsRUFFQSxNQUFBLEVBQVEsU0FBQSxHQUFBO1dBQUcsSUFBQyxDQUFBLE1BQUQsQ0FBQSxFQUFIO0VBQUEsQ0FGUjtBQUFBLEVBSUEsUUFBQSxFQUFVLFNBQUEsR0FBQTtXQUNULElBQUMsQ0FBQSxFQUFELENBQUksYUFBSixFQUFtQixTQUFDLENBQUQsR0FBQTtBQUNsQixVQUFBLElBQUE7QUFBQSxNQUFBLElBQUMsQ0FBQSxJQUFELENBQU0sU0FBTixFQUFpQixJQUFDLENBQUEsR0FBRCxDQUFLLFNBQUwsQ0FBakIsQ0FBQSxDQUFBO0FBQUEsTUFHQSxJQUFDLENBQUEsR0FBRCxDQUFLLGFBQUwsQ0FIQSxDQUFBO0FBQUEsTUFJQSxRQUFRLENBQUMsY0FBVCxDQUF3QixTQUF4QixDQUFrQyxDQUFDLFFBQW5DLEdBQThDLElBSjlDLENBQUE7QUFBQSxNQUtBLFFBQUEsQ0FBUyxDQUFDLENBQUMsSUFBWCxFQUFpQixVQUFqQixDQUxBLENBQUE7QUFBQSxNQVFBLElBQUEsR0FBTyxJQUFDLENBQUEsSUFBRCxDQUFNLG1CQUFOLENBUlAsQ0FBQTthQVNBLElBQUksQ0FBQyxTQUFMLEdBQWlCLE9BVkM7SUFBQSxDQUFuQixFQURTO0VBQUEsQ0FKVjtDQUZnQixDQVpqQixDQUFBOzs7OztBQ0FBO0FBQUE7Ozs7O0dBQUE7QUFBQSxJQUFBLG1DQUFBOztBQUFBLE1BUUEsR0FBUyxPQUFBLENBQVEsbUJBQVIsQ0FSVCxDQUFBOztBQUFBLElBU0EsR0FBTyxPQUFBLENBQVEsTUFBUixDQVRQLENBQUE7O0FBQUEsSUFXQSxHQUFPLE9BQUEsQ0FBUSxNQUFSLENBQWUsQ0FBQyxNQUFNLENBQUMsSUFYOUIsQ0FBQTs7QUFBQSxLQVlBLEdBQVEsT0FBQSxDQUFRLE1BQVIsQ0FBZSxDQUFDLE1BQU0sQ0FBQyxLQVovQixDQUFBOztBQUFBLFFBYUEsR0FBVyxPQUFBLENBQVEsa0JBQVIsQ0FiWCxDQUFBOztBQUFBLE1BZU0sQ0FBQyxPQUFQLEdBQWlCLE1BQU0sQ0FBQyxNQUFQLENBRWhCO0FBQUEsRUFBQSxRQUFBLEVBQVUsT0FBQSxDQUFRLG1CQUFSLENBQVY7QUFBQSxFQUVBLFFBQUEsRUFDQztBQUFBLElBQUEsYUFBQSxFQUFlLE9BQUEsQ0FBUSw4QkFBUixDQUFmO0FBQUEsSUFDQSxJQUFBLEVBQU0sT0FBQSxDQUFRLG9CQUFSLENBRE47QUFBQSxJQUVBLEdBQUEsRUFBSyxPQUFBLENBQVEsbUJBQVIsQ0FGTDtHQUhEO0FBQUEsRUFPQSxJQUFBLEVBQ0M7QUFBQSxJQUFBLE9BQUEsRUFBUyxDQUFUO0FBQUEsSUFDQSxNQUFBLEVBQ0M7QUFBQSxNQUFBLENBQUEsRUFBRyxTQUFIO0FBQUEsTUFDQSxDQUFBLEVBQUcsS0FESDtBQUFBLE1BRUEsQ0FBQSxFQUFHLE9BRkg7S0FGRDtHQVJEO0FBQUEsRUFjQSxNQUFBLEVBQVEsU0FBQSxHQUFBO0FBRVAsSUFBQSxNQUFNLENBQUMsU0FBUCxHQUFtQixDQUFBLFNBQUEsS0FBQSxHQUFBO2FBQUEsU0FBQyxDQUFELEdBQUE7QUFDbEIsUUFBQSxJQUFnQixDQUFDLENBQUMsT0FBRixLQUFhLEVBQTdCO0FBQUEsVUFBQSxLQUFDLENBQUEsU0FBRCxDQUFBLENBQUEsQ0FBQTtTQUFBO0FBQ0EsUUFBQSxJQUFnQixDQUFDLENBQUMsT0FBRixLQUFhLEVBQTdCO2lCQUFBLEtBQUMsQ0FBQSxTQUFELENBQUEsRUFBQTtTQUZrQjtNQUFBLEVBQUE7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQW5CLENBQUE7QUFBQSxJQUlBLElBQUMsQ0FBQSxFQUFELENBQUksYUFBSixFQUFtQixTQUFBLEdBQUE7YUFBRyxJQUFDLENBQUEsU0FBRCxDQUFBLEVBQUg7SUFBQSxDQUFuQixDQUpBLENBQUE7QUFBQSxJQUtBLElBQUMsQ0FBQSxFQUFELENBQUksYUFBSixFQUFtQixTQUFBLEdBQUE7YUFBRyxJQUFDLENBQUEsU0FBRCxDQUFBLEVBQUg7SUFBQSxDQUFuQixDQUxBLENBQUE7V0FPQSxJQUFDLENBQUEsT0FBRCxDQUFTLE1BQVQsRUFBaUIsQ0FBQSxTQUFBLEtBQUEsR0FBQTthQUFBLFNBQUMsUUFBRCxHQUFBO0FBQ2hCLFFBQUEsSUFBRyxRQUFIO2lCQUNDLEtBQUEsQ0FBTSxLQUFDLENBQUEsR0FBRCxDQUFLLFFBQUwsQ0FBTixFQUFzQixTQUFDLENBQUQsRUFBSSxDQUFKLEdBQUE7QUFBVSxZQUFBLElBQXVDLENBQUEsS0FBSyxRQUE1QztBQUFBLHFCQUFPLEtBQUMsQ0FBQSxHQUFELENBQUs7QUFBQSxnQkFBQSxPQUFBLEVBQVMsUUFBQSxDQUFTLENBQVQsRUFBVyxFQUFYLENBQVQ7ZUFBTCxDQUFQLENBQUE7YUFBVjtVQUFBLENBQXRCLEVBREQ7U0FEZ0I7TUFBQSxFQUFBO0lBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFqQixFQVRPO0VBQUEsQ0FkUjtBQUFBLEVBMkJBLFNBQUEsRUFBVyxTQUFBLEdBQUE7QUFDVixRQUFBLGFBQUE7QUFBQSxJQUFBLE9BQUEsR0FBVSxJQUFDLENBQUEsR0FBRCxDQUFLLFNBQUwsQ0FBVixDQUFBO0FBQUEsSUFDQSxJQUFBLEdBQVUsT0FBQSxLQUFXLElBQUEsQ0FBSyxJQUFDLENBQUEsR0FBRCxDQUFLLFFBQUwsQ0FBTCxDQUFvQixDQUFDLE1BQW5DLEdBQStDLENBQS9DLEdBQXNELE9BQUEsSUFBUyxDQUR0RSxDQUFBO1dBRUEsSUFBQyxDQUFBLFFBQUQsQ0FBVSxJQUFWLEVBSFU7RUFBQSxDQTNCWDtBQUFBLEVBZ0NBLFNBQUEsRUFBVyxTQUFBLEdBQUE7QUFDVixRQUFBLGFBQUE7QUFBQSxJQUFBLE9BQUEsR0FBVSxJQUFDLENBQUEsR0FBRCxDQUFLLFNBQUwsQ0FBVixDQUFBO0FBQUEsSUFDQSxJQUFBLEdBQVUsT0FBQSxLQUFXLENBQWQsR0FBcUIsSUFBQSxDQUFLLElBQUMsQ0FBQSxHQUFELENBQUssUUFBTCxDQUFMLENBQW9CLENBQUMsTUFBMUMsR0FBc0QsT0FBQSxJQUFTLENBRHRFLENBQUE7V0FFQSxJQUFDLENBQUEsUUFBRCxDQUFVLElBQVYsRUFIVTtFQUFBLENBaENYO0FBQUEsRUFxQ0EsUUFBQSxFQUFVLFNBQUMsS0FBRCxHQUFBO1dBQ1QsSUFBQSxDQUFLLEdBQUEsR0FBRyxDQUFDLElBQUMsQ0FBQSxHQUFELENBQUssTUFBTCxDQUFELENBQUgsR0FBaUIsR0FBakIsR0FBbUIsQ0FBQyxJQUFDLENBQUEsR0FBRCxDQUFLLFNBQUEsR0FBVSxLQUFmLENBQUQsQ0FBeEIsRUFEUztFQUFBLENBckNWO0NBRmdCLENBZmpCLENBQUE7Ozs7O0FDQUEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBQyxFQUFELEVBQUssU0FBTCxHQUFBO0FBQ2hCLEVBQUEsSUFBRyxVQUFIO0FBQ0MsSUFBQSxJQUFHLG9CQUFIO2FBQ0MsRUFBRSxDQUFDLFNBQVMsQ0FBQyxHQUFiLENBQWlCLFNBQWpCLEVBREQ7S0FBQSxNQUFBO2FBR0MsRUFBRSxDQUFDLFNBQUgsSUFBZ0IsR0FBQSxHQUFNLFVBSHZCO0tBREQ7R0FEZ0I7QUFBQSxDQUFqQixDQUFBOzs7OztBQ0FBLElBQUEsUUFBQTs7QUFBQSxRQUFBLEdBQVcsT0FBQSxDQUFRLFVBQVIsQ0FBWCxDQUFBOztBQUFBLE1BRU0sQ0FBQyxPQUFQLEdBQWlCLFNBQUEsR0FBQTtBQUdOLEVBQUEsSUFBRyxRQUFRLENBQUMsSUFBVCxLQUFpQixJQUFqQixJQUEwQixVQUFBLENBQVcsUUFBUSxDQUFDLE9BQXBCLENBQUEsR0FBK0IsQ0FBNUQ7V0FBbUUsTUFBbkU7R0FBQSxNQUFBO1dBQThFLEtBQTlFO0dBSE07QUFBQSxDQUZqQixDQUFBOzs7OztBQ0FBLElBQUEsMkRBQUE7RUFBQSxtSkFBQTs7QUFBQSxPQUFBLEdBQVUsT0FBQSxDQUFRLFNBQVIsQ0FBVixDQUFBOztBQUFBLFFBQ0EsR0FBVyxPQUFBLENBQVEsVUFBUixDQURYLENBQUE7O0FBQUEsSUFFQSxHQUFPLE9BQUEsQ0FBUSxNQUFSLENBRlAsQ0FBQTs7QUFBQSxTQUlBLEdBQVksT0FBQSxDQUFRLG1CQUFSLENBSlosQ0FBQTs7QUFBQSxJQUtBLEdBQU8sT0FBQSxDQUFRLE1BQVIsQ0FBZSxDQUFDLEtBQUssQ0FBQyxJQUw3QixDQUFBOztBQUFBLElBTUEsR0FBTyxPQUFBLENBQVEsTUFBUixDQUFlLENBQUMsTUFBTSxDQUFDLElBTjlCLENBQUE7O0FBQUEsR0FPQSxHQUFNLE9BQUEsQ0FBUSxNQUFSLENBQWUsQ0FBQyxNQUFNLENBQUMsR0FQN0IsQ0FBQTs7QUFBQSxNQVNBLEdBQVMsT0FBQSxDQUFRLFdBQVIsQ0FUVCxDQUFBOztBQUFBLE1BV00sQ0FBQyxPQUFQLEdBQWlCLE9BQU8sQ0FBQyxNQUFSLENBRWhCO0FBQUEsRUFBQSxFQUFBLEVBQUksUUFBUSxDQUFDLElBQWI7QUFBQSxFQUVBLE1BQUEsRUFBUSxJQUZSO0FBQUEsRUFJQSxRQUFBLEVBQVUsT0FBQSxDQUFRLGdCQUFSLENBSlY7QUFBQSxFQU1BLFFBQUEsRUFDQztBQUFBLElBQUEsTUFBQSxFQUFRLE9BQUEsQ0FBUSxzQkFBUixDQUFSO0dBUEQ7QUFBQSxFQVNBLElBQUEsRUFDQztBQUFBLElBQUEsSUFBQSxFQUFNLElBQU47QUFBQSxJQUNBLElBQUEsRUFBTSxJQUROO0FBQUEsSUFFQSxPQUFBLEVBQVMsSUFGVDtBQUFBLElBR0EsS0FBQSxFQUFPLElBSFA7QUFBQSxJQUlBLFVBQUEsRUFBWSxJQUpaO0FBQUEsSUFLQSxNQUFBLEVBQVEsS0FMUjtBQUFBLElBTUEsU0FBQSxFQUFXLElBTlg7R0FWRDtBQUFBLEVBa0JBLEVBQUEsRUFBSSxJQWxCSjtBQUFBLEVBb0JBLE1BQUEsRUFBUSxTQUFBLEdBQUE7QUFDUCxJQUFBLElBQUMsQ0FBQSxVQUFELENBQUEsQ0FBQSxDQUFBO0FBQUEsSUFHQSxJQUFDLENBQUEsR0FBRCxDQUFLO0FBQUEsTUFBQSxTQUFBLEVBQVcsU0FBQSxDQUFBLENBQVg7S0FBTCxDQUhBLENBQUE7QUFJQSxJQUFBLElBQVUsQ0FBQSxJQUFFLENBQUEsR0FBRCxDQUFLLFdBQUwsQ0FBWDtBQUFBO0tBTE87RUFBQSxDQXBCUjtBQUFBLEVBMkJBLFFBQUEsRUFBVSxTQUFBLEdBQUE7QUFFVCxRQUFBLElBQUE7QUFBQSxJQUFBLElBQUEsR0FBTyxJQUFDLENBQUEsR0FBRCxDQUFLLE1BQUwsQ0FBUCxDQUFBO0FBQ0EsSUFBQSxJQUFHLFlBQUg7YUFBYyxJQUFDLENBQUEsT0FBRCxDQUFTLElBQVQsRUFBZDtLQUFBLE1BQUE7YUFBa0MsSUFBQyxDQUFBLEdBQUQsQ0FBSyxZQUFMLEVBQW1CLEtBQW5CLEVBQWxDO0tBSFM7RUFBQSxDQTNCVjtBQUFBLEVBZ0NBLE9BQUEsRUFBUyxTQUFDLElBQUQsR0FBQTtBQUVSLElBQUEsSUFBQyxDQUFBLEVBQUQsR0FBVSxJQUFBLFFBQUEsQ0FBUyxVQUFBLEdBQVcsTUFBTSxDQUFDLFFBQWxCLEdBQTJCLGtCQUFwQyxDQUFWLENBQUE7V0FFQSxJQUFDLENBQUEsRUFBRSxDQUFDLElBQUosQ0FBUyxPQUFULEVBQWtCLENBQUEsU0FBQSxLQUFBLEdBQUE7YUFBQSxTQUFDLFFBQUQsR0FBQTtBQUNqQixZQUFBLElBQUE7QUFBQSxRQUFBLElBQUEsR0FBTyxRQUFRLENBQUMsR0FBVCxDQUFBLENBQVAsQ0FBQTtBQUFBLFFBQ0EsS0FBQyxDQUFBLEdBQUQsQ0FBSztBQUFBLFVBQUEsVUFBQSxFQUFlLGFBQVEsSUFBQSxDQUFLLElBQUksQ0FBQyxNQUFWLENBQVIsRUFBQSxJQUFBLE1BQUgsR0FBa0MsSUFBbEMsR0FBNEMsS0FBeEQ7U0FBTCxDQURBLENBQUE7QUFFQSxRQUFBLElBQVUsQ0FBQSxLQUFFLENBQUEsR0FBRCxDQUFLLFlBQUwsQ0FBWDtBQUFBLGdCQUFBLENBQUE7U0FGQTtlQUdBLEtBQUMsQ0FBQSxhQUFELENBQWUsSUFBZixFQUFxQixJQUFyQixFQUppQjtNQUFBLEVBQUE7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQWxCLEVBS0UsU0FBQyxHQUFELEdBQUE7YUFDRSxPQUFPLENBQUMsR0FBUixDQUFZLE1BQVosRUFBb0IsR0FBRyxDQUFDLElBQXhCLEVBREY7SUFBQSxDQUxGLEVBSlE7RUFBQSxDQWhDVDtBQUFBLEVBNENBLGFBQUEsRUFBZSxTQUFDLElBQUQsRUFBTyxJQUFQLEdBQUE7QUFFZCxJQUFBLElBQUMsQ0FBQSxHQUFELENBQ0M7QUFBQSxNQUFBLE9BQUEsRUFBUyxJQUFJLENBQUMsT0FBZDtBQUFBLE1BQ0EsS0FBQSxFQUFPLElBQUksQ0FBQyxNQUFPLENBQUEsRUFBQSxHQUFHLElBQUgsQ0FEbkI7QUFBQSxNQUVBLE9BQUEsRUFBWSxJQUFJLENBQUMsUUFBTCxJQUFrQixrQ0FBckIsR0FBb0QsSUFBSSxDQUFDLFFBQVMsQ0FBQSxFQUFBLEdBQUcsSUFBSCxDQUFXLENBQUEsRUFBQSxHQUFFLENBQUMsSUFBQSxDQUFLLElBQUEsQ0FBSyxJQUFJLENBQUMsUUFBUyxDQUFBLEVBQUEsR0FBRyxJQUFILENBQW5CLENBQUwsQ0FBRCxDQUFGLENBQTBDLENBQUMsT0FBeEgsR0FBcUksRUFGOUk7QUFBQSxNQUdBLE1BQUEsRUFBUSxJQUhSO0tBREQsQ0FBQSxDQUFBO1dBT0EsSUFBQyxDQUFBLEVBQUQsQ0FBSSxXQUFKLEVBQWlCLFNBQUMsR0FBRCxHQUFBO0FBQ2hCLFVBQUEsT0FBQTtBQUFBLE1BQUEsR0FBQSxHQUFVLElBQUEsSUFBQSxDQUFBLENBQVYsQ0FBQTtBQUFBLE1BQ0EsRUFBQSxHQUFLLEVBQUEsR0FBRSxDQUFDLEdBQUcsQ0FBQyxXQUFKLENBQUEsQ0FBRCxDQUFGLEdBQXNCLENBQUMsR0FBQSxDQUFJLEdBQUcsQ0FBQyxRQUFKLENBQUEsQ0FBQSxHQUFlLENBQW5CLEVBQXNCLENBQXRCLENBQUQsQ0FBdEIsR0FBaUQsQ0FBQyxHQUFBLENBQUksR0FBRyxDQUFDLE9BQUosQ0FBQSxDQUFKLEVBQW1CLENBQW5CLENBQUQsQ0FEdEQsQ0FBQTthQUVBLElBQUMsQ0FBQSxFQUFFLENBQUMsS0FBSixDQUFVLFdBQUEsR0FBVyxDQUFDLElBQUMsQ0FBQSxHQUFELENBQUssTUFBTCxDQUFELENBQXJCLENBQXFDLENBQUMsSUFBdEMsQ0FDQztBQUFBLFFBQUEsT0FBQSxFQUFTLEdBQVQ7QUFBQSxRQUNBLFNBQUEsRUFBVyxFQURYO09BREQsRUFIZ0I7SUFBQSxDQUFqQixFQVRjO0VBQUEsQ0E1Q2Y7QUFBQSxFQTREQSxVQUFBLEVBQVksU0FBQSxHQUFBO0FBQ1gsUUFBQSxJQUFBO0FBQUEsSUFBQSxJQUFBLEdBQU8sSUFBUCxDQUFBO0FBQUEsSUFFQSxJQUFBLENBQUssZ0JBQUwsRUFBdUIsU0FBQyxHQUFELEdBQUE7YUFDdEIsSUFBSSxDQUFDLEdBQUwsQ0FDQztBQUFBLFFBQUEsSUFBQSxFQUFNLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBakI7QUFBQSxRQUNBLElBQUEsRUFBUyx3QkFBSCxHQUEwQixHQUFHLENBQUMsTUFBTSxDQUFDLEtBQXJDLEdBQWdELFNBRHREO09BREQsRUFEc0I7SUFBQSxDQUF2QixDQUZBLENBQUE7V0FPQSxJQUFBLENBQUs7QUFBQSxNQUFBLEtBQUEsRUFBTyxLQUFQO0FBQUEsTUFBYyxRQUFBLEVBQVUsSUFBeEI7QUFBQSxNQUE4QixRQUFBLEVBQVUsS0FBeEM7S0FBTCxFQVJXO0VBQUEsQ0E1RFo7Q0FGZ0IsQ0FYakIsQ0FBQTs7Ozs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JpT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy81RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDanNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL21DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIiMgcmVnaXN0ZXIgYWxsIG1vZHVsZXNcbnJlcXVpcmUgXCIuL21vZHVsZS9pbmRleFwiXG5cbiMgcmVxdWlyZSBHU0FQXG5yZXF1aXJlIFwiZ3NhcFwiXG5cbiMgcmVxdWlyZSBSYWN0aXZlIHBsdWdpbnNcbnJlcXVpcmUgXCJyYWN0aXZlLWV2ZW50cy10YXBcIlxucmVxdWlyZSBcInJhY3RpdmUtdG91Y2hcIlxucmVxdWlyZSBcInJhY3RpdmUtdHJhbnNpdGlvbnMtZmFkZVwiXG5yZXF1aXJlIFwicmFjdGl2ZS10cmFuc2l0aW9ucy1mbHlcIlxucmVxdWlyZSBcInJhY3RpdmUtdHJhbnNpdGlvbnMtc2xpZGVcIlxuXG4jIHdhaXQgZm9yIHdoZW4gdGhlIGRvbSBpcyByZWFkeSBhbmQgbG9hZCBtYWluIHZpZXdcbnJlcXVpcmUoXCJkb21yZWFkeVwiKSAtPlxuXHRyZXF1aXJlKFwiLi9hcHAtZGVidWdcIikoKSBpZiBwcm9jZXNzLmVudi5OT0RFX0VOViBpcyBcImRldmVsb3BtZW50XCJcblxuXHRWaWV3ID0gcmVxdWlyZSBcIi4vdmlldy9tYWluLXZpZXdcIlxuXHR3aW5kb3cuX3ZpZXcgPSBuZXcgVmlldygpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdmVuZG9yL2RhdC5ndWknKVxubW9kdWxlLmV4cG9ydHMuY29sb3IgPSByZXF1aXJlKCcuL3ZlbmRvci9kYXQuY29sb3InKSIsIi8qKlxuICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhdC1ndWlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG4vKiogQG5hbWVzcGFjZSAqL1xudmFyIGRhdCA9IG1vZHVsZS5leHBvcnRzID0gZGF0IHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LmNvbG9yID0gZGF0LmNvbG9yIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LnV0aWxzID0gZGF0LnV0aWxzIHx8IHt9O1xuXG5kYXQudXRpbHMuY29tbW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgXG4gIHZhciBBUlJfRUFDSCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICB2YXIgQVJSX1NMSUNFID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBCYW5kLWFpZCBtZXRob2RzIGZvciB0aGluZ3MgdGhhdCBzaG91bGQgYmUgYSBsb3QgZWFzaWVyIGluIEphdmFTY3JpcHQuXG4gICAqIEltcGxlbWVudGF0aW9uIGFuZCBzdHJ1Y3R1cmUgaW5zcGlyZWQgYnkgdW5kZXJzY29yZS5qc1xuICAgKiBodHRwOi8vZG9jdW1lbnRjbG91ZC5naXRodWIuY29tL3VuZGVyc2NvcmUvXG4gICAqL1xuXG4gIHJldHVybiB7IFxuICAgIFxuICAgIEJSRUFLOiB7fSxcbiAgXG4gICAgZXh0ZW5kOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIFxuICAgICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICBpZiAoIXRoaXMuaXNVbmRlZmluZWQob2JqW2tleV0pKSBcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgfSwgdGhpcyk7XG4gICAgICBcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICBcbiAgICB9LFxuICAgIFxuICAgIGRlZmF1bHRzOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIFxuICAgICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICBpZiAodGhpcy5pc1VuZGVmaW5lZCh0YXJnZXRba2V5XSkpIFxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICBcbiAgICB9LFxuICAgIFxuICAgIGNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRvQ2FsbCA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRvQ2FsbC5sZW5ndGggLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IFt0b0NhbGxbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgZWFjaDogZnVuY3Rpb24ob2JqLCBpdHIsIHNjb3BlKSB7XG5cbiAgICAgIFxuICAgICAgaWYgKEFSUl9FQUNIICYmIG9iai5mb3JFYWNoID09PSBBUlJfRUFDSCkgeyBcbiAgICAgICAgXG4gICAgICAgIG9iai5mb3JFYWNoKGl0ciwgc2NvcGUpO1xuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gb2JqLmxlbmd0aCArIDApIHsgLy8gSXMgbnVtYmVyIGJ1dCBub3QgTmFOXG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgPSAwLCBsID0gb2JqLmxlbmd0aDsga2V5IDwgbDsga2V5KyspXG4gICAgICAgICAgaWYgKGtleSBpbiBvYmogJiYgaXRyLmNhbGwoc2NvcGUsIG9ialtrZXldLCBrZXkpID09PSB0aGlzLkJSRUFLKSBcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBcbiAgICAgICAgICBpZiAoaXRyLmNhbGwoc2NvcGUsIG9ialtrZXldLCBrZXkpID09PSB0aGlzLkJSRUFLKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICB9XG4gICAgICAgICAgICBcbiAgICB9LFxuICAgIFxuICAgIGRlZmVyOiBmdW5jdGlvbihmbmMpIHtcbiAgICAgIHNldFRpbWVvdXQoZm5jLCAwKTtcbiAgICB9LFxuICAgIFxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iai50b0FycmF5KSByZXR1cm4gb2JqLnRvQXJyYXkoKTtcbiAgICAgIHJldHVybiBBUlJfU0xJQ0UuY2FsbChvYmopO1xuICAgIH0sXG5cbiAgICBpc1VuZGVmaW5lZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBcbiAgICBpc051bGw6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgICB9LFxuICAgIFxuICAgIGlzTmFOOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogIT09IG9iajtcbiAgICB9LFxuICAgIFxuICAgIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yID09PSBBcnJheTtcbiAgICB9LFxuICAgIFxuICAgIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICAgIH0sXG4gICAgXG4gICAgaXNOdW1iZXI6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gb2JqKzA7XG4gICAgfSxcbiAgICBcbiAgICBpc1N0cmluZzogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBvYmorJyc7XG4gICAgfSxcbiAgICBcbiAgICBpc0Jvb2xlYW46IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSB0cnVlO1xuICAgIH0sXG4gICAgXG4gICAgaXNGdW5jdGlvbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuICBcbiAgfTtcbiAgICBcbn0pKCk7XG5cblxuZGF0LmNvbG9yLnRvU3RyaW5nID0gKGZ1bmN0aW9uIChjb21tb24pIHtcblxuICByZXR1cm4gZnVuY3Rpb24oY29sb3IpIHtcblxuICAgIGlmIChjb2xvci5hID09IDEgfHwgY29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLmEpKSB7XG5cbiAgICAgIHZhciBzID0gY29sb3IuaGV4LnRvU3RyaW5nKDE2KTtcbiAgICAgIHdoaWxlIChzLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgcyA9ICcwJyArIHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnIycgKyBzO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuICdyZ2JhKCcgKyBNYXRoLnJvdW5kKGNvbG9yLnIpICsgJywnICsgTWF0aC5yb3VuZChjb2xvci5nKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuYikgKyAnLCcgKyBjb2xvci5hICsgJyknO1xuXG4gICAgfVxuXG4gIH1cblxufSkoZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LkNvbG9yID0gZGF0LmNvbG9yLkNvbG9yID0gKGZ1bmN0aW9uIChpbnRlcnByZXQsIG1hdGgsIHRvU3RyaW5nLCBjb21tb24pIHtcblxuICB2YXIgQ29sb3IgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuX19zdGF0ZSA9IGludGVycHJldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93ICdGYWlsZWQgdG8gaW50ZXJwcmV0IGNvbG9yIGFyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgdGhpcy5fX3N0YXRlLmEgPSB0aGlzLl9fc3RhdGUuYSB8fCAxO1xuXG5cbiAgfTtcblxuICBDb2xvci5DT01QT05FTlRTID0gWydyJywnZycsJ2InLCdoJywncycsJ3YnLCdoZXgnLCdhJ107XG5cbiAgY29tbW9uLmV4dGVuZChDb2xvci5wcm90b3R5cGUsIHtcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9PcmlnaW5hbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmNvbnZlcnNpb24ud3JpdGUodGhpcyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdyJywgMik7XG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdnJywgMSk7XG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdiJywgMCk7XG5cbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2gnKTtcbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3MnKTtcbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3YnKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnYScsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmE7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5fX3N0YXRlLmEgPSB2O1xuICAgIH1cblxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnaGV4Jywge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKCF0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIRVgnKSB7XG4gICAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSBtYXRoLnJnYl90b19oZXgodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuaGV4O1xuXG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSB2O1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGRlZmluZVJHQkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdSR0InKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnUkdCJykge1xuICAgICAgICAgIHJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICAgICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdSR0InO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lSFNWQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50KSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcblxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnSFNWJylcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgICAgcmVjYWxjdWxhdGVIU1YodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSFNWJykge1xuICAgICAgICAgIHJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIU1YnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVSR0IoY29sb3IsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcblxuICAgIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSEVYJykge1xuXG4gICAgICBjb2xvci5fX3N0YXRlW2NvbXBvbmVudF0gPSBtYXRoLmNvbXBvbmVudF9mcm9tX2hleChjb2xvci5fX3N0YXRlLmhleCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXG4gICAgfSBlbHNlIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xuXG4gICAgICBjb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsIG1hdGguaHN2X3RvX3JnYihjb2xvci5fX3N0YXRlLmgsIGNvbG9yLl9fc3RhdGUucywgY29sb3IuX19zdGF0ZS52KSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aHJvdyAnQ29ycnVwdGVkIGNvbG9yIHN0YXRlJztcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVIU1YoY29sb3IpIHtcblxuICAgIHZhciByZXN1bHQgPSBtYXRoLnJnYl90b19oc3YoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cbiAgICBjb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsXG4gICAgICAgIHtcbiAgICAgICAgICBzOiByZXN1bHQucyxcbiAgICAgICAgICB2OiByZXN1bHQudlxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGlmICghY29tbW9uLmlzTmFOKHJlc3VsdC5oKSkge1xuICAgICAgY29sb3IuX19zdGF0ZS5oID0gcmVzdWx0Lmg7XG4gICAgfSBlbHNlIGlmIChjb21tb24uaXNVbmRlZmluZWQoY29sb3IuX19zdGF0ZS5oKSkge1xuICAgICAgY29sb3IuX19zdGF0ZS5oID0gMDtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBDb2xvcjtcblxufSkoZGF0LmNvbG9yLmludGVycHJldCA9IChmdW5jdGlvbiAodG9TdHJpbmcsIGNvbW1vbikge1xuXG4gIHZhciByZXN1bHQsIHRvUmV0dXJuO1xuXG4gIHZhciBpbnRlcnByZXQgPSBmdW5jdGlvbigpIHtcblxuICAgIHRvUmV0dXJuID0gZmFsc2U7XG5cbiAgICB2YXIgb3JpZ2luYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGNvbW1vbi50b0FycmF5KGFyZ3VtZW50cykgOiBhcmd1bWVudHNbMF07XG5cbiAgICBjb21tb24uZWFjaChJTlRFUlBSRVRBVElPTlMsIGZ1bmN0aW9uKGZhbWlseSkge1xuXG4gICAgICBpZiAoZmFtaWx5LmxpdG11cyhvcmlnaW5hbCkpIHtcblxuICAgICAgICBjb21tb24uZWFjaChmYW1pbHkuY29udmVyc2lvbnMsIGZ1bmN0aW9uKGNvbnZlcnNpb24sIGNvbnZlcnNpb25OYW1lKSB7XG5cbiAgICAgICAgICByZXN1bHQgPSBjb252ZXJzaW9uLnJlYWQob3JpZ2luYWwpO1xuXG4gICAgICAgICAgaWYgKHRvUmV0dXJuID09PSBmYWxzZSAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b1JldHVybiA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uTmFtZSA9IGNvbnZlcnNpb25OYW1lO1xuICAgICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb24gPSBjb252ZXJzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbi5CUkVBSztcblxuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY29tbW9uLkJSRUFLO1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIHJldHVybiB0b1JldHVybjtcblxuICB9O1xuXG4gIHZhciBJTlRFUlBSRVRBVElPTlMgPSBbXG5cbiAgICAvLyBTdHJpbmdzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc1N0cmluZyxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBUSFJFRV9DSEFSX0hFWDoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV0pKFtBLUYwLTldKShbQS1GMC05XSkkL2kpO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IHBhcnNlSW50KFxuICAgICAgICAgICAgICAgICAgJzB4JyArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsxXS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzJdLnRvU3RyaW5nKCkgKyB0ZXN0WzJdLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbM10udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBTSVhfQ0hBUl9IRVg6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldezZ9KSQvaSk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogcGFyc2VJbnQoJzB4JyArIHRlc3RbMV0udG9TdHJpbmcoKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBDU1NfUkdCOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiXFwoXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIENTU19SR0JBOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiYVxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwsXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSksXG4gICAgICAgICAgICAgIGE6IHBhcnNlRmxvYXQodGVzdFs0XSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gTnVtYmVyc1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNOdW1iZXIsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgSEVYOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBvcmlnaW5hbCxcbiAgICAgICAgICAgICAgY29udmVyc2lvbk5hbWU6ICdIRVgnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yLmhleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIEFycmF5c1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNBcnJheSxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBSR0JfQVJSQVk6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPSAzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICAgICAgYjogb3JpZ2luYWxbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICBSR0JBX0FSUkFZOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT0gNCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgICAgIGI6IG9yaWdpbmFsWzJdLFxuICAgICAgICAgICAgICBhOiBvcmlnaW5hbFszXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmFdO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBPYmplY3RzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc09iamVjdCxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBSR0JBX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgICAgICBiOiBvcmlnaW5hbC5iLFxuICAgICAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgICAgIGI6IGNvbG9yLmIsXG4gICAgICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgICAgICBiOiBvcmlnaW5hbC5iXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgICAgICBiOiBjb2xvci5iXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIEhTVkFfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgICAgIHY6IG9yaWdpbmFsLnYsXG4gICAgICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICAgICAgdjogY29sb3IudixcbiAgICAgICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBIU1ZfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgICAgIHY6IG9yaWdpbmFsLnZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgICAgIHY6IGNvbG9yLnZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cblxuICBdO1xuXG4gIHJldHVybiBpbnRlcnByZXQ7XG5cblxufSkoZGF0LmNvbG9yLnRvU3RyaW5nLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuY29sb3IubWF0aCA9IChmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHRtcENvbXBvbmVudDtcblxuICByZXR1cm4ge1xuXG4gICAgaHN2X3RvX3JnYjogZnVuY3Rpb24oaCwgcywgdikge1xuXG4gICAgICB2YXIgaGkgPSBNYXRoLmZsb29yKGggLyA2MCkgJSA2O1xuXG4gICAgICB2YXIgZiA9IGggLyA2MCAtIE1hdGguZmxvb3IoaCAvIDYwKTtcbiAgICAgIHZhciBwID0gdiAqICgxLjAgLSBzKTtcbiAgICAgIHZhciBxID0gdiAqICgxLjAgLSAoZiAqIHMpKTtcbiAgICAgIHZhciB0ID0gdiAqICgxLjAgLSAoKDEuMCAtIGYpICogcykpO1xuICAgICAgdmFyIGMgPSBbXG4gICAgICAgIFt2LCB0LCBwXSxcbiAgICAgICAgW3EsIHYsIHBdLFxuICAgICAgICBbcCwgdiwgdF0sXG4gICAgICAgIFtwLCBxLCB2XSxcbiAgICAgICAgW3QsIHAsIHZdLFxuICAgICAgICBbdiwgcCwgcV1cbiAgICAgIF1baGldO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByOiBjWzBdICogMjU1LFxuICAgICAgICBnOiBjWzFdICogMjU1LFxuICAgICAgICBiOiBjWzJdICogMjU1XG4gICAgICB9O1xuXG4gICAgfSxcblxuICAgIHJnYl90b19oc3Y6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblxuICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgICAgIGgsIHM7XG5cbiAgICAgIGlmIChtYXggIT0gMCkge1xuICAgICAgICBzID0gZGVsdGEgLyBtYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGg6IE5hTixcbiAgICAgICAgICBzOiAwLFxuICAgICAgICAgIHY6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHIgPT0gbWF4KSB7XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGcgPT0gbWF4KSB7XG4gICAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG4gICAgICB9XG4gICAgICBoIC89IDY7XG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoOiBoICogMzYwLFxuICAgICAgICBzOiBzLFxuICAgICAgICB2OiBtYXggLyAyNTVcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHJnYl90b19oZXg6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICAgIHZhciBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudCgwLCAyLCByKTtcbiAgICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMSwgZyk7XG4gICAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDAsIGIpO1xuICAgICAgcmV0dXJuIGhleDtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50X2Zyb21faGV4OiBmdW5jdGlvbihoZXgsIGNvbXBvbmVudEluZGV4KSB7XG4gICAgICByZXR1cm4gKGhleCA+PiAoY29tcG9uZW50SW5kZXggKiA4KSkgJiAweEZGO1xuICAgIH0sXG5cbiAgICBoZXhfd2l0aF9jb21wb25lbnQ6IGZ1bmN0aW9uKGhleCwgY29tcG9uZW50SW5kZXgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPDwgKHRtcENvbXBvbmVudCA9IGNvbXBvbmVudEluZGV4ICogOCkgfCAoaGV4ICYgfiAoMHhGRiA8PCB0bXBDb21wb25lbnQpKTtcbiAgICB9XG5cbiAgfVxuXG59KSgpLFxuZGF0LmNvbG9yLnRvU3RyaW5nLFxuZGF0LnV0aWxzLmNvbW1vbik7IiwiLyoqXG4gKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuICpcbiAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbi8qKiBAbmFtZXNwYWNlICovXG52YXIgZGF0ID0gbW9kdWxlLmV4cG9ydHMgPSBkYXQgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQuZ3VpID0gZGF0Lmd1aSB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC51dGlscyA9IGRhdC51dGlscyB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5jb250cm9sbGVycyA9IGRhdC5jb250cm9sbGVycyB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5kb20gPSBkYXQuZG9tIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LmNvbG9yID0gZGF0LmNvbG9yIHx8IHt9O1xuXG5kYXQudXRpbHMuY3NzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBsb2FkOiBmdW5jdGlvbiAodXJsLCBkb2MpIHtcbiAgICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcbiAgICAgIHZhciBsaW5rID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICAgIGxpbmsudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICAgIGxpbmsuaHJlZiA9IHVybDtcbiAgICAgIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIH0sXG4gICAgaW5qZWN0OiBmdW5jdGlvbihjc3MsIGRvYykge1xuICAgICAgZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuICAgICAgdmFyIGluamVjdGVkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIGluamVjdGVkLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgaW5qZWN0ZWQuaW5uZXJIVE1MID0gY3NzO1xuICAgICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoaW5qZWN0ZWQpO1xuICAgIH1cbiAgfVxufSkoKTtcblxuXG5kYXQudXRpbHMuY29tbW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgXG4gIHZhciBBUlJfRUFDSCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICB2YXIgQVJSX1NMSUNFID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBCYW5kLWFpZCBtZXRob2RzIGZvciB0aGluZ3MgdGhhdCBzaG91bGQgYmUgYSBsb3QgZWFzaWVyIGluIEphdmFTY3JpcHQuXG4gICAqIEltcGxlbWVudGF0aW9uIGFuZCBzdHJ1Y3R1cmUgaW5zcGlyZWQgYnkgdW5kZXJzY29yZS5qc1xuICAgKiBodHRwOi8vZG9jdW1lbnRjbG91ZC5naXRodWIuY29tL3VuZGVyc2NvcmUvXG4gICAqL1xuXG4gIHJldHVybiB7IFxuICAgIFxuICAgIEJSRUFLOiB7fSxcbiAgXG4gICAgZXh0ZW5kOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIFxuICAgICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICBpZiAoIXRoaXMuaXNVbmRlZmluZWQob2JqW2tleV0pKSBcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgfSwgdGhpcyk7XG4gICAgICBcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICBcbiAgICB9LFxuICAgIFxuICAgIGRlZmF1bHRzOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIFxuICAgICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICBpZiAodGhpcy5pc1VuZGVmaW5lZCh0YXJnZXRba2V5XSkpIFxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICBcbiAgICB9LFxuICAgIFxuICAgIGNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRvQ2FsbCA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRvQ2FsbC5sZW5ndGggLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IFt0b0NhbGxbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgZWFjaDogZnVuY3Rpb24ob2JqLCBpdHIsIHNjb3BlKSB7XG5cbiAgICAgIFxuICAgICAgaWYgKEFSUl9FQUNIICYmIG9iai5mb3JFYWNoID09PSBBUlJfRUFDSCkgeyBcbiAgICAgICAgXG4gICAgICAgIG9iai5mb3JFYWNoKGl0ciwgc2NvcGUpO1xuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gb2JqLmxlbmd0aCArIDApIHsgLy8gSXMgbnVtYmVyIGJ1dCBub3QgTmFOXG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgPSAwLCBsID0gb2JqLmxlbmd0aDsga2V5IDwgbDsga2V5KyspXG4gICAgICAgICAgaWYgKGtleSBpbiBvYmogJiYgaXRyLmNhbGwoc2NvcGUsIG9ialtrZXldLCBrZXkpID09PSB0aGlzLkJSRUFLKSBcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBcbiAgICAgICAgICBpZiAoaXRyLmNhbGwoc2NvcGUsIG9ialtrZXldLCBrZXkpID09PSB0aGlzLkJSRUFLKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICB9XG4gICAgICAgICAgICBcbiAgICB9LFxuICAgIFxuICAgIGRlZmVyOiBmdW5jdGlvbihmbmMpIHtcbiAgICAgIHNldFRpbWVvdXQoZm5jLCAwKTtcbiAgICB9LFxuICAgIFxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iai50b0FycmF5KSByZXR1cm4gb2JqLnRvQXJyYXkoKTtcbiAgICAgIHJldHVybiBBUlJfU0xJQ0UuY2FsbChvYmopO1xuICAgIH0sXG5cbiAgICBpc1VuZGVmaW5lZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBcbiAgICBpc051bGw6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgICB9LFxuICAgIFxuICAgIGlzTmFOOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogIT09IG9iajtcbiAgICB9LFxuICAgIFxuICAgIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yID09PSBBcnJheTtcbiAgICB9LFxuICAgIFxuICAgIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICAgIH0sXG4gICAgXG4gICAgaXNOdW1iZXI6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gb2JqKzA7XG4gICAgfSxcbiAgICBcbiAgICBpc1N0cmluZzogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBvYmorJyc7XG4gICAgfSxcbiAgICBcbiAgICBpc0Jvb2xlYW46IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSB0cnVlO1xuICAgIH0sXG4gICAgXG4gICAgaXNGdW5jdGlvbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuICBcbiAgfTtcbiAgICBcbn0pKCk7XG5cblxuZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgQW4gXCJhYnN0cmFjdFwiIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGdpdmVuIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBDb250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgdGhpcy5pbml0aWFsVmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuXG4gICAgLyoqXG4gICAgICogVGhvc2Ugd2hvIGV4dGVuZCB0aGlzIGNsYXNzIHdpbGwgcHV0IHRoZWlyIERPTSBlbGVtZW50cyBpbiBoZXJlLlxuICAgICAqIEB0eXBlIHtET01FbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCB0byBtYW5pcHVsYXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBtYW5pcHVsYXRlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGNoYW5nZS5cbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19vbkNoYW5nZSA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZmluaXNoaW5nIGNoYW5nZS5cbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZSA9IHVuZGVmaW5lZDtcblxuICB9O1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICAvKiogQGxlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLnByb3RvdHlwZSAqL1xuICAgICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IHRoYXQgYSBmdW5jdGlvbiBmaXJlIGV2ZXJ5IHRpbWUgc29tZW9uZSBjaGFuZ2VzIHRoZSB2YWx1ZSB3aXRoXG4gICAgICAgICAqIHRoaXMgQ29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5jIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHZhbHVlXG4gICAgICAgICAqIGlzIG1vZGlmaWVkIHZpYSB0aGlzIENvbnRyb2xsZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKGZuYykge1xuICAgICAgICAgIHRoaXMuX19vbkNoYW5nZSA9IGZuYztcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSB0aGF0IGEgZnVuY3Rpb24gZmlyZSBldmVyeSB0aW1lIHNvbWVvbmUgXCJmaW5pc2hlc1wiIGNoYW5naW5nXG4gICAgICAgICAqIHRoZSB2YWx1ZSB3aWggdGhpcyBDb250cm9sbGVyLiBVc2VmdWwgZm9yIHZhbHVlcyB0aGF0IGNoYW5nZVxuICAgICAgICAgKiBpbmNyZW1lbnRhbGx5IGxpa2UgbnVtYmVycyBvciBzdHJpbmdzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbmMgVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlclxuICAgICAgICAgKiBzb21lb25lIFwiZmluaXNoZXNcIiBjaGFuZ2luZyB0aGUgdmFsdWUgdmlhIHRoaXMgQ29udHJvbGxlci5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBvbkZpbmlzaENoYW5nZTogZnVuY3Rpb24oZm5jKSB7XG4gICAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlID0gZm5jO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2UgdGhlIHZhbHVlIG9mIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIG9mIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqL1xuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgICB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIGlmICh0aGlzLl9fb25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMsIG5ld1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjdXJyZW50IHZhbHVlIG9mIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZyZXNoZXMgdGhlIHZpc3VhbCBkaXNwbGF5IG9mIGEgQ29udHJvbGxlciBpbiBvcmRlciB0byBrZWVwIHN5bmNcbiAgICAgICAgICogd2l0aCB0aGUgb2JqZWN0J3MgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIHZhbHVlIGhhcyBkZXZpYXRlZCBmcm9tIGluaXRpYWxWYWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNNb2RpZmllZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlICE9PSB0aGlzLmdldFZhbHVlKClcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gQ29udHJvbGxlcjtcblxuXG59KShkYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuZG9tLmRvbSA9IChmdW5jdGlvbiAoY29tbW9uKSB7XG5cbiAgdmFyIEVWRU5UX01BUCA9IHtcbiAgICAnSFRNTEV2ZW50cyc6IFsnY2hhbmdlJ10sXG4gICAgJ01vdXNlRXZlbnRzJzogWydjbGljaycsJ21vdXNlbW92ZScsJ21vdXNlZG93bicsJ21vdXNldXAnLCAnbW91c2VvdmVyJ10sXG4gICAgJ0tleWJvYXJkRXZlbnRzJzogWydrZXlkb3duJ11cbiAgfTtcblxuICB2YXIgRVZFTlRfTUFQX0lOViA9IHt9O1xuICBjb21tb24uZWFjaChFVkVOVF9NQVAsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICBjb21tb24uZWFjaCh2LCBmdW5jdGlvbihlKSB7XG4gICAgICBFVkVOVF9NQVBfSU5WW2VdID0gaztcbiAgICB9KTtcbiAgfSk7XG5cbiAgdmFyIENTU19WQUxVRV9QSVhFTFMgPSAvKFxcZCsoXFwuXFxkKyk/KXB4LztcblxuICBmdW5jdGlvbiBjc3NWYWx1ZVRvUGl4ZWxzKHZhbCkge1xuXG4gICAgaWYgKHZhbCA9PT0gJzAnIHx8IGNvbW1vbi5pc1VuZGVmaW5lZCh2YWwpKSByZXR1cm4gMDtcblxuICAgIHZhciBtYXRjaCA9IHZhbC5tYXRjaChDU1NfVkFMVUVfUElYRUxTKTtcblxuICAgIGlmICghY29tbW9uLmlzTnVsbChtYXRjaCkpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIC4uLmVtcz8gJT9cblxuICAgIHJldHVybiAwO1xuXG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyIGRhdC5kb21cbiAgICovXG4gIHZhciBkb20gPSB7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBzZWxlY3RhYmxlXG4gICAgICovXG4gICAgbWFrZVNlbGVjdGFibGU6IGZ1bmN0aW9uKGVsZW0sIHNlbGVjdGFibGUpIHtcblxuICAgICAgaWYgKGVsZW0gPT09IHVuZGVmaW5lZCB8fCBlbGVtLnN0eWxlID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgZWxlbS5vbnNlbGVjdHN0YXJ0ID0gc2VsZWN0YWJsZSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuXG4gICAgICBlbGVtLnN0eWxlLk1velVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgICAgZWxlbS5zdHlsZS5LaHRtbFVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgICAgZWxlbS51bnNlbGVjdGFibGUgPSBzZWxlY3RhYmxlID8gJ29uJyA6ICdvZmYnO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gaG9yaXpvbnRhbFxuICAgICAqIEBwYXJhbSB2ZXJ0aWNhbFxuICAgICAqL1xuICAgIG1ha2VGdWxsc2NyZWVuOiBmdW5jdGlvbihlbGVtLCBob3Jpem9udGFsLCB2ZXJ0aWNhbCkge1xuXG4gICAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKGhvcml6b250YWwpKSBob3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQodmVydGljYWwpKSB2ZXJ0aWNhbCA9IHRydWU7XG5cbiAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICBlbGVtLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgICBlbGVtLnN0eWxlLnJpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBlbGVtLnN0eWxlLnRvcCA9IDA7XG4gICAgICAgIGVsZW0uc3R5bGUuYm90dG9tID0gMDtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZVxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBmYWtlRXZlbnQ6IGZ1bmN0aW9uKGVsZW0sIGV2ZW50VHlwZSwgcGFyYW1zLCBhdXgpIHtcbiAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgIHZhciBjbGFzc05hbWUgPSBFVkVOVF9NQVBfSU5WW2V2ZW50VHlwZV07XG4gICAgICBpZiAoIWNsYXNzTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IHR5cGUgJyArIGV2ZW50VHlwZSArICcgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChjbGFzc05hbWUpO1xuICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgY2FzZSAnTW91c2VFdmVudHMnOlxuICAgICAgICAgIHZhciBjbGllbnRYID0gcGFyYW1zLnggfHwgcGFyYW1zLmNsaWVudFggfHwgMDtcbiAgICAgICAgICB2YXIgY2xpZW50WSA9IHBhcmFtcy55IHx8IHBhcmFtcy5jbGllbnRZIHx8IDA7XG4gICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsXG4gICAgICAgICAgICAgIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUsIHdpbmRvdywgcGFyYW1zLmNsaWNrQ291bnQgfHwgMSxcbiAgICAgICAgICAgICAgMCwgLy9zY3JlZW4gWFxuICAgICAgICAgICAgICAwLCAvL3NjcmVlbiBZXG4gICAgICAgICAgICAgIGNsaWVudFgsIC8vY2xpZW50IFhcbiAgICAgICAgICAgICAgY2xpZW50WSwgLy9jbGllbnQgWVxuICAgICAgICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0tleWJvYXJkRXZlbnRzJzpcbiAgICAgICAgICB2YXIgaW5pdCA9IGV2dC5pbml0S2V5Ym9hcmRFdmVudCB8fCBldnQuaW5pdEtleUV2ZW50OyAvLyB3ZWJraXQgfHwgbW96XG4gICAgICAgICAgY29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGN0cmxLZXk6IGZhbHNlLFxuICAgICAgICAgICAgYWx0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgICAgICAgICAga2V5Q29kZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hhckNvZGU6IHVuZGVmaW5lZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGluaXQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgcGFyYW1zLmNhbmNlbGFibGUsIHdpbmRvdyxcbiAgICAgICAgICAgICAgcGFyYW1zLmN0cmxLZXksIHBhcmFtcy5hbHRLZXksXG4gICAgICAgICAgICAgIHBhcmFtcy5zaGlmdEtleSwgcGFyYW1zLm1ldGFLZXksXG4gICAgICAgICAgICAgIHBhcmFtcy5rZXlDb2RlLCBwYXJhbXMuY2hhckNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGV2dC5pbml0RXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgcGFyYW1zLmNhbmNlbGFibGUgfHwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb21tb24uZGVmYXVsdHMoZXZ0LCBhdXgpO1xuICAgICAgZWxlbS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAqIEBwYXJhbSBib29sXG4gICAgICovXG4gICAgYmluZDogZnVuY3Rpb24oZWxlbSwgZXZlbnQsIGZ1bmMsIGJvb2wpIHtcbiAgICAgIGJvb2wgPSBib29sIHx8IGZhbHNlO1xuICAgICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jLCBib29sKTtcbiAgICAgIGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpXG4gICAgICAgIGVsZW0uYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmdW5jKTtcbiAgICAgIHJldHVybiBkb207XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAqIEBwYXJhbSBib29sXG4gICAgICovXG4gICAgdW5iaW5kOiBmdW5jdGlvbihlbGVtLCBldmVudCwgZnVuYywgYm9vbCkge1xuICAgICAgYm9vbCA9IGJvb2wgfHwgZmFsc2U7XG4gICAgICBpZiAoZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKVxuICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsIGJvb2wpO1xuICAgICAgZWxzZSBpZiAoZWxlbS5kZXRhY2hFdmVudClcbiAgICAgICAgZWxlbS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZ1bmMpO1xuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICAgKi9cbiAgICBhZGRDbGFzczogZnVuY3Rpb24oZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbS5jbGFzc05hbWUgIT09IGNsYXNzTmFtZSkge1xuICAgICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xuICAgICAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPT0gLTEpIHtcbiAgICAgICAgICBjbGFzc2VzLnB1c2goY2xhc3NOYW1lKTtcbiAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZVxuICAgICAqL1xuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihlbGVtLCBjbGFzc05hbWUpIHtcbiAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKGVsZW0uY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gY2xhc3NOYW1lKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKTtcbiAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb207XG4gICAgfSxcblxuICAgIGhhc0NsYXNzOiBmdW5jdGlvbihlbGVtLCBjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefFxcXFxzKyknICsgY2xhc3NOYW1lICsgJyg/OlxcXFxzK3wkKScpLnRlc3QoZWxlbS5jbGFzc05hbWUpIHx8IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICovXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKGVsZW0pIHtcblxuICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcblxuICAgICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1sZWZ0LXdpZHRoJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItcmlnaHQtd2lkdGgnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctbGVmdCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1yaWdodCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnd2lkdGgnXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKGVsZW0pIHtcblxuICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcblxuICAgICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci10b3Atd2lkdGgnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1ib3R0b20td2lkdGgnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctdG9wJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLWJvdHRvbSddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnaGVpZ2h0J10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICovXG4gICAgZ2V0T2Zmc2V0OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0ge2xlZnQ6IDAsIHRvcDowfTtcbiAgICAgIGlmIChlbGVtLm9mZnNldFBhcmVudCkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb2Zmc2V0LmxlZnQgKz0gZWxlbS5vZmZzZXRMZWZ0O1xuICAgICAgICAgIG9mZnNldC50b3AgKz0gZWxlbS5vZmZzZXRUb3A7XG4gICAgICAgIH0gd2hpbGUgKGVsZW0gPSBlbGVtLm9mZnNldFBhcmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcG9zdHMvMjY4NDU2MS9yZXZpc2lvbnNcbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqL1xuICAgIGlzQWN0aXZlOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICByZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgKTtcbiAgICB9XG5cbiAgfTtcblxuICByZXR1cm4gZG9tO1xuXG59KShkYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuT3B0aW9uQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFByb3ZpZGVzIGEgc2VsZWN0IGlucHV0IHRvIGFsdGVyIHRoZSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QsIHVzaW5nIGFcbiAgICogbGlzdCBvZiBhY2NlcHRlZCB2YWx1ZXMuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ1tdfSBvcHRpb25zIEEgbWFwIG9mIGxhYmVscyB0byBhY2NlcHRhYmxlIHZhbHVlcywgb3JcbiAgICogYSBsaXN0IG9mIGFjY2VwdGFibGUgc3RyaW5nIHZhbHVlcy5cbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBPcHRpb25Db250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgb3B0aW9ucykge1xuXG4gICAgT3B0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRyb3AgZG93biBtZW51XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19zZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcblxuICAgIGlmIChjb21tb24uaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgY29tbW9uLmVhY2gob3B0aW9ucywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBtYXBbZWxlbWVudF0gPSBlbGVtZW50O1xuICAgICAgfSk7XG4gICAgICBvcHRpb25zID0gbWFwO1xuICAgIH1cblxuICAgIGNvbW1vbi5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblxuICAgICAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgb3B0LmlubmVySFRNTCA9IGtleTtcbiAgICAgIG9wdC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgX3RoaXMuX19zZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcblxuICAgIH0pO1xuXG4gICAgLy8gQWNrbm93bGVkZ2Ugb3JpZ2luYWwgdmFsdWVcbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19zZWxlY3QsICdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkZXNpcmVkVmFsdWUgPSB0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgIF90aGlzLnNldFZhbHVlKGRlc2lyZWRWYWx1ZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX3NlbGVjdCk7XG5cbiAgfTtcblxuICBPcHRpb25Db250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odikge1xuICAgICAgICAgIHZhciB0b1JldHVybiA9IE9wdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCh0aGlzLCB2KTtcbiAgICAgICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5fX3NlbGVjdC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIE9wdGlvbkNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBSZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0IHRoYXQgaXMgYSBudW1iZXIuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1pbl0gTWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1heF0gTWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLnN0ZXBdIEluY3JlbWVudCBieSB3aGljaCB0byBjaGFuZ2UgdmFsdWVcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBOdW1iZXJDb250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG5cbiAgICBOdW1iZXJDb250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIHRoaXMuX19taW4gPSBwYXJhbXMubWluO1xuICAgIHRoaXMuX19tYXggPSBwYXJhbXMubWF4O1xuICAgIHRoaXMuX19zdGVwID0gcGFyYW1zLnN0ZXA7XG5cbiAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHRoaXMuX19zdGVwKSkge1xuXG4gICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgPT0gMCkge1xuICAgICAgICB0aGlzLl9faW1wbGllZFN0ZXAgPSAxOyAvLyBXaGF0IGFyZSB3ZSwgcHN5Y2hpY3M/XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIZXkgRG91ZywgY2hlY2sgdGhpcyBvdXQuXG4gICAgICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHRoaXMuaW5pdGlhbFZhbHVlKS9NYXRoLkxOMTApKS8xMDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IHRoaXMuX19zdGVwO1xuXG4gICAgfVxuXG4gICAgdGhpcy5fX3ByZWNpc2lvbiA9IG51bURlY2ltYWxzKHRoaXMuX19pbXBsaWVkU3RlcCk7XG5cblxuICB9O1xuXG4gIE51bWJlckNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAgLyoqIEBsZW5kcyBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUgKi9cbiAgICAgIHtcblxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odikge1xuXG4gICAgICAgICAgaWYgKHRoaXMuX19taW4gIT09IHVuZGVmaW5lZCAmJiB2IDwgdGhpcy5fX21pbikge1xuICAgICAgICAgICAgdiA9IHRoaXMuX19taW47XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9fbWF4ICE9PSB1bmRlZmluZWQgJiYgdiA+IHRoaXMuX19tYXgpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLl9fbWF4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLl9fc3RlcCAhPT0gdW5kZWZpbmVkICYmIHYgJSB0aGlzLl9fc3RlcCAhPSAwKSB7XG4gICAgICAgICAgICB2ID0gTWF0aC5yb3VuZCh2IC8gdGhpcy5fX3N0ZXApICogdGhpcy5fX3N0ZXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCh0aGlzLCB2KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGEgbWluaW11bSB2YWx1ZSBmb3IgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5WYWx1ZSBUaGUgbWluaW11bSB2YWx1ZSBmb3JcbiAgICAgICAgICogPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBtaW46IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9fbWluID0gdjtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSBhIG1heGltdW0gdmFsdWUgZm9yIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4VmFsdWUgVGhlIG1heGltdW0gdmFsdWUgZm9yXG4gICAgICAgICAqIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgbWF4OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fX21heCA9IHY7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgYSBzdGVwIHZhbHVlIHRoYXQgZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJcbiAgICAgICAgICogaW5jcmVtZW50cyBieS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBWYWx1ZSBUaGUgc3RlcCB2YWx1ZSBmb3JcbiAgICAgICAgICogZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJcbiAgICAgICAgICogQGRlZmF1bHQgaWYgbWluaW11bSBhbmQgbWF4aW11bSBzcGVjaWZpZWQgaW5jcmVtZW50IGlzIDElIG9mIHRoZVxuICAgICAgICAgKiBkaWZmZXJlbmNlIG90aGVyd2lzZSBzdGVwVmFsdWUgaXMgMVxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHN0ZXA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9fc3RlcCA9IHY7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgZnVuY3Rpb24gbnVtRGVjaW1hbHMoeCkge1xuICAgIHggPSB4LnRvU3RyaW5nKCk7XG4gICAgaWYgKHguaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHJldHVybiB4Lmxlbmd0aCAtIHguaW5kZXhPZignLicpIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJCb3ggPSAoZnVuY3Rpb24gKE51bWJlckNvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBSZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0IHRoYXQgaXMgYSBudW1iZXIgYW5kXG4gICAqIHByb3ZpZGVzIGFuIGlucHV0IGVsZW1lbnQgd2l0aCB3aGljaCB0byBtYW5pcHVsYXRlIGl0LlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5taW5dIE1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5tYXhdIE1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5zdGVwXSBJbmNyZW1lbnQgYnkgd2hpY2ggdG8gY2hhbmdlIHZhbHVlXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgTnVtYmVyQ29udHJvbGxlckJveCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuXG4gICAgdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcblxuICAgIE51bWJlckNvbnRyb2xsZXJCb3guc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHBhcmFtcyk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICoge051bWJlcn0gUHJldmlvdXMgbW91c2UgeSBwb3NpdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB2YXIgcHJldl95O1xuXG4gICAgdGhpcy5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0aGlzLl9faW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcblxuICAgIC8vIE1ha2VzIGl0IHNvIG1hbnVhbGx5IHNwZWNpZmllZCB2YWx1ZXMgYXJlIG5vdCB0cnVuY2F0ZWQuXG5cbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgIC8vIFdoZW4gcHJlc3NpbmcgZW50aXJlLCB5b3UgY2FuIGJlIGFzIHByZWNpc2UgYXMgeW91IHdhbnQuXG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICBfdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgX3RoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgdmFyIGF0dGVtcHRlZCA9IHBhcnNlRmxvYXQoX3RoaXMuX19pbnB1dC52YWx1ZSk7XG4gICAgICBpZiAoIWNvbW1vbi5pc05hTihhdHRlbXB0ZWQpKSBfdGhpcy5zZXRWYWx1ZShhdHRlbXB0ZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgcHJldl95ID0gZS5jbGllbnRZO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VEcmFnKGUpIHtcblxuICAgICAgdmFyIGRpZmYgPSBwcmV2X3kgLSBlLmNsaWVudFk7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5nZXRWYWx1ZSgpICsgZGlmZiAqIF90aGlzLl9faW1wbGllZFN0ZXApO1xuXG4gICAgICBwcmV2X3kgPSBlLmNsaWVudFk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2lucHV0KTtcblxuICB9O1xuXG4gIE51bWJlckNvbnRyb2xsZXJCb3guc3VwZXJjbGFzcyA9IE51bWJlckNvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgTnVtYmVyQ29udHJvbGxlckJveC5wcm90b3R5cGUsXG4gICAgICBOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPyB0aGlzLmdldFZhbHVlKCkgOiByb3VuZFRvRGVjaW1hbCh0aGlzLmdldFZhbHVlKCksIHRoaXMuX19wcmVjaXNpb24pO1xuICAgICAgICAgIHJldHVybiBOdW1iZXJDb250cm9sbGVyQm94LnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICBmdW5jdGlvbiByb3VuZFRvRGVjaW1hbCh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgICB2YXIgdGVuVG8gPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogdGVuVG8pIC8gdGVuVG87XG4gIH1cblxuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlckJveDtcblxufSkoZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyU2xpZGVyID0gKGZ1bmN0aW9uIChOdW1iZXJDb250cm9sbGVyLCBkb20sIGNzcywgY29tbW9uLCBzdHlsZVNoZWV0KSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBSZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0IHRoYXQgaXMgYSBudW1iZXIsIGNvbnRhaW5zXG4gICAqIGEgbWluaW11bSBhbmQgbWF4aW11bSwgYW5kIHByb3ZpZGVzIGEgc2xpZGVyIGVsZW1lbnQgd2l0aCB3aGljaCB0b1xuICAgKiBtYW5pcHVsYXRlIGl0LiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCB0aGUgc2xpZGVyIGVsZW1lbnQgaXMgbWFkZSB1cCBvZlxuICAgKiA8Y29kZT4mbHQ7ZGl2Jmd0OzwvY29kZT4gdGFncywgPHN0cm9uZz5ub3Q8L3N0cm9uZz4gdGhlIGh0bWw1XG4gICAqIDxjb2RlPiZsdDtzbGlkZXImZ3Q7PC9jb2RlPiBlbGVtZW50LlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclxuICAgKiBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1pblZhbHVlIE1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4VmFsdWUgTWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwVmFsdWUgSW5jcmVtZW50IGJ5IHdoaWNoIHRvIGNoYW5nZSB2YWx1ZVxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIE51bWJlckNvbnRyb2xsZXJTbGlkZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBtaW4sIG1heCwgc3RlcCkge1xuXG4gICAgTnVtYmVyQ29udHJvbGxlclNsaWRlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IG1pbiwgbWF4OiBtYXgsIHN0ZXA6IHN0ZXAgfSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fX2JhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fZm9yZWdyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIFxuXG5cbiAgICBkb20uYmluZCh0aGlzLl9fYmFja2dyb3VuZCwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICBcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2JhY2tncm91bmQsICdzbGlkZXInKTtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2ZvcmVncm91bmQsICdzbGlkZXItZmcnKTtcblxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcblxuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG5cbiAgICAgIG9uTW91c2VEcmFnKGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VEcmFnKGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gZG9tLmdldE9mZnNldChfdGhpcy5fX2JhY2tncm91bmQpO1xuICAgICAgdmFyIHdpZHRoID0gZG9tLmdldFdpZHRoKF90aGlzLl9fYmFja2dyb3VuZCk7XG4gICAgICBcbiAgICAgIF90aGlzLnNldFZhbHVlKFxuICAgICAgICBtYXAoZS5jbGllbnRYLCBvZmZzZXQubGVmdCwgb2Zmc2V0LmxlZnQgKyB3aWR0aCwgX3RoaXMuX19taW4sIF90aGlzLl9fbWF4KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIHRoaXMuX19iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuX19mb3JlZ3JvdW5kKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2JhY2tncm91bmQpO1xuXG4gIH07XG5cbiAgTnVtYmVyQ29udHJvbGxlclNsaWRlci5zdXBlcmNsYXNzID0gTnVtYmVyQ29udHJvbGxlcjtcblxuICAvKipcbiAgICogSW5qZWN0cyBkZWZhdWx0IHN0eWxlc2hlZXQgZm9yIHNsaWRlciBlbGVtZW50cy5cbiAgICovXG4gIE51bWJlckNvbnRyb2xsZXJTbGlkZXIudXNlRGVmYXVsdFN0eWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGNzcy5pbmplY3Qoc3R5bGVTaGVldCk7XG4gIH07XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgTnVtYmVyQ29udHJvbGxlclNsaWRlci5wcm90b3R5cGUsXG4gICAgICBOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwY3QgPSAodGhpcy5nZXRWYWx1ZSgpIC0gdGhpcy5fX21pbikvKHRoaXMuX19tYXggLSB0aGlzLl9fbWluKTtcbiAgICAgICAgICB0aGlzLl9fZm9yZWdyb3VuZC5zdHlsZS53aWR0aCA9IHBjdCoxMDArJyUnO1xuICAgICAgICAgIHJldHVybiBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cblxuXG4gICk7XG5cbiAgZnVuY3Rpb24gbWFwKHYsIGkxLCBpMiwgbzEsIG8yKSB7XG4gICAgcmV0dXJuIG8xICsgKG8yIC0gbzEpICogKCh2IC0gaTEpIC8gKGkyIC0gaTEpKTtcbiAgfVxuXG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyU2xpZGVyO1xuICBcbn0pKGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY3NzLFxuZGF0LnV0aWxzLmNvbW1vbixcblwiLnNsaWRlciB7XFxuICBib3gtc2hhZG93OiBpbnNldCAwIDJweCA0cHggcmdiYSgwLDAsMCwwLjE1KTtcXG4gIGhlaWdodDogMWVtO1xcbiAgYm9yZGVyLXJhZGl1czogMWVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gIHBhZGRpbmc6IDAgMC41ZW07XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4uc2xpZGVyLWZnIHtcXG4gIHBhZGRpbmc6IDFweCAwIDJweCAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2FhYTtcXG4gIGhlaWdodDogMWVtO1xcbiAgbWFyZ2luLWxlZnQ6IC0wLjVlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDAuNWVtO1xcbiAgYm9yZGVyLXJhZGl1czogMWVtIDAgMCAxZW07XFxufVxcblxcbi5zbGlkZXItZmc6YWZ0ZXIge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgYm9yZGVyLXJhZGl1czogMWVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGJvcmRlcjogIDFweCBzb2xpZCAjYWFhO1xcbiAgY29udGVudDogJyc7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBtYXJnaW4tcmlnaHQ6IC0xZW07XFxuICBtYXJnaW4tdG9wOiAtMXB4O1xcbiAgaGVpZ2h0OiAwLjllbTtcXG4gIHdpZHRoOiAwLjllbTtcXG59XCIpO1xuXG5cbmRhdC5jb250cm9sbGVycy5GdW5jdGlvbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBQcm92aWRlcyBhIEdVSSBpbnRlcmZhY2UgdG8gZmlyZSBhIHNwZWNpZmllZCBtZXRob2QsIGEgcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIEZ1bmN0aW9uQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIHRleHQpIHtcblxuICAgIEZ1bmN0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fX2J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19idXR0b24uaW5uZXJIVE1MID0gdGV4dCA9PT0gdW5kZWZpbmVkID8gJ0ZpcmUnIDogdGV4dDtcbiAgICBkb20uYmluZCh0aGlzLl9fYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBfdGhpcy5maXJlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2J1dHRvbiwgJ2J1dHRvbicpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19idXR0b24pO1xuXG5cbiAgfTtcblxuICBGdW5jdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgRnVuY3Rpb25Db250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAge1xuICAgICAgICBcbiAgICAgICAgZmlyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uQ2hhbmdlLmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZ2V0VmFsdWUoKS5jYWxsKHRoaXMub2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIEZ1bmN0aW9uQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5Cb29sZWFuQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFByb3ZpZGVzIGEgY2hlY2tib3ggaW5wdXQgdG8gYWx0ZXIgdGhlIGJvb2xlYW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIEJvb2xlYW5Db250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgQm9vbGVhbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9fcHJldiA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICAgIHRoaXMuX19jaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGhpcy5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuXG5cbiAgICBkb20uYmluZCh0aGlzLl9fY2hlY2tib3gsICdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19jaGVja2JveCk7XG5cbiAgICAvLyBNYXRjaCBvcmlnaW5hbCB2YWx1ZVxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBfdGhpcy5zZXRWYWx1ZSghX3RoaXMuX19wcmV2KTtcbiAgICB9XG5cbiAgfTtcblxuICBCb29sZWFuQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdmFyIHRvUmV0dXJuID0gQm9vbGVhbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCh0aGlzLCB2KTtcbiAgICAgICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9fcHJldiA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHRoaXMuZ2V0VmFsdWUoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgICAgICAgICB0aGlzLl9fY2hlY2tib3guY2hlY2tlZCA9IHRydWU7ICAgIFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX19jaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIEJvb2xlYW5Db250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcblxuICAgICAgICB9XG5cblxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIEJvb2xlYW5Db250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbG9yLnRvU3RyaW5nID0gKGZ1bmN0aW9uIChjb21tb24pIHtcblxuICByZXR1cm4gZnVuY3Rpb24oY29sb3IpIHtcblxuICAgIGlmIChjb2xvci5hID09IDEgfHwgY29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLmEpKSB7XG5cbiAgICAgIHZhciBzID0gY29sb3IuaGV4LnRvU3RyaW5nKDE2KTtcbiAgICAgIHdoaWxlIChzLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgcyA9ICcwJyArIHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnIycgKyBzO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuICdyZ2JhKCcgKyBNYXRoLnJvdW5kKGNvbG9yLnIpICsgJywnICsgTWF0aC5yb3VuZChjb2xvci5nKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuYikgKyAnLCcgKyBjb2xvci5hICsgJyknO1xuXG4gICAgfVxuXG4gIH1cblxufSkoZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbG9yLmludGVycHJldCA9IChmdW5jdGlvbiAodG9TdHJpbmcsIGNvbW1vbikge1xuXG4gIHZhciByZXN1bHQsIHRvUmV0dXJuO1xuXG4gIHZhciBpbnRlcnByZXQgPSBmdW5jdGlvbigpIHtcblxuICAgIHRvUmV0dXJuID0gZmFsc2U7XG5cbiAgICB2YXIgb3JpZ2luYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGNvbW1vbi50b0FycmF5KGFyZ3VtZW50cykgOiBhcmd1bWVudHNbMF07XG5cbiAgICBjb21tb24uZWFjaChJTlRFUlBSRVRBVElPTlMsIGZ1bmN0aW9uKGZhbWlseSkge1xuXG4gICAgICBpZiAoZmFtaWx5LmxpdG11cyhvcmlnaW5hbCkpIHtcblxuICAgICAgICBjb21tb24uZWFjaChmYW1pbHkuY29udmVyc2lvbnMsIGZ1bmN0aW9uKGNvbnZlcnNpb24sIGNvbnZlcnNpb25OYW1lKSB7XG5cbiAgICAgICAgICByZXN1bHQgPSBjb252ZXJzaW9uLnJlYWQob3JpZ2luYWwpO1xuXG4gICAgICAgICAgaWYgKHRvUmV0dXJuID09PSBmYWxzZSAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b1JldHVybiA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uTmFtZSA9IGNvbnZlcnNpb25OYW1lO1xuICAgICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb24gPSBjb252ZXJzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbi5CUkVBSztcblxuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY29tbW9uLkJSRUFLO1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIHJldHVybiB0b1JldHVybjtcblxuICB9O1xuXG4gIHZhciBJTlRFUlBSRVRBVElPTlMgPSBbXG5cbiAgICAvLyBTdHJpbmdzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc1N0cmluZyxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBUSFJFRV9DSEFSX0hFWDoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV0pKFtBLUYwLTldKShbQS1GMC05XSkkL2kpO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IHBhcnNlSW50KFxuICAgICAgICAgICAgICAgICAgJzB4JyArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsxXS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzJdLnRvU3RyaW5nKCkgKyB0ZXN0WzJdLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbM10udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBTSVhfQ0hBUl9IRVg6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldezZ9KSQvaSk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogcGFyc2VJbnQoJzB4JyArIHRlc3RbMV0udG9TdHJpbmcoKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBDU1NfUkdCOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiXFwoXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIENTU19SR0JBOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiYVxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwsXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSksXG4gICAgICAgICAgICAgIGE6IHBhcnNlRmxvYXQodGVzdFs0XSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gTnVtYmVyc1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNOdW1iZXIsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgSEVYOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBvcmlnaW5hbCxcbiAgICAgICAgICAgICAgY29udmVyc2lvbk5hbWU6ICdIRVgnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yLmhleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIEFycmF5c1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNBcnJheSxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBSR0JfQVJSQVk6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPSAzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICAgICAgYjogb3JpZ2luYWxbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICBSR0JBX0FSUkFZOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT0gNCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgICAgIGI6IG9yaWdpbmFsWzJdLFxuICAgICAgICAgICAgICBhOiBvcmlnaW5hbFszXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmFdO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBPYmplY3RzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc09iamVjdCxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBSR0JBX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgICAgICBiOiBvcmlnaW5hbC5iLFxuICAgICAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgICAgIGI6IGNvbG9yLmIsXG4gICAgICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgICAgICBiOiBvcmlnaW5hbC5iXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgICAgICBiOiBjb2xvci5iXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIEhTVkFfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgICAgIHY6IG9yaWdpbmFsLnYsXG4gICAgICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICAgICAgdjogY29sb3IudixcbiAgICAgICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBIU1ZfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgICAgIHY6IG9yaWdpbmFsLnZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgICAgIHY6IGNvbG9yLnZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cblxuICBdO1xuXG4gIHJldHVybiBpbnRlcnByZXQ7XG5cblxufSkoZGF0LmNvbG9yLnRvU3RyaW5nLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LkdVSSA9IGRhdC5ndWkuR1VJID0gKGZ1bmN0aW9uIChjc3MsIHNhdmVEaWFsb2d1ZUNvbnRlbnRzLCBzdHlsZVNoZWV0LCBjb250cm9sbGVyRmFjdG9yeSwgQ29udHJvbGxlciwgQm9vbGVhbkNvbnRyb2xsZXIsIEZ1bmN0aW9uQ29udHJvbGxlciwgTnVtYmVyQ29udHJvbGxlckJveCwgTnVtYmVyQ29udHJvbGxlclNsaWRlciwgT3B0aW9uQ29udHJvbGxlciwgQ29sb3JDb250cm9sbGVyLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIENlbnRlcmVkRGl2LCBkb20sIGNvbW1vbikge1xuXG4gIGNzcy5pbmplY3Qoc3R5bGVTaGVldCk7XG5cbiAgLyoqIE91dGVyLW1vc3QgY2xhc3NOYW1lIGZvciBHVUkncyAqL1xuICB2YXIgQ1NTX05BTUVTUEFDRSA9ICdkZyc7XG5cbiAgdmFyIEhJREVfS0VZX0NPREUgPSA3MjtcblxuICAvKiogVGhlIG9ubHkgdmFsdWUgc2hhcmVkIGJldHdlZW4gdGhlIEpTIGFuZCBTQ1NTLiBVc2UgY2F1dGlvbi4gKi9cbiAgdmFyIENMT1NFX0JVVFRPTl9IRUlHSFQgPSAyMDtcblxuICB2YXIgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FID0gJ0RlZmF1bHQnO1xuXG4gIHZhciBTVVBQT1JUU19MT0NBTF9TVE9SQUdFID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gJ2xvY2FsU3RvcmFnZScgaW4gd2luZG93ICYmIHdpbmRvd1snbG9jYWxTdG9yYWdlJ10gIT09IG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSkoKTtcblxuICB2YXIgU0FWRV9ESUFMT0dVRTtcblxuICAvKiogSGF2ZSB3ZSB5ZXQgdG8gY3JlYXRlIGFuIGF1dG9QbGFjZSBHVUk/ICovXG4gIHZhciBhdXRvX3BsYWNlX3ZpcmdpbiA9IHRydWU7XG5cbiAgLyoqIEZpeGVkIHBvc2l0aW9uIGRpdiB0aGF0IGF1dG8gcGxhY2UgR1VJJ3MgZ28gaW5zaWRlICovXG4gIHZhciBhdXRvX3BsYWNlX2NvbnRhaW5lcjtcblxuICAvKiogQXJlIHdlIGhpZGluZyB0aGUgR1VJJ3MgPyAqL1xuICB2YXIgaGlkZSA9IGZhbHNlO1xuXG4gIC8qKiBHVUkncyB3aGljaCBzaG91bGQgYmUgaGlkZGVuICovXG4gIHZhciBoaWRlYWJsZV9ndWlzID0gW107XG5cbiAgLyoqXG4gICAqIEEgbGlnaHR3ZWlnaHQgY29udHJvbGxlciBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0LiBJdCBhbGxvd3MgeW91IHRvIGVhc2lseVxuICAgKiBtYW5pcHVsYXRlIHZhcmlhYmxlcyBhbmQgZmlyZSBmdW5jdGlvbnMgb24gdGhlIGZseS5cbiAgICogQGNsYXNzXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0Lmd1aVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMubmFtZV0gVGhlIG5hbWUgb2YgdGhpcyBHVUkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zLmxvYWRdIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2F2ZWQgc3RhdGUgb2ZcbiAgICogdGhpcyBHVUkuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5hdXRvPXRydWVdXG4gICAqIEBwYXJhbSB7ZGF0Lmd1aS5HVUl9IFtwYXJhbXMucGFyZW50XSBUaGUgR1VJIEknbSBuZXN0ZWQgaW4uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5jbG9zZWRdIElmIHRydWUsIHN0YXJ0cyBjbG9zZWRcbiAgICovXG4gIHZhciBHVUkgPSBmdW5jdGlvbihwYXJhbXMpIHtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBPdXRlcm1vc3QgRE9NIEVsZW1lbnRcbiAgICAgKiBAdHlwZSBET01FbGVtZW50XG4gICAgICovXG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX3VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX3VsKTtcblxuICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIENTU19OQU1FU1BBQ0UpO1xuXG4gICAgLyoqXG4gICAgICogTmVzdGVkIEdVSSdzIGJ5IG5hbWVcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX2ZvbGRlcnMgPSB7fTtcblxuICAgIHRoaXMuX19jb250cm9sbGVycyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBvYmplY3RzIEknbSByZW1lbWJlcmluZyBmb3Igc2F2ZSwgb25seSB1c2VkIGluIHRvcCBsZXZlbCBHVUlcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIHRoZSBpbmRleCBvZiByZW1lbWJlcmVkIG9iamVjdHMgdG8gYSBtYXAgb2YgY29udHJvbGxlcnMsIG9ubHkgdXNlZFxuICAgICAqIGluIHRvcCBsZXZlbCBHVUkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpZ25vcmVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogW1xuICAgICAqICB7XG4gICAgICogICAgcHJvcGVydHlOYW1lOiBDb250cm9sbGVyLFxuICAgICAqICAgIGFub3RoZXJQcm9wZXJ0eU5hbWU6IENvbnRyb2xsZXJcbiAgICAgKiAgfSxcbiAgICAgKiAge1xuICAgICAqICAgIHByb3BlcnR5TmFtZTogQ29udHJvbGxlclxuICAgICAqICB9XG4gICAgICogXVxuICAgICAqL1xuICAgIHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnMgPSBbXTtcblxuICAgIHRoaXMuX19saXN0ZW5pbmcgPSBbXTtcblxuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIC8vIERlZmF1bHQgcGFyYW1ldGVyc1xuICAgIHBhcmFtcyA9IGNvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICAgIGF1dG9QbGFjZTogdHJ1ZSxcbiAgICAgIHdpZHRoOiBHVUkuREVGQVVMVF9XSURUSFxuICAgIH0pO1xuXG4gICAgcGFyYW1zID0gY29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgcmVzaXphYmxlOiBwYXJhbXMuYXV0b1BsYWNlLFxuICAgICAgaGlkZWFibGU6IHBhcmFtcy5hdXRvUGxhY2VcbiAgICB9KTtcblxuXG4gICAgaWYgKCFjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLmxvYWQpKSB7XG5cbiAgICAgIC8vIEV4cGxpY2l0IHByZXNldFxuICAgICAgaWYgKHBhcmFtcy5wcmVzZXQpIHBhcmFtcy5sb2FkLnByZXNldCA9IHBhcmFtcy5wcmVzZXQ7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBwYXJhbXMubG9hZCA9IHsgcHJlc2V0OiBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUgfTtcblxuICAgIH1cblxuICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLmhpZGVhYmxlKSB7XG4gICAgICBoaWRlYWJsZV9ndWlzLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgLy8gT25seSByb290IGxldmVsIEdVSSdzIGFyZSByZXNpemFibGUuXG4gICAgcGFyYW1zLnJlc2l6YWJsZSA9IGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMucmVzaXphYmxlO1xuXG5cbiAgICBpZiAocGFyYW1zLmF1dG9QbGFjZSAmJiBjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnNjcm9sbGFibGUpKSB7XG4gICAgICBwYXJhbXMuc2Nyb2xsYWJsZSA9IHRydWU7XG4gICAgfVxuLy8gICAgcGFyYW1zLnNjcm9sbGFibGUgPSBjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLnNjcm9sbGFibGUgPT09IHRydWU7XG5cbiAgICAvLyBOb3QgcGFydCBvZiBwYXJhbXMgYmVjYXVzZSBJIGRvbid0IHdhbnQgcGVvcGxlIHBhc3NpbmcgdGhpcyBpbiB2aWFcbiAgICAvLyBjb25zdHJ1Y3Rvci4gU2hvdWxkIGJlIGEgJ3JlbWVtYmVyZWQnIHZhbHVlLlxuICAgIHZhciB1c2VfbG9jYWxfc3RvcmFnZSA9XG4gICAgICAgIFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgJiZcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2godGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsXG5cbiAgICAgICAgLyoqIEBsZW5kcyBkYXQuZ3VpLkdVSS5wcm90b3R5cGUgKi9cbiAgICAgICAge1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIHBhcmVudCA8Y29kZT5HVUk8L2NvZGU+XG4gICAgICAgICAgICogQHR5cGUgZGF0Lmd1aS5HVUlcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzY3JvbGxhYmxlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLnNjcm9sbGFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEhhbmRsZXMgPGNvZGU+R1VJPC9jb2RlPidzIGVsZW1lbnQgcGxhY2VtZW50IGZvciB5b3VcbiAgICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAgICovXG4gICAgICAgICAgYXV0b1BsYWNlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLmF1dG9QbGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIGlkZW50aWZpZXIgZm9yIGEgc2V0IG9mIHNhdmVkIHZhbHVlc1xuICAgICAgICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIHByZXNldDoge1xuXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFJvb3QoKS5wcmVzZXQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5sb2FkLnByZXNldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5nZXRSb290KCkucHJlc2V0ID0gdjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMubG9hZC5wcmVzZXQgPSB2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldFByZXNldFNlbGVjdEluZGV4KHRoaXMpO1xuICAgICAgICAgICAgICBfdGhpcy5yZXZlcnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgd2lkdGggb2YgPGNvZGU+R1VJPC9jb2RlPiBlbGVtZW50XG4gICAgICAgICAgICogQHR5cGUgTnVtYmVyXG4gICAgICAgICAgICovXG4gICAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMud2lkdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIHBhcmFtcy53aWR0aCA9IHY7XG4gICAgICAgICAgICAgIHNldFdpZHRoKF90aGlzLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIG5hbWUgb2YgPGNvZGU+R1VJPC9jb2RlPi4gVXNlZCBmb3IgZm9sZGVycy4gaS5lXG4gICAgICAgICAgICogYSBmb2xkZXIncyBuYW1lXG4gICAgICAgICAgICogQHR5cGUgU3RyaW5nXG4gICAgICAgICAgICovXG4gICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5uYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAvLyBUT0RPIENoZWNrIGZvciBjb2xsaXNpb25zIGFtb25nIHNpYmxpbmcgZm9sZGVyc1xuICAgICAgICAgICAgICBwYXJhbXMubmFtZSA9IHY7XG4gICAgICAgICAgICAgIGlmICh0aXRsZV9yb3dfbmFtZSkge1xuICAgICAgICAgICAgICAgIHRpdGxlX3Jvd19uYW1lLmlubmVySFRNTCA9IHBhcmFtcy5uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZXRoZXIgdGhlIDxjb2RlPkdVSTwvY29kZT4gaXMgY29sbGFwc2VkIG9yIG5vdFxuICAgICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjbG9zZWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMuY2xvc2VkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICBwYXJhbXMuY2xvc2VkID0gdjtcbiAgICAgICAgICAgICAgaWYgKHBhcmFtcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBkb20uYWRkQ2xhc3MoX3RoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEZvciBicm93c2VycyB0aGF0IGFyZW4ndCBnb2luZyB0byByZXNwZWN0IHRoZSBDU1MgdHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgLy8gTGV0cyBqdXN0IGNoZWNrIG91ciBoZWlnaHQgYWdhaW5zdCB0aGUgd2luZG93IGhlaWdodCByaWdodCBvZmZcbiAgICAgICAgICAgICAgLy8gdGhlIGJhdC5cbiAgICAgICAgICAgICAgdGhpcy5vblJlc2l6ZSgpO1xuXG4gICAgICAgICAgICAgIGlmIChfdGhpcy5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX19jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSB2ID8gR1VJLlRFWFRfT1BFTiA6IEdVSS5URVhUX0NMT1NFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBDb250YWlucyBhbGwgcHJlc2V0c1xuICAgICAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICAgICAqL1xuICAgICAgICAgIGxvYWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMubG9hZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byB1c2UgPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9TdG9yYWdlI2xvY2FsU3RvcmFnZVwiPmxvY2FsU3RvcmFnZTwvYT4gYXMgdGhlIG1lYW5zIGZvclxuICAgICAgICAgICAqIDxjb2RlPnJlbWVtYmVyPC9jb2RlPmluZ1xuICAgICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB1c2VMb2NhbFN0b3JhZ2U6IHtcblxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVzZV9sb2NhbF9zdG9yYWdlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oYm9vbCkge1xuICAgICAgICAgICAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuICAgICAgICAgICAgICAgIHVzZV9sb2NhbF9zdG9yYWdlID0gYm9vbDtcbiAgICAgICAgICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgICAgICAgZG9tLmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd1bmxvYWQnLCBzYXZlVG9Mb2NhbFN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnaXNMb2NhbCcpLCBib29sKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgLy8gQXJlIHdlIGEgcm9vdCBsZXZlbCBHVUk/XG4gICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSkge1xuXG4gICAgICBwYXJhbXMuY2xvc2VkID0gZmFsc2U7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIEdVSS5DTEFTU19NQUlOKTtcbiAgICAgIGRvbS5tYWtlU2VsZWN0YWJsZSh0aGlzLmRvbUVsZW1lbnQsIGZhbHNlKTtcblxuICAgICAgLy8gQXJlIHdlIHN1cHBvc2VkIHRvIGJlIGxvYWRpbmcgbG9jYWxseT9cbiAgICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG5cbiAgICAgICAgaWYgKHVzZV9sb2NhbF9zdG9yYWdlKSB7XG5cbiAgICAgICAgICBfdGhpcy51c2VMb2NhbFN0b3JhZ2UgPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHNhdmVkX2d1aSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2godGhpcywgJ2d1aScpKTtcblxuICAgICAgICAgIGlmIChzYXZlZF9ndWkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5sb2FkID0gSlNPTi5wYXJzZShzYXZlZF9ndWkpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5fX2Nsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLl9fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gR1VJLlRFWFRfQ0xPU0VEO1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX0JVVFRPTik7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2Nsb3NlQnV0dG9uKTtcblxuICAgICAgZG9tLmJpbmQodGhpcy5fX2Nsb3NlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcblxuICAgICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuXG5cbiAgICAgIH0pO1xuXG5cbiAgICAgIC8vIE9oLCB5b3UncmUgYSBuZXN0ZWQgR1VJIVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmIChwYXJhbXMuY2xvc2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zLmNsb3NlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aXRsZV9yb3dfbmFtZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBhcmFtcy5uYW1lKTtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aXRsZV9yb3dfbmFtZSwgJ2NvbnRyb2xsZXItbmFtZScpO1xuXG4gICAgICB2YXIgdGl0bGVfcm93ID0gYWRkUm93KF90aGlzLCB0aXRsZV9yb3dfbmFtZSk7XG5cbiAgICAgIHZhciBvbl9jbGlja190aXRsZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcblxuICAgICAgZG9tLmFkZENsYXNzKHRpdGxlX3JvdywgJ3RpdGxlJyk7XG4gICAgICBkb20uYmluZCh0aXRsZV9yb3csICdjbGljaycsIG9uX2NsaWNrX3RpdGxlKTtcblxuICAgICAgaWYgKCFwYXJhbXMuY2xvc2VkKSB7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmF1dG9QbGFjZSkge1xuXG4gICAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XG5cbiAgICAgICAgaWYgKGF1dG9fcGxhY2VfdmlyZ2luKSB7XG4gICAgICAgICAgYXV0b19wbGFjZV9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b19wbGFjZV9jb250YWluZXIsIENTU19OQU1FU1BBQ0UpO1xuICAgICAgICAgIGRvbS5hZGRDbGFzcyhhdXRvX3BsYWNlX2NvbnRhaW5lciwgR1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSKTtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGF1dG9fcGxhY2VfY29udGFpbmVyKTtcbiAgICAgICAgICBhdXRvX3BsYWNlX3ZpcmdpbiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHV0IGl0IGluIHRoZSBkb20gZm9yIHlvdS5cbiAgICAgICAgYXV0b19wbGFjZV9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcblxuICAgICAgICAvLyBBcHBseSB0aGUgYXV0byBzdHlsZXNcbiAgICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX0FVVE9fUExBQ0UpO1xuXG4gICAgICB9XG5cblxuICAgICAgLy8gTWFrZSBpdCBub3QgZWxhc3RpYy5cbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHNldFdpZHRoKF90aGlzLCBwYXJhbXMud2lkdGgpO1xuXG4gICAgfVxuXG4gICAgZG9tLmJpbmQod2luZG93LCAncmVzaXplJywgZnVuY3Rpb24oKSB7IF90aGlzLm9uUmVzaXplKCkgfSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX3VsLCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uKCkgeyBfdGhpcy5vblJlc2l6ZSgpOyB9KTtcbiAgICBkb20uYmluZCh0aGlzLl9fdWwsICd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24oKSB7IF90aGlzLm9uUmVzaXplKCkgfSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX3VsLCAnb1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbigpIHsgX3RoaXMub25SZXNpemUoKSB9KTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG5cblxuICAgIGlmIChwYXJhbXMucmVzaXphYmxlKSB7XG4gICAgICBhZGRSZXNpemVIYW5kbGUodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2F2ZVRvTG9jYWxTdG9yYWdlKCkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2d1aScpLCBKU09OLnN0cmluZ2lmeShfdGhpcy5nZXRTYXZlT2JqZWN0KCkpKTtcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IF90aGlzLmdldFJvb3QoKTtcbiAgICBmdW5jdGlvbiByZXNldFdpZHRoKCkge1xuICAgICAgICB2YXIgcm9vdCA9IF90aGlzLmdldFJvb3QoKTtcbiAgICAgICAgcm9vdC53aWR0aCArPSAxO1xuICAgICAgICBjb21tb24uZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcm9vdC53aWR0aCAtPSAxO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJhbXMucGFyZW50KSB7XG4gICAgICAgIHJlc2V0V2lkdGgoKTtcbiAgICAgIH1cblxuICB9O1xuXG4gIEdVSS50b2dnbGVIaWRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICBoaWRlID0gIWhpZGU7XG4gICAgY29tbW9uLmVhY2goaGlkZWFibGVfZ3VpcywgZnVuY3Rpb24oZ3VpKSB7XG4gICAgICBndWkuZG9tRWxlbWVudC5zdHlsZS56SW5kZXggPSBoaWRlID8gLTk5OSA6IDk5OTtcbiAgICAgIGd1aS5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBoaWRlID8gMCA6IDE7XG4gICAgfSk7XG4gIH07XG5cbiAgR1VJLkNMQVNTX0FVVE9fUExBQ0UgPSAnYSc7XG4gIEdVSS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUiA9ICdhYyc7XG4gIEdVSS5DTEFTU19NQUlOID0gJ21haW4nO1xuICBHVUkuQ0xBU1NfQ09OVFJPTExFUl9ST1cgPSAnY3InO1xuICBHVUkuQ0xBU1NfVE9PX1RBTEwgPSAndGFsbGVyLXRoYW4td2luZG93JztcbiAgR1VJLkNMQVNTX0NMT1NFRCA9ICdjbG9zZWQnO1xuICBHVUkuQ0xBU1NfQ0xPU0VfQlVUVE9OID0gJ2Nsb3NlLWJ1dHRvbic7XG4gIEdVSS5DTEFTU19EUkFHID0gJ2RyYWcnO1xuXG4gIEdVSS5ERUZBVUxUX1dJRFRIID0gMjQ1O1xuICBHVUkuVEVYVF9DTE9TRUQgPSAnQ2xvc2UgQ29udHJvbHMnO1xuICBHVUkuVEVYVF9PUEVOID0gJ09wZW4gQ29udHJvbHMnO1xuXG4gIGRvbS5iaW5kKHdpbmRvdywgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG5cbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50eXBlICE9PSAndGV4dCcgJiZcbiAgICAgICAgKGUud2hpY2ggPT09IEhJREVfS0VZX0NPREUgfHwgZS5rZXlDb2RlID09IEhJREVfS0VZX0NPREUpKSB7XG4gICAgICBHVUkudG9nZ2xlSGlkZSgpO1xuICAgIH1cblxuICB9LCBmYWxzZSk7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgR1VJLnByb3RvdHlwZSxcblxuICAgICAgLyoqIEBsZW5kcyBkYXQuZ3VpLkdVSSAqL1xuICAgICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eVxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJ9IFRoZSBuZXcgY29udHJvbGxlciB0aGF0IHdhcyBhZGRlZC5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5QXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eVxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbG9yQ29udHJvbGxlcn0gVGhlIG5ldyBjb250cm9sbGVyIHRoYXQgd2FzIGFkZGVkLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGFkZENvbG9yOiBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGNvbnRyb2xsZXJcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcblxuICAgICAgICAgIC8vIFRPRE8gbGlzdGVuaW5nP1xuICAgICAgICAgIHRoaXMuX191bC5yZW1vdmVDaGlsZChjb250cm9sbGVyLl9fbGkpO1xuICAgICAgICAgIHRoaXMuX19jb250cm9sbGVycy5zbGljZSh0aGlzLl9fY29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSwgMSk7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBjb21tb24uZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfdGhpcy5vblJlc2l6ZSgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICBpZiAodGhpcy5hdXRvUGxhY2UpIHtcbiAgICAgICAgICAgIGF1dG9fcGxhY2VfY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuZ3VpLkdVSX0gVGhlIG5ldyBmb2xkZXIuXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGlzIEdVSSBhbHJlYWR5IGhhcyBhIGZvbGRlciBieSB0aGUgc3BlY2lmaWVkXG4gICAgICAgICAqIG5hbWVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGRGb2xkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcblxuICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcHJldmVudCBjb2xsaXNpb25zIG9uIG5hbWVzIGluIG9yZGVyIHRvIGhhdmUgYSBrZXlcbiAgICAgICAgICAvLyBieSB3aGljaCB0byByZW1lbWJlciBzYXZlZCB2YWx1ZXNcbiAgICAgICAgICBpZiAodGhpcy5fX2ZvbGRlcnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYWxyZWFkeSBoYXZlIGEgZm9sZGVyIGluIHRoaXMgR1VJIGJ5IHRoZScgK1xuICAgICAgICAgICAgICAgICcgbmFtZSBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld19ndWlfcGFyYW1zID0geyBuYW1lOiBuYW1lLCBwYXJlbnQ6IHRoaXMgfTtcblxuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcGFzcyBkb3duIHRoZSBhdXRvUGxhY2UgdHJhaXQgc28gdGhhdCB3ZSBjYW5cbiAgICAgICAgICAvLyBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHRvIG9wZW4vY2xvc2UgZm9sZGVyIGFjdGlvbnMgdG9cbiAgICAgICAgICAvLyBlbnN1cmUgdGhhdCBhIHNjcm9sbGJhciBhcHBlYXJzIGlmIHRoZSB3aW5kb3cgaXMgdG9vIHNob3J0LlxuICAgICAgICAgIG5ld19ndWlfcGFyYW1zLmF1dG9QbGFjZSA9IHRoaXMuYXV0b1BsYWNlO1xuXG4gICAgICAgICAgLy8gRG8gd2UgaGF2ZSBzYXZlZCBhcHBlYXJhbmNlIGRhdGEgZm9yIHRoaXMgZm9sZGVyP1xuXG4gICAgICAgICAgaWYgKHRoaXMubG9hZCAmJiAvLyBBbnl0aGluZyBsb2FkZWQ/XG4gICAgICAgICAgICAgIHRoaXMubG9hZC5mb2xkZXJzICYmIC8vIFdhcyBteSBwYXJlbnQgYSBkZWFkLWVuZD9cbiAgICAgICAgICAgICAgdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV0pIHsgLy8gRGlkIGRhZGR5IHJlbWVtYmVyIG1lP1xuXG4gICAgICAgICAgICAvLyBTdGFydCBtZSBjbG9zZWQgaWYgSSB3YXMgY2xvc2VkXG4gICAgICAgICAgICBuZXdfZ3VpX3BhcmFtcy5jbG9zZWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXS5jbG9zZWQ7XG5cbiAgICAgICAgICAgIC8vIFBhc3MgZG93biB0aGUgbG9hZGVkIGRhdGFcbiAgICAgICAgICAgIG5ld19ndWlfcGFyYW1zLmxvYWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBndWkgPSBuZXcgR1VJKG5ld19ndWlfcGFyYW1zKTtcbiAgICAgICAgICB0aGlzLl9fZm9sZGVyc1tuYW1lXSA9IGd1aTtcblxuICAgICAgICAgIHZhciBsaSA9IGFkZFJvdyh0aGlzLCBndWkuZG9tRWxlbWVudCk7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKGxpLCAnZm9sZGVyJyk7XG4gICAgICAgICAgcmV0dXJuIGd1aTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIG9wZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0Um9vdCgpO1xuXG4gICAgICAgICAgaWYgKHJvb3Quc2Nyb2xsYWJsZSkge1xuXG4gICAgICAgICAgICB2YXIgdG9wID0gZG9tLmdldE9mZnNldChyb290Ll9fdWwpLnRvcDtcbiAgICAgICAgICAgIHZhciBoID0gMDtcblxuICAgICAgICAgICAgY29tbW9uLmVhY2gocm9vdC5fX3VsLmNoaWxkTm9kZXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKCEgKHJvb3QuYXV0b1BsYWNlICYmIG5vZGUgPT09IHJvb3QuX19zYXZlX3JvdykpXG4gICAgICAgICAgICAgICAgaCArPSBkb20uZ2V0SGVpZ2h0KG5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3AgLSBDTE9TRV9CVVRUT05fSEVJR0hUIDwgaCkge1xuICAgICAgICAgICAgICBkb20uYWRkQ2xhc3Mocm9vdC5kb21FbGVtZW50LCBHVUkuQ0xBU1NfVE9PX1RBTEwpO1xuICAgICAgICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gdG9wIC0gQ0xPU0VfQlVUVE9OX0hFSUdIVCArICdweCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3Mocm9vdC5kb21FbGVtZW50LCBHVUkuQ0xBU1NfVE9PX1RBTEwpO1xuICAgICAgICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJvb3QuX19yZXNpemVfaGFuZGxlKSB7XG4gICAgICAgICAgICBjb21tb24uZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJvb3QuX19yZXNpemVfaGFuZGxlLnN0eWxlLmhlaWdodCA9IHJvb3QuX191bC5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJvb3QuX19jbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgcm9vdC5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gcm9vdC53aWR0aCArICdweCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmsgb2JqZWN0cyBmb3Igc2F2aW5nLiBUaGUgb3JkZXIgb2YgdGhlc2Ugb2JqZWN0cyBjYW5ub3QgY2hhbmdlIGFzXG4gICAgICAgICAqIHRoZSBHVUkgZ3Jvd3MuIFdoZW4gcmVtZW1iZXJpbmcgbmV3IG9iamVjdHMsIGFwcGVuZCB0aGVtIHRvIHRoZSBlbmRcbiAgICAgICAgICogb2YgdGhlIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0Li4ufSBvYmplY3RzXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBub3QgY2FsbGVkIG9uIGEgdG9wIGxldmVsIEdVSS5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICByZW1lbWJlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKFNBVkVfRElBTE9HVUUpKSB7XG4gICAgICAgICAgICBTQVZFX0RJQUxPR1VFID0gbmV3IENlbnRlcmVkRGl2KCk7XG4gICAgICAgICAgICBTQVZFX0RJQUxPR1VFLmRvbUVsZW1lbnQuaW5uZXJIVE1MID0gc2F2ZURpYWxvZ3VlQ29udGVudHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FuIG9ubHkgY2FsbCByZW1lbWJlciBvbiBhIHRvcCBsZXZlbCBHVUkuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICBjb21tb24uZWFjaChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIGFkZFNhdmVNZW51KF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PSAtMSkge1xuICAgICAgICAgICAgICBfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0aGlzLmF1dG9QbGFjZSkge1xuICAgICAgICAgICAgLy8gU2V0IHNhdmUgcm93IHdpZHRoXG4gICAgICAgICAgICBzZXRXaWR0aCh0aGlzLCB0aGlzLndpZHRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge2RhdC5ndWkuR1VJfSB0aGUgdG9wbW9zdCBwYXJlbnQgR1VJIG9mIGEgbmVzdGVkIEdVSS5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSb290OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZ3VpID0gdGhpcztcbiAgICAgICAgICB3aGlsZSAoZ3VpLnBhcmVudCkge1xuICAgICAgICAgICAgZ3VpID0gZ3VpLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGd1aTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gYSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgc3RhdGUgb2ZcbiAgICAgICAgICogdGhpcyBHVUkgYXMgd2VsbCBhcyBpdHMgcmVtZW1iZXJlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGdldFNhdmVPYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgdmFyIHRvUmV0dXJuID0gdGhpcy5sb2FkO1xuXG4gICAgICAgICAgdG9SZXR1cm4uY2xvc2VkID0gdGhpcy5jbG9zZWQ7XG5cbiAgICAgICAgICAvLyBBbSBJIHJlbWVtYmVyaW5nIGFueSB2YWx1ZXM/XG4gICAgICAgICAgaWYgKHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIHRvUmV0dXJuLnByZXNldCA9IHRoaXMucHJlc2V0O1xuXG4gICAgICAgICAgICBpZiAoIXRvUmV0dXJuLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b1JldHVybi5yZW1lbWJlcmVkW3RoaXMucHJlc2V0XSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b1JldHVybi5mb2xkZXJzID0ge307XG4gICAgICAgICAgY29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uKGVsZW1lbnQsIGtleSkge1xuICAgICAgICAgICAgdG9SZXR1cm4uZm9sZGVyc1trZXldID0gZWxlbWVudC5nZXRTYXZlT2JqZWN0KCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gdG9SZXR1cm47XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzYXZlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIGlmICghdGhpcy5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbdGhpcy5wcmVzZXRdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICAgICAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcywgZmFsc2UpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2F2ZUFzOiBmdW5jdGlvbihwcmVzZXROYW1lKSB7XG5cbiAgICAgICAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG5cbiAgICAgICAgICAgIC8vIFJldGFpbiBkZWZhdWx0IHZhbHVlcyB1cG9uIGZpcnN0IHNhdmVcbiAgICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkID0ge307XG4gICAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzLCB0cnVlKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3ByZXNldE5hbWVdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnByZXNldCA9IHByZXNldE5hbWU7XG4gICAgICAgICAgYWRkUHJlc2V0T3B0aW9uKHRoaXMsIHByZXNldE5hbWUsIHRydWUpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbihndWkpIHtcblxuICAgICAgICAgIGNvbW1vbi5lYWNoKHRoaXMuX19jb250cm9sbGVycywgZnVuY3Rpb24oY29udHJvbGxlcikge1xuICAgICAgICAgICAgLy8gTWFrZSByZXZlcnQgd29yayBvbiBEZWZhdWx0LlxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFJvb3QoKS5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5zZXRWYWx1ZShjb250cm9sbGVyLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNhbGxTYXZlZFZhbHVlKGd1aSB8fCB0aGlzLmdldFJvb3QoKSwgY29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICBjb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24oZm9sZGVyKSB7XG4gICAgICAgICAgICBmb2xkZXIucmV2ZXJ0KGZvbGRlcik7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWd1aSkge1xuICAgICAgICAgICAgbWFya1ByZXNldE1vZGlmaWVkKHRoaXMuZ2V0Um9vdCgpLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgfSxcblxuICAgICAgICBsaXN0ZW46IGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcblxuICAgICAgICAgIHZhciBpbml0ID0gdGhpcy5fX2xpc3RlbmluZy5sZW5ndGggPT0gMDtcbiAgICAgICAgICB0aGlzLl9fbGlzdGVuaW5nLnB1c2goY29udHJvbGxlcik7XG4gICAgICAgICAgaWYgKGluaXQpIHVwZGF0ZURpc3BsYXlzKHRoaXMuX19saXN0ZW5pbmcpO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgZnVuY3Rpb24gYWRkKGd1aSwgb2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG5cbiAgICBpZiAob2JqZWN0W3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3QgXCIgKyBvYmplY3QgKyBcIiBoYXMgbm8gcHJvcGVydHkgXFxcIlwiICsgcHJvcGVydHkgKyBcIlxcXCJcIik7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRyb2xsZXI7XG5cbiAgICBpZiAocGFyYW1zLmNvbG9yKSB7XG5cbiAgICAgIGNvbnRyb2xsZXIgPSBuZXcgQ29sb3JDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdmFyIGZhY3RvcnlBcmdzID0gW29iamVjdCxwcm9wZXJ0eV0uY29uY2F0KHBhcmFtcy5mYWN0b3J5QXJncyk7XG4gICAgICBjb250cm9sbGVyID0gY29udHJvbGxlckZhY3RvcnkuYXBwbHkoZ3VpLCBmYWN0b3J5QXJncyk7XG5cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmJlZm9yZSBpbnN0YW5jZW9mIENvbnRyb2xsZXIpIHtcbiAgICAgIHBhcmFtcy5iZWZvcmUgPSBwYXJhbXMuYmVmb3JlLl9fbGk7XG4gICAgfVxuXG4gICAgcmVjYWxsU2F2ZWRWYWx1ZShndWksIGNvbnRyb2xsZXIpO1xuXG4gICAgZG9tLmFkZENsYXNzKGNvbnRyb2xsZXIuZG9tRWxlbWVudCwgJ2MnKTtcblxuICAgIHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGRvbS5hZGRDbGFzcyhuYW1lLCAncHJvcGVydHktbmFtZScpO1xuICAgIG5hbWUuaW5uZXJIVE1MID0gY29udHJvbGxlci5wcm9wZXJ0eTtcblxuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobmFtZSk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRyb2xsZXIuZG9tRWxlbWVudCk7XG5cbiAgICB2YXIgbGkgPSBhZGRSb3coZ3VpLCBjb250YWluZXIsIHBhcmFtcy5iZWZvcmUpO1xuXG4gICAgZG9tLmFkZENsYXNzKGxpLCBHVUkuQ0xBU1NfQ09OVFJPTExFUl9ST1cpO1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgdHlwZW9mIGNvbnRyb2xsZXIuZ2V0VmFsdWUoKSk7XG5cbiAgICBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKTtcblxuICAgIGd1aS5fX2NvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XG5cbiAgICByZXR1cm4gY29udHJvbGxlcjtcblxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHJvdyB0byB0aGUgZW5kIG9mIHRoZSBHVUkgb3IgYmVmb3JlIGFub3RoZXIgcm93LlxuICAgKlxuICAgKiBAcGFyYW0gZ3VpXG4gICAqIEBwYXJhbSBbZG9tXSBJZiBzcGVjaWZpZWQsIGluc2VydHMgdGhlIGRvbSBjb250ZW50IGluIHRoZSBuZXcgcm93XG4gICAqIEBwYXJhbSBbbGlCZWZvcmVdIElmIHNwZWNpZmllZCwgcGxhY2VzIHRoZSBuZXcgcm93IGJlZm9yZSBhbm90aGVyIHJvd1xuICAgKi9cbiAgZnVuY3Rpb24gYWRkUm93KGd1aSwgZG9tLCBsaUJlZm9yZSkge1xuICAgIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgaWYgKGRvbSkgbGkuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICBpZiAobGlCZWZvcmUpIHtcbiAgICAgIGd1aS5fX3VsLmluc2VydEJlZm9yZShsaSwgcGFyYW1zLmJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGd1aS5fX3VsLmFwcGVuZENoaWxkKGxpKTtcbiAgICB9XG4gICAgZ3VpLm9uUmVzaXplKCk7XG4gICAgcmV0dXJuIGxpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXVnbWVudENvbnRyb2xsZXIoZ3VpLCBsaSwgY29udHJvbGxlcikge1xuXG4gICAgY29udHJvbGxlci5fX2xpID0gbGk7XG4gICAgY29udHJvbGxlci5fX2d1aSA9IGd1aTtcblxuICAgIGNvbW1vbi5leHRlbmQoY29udHJvbGxlciwge1xuXG4gICAgICBvcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcblxuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIGd1aSxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5vYmplY3QsXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIucHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgZmFjdG9yeUFyZ3M6IFtjb21tb24udG9BcnJheShhcmd1bWVudHMpXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc0FycmF5KG9wdGlvbnMpIHx8IGNvbW1vbi5pc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG5cbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICBndWksXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIub2JqZWN0LFxuICAgICAgICAgICAgICBjb250cm9sbGVyLnByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIGZhY3RvcnlBcmdzOiBbb3B0aW9uc11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9LFxuXG4gICAgICBuYW1lOiBmdW5jdGlvbih2KSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX19saS5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUwgPSB2O1xuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgIH0sXG5cbiAgICAgIGxpc3RlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX19ndWkubGlzdGVuKGNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX19ndWkucmVtb3ZlKGNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8gQWxsIHNsaWRlcnMgc2hvdWxkIGJlIGFjY29tcGFuaWVkIGJ5IGEgYm94LlxuICAgIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgTnVtYmVyQ29udHJvbGxlclNsaWRlcikge1xuXG4gICAgICB2YXIgYm94ID0gbmV3IE51bWJlckNvbnRyb2xsZXJCb3goY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksXG4gICAgICAgICAgeyBtaW46IGNvbnRyb2xsZXIuX19taW4sIG1heDogY29udHJvbGxlci5fX21heCwgc3RlcDogY29udHJvbGxlci5fX3N0ZXAgfSk7XG5cbiAgICAgIGNvbW1vbi5lYWNoKFsndXBkYXRlRGlzcGxheScsICdvbkNoYW5nZScsICdvbkZpbmlzaENoYW5nZSddLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgdmFyIHBjID0gY29udHJvbGxlclttZXRob2RdO1xuICAgICAgICB2YXIgcGIgPSBib3hbbWV0aG9kXTtcbiAgICAgICAgY29udHJvbGxlclttZXRob2RdID0gYm94W21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgcGMuYXBwbHkoY29udHJvbGxlciwgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIHBiLmFwcGx5KGJveCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBkb20uYWRkQ2xhc3MobGksICdoYXMtc2xpZGVyJyk7XG4gICAgICBjb250cm9sbGVyLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGJveC5kb21FbGVtZW50LCBjb250cm9sbGVyLmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBOdW1iZXJDb250cm9sbGVyQm94KSB7XG5cbiAgICAgIHZhciByID0gZnVuY3Rpb24ocmV0dXJuZWQpIHtcblxuICAgICAgICAvLyBIYXZlIHdlIGRlZmluZWQgYm90aCBib3VuZGFyaWVzP1xuICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19taW4pICYmIGNvbW1vbi5pc051bWJlcihjb250cm9sbGVyLl9fbWF4KSkge1xuXG4gICAgICAgICAgLy8gV2VsbCwgdGhlbiBsZXRzIGp1c3QgcmVwbGFjZSB0aGlzIHdpdGggYSBzbGlkZXIuXG4gICAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICBndWksXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIub2JqZWN0LFxuICAgICAgICAgICAgICBjb250cm9sbGVyLnByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIGZhY3RvcnlBcmdzOiBbY29udHJvbGxlci5fX21pbiwgY29udHJvbGxlci5fX21heCwgY29udHJvbGxlci5fX3N0ZXBdXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0dXJuZWQ7XG5cbiAgICAgIH07XG5cbiAgICAgIGNvbnRyb2xsZXIubWluID0gY29tbW9uLmNvbXBvc2UociwgY29udHJvbGxlci5taW4pO1xuICAgICAgY29udHJvbGxlci5tYXggPSBjb21tb24uY29tcG9zZShyLCBjb250cm9sbGVyLm1heCk7XG5cbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEJvb2xlYW5Db250cm9sbGVyKSB7XG5cbiAgICAgIGRvbS5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fY2hlY2tib3gsICdjbGljaycpO1xuICAgICAgfSk7XG5cbiAgICAgIGRvbS5iaW5kKGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpOyAvLyBQcmV2ZW50cyBkb3VibGUtdG9nZ2xlXG4gICAgICB9KVxuXG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBGdW5jdGlvbkNvbnRyb2xsZXIpIHtcblxuICAgICAgZG9tLmJpbmQobGksICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19idXR0b24sICdjbGljaycpO1xuICAgICAgfSk7XG5cbiAgICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLl9fYnV0dG9uLCAnaG92ZXInKTtcbiAgICAgIH0pO1xuXG4gICAgICBkb20uYmluZChsaSwgJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb250cm9sbGVyLl9fYnV0dG9uLCAnaG92ZXInKTtcbiAgICAgIH0pO1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBDb2xvckNvbnRyb2xsZXIpIHtcblxuICAgICAgZG9tLmFkZENsYXNzKGxpLCAnY29sb3InKTtcbiAgICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSA9IGNvbW1vbi5jb21wb3NlKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgbGkuc3R5bGUuYm9yZGVyTGVmdENvbG9yID0gY29udHJvbGxlci5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSwgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KTtcblxuICAgICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICB9XG5cbiAgICBjb250cm9sbGVyLnNldFZhbHVlID0gY29tbW9uLmNvbXBvc2UoZnVuY3Rpb24ocikge1xuICAgICAgaWYgKGd1aS5nZXRSb290KCkuX19wcmVzZXRfc2VsZWN0ICYmIGNvbnRyb2xsZXIuaXNNb2RpZmllZCgpKSB7XG4gICAgICAgIG1hcmtQcmVzZXRNb2RpZmllZChndWkuZ2V0Um9vdCgpLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH0sIGNvbnRyb2xsZXIuc2V0VmFsdWUpO1xuXG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcikge1xuXG4gICAgLy8gRmluZCB0aGUgdG9wbW9zdCBHVUksIHRoYXQncyB3aGVyZSByZW1lbWJlcmVkIG9iamVjdHMgbGl2ZS5cbiAgICB2YXIgcm9vdCA9IGd1aS5nZXRSb290KCk7XG5cbiAgICAvLyBEb2VzIHRoZSBvYmplY3Qgd2UncmUgY29udHJvbGxpbmcgbWF0Y2ggYW55dGhpbmcgd2UndmUgYmVlbiB0b2xkIHRvXG4gICAgLy8gcmVtZW1iZXI/XG4gICAgdmFyIG1hdGNoZWRfaW5kZXggPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihjb250cm9sbGVyLm9iamVjdCk7XG5cbiAgICAvLyBXaHkgeWVzLCBpdCBkb2VzIVxuICAgIGlmIChtYXRjaGVkX2luZGV4ICE9IC0xKSB7XG5cbiAgICAgIC8vIExldCBtZSBmZXRjaCBhIG1hcCBvZiBjb250cm9sbGVycyBmb3IgdGhjb21tb24uaXNPYmplY3QuXG4gICAgICB2YXIgY29udHJvbGxlcl9tYXAgPVxuICAgICAgICAgIHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbbWF0Y2hlZF9pbmRleF07XG5cbiAgICAgIC8vIE9ocCwgSSBiZWxpZXZlIHRoaXMgaXMgdGhlIGZpcnN0IGNvbnRyb2xsZXIgd2UndmUgY3JlYXRlZCBmb3IgdGhpc1xuICAgICAgLy8gb2JqZWN0LiBMZXRzIG1ha2UgdGhlIG1hcCBmcmVzaC5cbiAgICAgIGlmIChjb250cm9sbGVyX21hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRyb2xsZXJfbWFwID0ge307XG4gICAgICAgIHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbbWF0Y2hlZF9pbmRleF0gPVxuICAgICAgICAgICAgY29udHJvbGxlcl9tYXA7XG4gICAgICB9XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhpcyBjb250cm9sbGVyXG4gICAgICBjb250cm9sbGVyX21hcFtjb250cm9sbGVyLnByb3BlcnR5XSA9IGNvbnRyb2xsZXI7XG5cbiAgICAgIC8vIE9rYXksIG5vdyBoYXZlIHdlIHNhdmVkIGFueSB2YWx1ZXMgZm9yIHRoaXMgY29udHJvbGxlcj9cbiAgICAgIGlmIChyb290LmxvYWQgJiYgcm9vdC5sb2FkLnJlbWVtYmVyZWQpIHtcblxuICAgICAgICB2YXIgcHJlc2V0X21hcCA9IHJvb3QubG9hZC5yZW1lbWJlcmVkO1xuXG4gICAgICAgIC8vIFdoaWNoIHByZXNldCBhcmUgd2UgdHJ5aW5nIHRvIGxvYWQ/XG4gICAgICAgIHZhciBwcmVzZXQ7XG5cbiAgICAgICAgaWYgKHByZXNldF9tYXBbZ3VpLnByZXNldF0pIHtcblxuICAgICAgICAgIHByZXNldCA9IHByZXNldF9tYXBbZ3VpLnByZXNldF07XG5cbiAgICAgICAgfSBlbHNlIGlmIChwcmVzZXRfbWFwW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV0pIHtcblxuICAgICAgICAgIC8vIFVoaCwgeW91IGNhbiBoYXZlIHRoZSBkZWZhdWx0IGluc3RlYWQ/XG4gICAgICAgICAgcHJlc2V0ID0gcHJlc2V0X21hcFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBOYWRhLlxuXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIERpZCB0aGUgbG9hZGVkIG9iamVjdCByZW1lbWJlciB0aGNvbW1vbi5pc09iamVjdD9cbiAgICAgICAgaWYgKHByZXNldFttYXRjaGVkX2luZGV4XSAmJlxuXG4gICAgICAgICAgLy8gRGlkIHdlIHJlbWVtYmVyIHRoaXMgcGFydGljdWxhciBwcm9wZXJ0eT9cbiAgICAgICAgICAgIHByZXNldFttYXRjaGVkX2luZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAvLyBXZSBkaWQgcmVtZW1iZXIgc29tZXRoaW5nIGZvciB0aGlzIGd1eSAuLi5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBwcmVzZXRbbWF0Y2hlZF9pbmRleF1bY29udHJvbGxlci5wcm9wZXJ0eV07XG5cbiAgICAgICAgICAvLyBBbmQgdGhhdCdzIHdoYXQgaXQgaXMuXG4gICAgICAgICAgY29udHJvbGxlci5pbml0aWFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKHZhbHVlKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TG9jYWxTdG9yYWdlSGFzaChndWksIGtleSkge1xuICAgIC8vIFRPRE8gaG93IGRvZXMgdGhpcyBkZWFsIHdpdGggbXVsdGlwbGUgR1VJJ3M/XG4gICAgcmV0dXJuIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgKyAnLicgKyBrZXk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFNhdmVNZW51KGd1aSkge1xuXG4gICAgdmFyIGRpdiA9IGd1aS5fX3NhdmVfcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblxuICAgIGRvbS5hZGRDbGFzcyhndWkuZG9tRWxlbWVudCwgJ2hhcy1zYXZlJyk7XG5cbiAgICBndWkuX191bC5pbnNlcnRCZWZvcmUoZGl2LCBndWkuX191bC5maXJzdENoaWxkKTtcblxuICAgIGRvbS5hZGRDbGFzcyhkaXYsICdzYXZlLXJvdycpO1xuXG4gICAgdmFyIGdlYXJzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGdlYXJzLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICAgIGRvbS5hZGRDbGFzcyhnZWFycywgJ2J1dHRvbiBnZWFycycpO1xuXG4gICAgLy8gVE9ETyByZXBsYWNlIHdpdGggRnVuY3Rpb25Db250cm9sbGVyXG4gICAgdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBidXR0b24uaW5uZXJIVE1MID0gJ1NhdmUnO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24sICdidXR0b24nKTtcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uLCAnc2F2ZScpO1xuXG4gICAgdmFyIGJ1dHRvbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgYnV0dG9uMi5pbm5lckhUTUwgPSAnTmV3JztcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uMiwgJ2J1dHRvbicpO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24yLCAnc2F2ZS1hcycpO1xuXG4gICAgdmFyIGJ1dHRvbjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgYnV0dG9uMy5pbm5lckhUTUwgPSAnUmV2ZXJ0JztcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ2J1dHRvbicpO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24zLCAncmV2ZXJ0Jyk7XG5cbiAgICB2YXIgc2VsZWN0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuXG4gICAgaWYgKGd1aS5sb2FkICYmIGd1aS5sb2FkLnJlbWVtYmVyZWQpIHtcblxuICAgICAgY29tbW9uLmVhY2goZ3VpLmxvYWQucmVtZW1iZXJlZCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBrZXksIGtleSA9PSBndWkucHJlc2V0KTtcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFByZXNldE9wdGlvbihndWksIERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGRvbS5iaW5kKHNlbGVjdCwgJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuXG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS5pbm5lckhUTUwgPSBndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgZ3VpLnByZXNldCA9IHRoaXMudmFsdWU7XG5cbiAgICB9KTtcblxuICAgIGRpdi5hcHBlbmRDaGlsZChzZWxlY3QpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChnZWFycyk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjIpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChidXR0b24zKTtcblxuICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG5cbiAgICAgIHZhciBzYXZlTG9jYWxseSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1zYXZlLWxvY2FsbHknKTtcbiAgICAgIHZhciBleHBsYWluID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLWxvY2FsLWV4cGxhaW4nKTtcblxuICAgICAgc2F2ZUxvY2FsbHkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgIHZhciBsb2NhbFN0b3JhZ2VDaGVja0JveCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1zdG9yYWdlJyk7XG5cbiAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJykge1xuICAgICAgICBsb2NhbFN0b3JhZ2VDaGVja0JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzaG93SGlkZUV4cGxhaW4oKSB7XG4gICAgICAgIGV4cGxhaW4uc3R5bGUuZGlzcGxheSA9IGd1aS51c2VMb2NhbFN0b3JhZ2UgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICBzaG93SGlkZUV4cGxhaW4oKTtcblxuICAgICAgLy8gVE9ETzogVXNlIGEgYm9vbGVhbiBjb250cm9sbGVyLCBmb29sIVxuICAgICAgZG9tLmJpbmQobG9jYWxTdG9yYWdlQ2hlY2tCb3gsICdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZ3VpLnVzZUxvY2FsU3RvcmFnZSA9ICFndWkudXNlTG9jYWxTdG9yYWdlO1xuICAgICAgICBzaG93SGlkZUV4cGxhaW4oKTtcbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgdmFyIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbmV3LWNvbnN0cnVjdG9yJyk7XG5cbiAgICBkb20uYmluZChuZXdDb25zdHJ1Y3RvclRleHRBcmVhLCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLm1ldGFLZXkgJiYgKGUud2hpY2ggPT09IDY3IHx8IGUua2V5Q29kZSA9PSA2NykpIHtcbiAgICAgICAgU0FWRV9ESUFMT0dVRS5oaWRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkb20uYmluZChnZWFycywgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLmlubmVySFRNTCA9IEpTT04uc3RyaW5naWZ5KGd1aS5nZXRTYXZlT2JqZWN0KCksIHVuZGVmaW5lZCwgMik7XG4gICAgICBTQVZFX0RJQUxPR1VFLnNob3coKTtcbiAgICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuZm9jdXMoKTtcbiAgICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuc2VsZWN0KCk7XG4gICAgfSk7XG5cbiAgICBkb20uYmluZChidXR0b24sICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgZ3VpLnNhdmUoKTtcbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKGJ1dHRvbjIsICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByZXNldE5hbWUgPSBwcm9tcHQoJ0VudGVyIGEgbmV3IHByZXNldCBuYW1lLicpO1xuICAgICAgaWYgKHByZXNldE5hbWUpIGd1aS5zYXZlQXMocHJlc2V0TmFtZSk7XG4gICAgfSk7XG5cbiAgICBkb20uYmluZChidXR0b24zLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIGd1aS5yZXZlcnQoKTtcbiAgICB9KTtcblxuLy8gICAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjIpO1xuXG4gIH1cblxuICBmdW5jdGlvbiBhZGRSZXNpemVIYW5kbGUoZ3VpKSB7XG5cbiAgICBndWkuX19yZXNpemVfaGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBjb21tb24uZXh0ZW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUsIHtcblxuICAgICAgd2lkdGg6ICc2cHgnLFxuICAgICAgbWFyZ2luTGVmdDogJy0zcHgnLFxuICAgICAgaGVpZ2h0OiAnMjAwcHgnLFxuICAgICAgY3Vyc29yOiAnZXctcmVzaXplJyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4vLyAgICAgIGJvcmRlcjogJzFweCBzb2xpZCBibHVlJ1xuXG4gICAgfSk7XG5cbiAgICB2YXIgcG1vdXNlWDtcblxuICAgIGRvbS5iaW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuICAgIGRvbS5iaW5kKGd1aS5fX2Nsb3NlQnV0dG9uLCAnbW91c2Vkb3duJywgZHJhZ1N0YXJ0KTtcblxuICAgIGd1aS5kb21FbGVtZW50Lmluc2VydEJlZm9yZShndWkuX19yZXNpemVfaGFuZGxlLCBndWkuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG5cbiAgICBmdW5jdGlvbiBkcmFnU3RhcnQoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHBtb3VzZVggPSBlLmNsaWVudFg7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgZHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZHJhZ1N0b3ApO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmFnKGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBndWkud2lkdGggKz0gcG1vdXNlWCAtIGUuY2xpZW50WDtcbiAgICAgIGd1aS5vblJlc2l6ZSgpO1xuICAgICAgcG1vdXNlWCA9IGUuY2xpZW50WDtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhZ1N0b3AoKSB7XG5cbiAgICAgIGRvbS5yZW1vdmVDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGRyYWdTdG9wKTtcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gc2V0V2lkdGgoZ3VpLCB3KSB7XG4gICAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAvLyBBdXRvIHBsYWNlZCBzYXZlLXJvd3MgYXJlIHBvc2l0aW9uIGZpeGVkLCBzbyB3ZSBoYXZlIHRvXG4gICAgLy8gc2V0IHRoZSB3aWR0aCBtYW51YWxseSBpZiB3ZSB3YW50IGl0IHRvIGJsZWVkIHRvIHRoZSBlZGdlXG4gICAgaWYgKGd1aS5fX3NhdmVfcm93ICYmIGd1aS5hdXRvUGxhY2UpIHtcbiAgICAgIGd1aS5fX3NhdmVfcm93LnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgfWlmIChndWkuX19jbG9zZUJ1dHRvbikge1xuICAgICAgZ3VpLl9fY2xvc2VCdXR0b24uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXJyZW50UHJlc2V0KGd1aSwgdXNlSW5pdGlhbFZhbHVlcykge1xuXG4gICAgdmFyIHRvUmV0dXJuID0ge307XG5cbiAgICAvLyBGb3IgZWFjaCBvYmplY3QgSSdtIHJlbWVtYmVyaW5nXG4gICAgY29tbW9uLmVhY2goZ3VpLl9fcmVtZW1iZXJlZE9iamVjdHMsIGZ1bmN0aW9uKHZhbCwgaW5kZXgpIHtcblxuICAgICAgdmFyIHNhdmVkX3ZhbHVlcyA9IHt9O1xuXG4gICAgICAvLyBUaGUgY29udHJvbGxlcnMgSSd2ZSBtYWRlIGZvciB0aGNvbW1vbi5pc09iamVjdCBieSBwcm9wZXJ0eVxuICAgICAgdmFyIGNvbnRyb2xsZXJfbWFwID1cbiAgICAgICAgICBndWkuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbaW5kZXhdO1xuXG4gICAgICAvLyBSZW1lbWJlciBlYWNoIHZhbHVlIGZvciBlYWNoIHByb3BlcnR5XG4gICAgICBjb21tb24uZWFjaChjb250cm9sbGVyX21hcCwgZnVuY3Rpb24oY29udHJvbGxlciwgcHJvcGVydHkpIHtcbiAgICAgICAgc2F2ZWRfdmFsdWVzW3Byb3BlcnR5XSA9IHVzZUluaXRpYWxWYWx1ZXMgPyBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA6IGNvbnRyb2xsZXIuZ2V0VmFsdWUoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTYXZlIHRoZSB2YWx1ZXMgZm9yIHRoY29tbW9uLmlzT2JqZWN0XG4gICAgICB0b1JldHVybltpbmRleF0gPSBzYXZlZF92YWx1ZXM7XG5cbiAgICB9KTtcblxuICAgIHJldHVybiB0b1JldHVybjtcblxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUHJlc2V0T3B0aW9uKGd1aSwgbmFtZSwgc2V0U2VsZWN0ZWQpIHtcbiAgICB2YXIgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgb3B0LmlubmVySFRNTCA9IG5hbWU7XG4gICAgb3B0LnZhbHVlID0gbmFtZTtcbiAgICBndWkuX19wcmVzZXRfc2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XG4gICAgaWYgKHNldFNlbGVjdGVkKSB7XG4gICAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aCAtIDE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJlc2V0U2VsZWN0SW5kZXgoZ3VpKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0udmFsdWUgPT0gZ3VpLnByZXNldCkge1xuICAgICAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLCBtb2RpZmllZCkge1xuICAgIHZhciBvcHQgPSBndWkuX19wcmVzZXRfc2VsZWN0W2d1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleF07XG4vLyAgICBjb25zb2xlLmxvZygnbWFyaycsIG1vZGlmaWVkLCBvcHQpO1xuICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgb3B0LmlubmVySFRNTCA9IG9wdC52YWx1ZSArIFwiKlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSkge1xuXG5cbiAgICBpZiAoY29udHJvbGxlckFycmF5Lmxlbmd0aCAhPSAwKSB7XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgdXBkYXRlRGlzcGxheXMoY29udHJvbGxlckFycmF5KTtcbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgY29tbW9uLmVhY2goY29udHJvbGxlckFycmF5LCBmdW5jdGlvbihjKSB7XG4gICAgICBjLnVwZGF0ZURpc3BsYXkoKTtcbiAgICB9KTtcblxuICB9XG5cbiAgcmV0dXJuIEdVSTtcblxufSkoZGF0LnV0aWxzLmNzcyxcblwiPGRpdiBpZD1cXFwiZGctc2F2ZVxcXCIgY2xhc3M9XFxcImRnIGRpYWxvZ3VlXFxcIj5cXG5cXG4gIEhlcmUncyB0aGUgbmV3IGxvYWQgcGFyYW1ldGVyIGZvciB5b3VyIDxjb2RlPkdVSTwvY29kZT4ncyBjb25zdHJ1Y3RvcjpcXG5cXG4gIDx0ZXh0YXJlYSBpZD1cXFwiZGctbmV3LWNvbnN0cnVjdG9yXFxcIj48L3RleHRhcmVhPlxcblxcbiAgPGRpdiBpZD1cXFwiZGctc2F2ZS1sb2NhbGx5XFxcIj5cXG5cXG4gICAgPGlucHV0IGlkPVxcXCJkZy1sb2NhbC1zdG9yYWdlXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIvPiBBdXRvbWF0aWNhbGx5IHNhdmVcXG4gICAgdmFsdWVzIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gb24gZXhpdC5cXG5cXG4gICAgPGRpdiBpZD1cXFwiZGctbG9jYWwtZXhwbGFpblxcXCI+VGhlIHZhbHVlcyBzYXZlZCB0byA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IHdpbGxcXG4gICAgICBvdmVycmlkZSB0aG9zZSBwYXNzZWQgdG8gPGNvZGU+ZGF0LkdVSTwvY29kZT4ncyBjb25zdHJ1Y3Rvci4gVGhpcyBtYWtlcyBpdFxcbiAgICAgIGVhc2llciB0byB3b3JrIGluY3JlbWVudGFsbHksIGJ1dCA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IGlzIGZyYWdpbGUsXFxuICAgICAgYW5kIHlvdXIgZnJpZW5kcyBtYXkgbm90IHNlZSB0aGUgc2FtZSB2YWx1ZXMgeW91IGRvLlxcbiAgICAgIFxcbiAgICA8L2Rpdj5cXG4gICAgXFxuICA8L2Rpdj5cXG5cXG48L2Rpdj5cIixcblwiLmRnIHVse2xpc3Qtc3R5bGU6bm9uZTttYXJnaW46MDtwYWRkaW5nOjA7d2lkdGg6MTAwJTtjbGVhcjpib3RofS5kZy5hY3twb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtoZWlnaHQ6MDt6LWluZGV4OjB9LmRnOm5vdCguYWMpIC5tYWlue292ZXJmbG93OmhpZGRlbn0uZGcubWFpbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjstby10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvd3tvdmVyZmxvdy15OmF1dG99LmRnLm1haW4udGFsbGVyLXRoYW4td2luZG93IC5jbG9zZS1idXR0b257b3BhY2l0eToxO21hcmdpbi10b3A6LTFweDtib3JkZXItdG9wOjFweCBzb2xpZCAjMmMyYzJjfS5kZy5tYWluIHVsLmNsb3NlZCAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MSAhaW1wb3J0YW50fS5kZy5tYWluOmhvdmVyIC5jbG9zZS1idXR0b24sLmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5kcmFne29wYWNpdHk6MX0uZGcubWFpbiAuY2xvc2UtYnV0dG9uey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7Ym9yZGVyOjA7cG9zaXRpb246YWJzb2x1dGU7bGluZS1oZWlnaHQ6MTlweDtoZWlnaHQ6MjBweDtjdXJzb3I6cG9pbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDB9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxMTF9LmRnLmF7ZmxvYXQ6cmlnaHQ7bWFyZ2luLXJpZ2h0OjE1cHg7b3ZlcmZsb3cteDpoaWRkZW59LmRnLmEuaGFzLXNhdmUgdWx7bWFyZ2luLXRvcDoyN3B4fS5kZy5hLmhhcy1zYXZlIHVsLmNsb3NlZHttYXJnaW4tdG9wOjB9LmRnLmEgLnNhdmUtcm93e3Bvc2l0aW9uOmZpeGVkO3RvcDowO3otaW5kZXg6MTAwMn0uZGcgbGl7LXdlYmtpdC10cmFuc2l0aW9uOmhlaWdodCAwLjFzIGVhc2Utb3V0Oy1vLXRyYW5zaXRpb246aGVpZ2h0IDAuMXMgZWFzZS1vdXQ7LW1vei10cmFuc2l0aW9uOmhlaWdodCAwLjFzIGVhc2Utb3V0O3RyYW5zaXRpb246aGVpZ2h0IDAuMXMgZWFzZS1vdXR9LmRnIGxpOm5vdCguZm9sZGVyKXtjdXJzb3I6YXV0bztoZWlnaHQ6MjdweDtsaW5lLWhlaWdodDoyN3B4O292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjAgNHB4IDAgNXB4fS5kZyBsaS5mb2xkZXJ7cGFkZGluZzowO2JvcmRlci1sZWZ0OjRweCBzb2xpZCByZ2JhKDAsMCwwLDApfS5kZyBsaS50aXRsZXtjdXJzb3I6cG9pbnRlcjttYXJnaW4tbGVmdDotNHB4fS5kZyAuY2xvc2VkIGxpOm5vdCgudGl0bGUpLC5kZyAuY2xvc2VkIHVsIGxpLC5kZyAuY2xvc2VkIHVsIGxpID4gKntoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyOjB9LmRnIC5jcntjbGVhcjpib3RoO3BhZGRpbmctbGVmdDozcHg7aGVpZ2h0OjI3cHh9LmRnIC5wcm9wZXJ0eS1uYW1le2N1cnNvcjpkZWZhdWx0O2Zsb2F0OmxlZnQ7Y2xlYXI6bGVmdDt3aWR0aDo0MCU7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9LmRnIC5je2Zsb2F0OmxlZnQ7d2lkdGg6NjAlfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JvcmRlcjowO21hcmdpbi10b3A6NHB4O3BhZGRpbmc6M3B4O3dpZHRoOjEwMCU7ZmxvYXQ6cmlnaHR9LmRnIC5oYXMtc2xpZGVyIGlucHV0W3R5cGU9dGV4dF17d2lkdGg6MzAlO21hcmdpbi1sZWZ0OjB9LmRnIC5zbGlkZXJ7ZmxvYXQ6bGVmdDt3aWR0aDo2NiU7bWFyZ2luLWxlZnQ6LTVweDttYXJnaW4tcmlnaHQ6MDtoZWlnaHQ6MTlweDttYXJnaW4tdG9wOjRweH0uZGcgLnNsaWRlci1mZ3toZWlnaHQ6MTAwJX0uZGcgLmMgaW5wdXRbdHlwZT1jaGVja2JveF17bWFyZ2luLXRvcDo5cHh9LmRnIC5jIHNlbGVjdHttYXJnaW4tdG9wOjVweH0uZGcgLmNyLmZ1bmN0aW9uLC5kZyAuY3IuZnVuY3Rpb24gLnByb3BlcnR5LW5hbWUsLmRnIC5jci5mdW5jdGlvbiAqLC5kZyAuY3IuYm9vbGVhbiwuZGcgLmNyLmJvb2xlYW4gKntjdXJzb3I6cG9pbnRlcn0uZGcgLnNlbGVjdG9ye2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW4tbGVmdDotOXB4O21hcmdpbi10b3A6MjNweDt6LWluZGV4OjEwfS5kZyAuYzpob3ZlciAuc2VsZWN0b3IsLmRnIC5zZWxlY3Rvci5kcmFne2Rpc3BsYXk6YmxvY2t9LmRnIGxpLnNhdmUtcm93e3BhZGRpbmc6MH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjBweCA2cHh9LmRnLmRpYWxvZ3Vle2JhY2tncm91bmQtY29sb3I6IzIyMjt3aWR0aDo0NjBweDtwYWRkaW5nOjE1cHg7Zm9udC1zaXplOjEzcHg7bGluZS1oZWlnaHQ6MTVweH0jZGctbmV3LWNvbnN0cnVjdG9ye3BhZGRpbmc6MTBweDtjb2xvcjojMjIyO2ZvbnQtZmFtaWx5Ok1vbmFjbywgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMHB4O2JvcmRlcjowO3Jlc2l6ZTpub25lO2JveC1zaGFkb3c6aW5zZXQgMXB4IDFweCAxcHggIzg4ODt3b3JkLXdyYXA6YnJlYWstd29yZDttYXJnaW46MTJweCAwO2Rpc3BsYXk6YmxvY2s7d2lkdGg6NDQwcHg7b3ZlcmZsb3cteTpzY3JvbGw7aGVpZ2h0OjEwMHB4O3Bvc2l0aW9uOnJlbGF0aXZlfSNkZy1sb2NhbC1leHBsYWlue2Rpc3BsYXk6bm9uZTtmb250LXNpemU6MTFweDtsaW5lLWhlaWdodDoxN3B4O2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQtY29sb3I6IzMzMztwYWRkaW5nOjhweDttYXJnaW4tdG9wOjEwcHh9I2RnLWxvY2FsLWV4cGxhaW4gY29kZXtmb250LXNpemU6MTBweH0jZGF0LWd1aS1zYXZlLWxvY2FsbHl7ZGlzcGxheTpub25lfS5kZ3tjb2xvcjojZWVlO2ZvbnQ6MTFweCAnTHVjaWRhIEdyYW5kZScsIHNhbnMtc2VyaWY7dGV4dC1zaGFkb3c6MCAtMXB4IDAgIzExMX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXJ7d2lkdGg6NXB4O2JhY2tncm91bmQ6IzFhMWExYX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVye2hlaWdodDowO2Rpc3BsYXk6bm9uZX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDojNjc2NzY3fS5kZyBsaTpub3QoLmZvbGRlcil7YmFja2dyb3VuZDojMWExYTFhO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICMyYzJjMmN9LmRnIGxpLnNhdmUtcm93e2xpbmUtaGVpZ2h0OjI1cHg7YmFja2dyb3VuZDojZGFkNWNiO2JvcmRlcjowfS5kZyBsaS5zYXZlLXJvdyBzZWxlY3R7bWFyZ2luLWxlZnQ6NXB4O3dpZHRoOjEwOHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue21hcmdpbi1sZWZ0OjVweDttYXJnaW4tdG9wOjFweDtib3JkZXItcmFkaXVzOjJweDtmb250LXNpemU6OXB4O2xpbmUtaGVpZ2h0OjdweDtwYWRkaW5nOjRweCA0cHggNXB4IDRweDtiYWNrZ3JvdW5kOiNjNWJkYWQ7Y29sb3I6I2ZmZjt0ZXh0LXNoYWRvdzowIDFweCAwICNiMGE1OGY7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmO2N1cnNvcjpwb2ludGVyfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uLmdlYXJze2JhY2tncm91bmQ6I2M1YmRhZCB1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBc0FBQUFOQ0FZQUFBQi85WlE3QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFRSkpSRUZVZU5waVlLQVUvUC8vUHdHSUMvQXBDQUJpQlNBVytJOEFDbEFjZ0t4UTRUOWhvTUFFVXJ4eDJRU0dONitlZ0RYKy92V1Q0ZTdOODJBTVlvUEF4L2V2d1dvWW9TWWJBQ1gyczdLeEN4emNzZXpEaDNldkZvREVCWVRFRXF5Y2dnV0F6QTlBdVVTUVFnZVlQYTlmUHY2L1lXbS9BY3g1SVBiN3R5L2Z3K1FaYmx3Njd2RHM4UjBZSHlRaGdPYngreUFKa0JxbUc1ZFBQRGgxYVBPR1IvZXVnVzBHNHZsSW9USWZ5RmNBK1Fla2hoSEpoUGRReGJpQUlndU1CVFFaclBENzEwOE02cm9XWURGUWlJQUF2NkFvdy8xYkZ3WGdpcytmMkxVQXlud29JYU5jejhYTngzRGw3TUVKVURHUXB4OWd0UThZQ3VlQitEMjZPRUNBQVFEYWR0N2U0NkQ0MlFBQUFBQkpSVTVFcmtKZ2dnPT0pIDJweCAxcHggbm8tcmVwZWF0O2hlaWdodDo3cHg7d2lkdGg6OHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2JhYjE5ZTtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGZ9LmRnIGxpLmZvbGRlcntib3JkZXItYm90dG9tOjB9LmRnIGxpLnRpdGxle3BhZGRpbmctbGVmdDoxNnB4O2JhY2tncm91bmQ6IzAwMCB1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxJK2hLZ0Z4b0NnQU93PT0pIDZweCAxMHB4IG5vLXJlcGVhdDtjdXJzb3I6cG9pbnRlcjtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMil9LmRnIC5jbG9zZWQgbGkudGl0bGV7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxHSVdxTUNiV0FFQU93PT0pfS5kZyAuY3IuYm9vbGVhbntib3JkZXItbGVmdDozcHggc29saWQgIzgwNjc4N30uZGcgLmNyLmZ1bmN0aW9ue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjZTYxZDVmfS5kZyAuY3IubnVtYmVye2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMmZhMWQ2fS5kZyAuY3IubnVtYmVyIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzJmYTFkNn0uZGcgLmNyLnN0cmluZ3tib3JkZXItbGVmdDozcHggc29saWQgIzFlZDM2Zn0uZGcgLmNyLnN0cmluZyBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMxZWQzNmZ9LmRnIC5jci5mdW5jdGlvbjpob3ZlciwuZGcgLmNyLmJvb2xlYW46aG92ZXJ7YmFja2dyb3VuZDojMTExfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JhY2tncm91bmQ6IzMwMzAzMDtvdXRsaW5lOm5vbmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmZvY3Vze2JhY2tncm91bmQ6IzQ5NDk0OTtjb2xvcjojZmZmfS5kZyAuYyAuc2xpZGVye2JhY2tncm91bmQ6IzMwMzAzMDtjdXJzb3I6ZXctcmVzaXplfS5kZyAuYyAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzJmYTFkNn0uZGcgLmMgLnNsaWRlcjpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIC5zbGlkZXI6aG92ZXIgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiM0NGFiZGF9XFxuXCIsXG5kYXQuY29udHJvbGxlcnMuZmFjdG9yeSA9IChmdW5jdGlvbiAoT3B0aW9uQ29udHJvbGxlciwgTnVtYmVyQ29udHJvbGxlckJveCwgTnVtYmVyQ29udHJvbGxlclNsaWRlciwgU3RyaW5nQ29udHJvbGxlciwgRnVuY3Rpb25Db250cm9sbGVyLCBCb29sZWFuQ29udHJvbGxlciwgY29tbW9uKSB7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG5cbiAgICAgICAgLy8gUHJvdmlkaW5nIG9wdGlvbnM/XG4gICAgICAgIGlmIChjb21tb24uaXNBcnJheShhcmd1bWVudHNbMl0pIHx8IGNvbW1vbi5pc09iamVjdChhcmd1bWVudHNbMl0pKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBPcHRpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcm92aWRpbmcgYSBtYXA/XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihpbml0aWFsVmFsdWUpKSB7XG5cbiAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1syXSkgJiYgY29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1szXSkpIHtcblxuICAgICAgICAgICAgLy8gSGFzIG1pbiBhbmQgbWF4LlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlckJveChvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogYXJndW1lbnRzWzJdLCBtYXg6IGFyZ3VtZW50c1szXSB9KTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc1N0cmluZyhpbml0aWFsVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc0Z1bmN0aW9uKGluaXRpYWxWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbW9uLmlzQm9vbGVhbihpbml0aWFsVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9KShkYXQuY29udHJvbGxlcnMuT3B0aW9uQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyQm94LFxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJTbGlkZXIsXG5kYXQuY29udHJvbGxlcnMuU3RyaW5nQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFByb3ZpZGVzIGEgdGV4dCBpbnB1dCB0byBhbHRlciB0aGUgc3RyaW5nIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBTdHJpbmdDb250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgU3RyaW5nQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0aGlzLl9faW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2tleXVwJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9faW5wdXQudmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2lucHV0KTtcblxuICB9O1xuXG4gIFN0cmluZ0NvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgU3RyaW5nQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIFN0b3BzIHRoZSBjYXJldCBmcm9tIG1vdmluZyBvbiBhY2NvdW50IG9mOlxuICAgICAgICAgIC8vIGtleXVwIC0+IHNldFZhbHVlIC0+IHVwZGF0ZURpc3BsYXlcbiAgICAgICAgICBpZiAoIWRvbS5pc0FjdGl2ZSh0aGlzLl9faW5wdXQpKSB7XG4gICAgICAgICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBTdHJpbmdDb250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gU3RyaW5nQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmNvbnRyb2xsZXJzLkZ1bmN0aW9uQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5Cb29sZWFuQ29udHJvbGxlcixcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuQm9vbGVhbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuRnVuY3Rpb25Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJCb3gsXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclNsaWRlcixcbmRhdC5jb250cm9sbGVycy5PcHRpb25Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLkNvbG9yQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBDb2xvciwgaW50ZXJwcmV0LCBjb21tb24pIHtcblxuICB2YXIgQ29sb3JDb250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgQ29sb3JDb250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHRoaXMuX19jb2xvciA9IG5ldyBDb2xvcih0aGlzLmdldFZhbHVlKCkpO1xuICAgIHRoaXMuX190ZW1wID0gbmV3IENvbG9yKDApO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgZG9tLm1ha2VTZWxlY3RhYmxlKHRoaXMuZG9tRWxlbWVudCwgZmFsc2UpO1xuXG4gICAgdGhpcy5fX3NlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX3NlbGVjdG9yLmNsYXNzTmFtZSA9ICdzZWxlY3Rvcic7XG5cbiAgICB0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLmNsYXNzTmFtZSA9ICdzYXR1cmF0aW9uLWZpZWxkJztcblxuICAgIHRoaXMuX19maWVsZF9rbm9iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2ZpZWxkX2tub2IuY2xhc3NOYW1lID0gJ2ZpZWxkLWtub2InO1xuICAgIHRoaXMuX19maWVsZF9rbm9iX2JvcmRlciA9ICcycHggc29saWQgJztcblxuICAgIHRoaXMuX19odWVfa25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19odWVfa25vYi5jbGFzc05hbWUgPSAnaHVlLWtub2InO1xuXG4gICAgdGhpcy5fX2h1ZV9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19odWVfZmllbGQuY2xhc3NOYW1lID0gJ2h1ZS1maWVsZCc7XG5cbiAgICB0aGlzLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMuX19pbnB1dC50eXBlID0gJ3RleHQnO1xuICAgIHRoaXMuX19pbnB1dF90ZXh0U2hhZG93ID0gJzAgMXB4IDFweCAnO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7IC8vIG9uIGVudGVyXG4gICAgICAgIG9uQmx1ci5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG5cbiAgICBkb20uYmluZCh0aGlzLl9fc2VsZWN0b3IsICdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgIGRvbVxuICAgICAgICAuYWRkQ2xhc3ModGhpcywgJ2RyYWcnKVxuICAgICAgICAuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3NlbGVjdG9yLCAnZHJhZycpO1xuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG4gICAgdmFyIHZhbHVlX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19zZWxlY3Rvci5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMjJweCcsXG4gICAgICBoZWlnaHQ6ICcxMDJweCcsXG4gICAgICBwYWRkaW5nOiAnM3B4JyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJyMyMjInLFxuICAgICAgYm94U2hhZG93OiAnMHB4IDFweCAzcHggcmdiYSgwLDAsMCwwLjMpJ1xuICAgIH0pO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fZmllbGRfa25vYi5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogJzEycHgnLFxuICAgICAgaGVpZ2h0OiAnMTJweCcsXG4gICAgICBib3JkZXI6IHRoaXMuX19maWVsZF9rbm9iX2JvcmRlciArICh0aGlzLl9fY29sb3IudiA8IC41ID8gJyNmZmYnIDogJyMwMDAnKSxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC41KScsXG4gICAgICBib3JkZXJSYWRpdXM6ICcxMnB4JyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIFxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2h1ZV9rbm9iLnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHdpZHRoOiAnMTVweCcsXG4gICAgICBoZWlnaHQ6ICcycHgnLFxuICAgICAgYm9yZGVyUmlnaHQ6ICc0cHggc29saWQgI2ZmZicsXG4gICAgICB6SW5kZXg6IDFcbiAgICB9KTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTAwcHgnLFxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgbWFyZ2luUmlnaHQ6ICczcHgnLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgIH0pO1xuXG4gICAgY29tbW9uLmV4dGVuZCh2YWx1ZV9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgYmFja2dyb3VuZDogJ25vbmUnXG4gICAgfSk7XG4gICAgXG4gICAgbGluZWFyR3JhZGllbnQodmFsdWVfZmllbGQsICd0b3AnLCAncmdiYSgwLDAsMCwwKScsICcjMDAwJyk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19odWVfZmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTVweCcsXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjNTU1JyxcbiAgICAgIGN1cnNvcjogJ25zLXJlc2l6ZSdcbiAgICB9KTtcblxuICAgIGh1ZUdyYWRpZW50KHRoaXMuX19odWVfZmllbGQpO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9faW5wdXQuc3R5bGUsIHtcbiAgICAgIG91dGxpbmU6ICdub25lJyxcbi8vICAgICAgd2lkdGg6ICcxMjBweCcsXG4gICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuLy8gICAgICBwYWRkaW5nOiAnNHB4Jyxcbi8vICAgICAgbWFyZ2luQm90dG9tOiAnNnB4JyxcbiAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICBib3JkZXI6IDAsXG4gICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICB0ZXh0U2hhZG93OiB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKDAsMCwwLDAuNyknXG4gICAgfSk7XG5cbiAgICBkb20uYmluZCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQodGhpcy5fX2ZpZWxkX2tub2IsICdtb3VzZWRvd24nLCBmaWVsZERvd24pO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX2h1ZV9maWVsZCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHNldEgoZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCB1bmJpbmRIKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZpZWxkRG93bihlKSB7XG4gICAgICBzZXRTVihlKTtcbiAgICAgIC8vIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ25vbmUnO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0U1YpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIHVuYmluZFNWKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmJpbmRTVigpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0U1YpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgdW5iaW5kU1YpO1xuICAgICAgLy8gZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgdmFyIGkgPSBpbnRlcnByZXQodGhpcy52YWx1ZSk7XG4gICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcbiAgICAgICAgX3RoaXMuX19jb2xvci5fX3N0YXRlID0gaTtcbiAgICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IF90aGlzLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmJpbmRIKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIHVuYmluZEgpO1xuICAgIH1cblxuICAgIHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLmFwcGVuZENoaWxkKHZhbHVlX2ZpZWxkKTtcbiAgICB0aGlzLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQodGhpcy5fX2ZpZWxkX2tub2IpO1xuICAgIHRoaXMuX19zZWxlY3Rvci5hcHBlbmRDaGlsZCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCk7XG4gICAgdGhpcy5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKHRoaXMuX19odWVfZmllbGQpO1xuICAgIHRoaXMuX19odWVfZmllbGQuYXBwZW5kQ2hpbGQodGhpcy5fX2h1ZV9rbm9iKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9faW5wdXQpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fc2VsZWN0b3IpO1xuXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICBmdW5jdGlvbiBzZXRTVihlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIHcgPSBkb20uZ2V0V2lkdGgoX3RoaXMuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICAgIHZhciBvID0gZG9tLmdldE9mZnNldChfdGhpcy5fX3NhdHVyYXRpb25fZmllbGQpO1xuICAgICAgdmFyIHMgPSAoZS5jbGllbnRYIC0gby5sZWZ0ICsgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KSAvIHc7XG4gICAgICB2YXIgdiA9IDEgLSAoZS5jbGllbnRZIC0gby50b3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCkgLyB3O1xuXG4gICAgICBpZiAodiA+IDEpIHYgPSAxO1xuICAgICAgZWxzZSBpZiAodiA8IDApIHYgPSAwO1xuXG4gICAgICBpZiAocyA+IDEpIHMgPSAxO1xuICAgICAgZWxzZSBpZiAocyA8IDApIHMgPSAwO1xuXG4gICAgICBfdGhpcy5fX2NvbG9yLnYgPSB2O1xuICAgICAgX3RoaXMuX19jb2xvci5zID0gcztcblxuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuXG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEgoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBzID0gZG9tLmdldEhlaWdodChfdGhpcy5fX2h1ZV9maWVsZCk7XG4gICAgICB2YXIgbyA9IGRvbS5nZXRPZmZzZXQoX3RoaXMuX19odWVfZmllbGQpO1xuICAgICAgdmFyIGggPSAxIC0gKGUuY2xpZW50WSAtIG8udG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApIC8gcztcblxuICAgICAgaWYgKGggPiAxKSBoID0gMTtcbiAgICAgIGVsc2UgaWYgKGggPCAwKSBoID0gMDtcblxuICAgICAgX3RoaXMuX19jb2xvci5oID0gaCAqIDM2MDtcblxuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgfTtcblxuICBDb2xvckNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgQ29sb3JDb250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLmdldFZhbHVlKCkpO1xuXG4gICAgICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgIHZhciBtaXNtYXRjaCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgbWlzbWF0Y2ggb24gdGhlIGludGVycHJldGVkIHZhbHVlLlxuXG4gICAgICAgICAgICBjb21tb24uZWFjaChDb2xvci5DT01QT05FTlRTLCBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgaWYgKCFjb21tb24uaXNVbmRlZmluZWQoaVtjb21wb25lbnRdKSAmJlxuICAgICAgICAgICAgICAgICAgIWNvbW1vbi5pc1VuZGVmaW5lZCh0aGlzLl9fY29sb3IuX19zdGF0ZVtjb21wb25lbnRdKSAmJlxuICAgICAgICAgICAgICAgICAgaVtjb21wb25lbnRdICE9PSB0aGlzLl9fY29sb3IuX19zdGF0ZVtjb21wb25lbnRdKSB7XG4gICAgICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTsgLy8gYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIC8vIElmIG5vdGhpbmcgZGl2ZXJnZXMsIHdlIGtlZXAgb3VyIHByZXZpb3VzIHZhbHVlc1xuICAgICAgICAgICAgLy8gZm9yIHN0YXRlZnVsbmVzcywgb3RoZXJ3aXNlIHdlIHJlY2FsY3VsYXRlIGZyZXNoXG4gICAgICAgICAgICBpZiAobWlzbWF0Y2gpIHtcbiAgICAgICAgICAgICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fY29sb3IuX19zdGF0ZSwgaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb21tb24uZXh0ZW5kKHRoaXMuX190ZW1wLl9fc3RhdGUsIHRoaXMuX19jb2xvci5fX3N0YXRlKTtcblxuICAgICAgICAgIHRoaXMuX190ZW1wLmEgPSAxO1xuXG4gICAgICAgICAgdmFyIGZsaXAgPSAodGhpcy5fX2NvbG9yLnYgPCAuNSB8fCB0aGlzLl9fY29sb3IucyA+IC41KSA/IDI1NSA6IDA7XG4gICAgICAgICAgdmFyIF9mbGlwID0gMjU1IC0gZmxpcDtcblxuICAgICAgICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IDEwMCAqIHRoaXMuX19jb2xvci5zIC0gNyArICdweCcsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDEwMCAqICgxIC0gdGhpcy5fX2NvbG9yLnYpIC0gNyArICdweCcsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX190ZW1wLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBib3JkZXI6IHRoaXMuX19maWVsZF9rbm9iX2JvcmRlciArICdyZ2IoJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJywnICsgZmxpcCArJyknXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLl9faHVlX2tub2Iuc3R5bGUubWFyZ2luVG9wID0gKDEgLSB0aGlzLl9fY29sb3IuaCAvIDM2MCkgKiAxMDAgKyAncHgnXG5cbiAgICAgICAgICB0aGlzLl9fdGVtcC5zID0gMTtcbiAgICAgICAgICB0aGlzLl9fdGVtcC52ID0gMTtcblxuICAgICAgICAgIGxpbmVhckdyYWRpZW50KHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbGVmdCcsICcjZmZmJywgdGhpcy5fX3RlbXAudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19pbnB1dC5zdHlsZSwge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLl9fY29sb3IudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGNvbG9yOiAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKycpJyxcbiAgICAgICAgICAgIHRleHRTaGFkb3c6IHRoaXMuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKyAnLCcgKyBfZmxpcCArJywuNyknXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcbiAgXG4gIHZhciB2ZW5kb3JzID0gWyctbW96LScsJy1vLScsJy13ZWJraXQtJywnLW1zLScsJyddO1xuICBcbiAgZnVuY3Rpb24gbGluZWFyR3JhZGllbnQoZWxlbSwgeCwgYSwgYikge1xuICAgIGVsZW0uc3R5bGUuYmFja2dyb3VuZCA9ICcnO1xuICAgIGNvbW1vbi5lYWNoKHZlbmRvcnMsIGZ1bmN0aW9uKHZlbmRvcikge1xuICAgICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAnICsgdmVuZG9yICsgJ2xpbmVhci1ncmFkaWVudCgnK3grJywgJythKycgMCUsICcgKyBiICsgJyAxMDAlKTsgJztcbiAgICB9KTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gaHVlR3JhZGllbnQoZWxlbSkge1xuICAgIGVsZW0uc3R5bGUuYmFja2dyb3VuZCA9ICcnO1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW1vei1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwgI2ZmMDBmZiAxNyUsICMwMDAwZmYgMzQlLCAjMDBmZmZmIDUwJSwgIzAwZmYwMCA2NyUsICNmZmZmMDAgODQlLCAjZmYwMDAwIDEwMCUpOydcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnXG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOydcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1tcy1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOydcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7J1xuICB9XG5cblxuICByZXR1cm4gQ29sb3JDb250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LmNvbG9yLkNvbG9yID0gKGZ1bmN0aW9uIChpbnRlcnByZXQsIG1hdGgsIHRvU3RyaW5nLCBjb21tb24pIHtcblxuICB2YXIgQ29sb3IgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuX19zdGF0ZSA9IGludGVycHJldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93ICdGYWlsZWQgdG8gaW50ZXJwcmV0IGNvbG9yIGFyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgdGhpcy5fX3N0YXRlLmEgPSB0aGlzLl9fc3RhdGUuYSB8fCAxO1xuXG5cbiAgfTtcblxuICBDb2xvci5DT01QT05FTlRTID0gWydyJywnZycsJ2InLCdoJywncycsJ3YnLCdoZXgnLCdhJ107XG5cbiAgY29tbW9uLmV4dGVuZChDb2xvci5wcm90b3R5cGUsIHtcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9PcmlnaW5hbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmNvbnZlcnNpb24ud3JpdGUodGhpcyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdyJywgMik7XG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdnJywgMSk7XG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdiJywgMCk7XG5cbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2gnKTtcbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3MnKTtcbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3YnKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnYScsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmE7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5fX3N0YXRlLmEgPSB2O1xuICAgIH1cblxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnaGV4Jywge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKCF0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIRVgnKSB7XG4gICAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSBtYXRoLnJnYl90b19oZXgodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuaGV4O1xuXG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSB2O1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGRlZmluZVJHQkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdSR0InKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnUkdCJykge1xuICAgICAgICAgIHJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICAgICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdSR0InO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lSFNWQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50KSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcblxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnSFNWJylcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgICAgcmVjYWxjdWxhdGVIU1YodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSFNWJykge1xuICAgICAgICAgIHJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIU1YnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVSR0IoY29sb3IsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcblxuICAgIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSEVYJykge1xuXG4gICAgICBjb2xvci5fX3N0YXRlW2NvbXBvbmVudF0gPSBtYXRoLmNvbXBvbmVudF9mcm9tX2hleChjb2xvci5fX3N0YXRlLmhleCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXG4gICAgfSBlbHNlIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xuXG4gICAgICBjb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsIG1hdGguaHN2X3RvX3JnYihjb2xvci5fX3N0YXRlLmgsIGNvbG9yLl9fc3RhdGUucywgY29sb3IuX19zdGF0ZS52KSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aHJvdyAnQ29ycnVwdGVkIGNvbG9yIHN0YXRlJztcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVIU1YoY29sb3IpIHtcblxuICAgIHZhciByZXN1bHQgPSBtYXRoLnJnYl90b19oc3YoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cbiAgICBjb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsXG4gICAgICAgIHtcbiAgICAgICAgICBzOiByZXN1bHQucyxcbiAgICAgICAgICB2OiByZXN1bHQudlxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGlmICghY29tbW9uLmlzTmFOKHJlc3VsdC5oKSkge1xuICAgICAgY29sb3IuX19zdGF0ZS5oID0gcmVzdWx0Lmg7XG4gICAgfSBlbHNlIGlmIChjb21tb24uaXNVbmRlZmluZWQoY29sb3IuX19zdGF0ZS5oKSkge1xuICAgICAgY29sb3IuX19zdGF0ZS5oID0gMDtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBDb2xvcjtcblxufSkoZGF0LmNvbG9yLmludGVycHJldCxcbmRhdC5jb2xvci5tYXRoID0gKGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdG1wQ29tcG9uZW50O1xuXG4gIHJldHVybiB7XG5cbiAgICBoc3ZfdG9fcmdiOiBmdW5jdGlvbihoLCBzLCB2KSB7XG5cbiAgICAgIHZhciBoaSA9IE1hdGguZmxvb3IoaCAvIDYwKSAlIDY7XG5cbiAgICAgIHZhciBmID0gaCAvIDYwIC0gTWF0aC5mbG9vcihoIC8gNjApO1xuICAgICAgdmFyIHAgPSB2ICogKDEuMCAtIHMpO1xuICAgICAgdmFyIHEgPSB2ICogKDEuMCAtIChmICogcykpO1xuICAgICAgdmFyIHQgPSB2ICogKDEuMCAtICgoMS4wIC0gZikgKiBzKSk7XG4gICAgICB2YXIgYyA9IFtcbiAgICAgICAgW3YsIHQsIHBdLFxuICAgICAgICBbcSwgdiwgcF0sXG4gICAgICAgIFtwLCB2LCB0XSxcbiAgICAgICAgW3AsIHEsIHZdLFxuICAgICAgICBbdCwgcCwgdl0sXG4gICAgICAgIFt2LCBwLCBxXVxuICAgICAgXVtoaV07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHI6IGNbMF0gKiAyNTUsXG4gICAgICAgIGc6IGNbMV0gKiAyNTUsXG4gICAgICAgIGI6IGNbMl0gKiAyNTVcbiAgICAgIH07XG5cbiAgICB9LFxuXG4gICAgcmdiX3RvX2hzdjogZnVuY3Rpb24ociwgZywgYikge1xuXG4gICAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICAgICAgaCwgcztcblxuICAgICAgaWYgKG1heCAhPSAwKSB7XG4gICAgICAgIHMgPSBkZWx0YSAvIG1heDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaDogTmFOLFxuICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgdjogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAociA9PSBtYXgpIHtcbiAgICAgICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgICAgIH0gZWxzZSBpZiAoZyA9PSBtYXgpIHtcbiAgICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICAgIH1cbiAgICAgIGggLz0gNjtcbiAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICBoICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGg6IGggKiAzNjAsXG4gICAgICAgIHM6IHMsXG4gICAgICAgIHY6IG1heCAvIDI1NVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmdiX3RvX2hleDogZnVuY3Rpb24ociwgZywgYikge1xuICAgICAgdmFyIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KDAsIDIsIHIpO1xuICAgICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAxLCBnKTtcbiAgICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMCwgYik7XG4gICAgICByZXR1cm4gaGV4O1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRfZnJvbV9oZXg6IGZ1bmN0aW9uKGhleCwgY29tcG9uZW50SW5kZXgpIHtcbiAgICAgIHJldHVybiAoaGV4ID4+IChjb21wb25lbnRJbmRleCAqIDgpKSAmIDB4RkY7XG4gICAgfSxcblxuICAgIGhleF93aXRoX2NvbXBvbmVudDogZnVuY3Rpb24oaGV4LCBjb21wb25lbnRJbmRleCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PCAodG1wQ29tcG9uZW50ID0gY29tcG9uZW50SW5kZXggKiA4KSB8IChoZXggJiB+ICgweEZGIDw8IHRtcENvbXBvbmVudCkpO1xuICAgIH1cblxuICB9XG5cbn0pKCksXG5kYXQuY29sb3IudG9TdHJpbmcsXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC5jb2xvci5pbnRlcnByZXQsXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiByZXF1aXJlanMgdmVyc2lvbiBvZiBQYXVsIElyaXNoJ3MgUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAqIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4gICAqL1xuXG4gIHJldHVybiB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICBmdW5jdGlvbihjYWxsYmFjaywgZWxlbWVudCkge1xuXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuXG4gICAgICB9O1xufSkoKSxcbmRhdC5kb20uQ2VudGVyZWREaXYgPSAoZnVuY3Rpb24gKGRvbSwgY29tbW9uKSB7XG5cblxuICB2YXIgQ2VudGVyZWREaXYgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgekluZGV4OiAnMTAwMCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJ29wYWNpdHkgMC4ycyBsaW5lYXInXG4gICAgfSk7XG5cbiAgICBkb20ubWFrZUZ1bGxzY3JlZW4odGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuZG9tRWxlbWVudC5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICB6SW5kZXg6ICcxMDAxJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnLXdlYmtpdC10cmFuc2Zvcm0gMC4ycyBlYXNlLW91dCwgb3BhY2l0eSAwLjJzIGxpbmVhcidcbiAgICB9KTtcblxuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmJhY2tncm91bmRFbGVtZW50KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGRvbS5iaW5kKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQsICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMuaGlkZSgpO1xuICAgIH0pO1xuXG5cbiAgfTtcblxuICBDZW50ZXJlZERpdi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBcblxuXG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4vLyAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUudG9wID0gJzUyJSc7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxLjEpJztcblxuICAgIHRoaXMubGF5b3V0KCk7XG5cbiAgICBjb21tb24uZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICBfdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgfSk7XG5cbiAgfTtcblxuICBDZW50ZXJlZERpdi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBoaWRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCBoaWRlKTtcbiAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ29UcmFuc2l0aW9uRW5kJywgaGlkZSk7XG5cbiAgICB9O1xuXG4gICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCBoaWRlKTtcbiAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICdvVHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbi8vICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSAnNDglJztcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxLjEpJztcblxuICB9O1xuXG4gIENlbnRlcmVkRGl2LnByb3RvdHlwZS5sYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUubGVmdCA9IHdpbmRvdy5pbm5lcldpZHRoLzIgLSBkb20uZ2V0V2lkdGgodGhpcy5kb21FbGVtZW50KSAvIDIgKyAncHgnO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSB3aW5kb3cuaW5uZXJIZWlnaHQvMiAtIGRvbS5nZXRIZWlnaHQodGhpcy5kb21FbGVtZW50KSAvIDIgKyAncHgnO1xuICB9O1xuICBcbiAgZnVuY3Rpb24gbG9ja1Njcm9sbChlKSB7XG4gICAgY29uc29sZS5sb2coZSk7XG4gIH1cblxuICByZXR1cm4gQ2VudGVyZWREaXY7XG5cbn0pKGRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pOyIsIi8qISBAbGljZW5zZSBGaXJlYmFzZSB2Mi4yLjAgLSBMaWNlbnNlOiBodHRwczovL3d3dy5maXJlYmFzZS5jb20vdGVybXMvdGVybXMtb2Ytc2VydmljZS5odG1sICovIChmdW5jdGlvbigpIHt2YXIgaCxhYT10aGlzO2Z1bmN0aW9uIG0oYSl7cmV0dXJuIHZvaWQgMCE9PWF9ZnVuY3Rpb24gYmEoKXt9ZnVuY3Rpb24gY2EoYSl7YS5PYj1mdW5jdGlvbigpe3JldHVybiBhLmtmP2Eua2Y6YS5rZj1uZXcgYX19XG5mdW5jdGlvbiBkYShhKXt2YXIgYj10eXBlb2YgYTtpZihcIm9iamVjdFwiPT1iKWlmKGEpe2lmKGEgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm5cImFycmF5XCI7aWYoYSBpbnN0YW5jZW9mIE9iamVjdClyZXR1cm4gYjt2YXIgYz1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk7aWYoXCJbb2JqZWN0IFdpbmRvd11cIj09YylyZXR1cm5cIm9iamVjdFwiO2lmKFwiW29iamVjdCBBcnJheV1cIj09Y3x8XCJudW1iZXJcIj09dHlwZW9mIGEubGVuZ3RoJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5zcGxpY2UmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcInNwbGljZVwiKSlyZXR1cm5cImFycmF5XCI7aWYoXCJbb2JqZWN0IEZ1bmN0aW9uXVwiPT1jfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5jYWxsJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSYmIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJjYWxsXCIpKXJldHVyblwiZnVuY3Rpb25cIn1lbHNlIHJldHVyblwibnVsbFwiO1xuZWxzZSBpZihcImZ1bmN0aW9uXCI9PWImJlwidW5kZWZpbmVkXCI9PXR5cGVvZiBhLmNhbGwpcmV0dXJuXCJvYmplY3RcIjtyZXR1cm4gYn1mdW5jdGlvbiBlYShhKXtyZXR1cm5cImFycmF5XCI9PWRhKGEpfWZ1bmN0aW9uIGZhKGEpe3ZhciBiPWRhKGEpO3JldHVyblwiYXJyYXlcIj09Ynx8XCJvYmplY3RcIj09YiYmXCJudW1iZXJcIj09dHlwZW9mIGEubGVuZ3RofWZ1bmN0aW9uIHAoYSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGF9ZnVuY3Rpb24gZ2EoYSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGF9ZnVuY3Rpb24gaGEoYSl7cmV0dXJuXCJmdW5jdGlvblwiPT1kYShhKX1mdW5jdGlvbiBpYShhKXt2YXIgYj10eXBlb2YgYTtyZXR1cm5cIm9iamVjdFwiPT1iJiZudWxsIT1hfHxcImZ1bmN0aW9uXCI9PWJ9ZnVuY3Rpb24gamEoYSxiLGMpe3JldHVybiBhLmNhbGwuYXBwbHkoYS5iaW5kLGFyZ3VtZW50cyl9XG5mdW5jdGlvbiBrYShhLGIsYyl7aWYoIWEpdGhyb3cgRXJyb3IoKTtpZigyPGFyZ3VtZW50cy5sZW5ndGgpe3ZhciBkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO0FycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGMsZCk7cmV0dXJuIGEuYXBwbHkoYixjKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGEuYXBwbHkoYixhcmd1bWVudHMpfX1mdW5jdGlvbiBxKGEsYixjKXtxPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kJiYtMSE9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQudG9TdHJpbmcoKS5pbmRleE9mKFwibmF0aXZlIGNvZGVcIik/amE6a2E7cmV0dXJuIHEuYXBwbHkobnVsbCxhcmd1bWVudHMpfXZhciBsYT1EYXRlLm5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4rbmV3IERhdGV9O1xuZnVuY3Rpb24gbWEoYSxiKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPWIucHJvdG90eXBlO2EuS2c9Yi5wcm90b3R5cGU7YS5wcm90b3R5cGU9bmV3IGM7YS5HZz1mdW5jdGlvbihhLGMsZil7cmV0dXJuIGIucHJvdG90eXBlW2NdLmFwcGx5KGEsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpKX19O2Z1bmN0aW9uIG5hKGEpe2E9U3RyaW5nKGEpO2lmKC9eXFxzKiQvLnRlc3QoYSk/MDovXltcXF0sOnt9XFxzXFx1MjAyOFxcdTIwMjldKiQvLnRlc3QoYS5yZXBsYWNlKC9cXFxcW1wiXFxcXFxcL2JmbnJ0dV0vZyxcIkBcIikucmVwbGFjZSgvXCJbXlwiXFxcXFxcblxcclxcdTIwMjhcXHUyMDI5XFx4MDAtXFx4MDhcXHgwYS1cXHgxZl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csXCJdXCIpLnJlcGxhY2UoLyg/Ol58OnwsKSg/OltcXHNcXHUyMDI4XFx1MjAyOV0qXFxbKSsvZyxcIlwiKSkpdHJ5e3JldHVybiBldmFsKFwiKFwiK2ErXCIpXCIpfWNhdGNoKGIpe310aHJvdyBFcnJvcihcIkludmFsaWQgSlNPTiBzdHJpbmc6IFwiK2EpO31mdW5jdGlvbiBvYSgpe3RoaXMuTWQ9dm9pZCAwfVxuZnVuY3Rpb24gcGEoYSxiLGMpe3N3aXRjaCh0eXBlb2YgYil7Y2FzZSBcInN0cmluZ1wiOnFhKGIsYyk7YnJlYWs7Y2FzZSBcIm51bWJlclwiOmMucHVzaChpc0Zpbml0ZShiKSYmIWlzTmFOKGIpP2I6XCJudWxsXCIpO2JyZWFrO2Nhc2UgXCJib29sZWFuXCI6Yy5wdXNoKGIpO2JyZWFrO2Nhc2UgXCJ1bmRlZmluZWRcIjpjLnB1c2goXCJudWxsXCIpO2JyZWFrO2Nhc2UgXCJvYmplY3RcIjppZihudWxsPT1iKXtjLnB1c2goXCJudWxsXCIpO2JyZWFrfWlmKGVhKGIpKXt2YXIgZD1iLmxlbmd0aDtjLnB1c2goXCJbXCIpO2Zvcih2YXIgZT1cIlwiLGY9MDtmPGQ7ZisrKWMucHVzaChlKSxlPWJbZl0scGEoYSxhLk1kP2EuTWQuY2FsbChiLFN0cmluZyhmKSxlKTplLGMpLGU9XCIsXCI7Yy5wdXNoKFwiXVwiKTticmVha31jLnB1c2goXCJ7XCIpO2Q9XCJcIjtmb3IoZiBpbiBiKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLGYpJiYoZT1iW2ZdLFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJihjLnB1c2goZCkscWEoZixjKSxcbmMucHVzaChcIjpcIikscGEoYSxhLk1kP2EuTWQuY2FsbChiLGYsZSk6ZSxjKSxkPVwiLFwiKSk7Yy5wdXNoKFwifVwiKTticmVhaztjYXNlIFwiZnVuY3Rpb25cIjpicmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIit0eXBlb2YgYik7fX12YXIgcmE9eydcIic6J1xcXFxcIicsXCJcXFxcXCI6XCJcXFxcXFxcXFwiLFwiL1wiOlwiXFxcXC9cIixcIlxcYlwiOlwiXFxcXGJcIixcIlxcZlwiOlwiXFxcXGZcIixcIlxcblwiOlwiXFxcXG5cIixcIlxcclwiOlwiXFxcXHJcIixcIlxcdFwiOlwiXFxcXHRcIixcIlxceDBCXCI6XCJcXFxcdTAwMGJcIn0sc2E9L1xcdWZmZmYvLnRlc3QoXCJcXHVmZmZmXCIpPy9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxcdWZmZmZdL2c6L1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4ZmZdL2c7XG5mdW5jdGlvbiBxYShhLGIpe2IucHVzaCgnXCInLGEucmVwbGFjZShzYSxmdW5jdGlvbihhKXtpZihhIGluIHJhKXJldHVybiByYVthXTt2YXIgYj1hLmNoYXJDb2RlQXQoMCksZT1cIlxcXFx1XCI7MTY+Yj9lKz1cIjAwMFwiOjI1Nj5iP2UrPVwiMDBcIjo0MDk2PmImJihlKz1cIjBcIik7cmV0dXJuIHJhW2FdPWUrYi50b1N0cmluZygxNil9KSwnXCInKX07ZnVuY3Rpb24gdGEoYSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBKU09OJiZtKEpTT04ucGFyc2UpP0pTT04ucGFyc2UoYSk6bmEoYSl9ZnVuY3Rpb24gcihhKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIEpTT04mJm0oSlNPTi5zdHJpbmdpZnkpKWE9SlNPTi5zdHJpbmdpZnkoYSk7ZWxzZXt2YXIgYj1bXTtwYShuZXcgb2EsYSxiKTthPWIuam9pbihcIlwiKX1yZXR1cm4gYX07ZnVuY3Rpb24gcyhhLGIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxiKX1mdW5jdGlvbiB0KGEsYil7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsYikpcmV0dXJuIGFbYl19ZnVuY3Rpb24gdWEoYSxiKXtmb3IodmFyIGMgaW4gYSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxjKSYmYihjLGFbY10pfWZ1bmN0aW9uIHZhKGEpe3ZhciBiPXt9O3VhKGEsZnVuY3Rpb24oYSxkKXtiW2FdPWR9KTtyZXR1cm4gYn07ZnVuY3Rpb24gd2EoYSl7dGhpcy52Yz1hO3RoaXMuSmQ9XCJmaXJlYmFzZTpcIn1oPXdhLnByb3RvdHlwZTtoLnNldD1mdW5jdGlvbihhLGIpe251bGw9PWI/dGhpcy52Yy5yZW1vdmVJdGVtKHRoaXMuSmQrYSk6dGhpcy52Yy5zZXRJdGVtKHRoaXMuSmQrYSxyKGIpKX07aC5nZXQ9ZnVuY3Rpb24oYSl7YT10aGlzLnZjLmdldEl0ZW0odGhpcy5KZCthKTtyZXR1cm4gbnVsbD09YT9udWxsOnRhKGEpfTtoLnJlbW92ZT1mdW5jdGlvbihhKXt0aGlzLnZjLnJlbW92ZUl0ZW0odGhpcy5KZCthKX07aC5sZj0hMTtoLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmMudG9TdHJpbmcoKX07ZnVuY3Rpb24geGEoKXt0aGlzLnBjPXt9fXhhLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXtudWxsPT1iP2RlbGV0ZSB0aGlzLnBjW2FdOnRoaXMucGNbYV09Yn07eGEucHJvdG90eXBlLmdldD1mdW5jdGlvbihhKXtyZXR1cm4gcyh0aGlzLnBjLGEpP3RoaXMucGNbYV06bnVsbH07eGEucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbihhKXtkZWxldGUgdGhpcy5wY1thXX07eGEucHJvdG90eXBlLmxmPSEwO2Z1bmN0aW9uIHlhKGEpe3RyeXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdyYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3dbYV0pe3ZhciBiPXdpbmRvd1thXTtiLnNldEl0ZW0oXCJmaXJlYmFzZTpzZW50aW5lbFwiLFwiY2FjaGVcIik7Yi5yZW1vdmVJdGVtKFwiZmlyZWJhc2U6c2VudGluZWxcIik7cmV0dXJuIG5ldyB3YShiKX19Y2F0Y2goYyl7fXJldHVybiBuZXcgeGF9dmFyIHphPXlhKFwibG9jYWxTdG9yYWdlXCIpLHY9eWEoXCJzZXNzaW9uU3RvcmFnZVwiKTtmdW5jdGlvbiBBYShhLGIsYyxkLGUpe3RoaXMuaG9zdD1hLnRvTG93ZXJDYXNlKCk7dGhpcy5kb21haW49dGhpcy5ob3N0LnN1YnN0cih0aGlzLmhvc3QuaW5kZXhPZihcIi5cIikrMSk7dGhpcy5CYj1iO3RoaXMudWI9Yzt0aGlzLkVnPWQ7dGhpcy5JZD1lfHxcIlwiO3RoaXMuTWE9emEuZ2V0KFwiaG9zdDpcIithKXx8dGhpcy5ob3N0fWZ1bmN0aW9uIEJhKGEsYil7YiE9PWEuTWEmJihhLk1hPWIsXCJzLVwiPT09YS5NYS5zdWJzdHIoMCwyKSYmemEuc2V0KFwiaG9zdDpcIithLmhvc3QsYS5NYSkpfUFhLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPSh0aGlzLkJiP1wiaHR0cHM6Ly9cIjpcImh0dHA6Ly9cIikrdGhpcy5ob3N0O3RoaXMuSWQmJihhKz1cIjxcIit0aGlzLklkK1wiPlwiKTtyZXR1cm4gYX07ZnVuY3Rpb24gQ2EoKXt0aGlzLlNhPS0xfTtmdW5jdGlvbiBEYSgpe3RoaXMuU2E9LTE7dGhpcy5TYT02NDt0aGlzLlI9W107dGhpcy5nZT1bXTt0aGlzLkVmPVtdO3RoaXMuRmQ9W107dGhpcy5GZFswXT0xMjg7Zm9yKHZhciBhPTE7YTx0aGlzLlNhOysrYSl0aGlzLkZkW2FdPTA7dGhpcy5ZZD10aGlzLlRiPTA7dGhpcy5yZXNldCgpfW1hKERhLENhKTtEYS5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLlJbMF09MTczMjU4NDE5Mzt0aGlzLlJbMV09NDAyMzIzMzQxNzt0aGlzLlJbMl09MjU2MjM4MzEwMjt0aGlzLlJbM109MjcxNzMzODc4O3RoaXMuUls0XT0zMjg1Mzc3NTIwO3RoaXMuWWQ9dGhpcy5UYj0wfTtcbmZ1bmN0aW9uIEVhKGEsYixjKXtjfHwoYz0wKTt2YXIgZD1hLkVmO2lmKHAoYikpZm9yKHZhciBlPTA7MTY+ZTtlKyspZFtlXT1iLmNoYXJDb2RlQXQoYyk8PDI0fGIuY2hhckNvZGVBdChjKzEpPDwxNnxiLmNoYXJDb2RlQXQoYysyKTw8OHxiLmNoYXJDb2RlQXQoYyszKSxjKz00O2Vsc2UgZm9yKGU9MDsxNj5lO2UrKylkW2VdPWJbY108PDI0fGJbYysxXTw8MTZ8YltjKzJdPDw4fGJbYyszXSxjKz00O2ZvcihlPTE2OzgwPmU7ZSsrKXt2YXIgZj1kW2UtM11eZFtlLThdXmRbZS0xNF1eZFtlLTE2XTtkW2VdPShmPDwxfGY+Pj4zMSkmNDI5NDk2NzI5NX1iPWEuUlswXTtjPWEuUlsxXTtmb3IodmFyIGc9YS5SWzJdLGs9YS5SWzNdLGw9YS5SWzRdLG4sZT0wOzgwPmU7ZSsrKTQwPmU/MjA+ZT8oZj1rXmMmKGdeayksbj0xNTE4NTAwMjQ5KTooZj1jXmdeayxuPTE4NTk3NzUzOTMpOjYwPmU/KGY9YyZnfGsmKGN8Zyksbj0yNDAwOTU5NzA4KTooZj1jXmdeayxuPTMzOTU0Njk3ODIpLGY9KGI8PFxuNXxiPj4+MjcpK2YrbCtuK2RbZV0mNDI5NDk2NzI5NSxsPWssaz1nLGc9KGM8PDMwfGM+Pj4yKSY0Mjk0OTY3Mjk1LGM9YixiPWY7YS5SWzBdPWEuUlswXStiJjQyOTQ5NjcyOTU7YS5SWzFdPWEuUlsxXStjJjQyOTQ5NjcyOTU7YS5SWzJdPWEuUlsyXStnJjQyOTQ5NjcyOTU7YS5SWzNdPWEuUlszXStrJjQyOTQ5NjcyOTU7YS5SWzRdPWEuUls0XStsJjQyOTQ5NjcyOTV9XG5EYS5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEsYil7bShiKXx8KGI9YS5sZW5ndGgpO2Zvcih2YXIgYz1iLXRoaXMuU2EsZD0wLGU9dGhpcy5nZSxmPXRoaXMuVGI7ZDxiOyl7aWYoMD09Zilmb3IoO2Q8PWM7KUVhKHRoaXMsYSxkKSxkKz10aGlzLlNhO2lmKHAoYSkpZm9yKDtkPGI7KXtpZihlW2ZdPWEuY2hhckNvZGVBdChkKSwrK2YsKytkLGY9PXRoaXMuU2Epe0VhKHRoaXMsZSk7Zj0wO2JyZWFrfX1lbHNlIGZvcig7ZDxiOylpZihlW2ZdPWFbZF0sKytmLCsrZCxmPT10aGlzLlNhKXtFYSh0aGlzLGUpO2Y9MDticmVha319dGhpcy5UYj1mO3RoaXMuWWQrPWJ9O2Z1bmN0aW9uIEZhKCl7cmV0dXJuIE1hdGguZmxvb3IoMjE0NzQ4MzY0OCpNYXRoLnJhbmRvbSgpKS50b1N0cmluZygzNikrTWF0aC5hYnMoTWF0aC5mbG9vcigyMTQ3NDgzNjQ4Kk1hdGgucmFuZG9tKCkpXmxhKCkpLnRvU3RyaW5nKDM2KX07dmFyIHc9QXJyYXkucHJvdG90eXBlLEdhPXcuaW5kZXhPZj9mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHcuaW5kZXhPZi5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbD09Yz8wOjA+Yz9NYXRoLm1heCgwLGEubGVuZ3RoK2MpOmM7aWYocChhKSlyZXR1cm4gcChiKSYmMT09Yi5sZW5ndGg/YS5pbmRleE9mKGIsYyk6LTE7Zm9yKDtjPGEubGVuZ3RoO2MrKylpZihjIGluIGEmJmFbY109PT1iKXJldHVybiBjO3JldHVybi0xfSxIYT13LmZvckVhY2g/ZnVuY3Rpb24oYSxiLGMpe3cuZm9yRWFjaC5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPXAoYSk/YS5zcGxpdChcIlwiKTphLGY9MDtmPGQ7ZisrKWYgaW4gZSYmYi5jYWxsKGMsZVtmXSxmLGEpfSxJYT13LmZpbHRlcj9mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHcuZmlsdGVyLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9W10sZj0wLGc9cChhKT9cbmEuc3BsaXQoXCJcIik6YSxrPTA7azxkO2srKylpZihrIGluIGcpe3ZhciBsPWdba107Yi5jYWxsKGMsbCxrLGEpJiYoZVtmKytdPWwpfXJldHVybiBlfSxKYT13Lm1hcD9mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHcubWFwLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9QXJyYXkoZCksZj1wKGEpP2Euc3BsaXQoXCJcIik6YSxnPTA7ZzxkO2crKylnIGluIGYmJihlW2ddPWIuY2FsbChjLGZbZ10sZyxhKSk7cmV0dXJuIGV9LEthPXcucmVkdWNlP2Z1bmN0aW9uKGEsYixjLGQpe2QmJihiPXEoYixkKSk7cmV0dXJuIHcucmVkdWNlLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1jO0hhKGEsZnVuY3Rpb24oYyxnKXtlPWIuY2FsbChkLGUsYyxnLGEpfSk7cmV0dXJuIGV9LExhPXcuZXZlcnk/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB3LmV2ZXJ5LmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9XG5wKGEpP2Euc3BsaXQoXCJcIik6YSxmPTA7ZjxkO2YrKylpZihmIGluIGUmJiFiLmNhbGwoYyxlW2ZdLGYsYSkpcmV0dXJuITE7cmV0dXJuITB9O2Z1bmN0aW9uIE1hKGEsYil7dmFyIGM9TmEoYSxiLHZvaWQgMCk7cmV0dXJuIDA+Yz9udWxsOnAoYSk/YS5jaGFyQXQoYyk6YVtjXX1mdW5jdGlvbiBOYShhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9cChhKT9hLnNwbGl0KFwiXCIpOmEsZj0wO2Y8ZDtmKyspaWYoZiBpbiBlJiZiLmNhbGwoYyxlW2ZdLGYsYSkpcmV0dXJuIGY7cmV0dXJuLTF9ZnVuY3Rpb24gT2EoYSxiKXt2YXIgYz1HYShhLGIpOzA8PWMmJncuc3BsaWNlLmNhbGwoYSxjLDEpfWZ1bmN0aW9uIFBhKGEsYixjKXtyZXR1cm4gMj49YXJndW1lbnRzLmxlbmd0aD93LnNsaWNlLmNhbGwoYSxiKTp3LnNsaWNlLmNhbGwoYSxiLGMpfWZ1bmN0aW9uIFFhKGEsYil7YS5zb3J0KGJ8fFJhKX1mdW5jdGlvbiBSYShhLGIpe3JldHVybiBhPmI/MTphPGI/LTE6MH07dmFyIFNhO2E6e3ZhciBUYT1hYS5uYXZpZ2F0b3I7aWYoVGEpe3ZhciBVYT1UYS51c2VyQWdlbnQ7aWYoVWEpe1NhPVVhO2JyZWFrIGF9fVNhPVwiXCJ9ZnVuY3Rpb24gVmEoYSl7cmV0dXJuLTEhPVNhLmluZGV4T2YoYSl9O3ZhciBXYT1WYShcIk9wZXJhXCIpfHxWYShcIk9QUlwiKSxYYT1WYShcIlRyaWRlbnRcIil8fFZhKFwiTVNJRVwiKSxZYT1WYShcIkdlY2tvXCIpJiYtMT09U2EudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwid2Via2l0XCIpJiYhKFZhKFwiVHJpZGVudFwiKXx8VmEoXCJNU0lFXCIpKSxaYT0tMSE9U2EudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwid2Via2l0XCIpOyhmdW5jdGlvbigpe3ZhciBhPVwiXCIsYjtpZihXYSYmYWEub3BlcmEpcmV0dXJuIGE9YWEub3BlcmEudmVyc2lvbixoYShhKT9hKCk6YTtZYT9iPS9ydlxcOihbXlxcKTtdKykoXFwpfDspLzpYYT9iPS9cXGIoPzpNU0lFfHJ2KVs6IF0oW15cXCk7XSspKFxcKXw7KS86WmEmJihiPS9XZWJLaXRcXC8oXFxTKykvKTtiJiYoYT0oYT1iLmV4ZWMoU2EpKT9hWzFdOlwiXCIpO3JldHVybiBYYSYmKGI9KGI9YWEuZG9jdW1lbnQpP2IuZG9jdW1lbnRNb2RlOnZvaWQgMCxiPnBhcnNlRmxvYXQoYSkpP1N0cmluZyhiKTphfSkoKTt2YXIgJGE9bnVsbCxhYj1udWxsLGJiPW51bGw7ZnVuY3Rpb24gY2IoYSxiKXtpZighZmEoYSkpdGhyb3cgRXJyb3IoXCJlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXJcIik7ZGIoKTtmb3IodmFyIGM9Yj9hYjokYSxkPVtdLGU9MDtlPGEubGVuZ3RoO2UrPTMpe3ZhciBmPWFbZV0sZz1lKzE8YS5sZW5ndGgsaz1nP2FbZSsxXTowLGw9ZSsyPGEubGVuZ3RoLG49bD9hW2UrMl06MCx1PWY+PjIsZj0oZiYzKTw8NHxrPj40LGs9KGsmMTUpPDwyfG4+PjYsbj1uJjYzO2x8fChuPTY0LGd8fChrPTY0KSk7ZC5wdXNoKGNbdV0sY1tmXSxjW2tdLGNbbl0pfXJldHVybiBkLmpvaW4oXCJcIil9XG5mdW5jdGlvbiBkYigpe2lmKCEkYSl7JGE9e307YWI9e307YmI9e307Zm9yKHZhciBhPTA7NjU+YTthKyspJGFbYV09XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLmNoYXJBdChhKSxhYlthXT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8uXCIuY2hhckF0KGEpLGJiW2FiW2FdXT1hfX07dmFyIGViPWZ1bmN0aW9uKCl7dmFyIGE9MTtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYSsrfX0oKTtmdW5jdGlvbiB5KGEsYil7aWYoIWEpdGhyb3cgZmIoYik7fWZ1bmN0aW9uIGZiKGEpe3JldHVybiBFcnJvcihcIkZpcmViYXNlIElOVEVSTkFMIEFTU0VSVCBGQUlMRUQ6XCIrYSl9XG5mdW5jdGlvbiBnYihhKXt0cnl7dmFyIGI7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhdG9iKWI9YXRvYihhKTtlbHNle2RiKCk7Zm9yKHZhciBjPWJiLGQ9W10sZT0wO2U8YS5sZW5ndGg7KXt2YXIgZj1jW2EuY2hhckF0KGUrKyldLGc9ZTxhLmxlbmd0aD9jW2EuY2hhckF0KGUpXTowOysrZTt2YXIgaz1lPGEubGVuZ3RoP2NbYS5jaGFyQXQoZSldOjY0OysrZTt2YXIgbD1lPGEubGVuZ3RoP2NbYS5jaGFyQXQoZSldOjY0OysrZTtpZihudWxsPT1mfHxudWxsPT1nfHxudWxsPT1rfHxudWxsPT1sKXRocm93IEVycm9yKCk7ZC5wdXNoKGY8PDJ8Zz4+NCk7NjQhPWsmJihkLnB1c2goZzw8NCYyNDB8az4+MiksNjQhPWwmJmQucHVzaChrPDw2JjE5MnxsKSl9aWYoODE5Mj5kLmxlbmd0aCliPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxkKTtlbHNle2E9XCJcIjtmb3IoYz0wO2M8ZC5sZW5ndGg7Yys9ODE5MilhKz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsUGEoZCxjLFxuYys4MTkyKSk7Yj1hfX1yZXR1cm4gYn1jYXRjaChuKXtoYihcImJhc2U2NERlY29kZSBmYWlsZWQ6IFwiLG4pfXJldHVybiBudWxsfWZ1bmN0aW9uIGliKGEpe3ZhciBiPWpiKGEpO2E9bmV3IERhO2EudXBkYXRlKGIpO3ZhciBiPVtdLGM9OCphLllkOzU2PmEuVGI/YS51cGRhdGUoYS5GZCw1Ni1hLlRiKTphLnVwZGF0ZShhLkZkLGEuU2EtKGEuVGItNTYpKTtmb3IodmFyIGQ9YS5TYS0xOzU2PD1kO2QtLSlhLmdlW2RdPWMmMjU1LGMvPTI1NjtFYShhLGEuZ2UpO2ZvcihkPWM9MDs1PmQ7ZCsrKWZvcih2YXIgZT0yNDswPD1lO2UtPTgpYltjXT1hLlJbZF0+PmUmMjU1LCsrYztyZXR1cm4gY2IoYil9XG5mdW5jdGlvbiBrYihhKXtmb3IodmFyIGI9XCJcIixjPTA7Yzxhcmd1bWVudHMubGVuZ3RoO2MrKyliPWZhKGFyZ3VtZW50c1tjXSk/YitrYi5hcHBseShudWxsLGFyZ3VtZW50c1tjXSk6XCJvYmplY3RcIj09PXR5cGVvZiBhcmd1bWVudHNbY10/YityKGFyZ3VtZW50c1tjXSk6Yithcmd1bWVudHNbY10sYis9XCIgXCI7cmV0dXJuIGJ9dmFyIGxiPW51bGwsbWI9ITA7ZnVuY3Rpb24gaGIoYSl7ITA9PT1tYiYmKG1iPSExLG51bGw9PT1sYiYmITA9PT12LmdldChcImxvZ2dpbmdfZW5hYmxlZFwiKSYmbmIoITApKTtpZihsYil7dmFyIGI9a2IuYXBwbHkobnVsbCxhcmd1bWVudHMpO2xiKGIpfX1mdW5jdGlvbiBvYihhKXtyZXR1cm4gZnVuY3Rpb24oKXtoYihhLGFyZ3VtZW50cyl9fVxuZnVuY3Rpb24gcGIoYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlKXt2YXIgYj1cIkZJUkVCQVNFIElOVEVSTkFMIEVSUk9SOiBcIitrYi5hcHBseShudWxsLGFyZ3VtZW50cyk7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlLmVycm9yP2NvbnNvbGUuZXJyb3IoYik6Y29uc29sZS5sb2coYil9fWZ1bmN0aW9uIHFiKGEpe3ZhciBiPWtiLmFwcGx5KG51bGwsYXJndW1lbnRzKTt0aHJvdyBFcnJvcihcIkZJUkVCQVNFIEZBVEFMIEVSUk9SOiBcIitiKTt9ZnVuY3Rpb24geihhKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUpe3ZhciBiPVwiRklSRUJBU0UgV0FSTklORzogXCIra2IuYXBwbHkobnVsbCxhcmd1bWVudHMpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZS53YXJuP2NvbnNvbGUud2FybihiKTpjb25zb2xlLmxvZyhiKX19XG5mdW5jdGlvbiByYihhKXt2YXIgYj1cIlwiLGM9XCJcIixkPVwiXCIsZT1cIlwiLGY9ITAsZz1cImh0dHBzXCIsaz00NDM7aWYocChhKSl7dmFyIGw9YS5pbmRleE9mKFwiLy9cIik7MDw9bCYmKGc9YS5zdWJzdHJpbmcoMCxsLTEpLGE9YS5zdWJzdHJpbmcobCsyKSk7bD1hLmluZGV4T2YoXCIvXCIpOy0xPT09bCYmKGw9YS5sZW5ndGgpO2I9YS5zdWJzdHJpbmcoMCxsKTtlPVwiXCI7YT1hLnN1YnN0cmluZyhsKS5zcGxpdChcIi9cIik7Zm9yKGw9MDtsPGEubGVuZ3RoO2wrKylpZigwPGFbbF0ubGVuZ3RoKXt2YXIgbj1hW2xdO3RyeXtuPWRlY29kZVVSSUNvbXBvbmVudChuLnJlcGxhY2UoL1xcKy9nLFwiIFwiKSl9Y2F0Y2godSl7fWUrPVwiL1wiK259YT1iLnNwbGl0KFwiLlwiKTszPT09YS5sZW5ndGg/KGM9YVsxXSxkPWFbMF0udG9Mb3dlckNhc2UoKSk6Mj09PWEubGVuZ3RoJiYoYz1hWzBdKTtsPWIuaW5kZXhPZihcIjpcIik7MDw9bCYmKGY9XCJodHRwc1wiPT09Z3x8XCJ3c3NcIj09PWcsaz1iLnN1YnN0cmluZyhsKzEpLGlzRmluaXRlKGspJiZcbihrPVN0cmluZyhrKSksaz1wKGspPy9eXFxzKi0/MHgvaS50ZXN0KGspP3BhcnNlSW50KGssMTYpOnBhcnNlSW50KGssMTApOk5hTil9cmV0dXJue2hvc3Q6Yixwb3J0OmssZG9tYWluOmMsQmc6ZCxCYjpmLHNjaGVtZTpnLFBjOmV9fWZ1bmN0aW9uIHNiKGEpe3JldHVybiBnYShhKSYmKGEhPWF8fGE9PU51bWJlci5QT1NJVElWRV9JTkZJTklUWXx8YT09TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKX1cbmZ1bmN0aW9uIHRiKGEpe2lmKFwiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUpYSgpO2Vsc2V7dmFyIGI9ITEsYz1mdW5jdGlvbigpe2RvY3VtZW50LmJvZHk/Ynx8KGI9ITAsYSgpKTpzZXRUaW1lb3V0KGMsTWF0aC5mbG9vcigxMCkpfTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyPyhkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGMsITEpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGMsITEpKTpkb2N1bWVudC5hdHRhY2hFdmVudCYmKGRvY3VtZW50LmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsZnVuY3Rpb24oKXtcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlJiZjKCl9KSx3aW5kb3cuYXR0YWNoRXZlbnQoXCJvbmxvYWRcIixjKSl9fVxuZnVuY3Rpb24gdWIoYSxiKXtpZihhPT09YilyZXR1cm4gMDtpZihcIltNSU5fTkFNRV1cIj09PWF8fFwiW01BWF9OQU1FXVwiPT09YilyZXR1cm4tMTtpZihcIltNSU5fTkFNRV1cIj09PWJ8fFwiW01BWF9OQU1FXVwiPT09YSlyZXR1cm4gMTt2YXIgYz12YihhKSxkPXZiKGIpO3JldHVybiBudWxsIT09Yz9udWxsIT09ZD8wPT1jLWQ/YS5sZW5ndGgtYi5sZW5ndGg6Yy1kOi0xOm51bGwhPT1kPzE6YTxiPy0xOjF9ZnVuY3Rpb24gd2IoYSxiKXtpZihiJiZhIGluIGIpcmV0dXJuIGJbYV07dGhyb3cgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIGtleSAoXCIrYStcIikgaW4gb2JqZWN0OiBcIityKGIpKTt9XG5mdW5jdGlvbiB4YihhKXtpZihcIm9iamVjdFwiIT09dHlwZW9mIGF8fG51bGw9PT1hKXJldHVybiByKGEpO3ZhciBiPVtdLGM7Zm9yKGMgaW4gYSliLnB1c2goYyk7Yi5zb3J0KCk7Yz1cIntcIjtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoO2QrKykwIT09ZCYmKGMrPVwiLFwiKSxjKz1yKGJbZF0pLGMrPVwiOlwiLGMrPXhiKGFbYltkXV0pO3JldHVybiBjK1wifVwifWZ1bmN0aW9uIHliKGEsYil7aWYoYS5sZW5ndGg8PWIpcmV0dXJuW2FdO2Zvcih2YXIgYz1bXSxkPTA7ZDxhLmxlbmd0aDtkKz1iKWQrYj5hP2MucHVzaChhLnN1YnN0cmluZyhkLGEubGVuZ3RoKSk6Yy5wdXNoKGEuc3Vic3RyaW5nKGQsZCtiKSk7cmV0dXJuIGN9ZnVuY3Rpb24gemIoYSxiKXtpZihlYShhKSlmb3IodmFyIGM9MDtjPGEubGVuZ3RoOysrYyliKGMsYVtjXSk7ZWxzZSBBKGEsYil9XG5mdW5jdGlvbiBBYihhKXt5KCFzYihhKSxcIkludmFsaWQgSlNPTiBudW1iZXJcIik7dmFyIGIsYyxkLGU7MD09PWE/KGQ9Yz0wLGI9LUluZmluaXR5PT09MS9hPzE6MCk6KGI9MD5hLGE9TWF0aC5hYnMoYSksYT49TWF0aC5wb3coMiwtMTAyMik/KGQ9TWF0aC5taW4oTWF0aC5mbG9vcihNYXRoLmxvZyhhKS9NYXRoLkxOMiksMTAyMyksYz1kKzEwMjMsZD1NYXRoLnJvdW5kKGEqTWF0aC5wb3coMiw1Mi1kKS1NYXRoLnBvdygyLDUyKSkpOihjPTAsZD1NYXRoLnJvdW5kKGEvTWF0aC5wb3coMiwtMTA3NCkpKSk7ZT1bXTtmb3IoYT01MjthO2EtPTEpZS5wdXNoKGQlMj8xOjApLGQ9TWF0aC5mbG9vcihkLzIpO2ZvcihhPTExO2E7YS09MSllLnB1c2goYyUyPzE6MCksYz1NYXRoLmZsb29yKGMvMik7ZS5wdXNoKGI/MTowKTtlLnJldmVyc2UoKTtiPWUuam9pbihcIlwiKTtjPVwiXCI7Zm9yKGE9MDs2ND5hO2ErPTgpZD1wYXJzZUludChiLnN1YnN0cihhLDgpLDIpLnRvU3RyaW5nKDE2KSwxPT09ZC5sZW5ndGgmJlxuKGQ9XCIwXCIrZCksYys9ZDtyZXR1cm4gYy50b0xvd2VyQ2FzZSgpfXZhciBCYj0vXi0/XFxkezEsMTB9JC87ZnVuY3Rpb24gdmIoYSl7cmV0dXJuIEJiLnRlc3QoYSkmJihhPU51bWJlcihhKSwtMjE0NzQ4MzY0ODw9YSYmMjE0NzQ4MzY0Nz49YSk/YTpudWxsfWZ1bmN0aW9uIENiKGEpe3RyeXthKCl9Y2F0Y2goYil7c2V0VGltZW91dChmdW5jdGlvbigpe3ooXCJFeGNlcHRpb24gd2FzIHRocm93biBieSB1c2VyIGNhbGxiYWNrLlwiLGIuc3RhY2t8fFwiXCIpO3Rocm93IGI7fSxNYXRoLmZsb29yKDApKX19ZnVuY3Rpb24gQihhLGIpe2lmKGhhKGEpKXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkuc2xpY2UoKTtDYihmdW5jdGlvbigpe2EuYXBwbHkobnVsbCxjKX0pfX07ZnVuY3Rpb24gRGIoYSxiLGMsZCl7dGhpcy5wZT1iO3RoaXMuU2Q9Yzt0aGlzLktkPWQ7dGhpcy5rZD1hfURiLnByb3RvdHlwZS5SYj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuU2QuZGMoKTtyZXR1cm5cInZhbHVlXCI9PT10aGlzLmtkP2EucGF0aDphLnBhcmVudCgpLnBhdGh9O0RiLnByb3RvdHlwZS50ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmtkfTtEYi5wcm90b3R5cGUuTWI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wZS5NYih0aGlzKX07RGIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuUmIoKS50b1N0cmluZygpK1wiOlwiK3RoaXMua2QrXCI6XCIrcih0aGlzLlNkLmNmKCkpfTtmdW5jdGlvbiBFYihhLGIsYyl7dGhpcy5wZT1hO3RoaXMuZXJyb3I9Yjt0aGlzLnBhdGg9Y31FYi5wcm90b3R5cGUuUmI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXRofTtFYi5wcm90b3R5cGUudGU9ZnVuY3Rpb24oKXtyZXR1cm5cImNhbmNlbFwifTtcbkViLnByb3RvdHlwZS5NYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBlLk1iKHRoaXMpfTtFYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXRoLnRvU3RyaW5nKCkrXCI6Y2FuY2VsXCJ9O2Z1bmN0aW9uIEMoYSxiLGMsZCl7dGhpcy50eXBlPWE7dGhpcy5IYT1iO3RoaXMuVWE9Yzt0aGlzLkVlPWQ7dGhpcy5LZD12b2lkIDB9ZnVuY3Rpb24gRmIoYSl7cmV0dXJuIG5ldyBDKEdiLGEpfXZhciBHYj1cInZhbHVlXCI7ZnVuY3Rpb24gSGIoYSxiLGMpe3RoaXMuSGI9YTt0aGlzLmxiPWI7dGhpcy5uYj1jfHxudWxsfWg9SGIucHJvdG90eXBlO2gud2Y9ZnVuY3Rpb24oYSl7cmV0dXJuXCJ2YWx1ZVwiPT09YX07aC5jcmVhdGVFdmVudD1mdW5jdGlvbihhLGIpe3ZhciBjPWIubi5nO3JldHVybiBuZXcgRGIoXCJ2YWx1ZVwiLHRoaXMsbmV3IEQoYS5IYSxiLmRjKCksYykpfTtoLk1iPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubmI7aWYoXCJjYW5jZWxcIj09PWEudGUoKSl7eSh0aGlzLmxiLFwiUmFpc2luZyBhIGNhbmNlbCBldmVudCBvbiBhIGxpc3RlbmVyIHdpdGggbm8gY2FuY2VsIGNhbGxiYWNrXCIpO3ZhciBjPXRoaXMubGI7cmV0dXJuIGZ1bmN0aW9uKCl7Yy5jYWxsKGIsYS5lcnJvcil9fXZhciBkPXRoaXMuSGI7cmV0dXJuIGZ1bmN0aW9uKCl7ZC5jYWxsKGIsYS5TZCl9fTtoLlplPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMubGI/bmV3IEViKHRoaXMsYSxiKTpudWxsfTtcbmgubWF0Y2hlcz1mdW5jdGlvbihhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIEhiP2EuSGImJnRoaXMuSGI/YS5IYj09PXRoaXMuSGImJmEubmI9PT10aGlzLm5iOiEwOiExfTtoLmpmPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLkhifTtmdW5jdGlvbiBJYihhLGIsYyl7dGhpcy5lYT1hO3RoaXMubGI9Yjt0aGlzLm5iPWN9aD1JYi5wcm90b3R5cGU7aC53Zj1mdW5jdGlvbihhKXthPVwiY2hpbGRyZW5fYWRkZWRcIj09PWE/XCJjaGlsZF9hZGRlZFwiOmE7cmV0dXJuKFwiY2hpbGRyZW5fcmVtb3ZlZFwiPT09YT9cImNoaWxkX3JlbW92ZWRcIjphKWluIHRoaXMuZWF9O2guWmU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5sYj9uZXcgRWIodGhpcyxhLGIpOm51bGx9O1xuaC5jcmVhdGVFdmVudD1mdW5jdGlvbihhLGIpe3kobnVsbCE9YS5VYSxcIkNoaWxkIGV2ZW50cyBzaG91bGQgaGF2ZSBhIGNoaWxkTmFtZS5cIik7dmFyIGM9Yi5kYygpLnUoYS5VYSk7cmV0dXJuIG5ldyBEYihhLnR5cGUsdGhpcyxuZXcgRChhLkhhLGMsYi5uLmcpLGEuS2QpfTtoLk1iPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubmI7aWYoXCJjYW5jZWxcIj09PWEudGUoKSl7eSh0aGlzLmxiLFwiUmFpc2luZyBhIGNhbmNlbCBldmVudCBvbiBhIGxpc3RlbmVyIHdpdGggbm8gY2FuY2VsIGNhbGxiYWNrXCIpO3ZhciBjPXRoaXMubGI7cmV0dXJuIGZ1bmN0aW9uKCl7Yy5jYWxsKGIsYS5lcnJvcil9fXZhciBkPXRoaXMuZWFbYS5rZF07cmV0dXJuIGZ1bmN0aW9uKCl7ZC5jYWxsKGIsYS5TZCxhLktkKX19O1xuaC5tYXRjaGVzPWZ1bmN0aW9uKGEpe2lmKGEgaW5zdGFuY2VvZiBJYil7aWYoIXRoaXMuZWF8fCFhLmVhKXJldHVybiEwO2lmKHRoaXMubmI9PT1hLm5iKXt2YXIgYj1KYihhLmVhKTtpZihiPT09SmIodGhpcy5lYSkpe2lmKDE9PT1iKXt2YXIgYj1LYihhLmVhKSxjPUtiKHRoaXMuZWEpO3JldHVybiBjPT09YiYmKCFhLmVhW2JdfHwhdGhpcy5lYVtjXXx8YS5lYVtiXT09PXRoaXMuZWFbY10pfXJldHVybiBMYih0aGlzLmVhLGZ1bmN0aW9uKGIsYyl7cmV0dXJuIGEuZWFbY109PT1ifSl9fX1yZXR1cm4hMX07aC5qZj1mdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5lYX07ZnVuY3Rpb24gamIoYSl7Zm9yKHZhciBiPVtdLGM9MCxkPTA7ZDxhLmxlbmd0aDtkKyspe3ZhciBlPWEuY2hhckNvZGVBdChkKTs1NTI5Njw9ZSYmNTYzMTk+PWUmJihlLT01NTI5NixkKysseShkPGEubGVuZ3RoLFwiU3Vycm9nYXRlIHBhaXIgbWlzc2luZyB0cmFpbCBzdXJyb2dhdGUuXCIpLGU9NjU1MzYrKGU8PDEwKSsoYS5jaGFyQ29kZUF0KGQpLTU2MzIwKSk7MTI4PmU/YltjKytdPWU6KDIwNDg+ZT9iW2MrK109ZT4+NnwxOTI6KDY1NTM2PmU/YltjKytdPWU+PjEyfDIyNDooYltjKytdPWU+PjE4fDI0MCxiW2MrK109ZT4+MTImNjN8MTI4KSxiW2MrK109ZT4+NiY2M3wxMjgpLGJbYysrXT1lJjYzfDEyOCl9cmV0dXJuIGJ9O2Z1bmN0aW9uIEUoYSxiLGMsZCl7dmFyIGU7ZDxiP2U9XCJhdCBsZWFzdCBcIitiOmQ+YyYmKGU9MD09PWM/XCJub25lXCI6XCJubyBtb3JlIHRoYW4gXCIrYyk7aWYoZSl0aHJvdyBFcnJvcihhK1wiIGZhaWxlZDogV2FzIGNhbGxlZCB3aXRoIFwiK2QrKDE9PT1kP1wiIGFyZ3VtZW50LlwiOlwiIGFyZ3VtZW50cy5cIikrXCIgRXhwZWN0cyBcIitlK1wiLlwiKTt9ZnVuY3Rpb24gRyhhLGIsYyl7dmFyIGQ9XCJcIjtzd2l0Y2goYil7Y2FzZSAxOmQ9Yz9cImZpcnN0XCI6XCJGaXJzdFwiO2JyZWFrO2Nhc2UgMjpkPWM/XCJzZWNvbmRcIjpcIlNlY29uZFwiO2JyZWFrO2Nhc2UgMzpkPWM/XCJ0aGlyZFwiOlwiVGhpcmRcIjticmVhaztjYXNlIDQ6ZD1jP1wiZm91cnRoXCI6XCJGb3VydGhcIjticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiZXJyb3JQcmVmaXggY2FsbGVkIHdpdGggYXJndW1lbnROdW1iZXIgPiA0LiAgTmVlZCB0byB1cGRhdGUgaXQ/XCIpO31yZXR1cm4gYT1hK1wiIGZhaWxlZDogXCIrKGQrXCIgYXJndW1lbnQgXCIpfVxuZnVuY3Rpb24gSChhLGIsYyxkKXtpZigoIWR8fG0oYykpJiYhaGEoYykpdGhyb3cgRXJyb3IoRyhhLGIsZCkrXCJtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uXCIpO31mdW5jdGlvbiBNYihhLGIsYyl7aWYobShjKSYmKCFpYShjKXx8bnVsbD09PWMpKXRocm93IEVycm9yKEcoYSxiLCEwKStcIm11c3QgYmUgYSB2YWxpZCBjb250ZXh0IG9iamVjdC5cIik7fTt2YXIgTmI9L1tcXFtcXF0uIyRcXC9cXHUwMDAwLVxcdTAwMUZcXHUwMDdGXS8sT2I9L1tcXFtcXF0uIyRcXHUwMDAwLVxcdTAwMUZcXHUwMDdGXS87ZnVuY3Rpb24gUGIoYSl7cmV0dXJuIHAoYSkmJjAhPT1hLmxlbmd0aCYmIU5iLnRlc3QoYSl9ZnVuY3Rpb24gUWIoYSl7cmV0dXJuIG51bGw9PT1hfHxwKGEpfHxnYShhKSYmIXNiKGEpfHxpYShhKSYmcyhhLFwiLnN2XCIpfWZ1bmN0aW9uIFJiKGEsYixjKXtjJiYhbShiKXx8U2IoRyhhLDEsYyksYil9XG5mdW5jdGlvbiBTYihhLGIsYyxkKXtjfHwoYz0wKTt2YXIgZT1kfHxbXTtpZighbShiKSl0aHJvdyBFcnJvcihhK1wiY29udGFpbnMgdW5kZWZpbmVkXCIrVGIoZSkpO2lmKGhhKGIpKXRocm93IEVycm9yKGErXCJjb250YWlucyBhIGZ1bmN0aW9uXCIrVGIoZSkrXCIgd2l0aCBjb250ZW50czogXCIrYi50b1N0cmluZygpKTtpZihzYihiKSl0aHJvdyBFcnJvcihhK1wiY29udGFpbnMgXCIrYi50b1N0cmluZygpK1RiKGUpKTtpZigxRTM8Yyl0aHJvdyBuZXcgVHlwZUVycm9yKGErXCJjb250YWlucyBhIGN5Y2xpYyBvYmplY3QgdmFsdWUgKFwiK2Uuc2xpY2UoMCwxMDApLmpvaW4oXCIuXCIpK1wiLi4uKVwiKTtpZihwKGIpJiZiLmxlbmd0aD4xMDQ4NTc2MC8zJiYxMDQ4NTc2MDxqYihiKS5sZW5ndGgpdGhyb3cgRXJyb3IoYStcImNvbnRhaW5zIGEgc3RyaW5nIGdyZWF0ZXIgdGhhbiAxMDQ4NTc2MCB1dGY4IGJ5dGVzXCIrVGIoZSkrXCIgKCdcIitiLnN1YnN0cmluZygwLDUwKStcIi4uLicpXCIpO2lmKGlhKGIpKXt2YXIgZj1cbiExLGc9ITE7dWEoYixmdW5jdGlvbihiLGQpe2lmKFwiLnZhbHVlXCI9PT1iKWY9ITA7ZWxzZSBpZihcIi5wcmlvcml0eVwiIT09YiYmXCIuc3ZcIiE9PWImJihnPSEwLCFQYihiKSkpdGhyb3cgRXJyb3IoYStcIiBjb250YWlucyBhbiBpbnZhbGlkIGtleSAoXCIrYitcIilcIitUYihlKSsnLiAgS2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzIGFuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCIvXCIsIFwiW1wiLCBvciBcIl1cIicpO2UucHVzaChiKTtTYihhLGQsYysxLGUpO2UucG9wKCl9KTtpZihmJiZnKXRocm93IEVycm9yKGErJyBjb250YWlucyBcIi52YWx1ZVwiIGNoaWxkJytUYihlKStcIiBpbiBhZGRpdGlvbiB0byBhY3R1YWwgY2hpbGRyZW4uXCIpO319ZnVuY3Rpb24gVGIoYSl7cmV0dXJuIDA9PWEubGVuZ3RoP1wiXCI6XCIgaW4gcHJvcGVydHkgJ1wiK2Euam9pbihcIi5cIikrXCInXCJ9XG5mdW5jdGlvbiBVYihhLGIpe2lmKCFpYShiKXx8ZWEoYikpdGhyb3cgRXJyb3IoRyhhLDEsITEpK1wiIG11c3QgYmUgYW4gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNoaWxkcmVuIHRvIHJlcGxhY2UuXCIpO2lmKHMoYixcIi52YWx1ZVwiKSl0aHJvdyBFcnJvcihHKGEsMSwhMSkrJyBtdXN0IG5vdCBjb250YWluIFwiLnZhbHVlXCIuICBUbyBvdmVyd3JpdGUgd2l0aCBhIGxlYWYgdmFsdWUsIGp1c3QgdXNlIC5zZXQoKSBpbnN0ZWFkLicpO1JiKGEsYiwhMSl9XG5mdW5jdGlvbiBWYihhLGIsYyl7aWYoc2IoYykpdGhyb3cgRXJyb3IoRyhhLGIsITEpK1wiaXMgXCIrYy50b1N0cmluZygpK1wiLCBidXQgbXVzdCBiZSBhIHZhbGlkIEZpcmViYXNlIHByaW9yaXR5IChhIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsKS5cIik7aWYoIVFiKGMpKXRocm93IEVycm9yKEcoYSxiLCExKStcIm11c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuXCIpO31cbmZ1bmN0aW9uIFdiKGEsYixjKXtpZighY3x8bShiKSlzd2l0Y2goYil7Y2FzZSBcInZhbHVlXCI6Y2FzZSBcImNoaWxkX2FkZGVkXCI6Y2FzZSBcImNoaWxkX3JlbW92ZWRcIjpjYXNlIFwiY2hpbGRfY2hhbmdlZFwiOmNhc2UgXCJjaGlsZF9tb3ZlZFwiOmJyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoRyhhLDEsYykrJ211c3QgYmUgYSB2YWxpZCBldmVudCB0eXBlOiBcInZhbHVlXCIsIFwiY2hpbGRfYWRkZWRcIiwgXCJjaGlsZF9yZW1vdmVkXCIsIFwiY2hpbGRfY2hhbmdlZFwiLCBvciBcImNoaWxkX21vdmVkXCIuJyk7fX1mdW5jdGlvbiBYYihhLGIsYyxkKXtpZigoIWR8fG0oYykpJiYhUGIoYykpdGhyb3cgRXJyb3IoRyhhLGIsZCkrJ3dhcyBhbiBpbnZhbGlkIGtleTogXCInK2MrJ1wiLiAgRmlyZWJhc2Uga2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzIGFuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCIvXCIsIFwiW1wiLCBvciBcIl1cIikuJyk7fVxuZnVuY3Rpb24gWWIoYSxiKXtpZighcChiKXx8MD09PWIubGVuZ3RofHxPYi50ZXN0KGIpKXRocm93IEVycm9yKEcoYSwxLCExKSsnd2FzIGFuIGludmFsaWQgcGF0aDogXCInK2IrJ1wiLiBQYXRocyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzIGFuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiJyk7fWZ1bmN0aW9uIFpiKGEsYil7aWYoXCIuaW5mb1wiPT09SShiKSl0aHJvdyBFcnJvcihhK1wiIGZhaWxlZDogQ2FuJ3QgbW9kaWZ5IGRhdGEgdW5kZXIgLy5pbmZvL1wiKTt9ZnVuY3Rpb24gJGIoYSxiKXtpZighcChiKSl0aHJvdyBFcnJvcihHKGEsMSwhMSkrXCJtdXN0IGJlIGEgdmFsaWQgY3JlZGVudGlhbCAoYSBzdHJpbmcpLlwiKTt9ZnVuY3Rpb24gYWMoYSxiLGMpe2lmKCFwKGMpKXRocm93IEVycm9yKEcoYSxiLCExKStcIm11c3QgYmUgYSB2YWxpZCBzdHJpbmcuXCIpO31cbmZ1bmN0aW9uIEooYSxiLGMsZCl7aWYoIWR8fG0oYykpaWYoIWlhKGMpfHxudWxsPT09Yyl0aHJvdyBFcnJvcihHKGEsYixkKStcIm11c3QgYmUgYSB2YWxpZCBvYmplY3QuXCIpO31mdW5jdGlvbiBLKGEsYixjKXtpZighaWEoYil8fG51bGw9PT1ifHwhcyhiLGMpKXRocm93IEVycm9yKEcoYSwxLCExKSsnbXVzdCBjb250YWluIHRoZSBrZXkgXCInK2MrJ1wiJyk7aWYoIXAodChiLGMpKSl0aHJvdyBFcnJvcihHKGEsMSwhMSkrJ211c3QgY29udGFpbiB0aGUga2V5IFwiJytjKydcIiB3aXRoIHR5cGUgXCJzdHJpbmdcIicpO307ZnVuY3Rpb24gYmMoYSl7dGhpcy5nPWF9aD1iYy5wcm90b3R5cGU7aC5EPWZ1bmN0aW9uKGEsYixjLGQsZSl7eShhLkJjKHRoaXMuZyksXCJBIG5vZGUgbXVzdCBiZSBpbmRleGVkIGlmIG9ubHkgYSBjaGlsZCBpcyB1cGRhdGVkXCIpO2Q9YS5LKGIpO2lmKGQuYWEoYykpcmV0dXJuIGE7bnVsbCE9ZSYmKGMuZSgpP2EuRGEoYik/Y2MoZSxuZXcgQyhcImNoaWxkX3JlbW92ZWRcIixkLGIpKTp5KGEuTSgpLFwiQSBjaGlsZCByZW1vdmUgd2l0aG91dCBhbiBvbGQgY2hpbGQgb25seSBtYWtlcyBzZW5zZSBvbiBhIGxlYWYgbm9kZVwiKTpkLmUoKT9jYyhlLG5ldyBDKFwiY2hpbGRfYWRkZWRcIixjLGIpKTpjYyhlLG5ldyBDKFwiY2hpbGRfY2hhbmdlZFwiLGMsYixkKSkpO3JldHVybiBhLk0oKSYmYy5lKCk/YTphLlAoYixjKS5oYih0aGlzLmcpfTtcbmgub2E9ZnVuY3Rpb24oYSxiLGMpe251bGwhPWMmJihhLk0oKXx8YS5VKEwsZnVuY3Rpb24oYSxlKXtiLkRhKGEpfHxjYyhjLG5ldyBDKFwiY2hpbGRfcmVtb3ZlZFwiLGUsYSkpfSksYi5NKCl8fGIuVShMLGZ1bmN0aW9uKGIsZSl7aWYoYS5EYShiKSl7dmFyIGY9YS5LKGIpO2YuYWEoZSl8fGNjKGMsbmV3IEMoXCJjaGlsZF9jaGFuZ2VkXCIsZSxiLGYpKX1lbHNlIGNjKGMsbmV3IEMoXCJjaGlsZF9hZGRlZFwiLGUsYikpfSkpO3JldHVybiBiLmhiKHRoaXMuZyl9O2guJD1mdW5jdGlvbihhLGIpe3JldHVybiBhLmUoKT9NOmEuJChiKX07aC5DYT1mdW5jdGlvbigpe3JldHVybiExfTtoLk5iPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2Z1bmN0aW9uIGRjKGEpe3RoaXMudmU9bmV3IGJjKGEuZyk7dGhpcy5nPWEuZzt2YXIgYjthLmlhPyhiPWVjKGEpLGI9YS5nLnVkKGZjKGEpLGIpKTpiPWEuZy55ZCgpO3RoaXMuVmM9YjthLnFhPyhiPWdjKGEpLGE9YS5nLnVkKGhjKGEpLGIpKTphPWEuZy53ZCgpO3RoaXMueGM9YX1oPWRjLnByb3RvdHlwZTtoLm1hdGNoZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIDA+PXRoaXMuZy5jb21wYXJlKHRoaXMuVmMsYSkmJjA+PXRoaXMuZy5jb21wYXJlKGEsdGhpcy54Yyl9O2guRD1mdW5jdGlvbihhLGIsYyxkLGUpe3RoaXMubWF0Y2hlcyhuZXcgTihiLGMpKXx8KGM9TSk7cmV0dXJuIHRoaXMudmUuRChhLGIsYyxkLGUpfTtoLm9hPWZ1bmN0aW9uKGEsYixjKXtiLk0oKSYmKGI9TSk7dmFyIGQ9Yi5oYih0aGlzLmcpLGQ9ZC4kKE0pLGU9dGhpcztiLlUoTCxmdW5jdGlvbihhLGIpe2UubWF0Y2hlcyhuZXcgTihhLGIpKXx8KGQ9ZC5QKGEsTSkpfSk7cmV0dXJuIHRoaXMudmUub2EoYSxkLGMpfTtcbmguJD1mdW5jdGlvbihhKXtyZXR1cm4gYX07aC5DYT1mdW5jdGlvbigpe3JldHVybiEwfTtoLk5iPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmV9O2Z1bmN0aW9uIGljKGEsYil7cmV0dXJuIHViKGEubmFtZSxiLm5hbWUpfWZ1bmN0aW9uIGpjKGEsYil7cmV0dXJuIHViKGEsYil9O2Z1bmN0aW9uIGtjKCl7fXZhciBsYz17fTtmdW5jdGlvbiBtYyhhKXtyZXR1cm4gcShhLmNvbXBhcmUsYSl9a2MucHJvdG90eXBlLndlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIDAhPT10aGlzLmNvbXBhcmUobmV3IE4oXCJbTUlOX05BTUVdXCIsYSksbmV3IE4oXCJbTUlOX05BTUVdXCIsYikpfTtrYy5wcm90b3R5cGUueWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmN9O2Z1bmN0aW9uIG9jKGEpe3RoaXMuVmI9YX1tYShvYyxrYyk7aD1vYy5wcm90b3R5cGU7aC5zZD1mdW5jdGlvbihhKXtyZXR1cm4hYS5LKHRoaXMuVmIpLmUoKX07aC5jb21wYXJlPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5WLksodGhpcy5WYiksZD1iLlYuSyh0aGlzLlZiKSxjPWMuZGQoZCk7cmV0dXJuIDA9PT1jP3ViKGEubmFtZSxiLm5hbWUpOmN9O2gudWQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1PKGEpLGM9TS5QKHRoaXMuVmIsYyk7cmV0dXJuIG5ldyBOKGIsYyl9O1xuaC53ZD1mdW5jdGlvbigpe3ZhciBhPU0uUCh0aGlzLlZiLHBjKTtyZXR1cm4gbmV3IE4oXCJbTUFYX05BTUVdXCIsYSl9O2gudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5WYn07dmFyIEw9bmV3IG9jKFwiLnByaW9yaXR5XCIpO2Z1bmN0aW9uIHFjKCl7fW1hKHFjLGtjKTtoPXFjLnByb3RvdHlwZTtoLmNvbXBhcmU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdWIoYS5uYW1lLGIubmFtZSl9O2guc2Q9ZnVuY3Rpb24oKXt0aHJvdyBmYihcIktleUluZGV4LmlzRGVmaW5lZE9uIG5vdCBleHBlY3RlZCB0byBiZSBjYWxsZWQuXCIpO307aC53ZT1mdW5jdGlvbigpe3JldHVybiExfTtoLnlkPWZ1bmN0aW9uKCl7cmV0dXJuIG5jfTtoLndkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBOKFwiW01BWF9OQU1FXVwiLE0pfTtoLnVkPWZ1bmN0aW9uKGEpe3kocChhKSxcIktleUluZGV4IGluZGV4VmFsdWUgbXVzdCBhbHdheXMgYmUgYSBzdHJpbmcuXCIpO3JldHVybiBuZXcgTihhLE0pfTtcbmgudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIi5rZXlcIn07dmFyIHJjPW5ldyBxYztmdW5jdGlvbiBzYygpe31tYShzYyxrYyk7aD1zYy5wcm90b3R5cGU7aC5jb21wYXJlPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5WLmRkKGIuVik7cmV0dXJuIDA9PT1jP3ViKGEubmFtZSxiLm5hbWUpOmN9O2guc2Q9ZnVuY3Rpb24oKXtyZXR1cm4hMH07aC53ZT1mdW5jdGlvbihhLGIpe3JldHVybiFhLmFhKGIpfTtoLnlkPWZ1bmN0aW9uKCl7cmV0dXJuIG5jfTtoLndkPWZ1bmN0aW9uKCl7cmV0dXJuIHRjfTtoLnVkPWZ1bmN0aW9uKGEsYil7dmFyIGM9TyhhKTtyZXR1cm4gbmV3IE4oYixjKX07aC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiLnZhbHVlXCJ9O3ZhciB1Yz1uZXcgc2M7ZnVuY3Rpb24gdmMoKXt9dmMucHJvdG90eXBlLmZmPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O3ZjLnByb3RvdHlwZS5zZT1mdW5jdGlvbigpe3JldHVybiBudWxsfTt2YXIgd2M9bmV3IHZjO2Z1bmN0aW9uIHhjKGEsYixjKXt0aGlzLkJmPWE7dGhpcy5JYT1iO3RoaXMuRWQ9Y314Yy5wcm90b3R5cGUuZmY9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5JYS5CO2lmKHljKGIsYSkpcmV0dXJuIGIuaigpLksoYSk7Yj1udWxsIT10aGlzLkVkP25ldyB6Yyh0aGlzLkVkLCEwLCExKTp0aGlzLklhLm8oKTtyZXR1cm4gdGhpcy5CZi5UYShhLGIpfTt4Yy5wcm90b3R5cGUuc2U9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW51bGwhPXRoaXMuRWQ/dGhpcy5FZDpBYyh0aGlzLklhKTthPXRoaXMuQmYuaGUoZCxiLDEsYyxhKTtyZXR1cm4gMD09PWEubGVuZ3RoP251bGw6YVswXX07ZnVuY3Rpb24gQmMoKXt0aGlzLlphPXt9fVxuZnVuY3Rpb24gY2MoYSxiKXt2YXIgYz1iLnR5cGUsZD1iLlVhO3koXCJjaGlsZF9hZGRlZFwiPT1jfHxcImNoaWxkX2NoYW5nZWRcIj09Y3x8XCJjaGlsZF9yZW1vdmVkXCI9PWMsXCJPbmx5IGNoaWxkIGNoYW5nZXMgc3VwcG9ydGVkIGZvciB0cmFja2luZ1wiKTt5KFwiLnByaW9yaXR5XCIhPT1kLFwiT25seSBub24tcHJpb3JpdHkgY2hpbGQgY2hhbmdlcyBjYW4gYmUgdHJhY2tlZC5cIik7dmFyIGU9dChhLlphLGQpO2lmKGUpe3ZhciBmPWUudHlwZTtpZihcImNoaWxkX2FkZGVkXCI9PWMmJlwiY2hpbGRfcmVtb3ZlZFwiPT1mKWEuWmFbZF09bmV3IEMoXCJjaGlsZF9jaGFuZ2VkXCIsYi5IYSxkLGUuSGEpO2Vsc2UgaWYoXCJjaGlsZF9yZW1vdmVkXCI9PWMmJlwiY2hpbGRfYWRkZWRcIj09ZilkZWxldGUgYS5aYVtkXTtlbHNlIGlmKFwiY2hpbGRfcmVtb3ZlZFwiPT1jJiZcImNoaWxkX2NoYW5nZWRcIj09ZilhLlphW2RdPW5ldyBDKFwiY2hpbGRfcmVtb3ZlZFwiLGUuRWUsZCk7ZWxzZSBpZihcImNoaWxkX2NoYW5nZWRcIj09YyYmXG5cImNoaWxkX2FkZGVkXCI9PWYpYS5aYVtkXT1uZXcgQyhcImNoaWxkX2FkZGVkXCIsYi5IYSxkKTtlbHNlIGlmKFwiY2hpbGRfY2hhbmdlZFwiPT1jJiZcImNoaWxkX2NoYW5nZWRcIj09ZilhLlphW2RdPW5ldyBDKFwiY2hpbGRfY2hhbmdlZFwiLGIuSGEsZCxlLkVlKTtlbHNlIHRocm93IGZiKFwiSWxsZWdhbCBjb21iaW5hdGlvbiBvZiBjaGFuZ2VzOiBcIitiK1wiIG9jY3VycmVkIGFmdGVyIFwiK2UpO31lbHNlIGEuWmFbZF09Yn07ZnVuY3Rpb24gTihhLGIpe3RoaXMubmFtZT1hO3RoaXMuVj1ifWZ1bmN0aW9uIENjKGEsYil7cmV0dXJuIG5ldyBOKGEsYil9O2Z1bmN0aW9uIERjKGEpe3RoaXMubWE9bmV3IGRjKGEpO3RoaXMuZz1hLmc7eShhLmthLFwiT25seSB2YWxpZCBpZiBsaW1pdCBoYXMgYmVlbiBzZXRcIik7dGhpcy5zYT1hLnNhO3RoaXMuQWI9IShcIlwiPT09YS5GYj9hLmlhOlwibFwiPT09YS5GYil9aD1EYy5wcm90b3R5cGU7aC5EPWZ1bmN0aW9uKGEsYixjLGQsZSl7dGhpcy5tYS5tYXRjaGVzKG5ldyBOKGIsYykpfHwoYz1NKTtyZXR1cm4gYS5LKGIpLmFhKGMpP2E6YS52YigpPHRoaXMuc2E/dGhpcy5tYS5OYigpLkQoYSxiLGMsZCxlKTpFYyh0aGlzLGEsYixjLGQsZSl9O1xuaC5vYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ7aWYoYi5NKCl8fGIuZSgpKWQ9TS5oYih0aGlzLmcpO2Vsc2UgaWYoMip0aGlzLnNhPGIudmIoKSYmYi5CYyh0aGlzLmcpKXtkPU0uaGIodGhpcy5nKTtiPXRoaXMuQWI/Yi5TYih0aGlzLm1hLnhjLHRoaXMuZyk6Yi5RYih0aGlzLm1hLlZjLHRoaXMuZyk7Zm9yKHZhciBlPTA7MDxiLk5hLmxlbmd0aCYmZTx0aGlzLnNhOyl7dmFyIGY9UChiKSxnO2lmKGc9dGhpcy5BYj8wPj10aGlzLmcuY29tcGFyZSh0aGlzLm1hLlZjLGYpOjA+PXRoaXMuZy5jb21wYXJlKGYsdGhpcy5tYS54YykpZD1kLlAoZi5uYW1lLGYuViksZSsrO2Vsc2UgYnJlYWt9fWVsc2V7ZD1iLmhiKHRoaXMuZyk7ZD1kLiQoTSk7dmFyIGssbCxuO2lmKHRoaXMuQWIpe2I9ZC5oZih0aGlzLmcpO2s9dGhpcy5tYS54YztsPXRoaXMubWEuVmM7dmFyIHU9bWModGhpcy5nKTtuPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHUoYixhKX19ZWxzZSBiPWQuUGIodGhpcy5nKSxrPXRoaXMubWEuVmMsXG5sPXRoaXMubWEueGMsbj1tYyh0aGlzLmcpO2Zvcih2YXIgZT0wLHg9ITE7MDxiLk5hLmxlbmd0aDspZj1QKGIpLCF4JiYwPj1uKGssZikmJih4PSEwKSwoZz14JiZlPHRoaXMuc2EmJjA+PW4oZixsKSk/ZSsrOmQ9ZC5QKGYubmFtZSxNKX1yZXR1cm4gdGhpcy5tYS5OYigpLm9hKGEsZCxjKX07aC4kPWZ1bmN0aW9uKGEpe3JldHVybiBhfTtoLkNhPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2guTmI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYS5OYigpfTtcbmZ1bmN0aW9uIEVjKGEsYixjLGQsZSxmKXt2YXIgZztpZihhLkFiKXt2YXIgaz1tYyhhLmcpO2c9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gayhiLGEpfX1lbHNlIGc9bWMoYS5nKTt5KGIudmIoKT09YS5zYSxcIlwiKTt2YXIgbD1uZXcgTihjLGQpLG49YS5BYj9GYyhiLGEuZyk6R2MoYixhLmcpLHU9YS5tYS5tYXRjaGVzKGwpO2lmKGIuRGEoYykpe3ZhciB4PWIuSyhjKSxuPWUuc2UoYS5nLG4sYS5BYik7bnVsbCE9biYmbi5uYW1lPT1jJiYobj1lLnNlKGEuZyxuLGEuQWIpKTtlPW51bGw9PW4/MTpnKG4sbCk7aWYodSYmIWQuZSgpJiYwPD1lKXJldHVybiBudWxsIT1mJiZjYyhmLG5ldyBDKFwiY2hpbGRfY2hhbmdlZFwiLGQsYyx4KSksYi5QKGMsZCk7bnVsbCE9ZiYmY2MoZixuZXcgQyhcImNoaWxkX3JlbW92ZWRcIix4LGMpKTtiPWIuUChjLE0pO3JldHVybiBudWxsIT1uJiZhLm1hLm1hdGNoZXMobik/KG51bGwhPWYmJmNjKGYsbmV3IEMoXCJjaGlsZF9hZGRlZFwiLG4uVixuLm5hbWUpKSxiLlAobi5uYW1lLFxubi5WKSk6Yn1yZXR1cm4gZC5lKCk/Yjp1JiYwPD1nKG4sbCk/KG51bGwhPWYmJihjYyhmLG5ldyBDKFwiY2hpbGRfcmVtb3ZlZFwiLG4uVixuLm5hbWUpKSxjYyhmLG5ldyBDKFwiY2hpbGRfYWRkZWRcIixkLGMpKSksYi5QKGMsZCkuUChuLm5hbWUsTSkpOmJ9O2Z1bmN0aW9uIEhjKCl7dGhpcy53Yz10aGlzLnFhPXRoaXMubGM9dGhpcy5pYT10aGlzLmthPSExO3RoaXMuc2E9MDt0aGlzLkZiPVwiXCI7dGhpcy5BYz1udWxsO3RoaXMuWGI9XCJcIjt0aGlzLnpjPW51bGw7dGhpcy5VYj1cIlwiO3RoaXMuZz1MfXZhciBJYz1uZXcgSGM7ZnVuY3Rpb24gZmMoYSl7eShhLmlhLFwiT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXRcIik7cmV0dXJuIGEuQWN9ZnVuY3Rpb24gZWMoYSl7eShhLmlhLFwiT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXRcIik7cmV0dXJuIGEubGM/YS5YYjpcIltNSU5fTkFNRV1cIn1mdW5jdGlvbiBoYyhhKXt5KGEucWEsXCJPbmx5IHZhbGlkIGlmIGVuZCBoYXMgYmVlbiBzZXRcIik7cmV0dXJuIGEuemN9ZnVuY3Rpb24gZ2MoYSl7eShhLnFhLFwiT25seSB2YWxpZCBpZiBlbmQgaGFzIGJlZW4gc2V0XCIpO3JldHVybiBhLndjP2EuVWI6XCJbTUFYX05BTUVdXCJ9XG5mdW5jdGlvbiBKYyhhKXt2YXIgYj1uZXcgSGM7Yi5rYT1hLmthO2Iuc2E9YS5zYTtiLmlhPWEuaWE7Yi5BYz1hLkFjO2IubGM9YS5sYztiLlhiPWEuWGI7Yi5xYT1hLnFhO2IuemM9YS56YztiLndjPWEud2M7Yi5VYj1hLlViO2IuZz1hLmc7cmV0dXJuIGJ9aD1IYy5wcm90b3R5cGU7aC5CZT1mdW5jdGlvbihhKXt2YXIgYj1KYyh0aGlzKTtiLmthPSEwO2Iuc2E9YTtiLkZiPVwiXCI7cmV0dXJuIGJ9O2guQ2U9ZnVuY3Rpb24oYSl7dmFyIGI9SmModGhpcyk7Yi5rYT0hMDtiLnNhPWE7Yi5GYj1cImxcIjtyZXR1cm4gYn07aC5EZT1mdW5jdGlvbihhKXt2YXIgYj1KYyh0aGlzKTtiLmthPSEwO2Iuc2E9YTtiLkZiPVwiclwiO3JldHVybiBifTtoLlRkPWZ1bmN0aW9uKGEsYil7dmFyIGM9SmModGhpcyk7Yy5pYT0hMDttKGEpfHwoYT1udWxsKTtjLkFjPWE7bnVsbCE9Yj8oYy5sYz0hMCxjLlhiPWIpOihjLmxjPSExLGMuWGI9XCJcIik7cmV0dXJuIGN9O1xuaC5qZD1mdW5jdGlvbihhLGIpe3ZhciBjPUpjKHRoaXMpO2MucWE9ITA7bShhKXx8KGE9bnVsbCk7Yy56Yz1hO20oYik/KGMud2M9ITAsYy5VYj1iKTooYy5KZz0hMSxjLlViPVwiXCIpO3JldHVybiBjfTtmdW5jdGlvbiBLYyhhLGIpe3ZhciBjPUpjKGEpO2MuZz1iO3JldHVybiBjfWZ1bmN0aW9uIExjKGEpe3ZhciBiPXt9O2EuaWEmJihiLnNwPWEuQWMsYS5sYyYmKGIuc249YS5YYikpO2EucWEmJihiLmVwPWEuemMsYS53YyYmKGIuZW49YS5VYikpO2lmKGEua2Epe2IubD1hLnNhO3ZhciBjPWEuRmI7XCJcIj09PWMmJihjPWEuaWE/XCJsXCI6XCJyXCIpO2IudmY9Y31hLmchPT1MJiYoYi5pPWEuZy50b1N0cmluZygpKTtyZXR1cm4gYn1mdW5jdGlvbiBNYyhhKXtyZXR1cm4hKGEuaWF8fGEucWF8fGEua2EpfWgudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcihMYyh0aGlzKSl9O2Z1bmN0aW9uIFEoYSxiLGMsZCl7dGhpcy5rPWE7dGhpcy5wYXRoPWI7dGhpcy5uPWM7dGhpcy5iYz1kfVxuZnVuY3Rpb24gTmMoYSl7dmFyIGI9bnVsbCxjPW51bGw7YS5pYSYmKGI9ZmMoYSkpO2EucWEmJihjPWhjKGEpKTtpZihhLmc9PT1yYyl7aWYoYS5pYSl7aWYoXCJbTUlOX05BTUVdXCIhPWVjKGEpKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB5b3UgbWF5IG9ubHkgcGFzcyBvbmUgYXJndW1lbnQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkuXCIpO2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYil0aHJvdyBFcnJvcihcIlF1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIGVuZEF0KCksb3IgZXF1YWxUbygpIG11c3QgYmUgYSBzdHJpbmcuXCIpO31pZihhLnFhKXtpZihcIltNQVhfTkFNRV1cIiE9Z2MoYSkpdGhyb3cgRXJyb3IoXCJRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHlvdSBtYXkgb25seSBwYXNzIG9uZSBhcmd1bWVudCB0byBzdGFydEF0KCksIGVuZEF0KCksIG9yIGVxdWFsVG8oKS5cIik7aWYoXCJzdHJpbmdcIiE9PVxudHlwZW9mIGMpdGhyb3cgRXJyb3IoXCJRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLG9yIGVxdWFsVG8oKSBtdXN0IGJlIGEgc3RyaW5nLlwiKTt9fWVsc2UgaWYoYS5nPT09TCl7aWYobnVsbCE9YiYmIVFiKGIpfHxudWxsIT1jJiYhUWIoYykpdGhyb3cgRXJyb3IoXCJRdWVyeTogV2hlbiBvcmRlcmluZyBieSBwcmlvcml0eSwgdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIGVuZEF0KCksIG9yIGVxdWFsVG8oKSBtdXN0IGJlIGEgdmFsaWQgcHJpb3JpdHkgdmFsdWUgKG51bGwsIGEgbnVtYmVyLCBvciBhIHN0cmluZykuXCIpO31lbHNlIGlmKHkoYS5nIGluc3RhbmNlb2Ygb2N8fGEuZz09PXVjLFwidW5rbm93biBpbmRleCB0eXBlLlwiKSxudWxsIT1iJiZcIm9iamVjdFwiPT09dHlwZW9mIGJ8fG51bGwhPWMmJlwib2JqZWN0XCI9PT10eXBlb2YgYyl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBGaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkgY2Fubm90IGJlIGFuIG9iamVjdC5cIik7XG59ZnVuY3Rpb24gT2MoYSl7aWYoYS5pYSYmYS5xYSYmYS5rYSYmKCFhLmthfHxcIlwiPT09YS5GYikpdGhyb3cgRXJyb3IoXCJRdWVyeTogQ2FuJ3QgY29tYmluZSBzdGFydEF0KCksIGVuZEF0KCksIGFuZCBsaW1pdCgpLiBVc2UgbGltaXRUb0ZpcnN0KCkgb3IgbGltaXRUb0xhc3QoKSBpbnN0ZWFkLlwiKTt9ZnVuY3Rpb24gUGMoYSxiKXtpZighMD09PWEuYmMpdGhyb3cgRXJyb3IoYitcIjogWW91IGNhbid0IGNvbWJpbmUgbXVsdGlwbGUgb3JkZXJCeSBjYWxscy5cIik7fVEucHJvdG90eXBlLmRjPWZ1bmN0aW9uKCl7RShcIlF1ZXJ5LnJlZlwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gbmV3IFIodGhpcy5rLHRoaXMucGF0aCl9O1EucHJvdG90eXBlLnJlZj1RLnByb3RvdHlwZS5kYztcblEucHJvdG90eXBlLndiPWZ1bmN0aW9uKGEsYixjLGQpe0UoXCJRdWVyeS5vblwiLDIsNCxhcmd1bWVudHMubGVuZ3RoKTtXYihcIlF1ZXJ5Lm9uXCIsYSwhMSk7SChcIlF1ZXJ5Lm9uXCIsMixiLCExKTt2YXIgZT1RYyhcIlF1ZXJ5Lm9uXCIsYyxkKTtpZihcInZhbHVlXCI9PT1hKVJjKHRoaXMuayx0aGlzLG5ldyBIYihiLGUuY2FuY2VsfHxudWxsLGUuS2F8fG51bGwpKTtlbHNle3ZhciBmPXt9O2ZbYV09YjtSYyh0aGlzLmssdGhpcyxuZXcgSWIoZixlLmNhbmNlbCxlLkthKSl9cmV0dXJuIGJ9O1EucHJvdG90eXBlLm9uPVEucHJvdG90eXBlLndiO1xuUS5wcm90b3R5cGUuJGI9ZnVuY3Rpb24oYSxiLGMpe0UoXCJRdWVyeS5vZmZcIiwwLDMsYXJndW1lbnRzLmxlbmd0aCk7V2IoXCJRdWVyeS5vZmZcIixhLCEwKTtIKFwiUXVlcnkub2ZmXCIsMixiLCEwKTtNYihcIlF1ZXJ5Lm9mZlwiLDMsYyk7dmFyIGQ9bnVsbCxlPW51bGw7XCJ2YWx1ZVwiPT09YT9kPW5ldyBIYihifHxudWxsLG51bGwsY3x8bnVsbCk6YSYmKGImJihlPXt9LGVbYV09YiksZD1uZXcgSWIoZSxudWxsLGN8fG51bGwpKTtlPXRoaXMuaztkPVwiLmluZm9cIj09PUkodGhpcy5wYXRoKT9lLnJkLmdiKHRoaXMsZCk6ZS5OLmdiKHRoaXMsZCk7U2MoZS5iYSx0aGlzLnBhdGgsZCl9O1EucHJvdG90eXBlLm9mZj1RLnByb3RvdHlwZS4kYjtcblEucHJvdG90eXBlLmxnPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhnKXtmJiYoZj0hMSxlLiRiKGEsYyksYi5jYWxsKGQuS2EsZykpfUUoXCJRdWVyeS5vbmNlXCIsMiw0LGFyZ3VtZW50cy5sZW5ndGgpO1diKFwiUXVlcnkub25jZVwiLGEsITEpO0goXCJRdWVyeS5vbmNlXCIsMixiLCExKTt2YXIgZD1RYyhcIlF1ZXJ5Lm9uY2VcIixhcmd1bWVudHNbMl0sYXJndW1lbnRzWzNdKSxlPXRoaXMsZj0hMDt0aGlzLndiKGEsYyxmdW5jdGlvbihiKXtlLiRiKGEsYyk7ZC5jYW5jZWwmJmQuY2FuY2VsLmNhbGwoZC5LYSxiKX0pfTtRLnByb3RvdHlwZS5vbmNlPVEucHJvdG90eXBlLmxnO1xuUS5wcm90b3R5cGUuQmU9ZnVuY3Rpb24oYSl7eihcIlF1ZXJ5LmxpbWl0KCkgYmVpbmcgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBRdWVyeS5saW1pdFRvRmlyc3QoKSBvciBRdWVyeS5saW1pdFRvTGFzdCgpIGluc3RlYWQuXCIpO0UoXCJRdWVyeS5saW1pdFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtpZighZ2EoYSl8fE1hdGguZmxvb3IoYSkhPT1hfHwwPj1hKXRocm93IEVycm9yKFwiUXVlcnkubGltaXQ6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLlwiKTtpZih0aGlzLm4ua2EpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdDogTGltaXQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gbGltaXQsIGxpbWl0VG9GaXJzdCwgb3JsaW1pdFRvTGFzdC5cIik7dmFyIGI9dGhpcy5uLkJlKGEpO09jKGIpO3JldHVybiBuZXcgUSh0aGlzLmssdGhpcy5wYXRoLGIsdGhpcy5iYyl9O1EucHJvdG90eXBlLmxpbWl0PVEucHJvdG90eXBlLkJlO1xuUS5wcm90b3R5cGUuQ2U9ZnVuY3Rpb24oYSl7RShcIlF1ZXJ5LmxpbWl0VG9GaXJzdFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtpZighZ2EoYSl8fE1hdGguZmxvb3IoYSkhPT1hfHwwPj1hKXRocm93IEVycm9yKFwiUXVlcnkubGltaXRUb0ZpcnN0OiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cIik7aWYodGhpcy5uLmthKXRocm93IEVycm9yKFwiUXVlcnkubGltaXRUb0ZpcnN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgbGltaXRUb0ZpcnN0LCBvciBsaW1pdFRvTGFzdCkuXCIpO3JldHVybiBuZXcgUSh0aGlzLmssdGhpcy5wYXRoLHRoaXMubi5DZShhKSx0aGlzLmJjKX07US5wcm90b3R5cGUubGltaXRUb0ZpcnN0PVEucHJvdG90eXBlLkNlO1xuUS5wcm90b3R5cGUuRGU9ZnVuY3Rpb24oYSl7RShcIlF1ZXJ5LmxpbWl0VG9MYXN0XCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKCFnYShhKXx8TWF0aC5mbG9vcihhKSE9PWF8fDA+PWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdFRvTGFzdDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuXCIpO2lmKHRoaXMubi5rYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmxpbWl0VG9MYXN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgbGltaXRUb0ZpcnN0LCBvciBsaW1pdFRvTGFzdCkuXCIpO3JldHVybiBuZXcgUSh0aGlzLmssdGhpcy5wYXRoLHRoaXMubi5EZShhKSx0aGlzLmJjKX07US5wcm90b3R5cGUubGltaXRUb0xhc3Q9US5wcm90b3R5cGUuRGU7XG5RLnByb3RvdHlwZS5tZz1mdW5jdGlvbihhKXtFKFwiUXVlcnkub3JkZXJCeUNoaWxkXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKFwiJGtleVwiPT09YSl0aHJvdyBFcnJvcignUXVlcnkub3JkZXJCeUNoaWxkOiBcIiRrZXlcIiBpcyBpbnZhbGlkLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlLZXkoKSBpbnN0ZWFkLicpO2lmKFwiJHByaW9yaXR5XCI9PT1hKXRocm93IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJHByaW9yaXR5XCIgaXMgaW52YWxpZC4gIFVzZSBRdWVyeS5vcmRlckJ5UHJpb3JpdHkoKSBpbnN0ZWFkLicpO2lmKFwiJHZhbHVlXCI9PT1hKXRocm93IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJHZhbHVlXCIgaXMgaW52YWxpZC4gIFVzZSBRdWVyeS5vcmRlckJ5VmFsdWUoKSBpbnN0ZWFkLicpO1hiKFwiUXVlcnkub3JkZXJCeUNoaWxkXCIsMSxhLCExKTtQYyh0aGlzLFwiUXVlcnkub3JkZXJCeUNoaWxkXCIpO3ZhciBiPUtjKHRoaXMubixuZXcgb2MoYSkpO05jKGIpO3JldHVybiBuZXcgUSh0aGlzLmssXG50aGlzLnBhdGgsYiwhMCl9O1EucHJvdG90eXBlLm9yZGVyQnlDaGlsZD1RLnByb3RvdHlwZS5tZztRLnByb3RvdHlwZS5uZz1mdW5jdGlvbigpe0UoXCJRdWVyeS5vcmRlckJ5S2V5XCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO1BjKHRoaXMsXCJRdWVyeS5vcmRlckJ5S2V5XCIpO3ZhciBhPUtjKHRoaXMubixyYyk7TmMoYSk7cmV0dXJuIG5ldyBRKHRoaXMuayx0aGlzLnBhdGgsYSwhMCl9O1EucHJvdG90eXBlLm9yZGVyQnlLZXk9US5wcm90b3R5cGUubmc7US5wcm90b3R5cGUub2c9ZnVuY3Rpb24oKXtFKFwiUXVlcnkub3JkZXJCeVByaW9yaXR5XCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO1BjKHRoaXMsXCJRdWVyeS5vcmRlckJ5UHJpb3JpdHlcIik7dmFyIGE9S2ModGhpcy5uLEwpO05jKGEpO3JldHVybiBuZXcgUSh0aGlzLmssdGhpcy5wYXRoLGEsITApfTtRLnByb3RvdHlwZS5vcmRlckJ5UHJpb3JpdHk9US5wcm90b3R5cGUub2c7XG5RLnByb3RvdHlwZS5wZz1mdW5jdGlvbigpe0UoXCJRdWVyeS5vcmRlckJ5VmFsdWVcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7UGModGhpcyxcIlF1ZXJ5Lm9yZGVyQnlWYWx1ZVwiKTt2YXIgYT1LYyh0aGlzLm4sdWMpO05jKGEpO3JldHVybiBuZXcgUSh0aGlzLmssdGhpcy5wYXRoLGEsITApfTtRLnByb3RvdHlwZS5vcmRlckJ5VmFsdWU9US5wcm90b3R5cGUucGc7XG5RLnByb3RvdHlwZS5UZD1mdW5jdGlvbihhLGIpe0UoXCJRdWVyeS5zdGFydEF0XCIsMCwyLGFyZ3VtZW50cy5sZW5ndGgpO1JiKFwiUXVlcnkuc3RhcnRBdFwiLGEsITApO1hiKFwiUXVlcnkuc3RhcnRBdFwiLDIsYiwhMCk7dmFyIGM9dGhpcy5uLlRkKGEsYik7T2MoYyk7TmMoYyk7aWYodGhpcy5uLmlhKXRocm93IEVycm9yKFwiUXVlcnkuc3RhcnRBdDogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gc3RhcnRBdCBvciBlcXVhbFRvKS5cIik7bShhKXx8KGI9YT1udWxsKTtyZXR1cm4gbmV3IFEodGhpcy5rLHRoaXMucGF0aCxjLHRoaXMuYmMpfTtRLnByb3RvdHlwZS5zdGFydEF0PVEucHJvdG90eXBlLlRkO1xuUS5wcm90b3R5cGUuamQ9ZnVuY3Rpb24oYSxiKXtFKFwiUXVlcnkuZW5kQXRcIiwwLDIsYXJndW1lbnRzLmxlbmd0aCk7UmIoXCJRdWVyeS5lbmRBdFwiLGEsITApO1hiKFwiUXVlcnkuZW5kQXRcIiwyLGIsITApO3ZhciBjPXRoaXMubi5qZChhLGIpO09jKGMpO05jKGMpO2lmKHRoaXMubi5xYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmVuZEF0OiBFbmRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQgb3IgZXF1YWxUbykuXCIpO3JldHVybiBuZXcgUSh0aGlzLmssdGhpcy5wYXRoLGMsdGhpcy5iYyl9O1EucHJvdG90eXBlLmVuZEF0PVEucHJvdG90eXBlLmpkO1xuUS5wcm90b3R5cGUuVGY9ZnVuY3Rpb24oYSxiKXtFKFwiUXVlcnkuZXF1YWxUb1wiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtSYihcIlF1ZXJ5LmVxdWFsVG9cIixhLCExKTtYYihcIlF1ZXJ5LmVxdWFsVG9cIiwyLGIsITApO2lmKHRoaXMubi5pYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmVxdWFsVG86IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGVuZEF0IG9yIGVxdWFsVG8pLlwiKTtpZih0aGlzLm4ucWEpdGhyb3cgRXJyb3IoXCJRdWVyeS5lcXVhbFRvOiBFbmRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQgb3IgZXF1YWxUbykuXCIpO3JldHVybiB0aGlzLlRkKGEsYikuamQoYSxiKX07US5wcm90b3R5cGUuZXF1YWxUbz1RLnByb3RvdHlwZS5UZjtRLnByb3RvdHlwZS5GYT1mdW5jdGlvbigpe3ZhciBhPXhiKExjKHRoaXMubikpO3JldHVyblwie31cIj09PWE/XCJkZWZhdWx0XCI6YX07XG5mdW5jdGlvbiBRYyhhLGIsYyl7dmFyIGQ9e2NhbmNlbDpudWxsLEthOm51bGx9O2lmKGImJmMpZC5jYW5jZWw9YixIKGEsMyxkLmNhbmNlbCwhMCksZC5LYT1jLE1iKGEsNCxkLkthKTtlbHNlIGlmKGIpaWYoXCJvYmplY3RcIj09PXR5cGVvZiBiJiZudWxsIT09YilkLkthPWI7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYilkLmNhbmNlbD1iO2Vsc2UgdGhyb3cgRXJyb3IoRyhhLDMsITApK1wiIG11c3QgZWl0aGVyIGJlIGEgY2FuY2VsIGNhbGxiYWNrIG9yIGEgY29udGV4dCBvYmplY3QuXCIpO3JldHVybiBkfTtmdW5jdGlvbiBTKGEsYil7aWYoMT09YXJndW1lbnRzLmxlbmd0aCl7dGhpcy53PWEuc3BsaXQoXCIvXCIpO2Zvcih2YXIgYz0wLGQ9MDtkPHRoaXMudy5sZW5ndGg7ZCsrKTA8dGhpcy53W2RdLmxlbmd0aCYmKHRoaXMud1tjXT10aGlzLndbZF0sYysrKTt0aGlzLncubGVuZ3RoPWM7dGhpcy5kYT0wfWVsc2UgdGhpcy53PWEsdGhpcy5kYT1ifWZ1bmN0aW9uIEkoYSl7cmV0dXJuIGEuZGE+PWEudy5sZW5ndGg/bnVsbDphLndbYS5kYV19ZnVuY3Rpb24gVGMoYSl7cmV0dXJuIGEudy5sZW5ndGgtYS5kYX1mdW5jdGlvbiBUKGEpe3ZhciBiPWEuZGE7YjxhLncubGVuZ3RoJiZiKys7cmV0dXJuIG5ldyBTKGEudyxiKX1mdW5jdGlvbiBVYyhhKXtyZXR1cm4gYS5kYTxhLncubGVuZ3RoP2Eud1thLncubGVuZ3RoLTFdOm51bGx9XG5TLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe2Zvcih2YXIgYT1cIlwiLGI9dGhpcy5kYTtiPHRoaXMudy5sZW5ndGg7YisrKVwiXCIhPT10aGlzLndbYl0mJihhKz1cIi9cIit0aGlzLndbYl0pO3JldHVybiBhfHxcIi9cIn07Uy5wcm90b3R5cGUucGFyZW50PWZ1bmN0aW9uKCl7aWYodGhpcy5kYT49dGhpcy53Lmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIGE9W10sYj10aGlzLmRhO2I8dGhpcy53Lmxlbmd0aC0xO2IrKylhLnB1c2godGhpcy53W2JdKTtyZXR1cm4gbmV3IFMoYSwwKX07XG5TLnByb3RvdHlwZS51PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1bXSxjPXRoaXMuZGE7Yzx0aGlzLncubGVuZ3RoO2MrKyliLnB1c2godGhpcy53W2NdKTtpZihhIGluc3RhbmNlb2YgUylmb3IoYz1hLmRhO2M8YS53Lmxlbmd0aDtjKyspYi5wdXNoKGEud1tjXSk7ZWxzZSBmb3IoYT1hLnNwbGl0KFwiL1wiKSxjPTA7YzxhLmxlbmd0aDtjKyspMDxhW2NdLmxlbmd0aCYmYi5wdXNoKGFbY10pO3JldHVybiBuZXcgUyhiLDApfTtTLnByb3RvdHlwZS5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGE+PXRoaXMudy5sZW5ndGh9O3ZhciBVPW5ldyBTKFwiXCIpO2Z1bmN0aW9uIFYoYSxiKXt2YXIgYz1JKGEpO2lmKG51bGw9PT1jKXJldHVybiBiO2lmKGM9PT1JKGIpKXJldHVybiBWKFQoYSksVChiKSk7dGhyb3cgRXJyb3IoXCJJTlRFUk5BTCBFUlJPUjogaW5uZXJQYXRoIChcIitiK1wiKSBpcyBub3Qgd2l0aGluIG91dGVyUGF0aCAoXCIrYStcIilcIik7fVxuUy5wcm90b3R5cGUuYWE9ZnVuY3Rpb24oYSl7aWYoVGModGhpcykhPT1UYyhhKSlyZXR1cm4hMTtmb3IodmFyIGI9dGhpcy5kYSxjPWEuZGE7Yjw9dGhpcy53Lmxlbmd0aDtiKyssYysrKWlmKHRoaXMud1tiXSE9PWEud1tjXSlyZXR1cm4hMTtyZXR1cm4hMH07Uy5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5kYSxjPWEuZGE7aWYoVGModGhpcyk+VGMoYSkpcmV0dXJuITE7Zm9yKDtiPHRoaXMudy5sZW5ndGg7KXtpZih0aGlzLndbYl0hPT1hLndbY10pcmV0dXJuITE7KytiOysrY31yZXR1cm4hMH07ZnVuY3Rpb24gVmMoKXt0aGlzLmNoaWxkcmVuPXt9O3RoaXMuYmQ9MDt0aGlzLnZhbHVlPW51bGx9ZnVuY3Rpb24gV2MoYSxiLGMpe3RoaXMuemQ9YT9hOlwiXCI7dGhpcy5PYz1iP2I6bnVsbDt0aGlzLkE9Yz9jOm5ldyBWY31mdW5jdGlvbiBYYyhhLGIpe2Zvcih2YXIgYz1iIGluc3RhbmNlb2YgUz9iOm5ldyBTKGIpLGQ9YSxlO251bGwhPT0oZT1JKGMpKTspZD1uZXcgV2MoZSxkLHQoZC5BLmNoaWxkcmVuLGUpfHxuZXcgVmMpLGM9VChjKTtyZXR1cm4gZH1oPVdjLnByb3RvdHlwZTtoLnphPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQS52YWx1ZX07ZnVuY3Rpb24gWWMoYSxiKXt5KFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYixcIkNhbm5vdCBzZXQgdmFsdWUgdG8gdW5kZWZpbmVkXCIpO2EuQS52YWx1ZT1iO1pjKGEpfWguY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLkEudmFsdWU9bnVsbDt0aGlzLkEuY2hpbGRyZW49e307dGhpcy5BLmJkPTA7WmModGhpcyl9O1xuaC5tZD1mdW5jdGlvbigpe3JldHVybiAwPHRoaXMuQS5iZH07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnphKCkmJiF0aGlzLm1kKCl9O2guVT1mdW5jdGlvbihhKXt2YXIgYj10aGlzO0EodGhpcy5BLmNoaWxkcmVuLGZ1bmN0aW9uKGMsZCl7YShuZXcgV2MoZCxiLGMpKX0pfTtmdW5jdGlvbiAkYyhhLGIsYyxkKXtjJiYhZCYmYihhKTthLlUoZnVuY3Rpb24oYSl7JGMoYSxiLCEwLGQpfSk7YyYmZCYmYihhKX1mdW5jdGlvbiBhZChhLGIpe2Zvcih2YXIgYz1hLnBhcmVudCgpO251bGwhPT1jJiYhYihjKTspYz1jLnBhcmVudCgpfWgucGF0aD1mdW5jdGlvbigpe3JldHVybiBuZXcgUyhudWxsPT09dGhpcy5PYz90aGlzLnpkOnRoaXMuT2MucGF0aCgpK1wiL1wiK3RoaXMuemQpfTtoLm5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy56ZH07aC5wYXJlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5PY307XG5mdW5jdGlvbiBaYyhhKXtpZihudWxsIT09YS5PYyl7dmFyIGI9YS5PYyxjPWEuemQsZD1hLmUoKSxlPXMoYi5BLmNoaWxkcmVuLGMpO2QmJmU/KGRlbGV0ZSBiLkEuY2hpbGRyZW5bY10sYi5BLmJkLS0sWmMoYikpOmR8fGV8fChiLkEuY2hpbGRyZW5bY109YS5BLGIuQS5iZCsrLFpjKGIpKX19O2Z1bmN0aW9uIGJkKGEsYil7dGhpcy5KYT1hO3RoaXMudmE9Yj9iOmNkfWg9YmQucHJvdG90eXBlO2guTGE9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IGJkKHRoaXMuSmEsdGhpcy52YS5MYShhLGIsdGhpcy5KYSkuWShudWxsLG51bGwsITEsbnVsbCxudWxsKSl9O2gucmVtb3ZlPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYmQodGhpcy5KYSx0aGlzLnZhLnJlbW92ZShhLHRoaXMuSmEpLlkobnVsbCxudWxsLCExLG51bGwsbnVsbCkpfTtoLmdldD1mdW5jdGlvbihhKXtmb3IodmFyIGIsYz10aGlzLnZhOyFjLmUoKTspe2I9dGhpcy5KYShhLGMua2V5KTtpZigwPT09YilyZXR1cm4gYy52YWx1ZTswPmI/Yz1jLmxlZnQ6MDxiJiYoYz1jLnJpZ2h0KX1yZXR1cm4gbnVsbH07XG5mdW5jdGlvbiBkZChhLGIpe2Zvcih2YXIgYyxkPWEudmEsZT1udWxsOyFkLmUoKTspe2M9YS5KYShiLGQua2V5KTtpZigwPT09Yyl7aWYoZC5sZWZ0LmUoKSlyZXR1cm4gZT9lLmtleTpudWxsO2ZvcihkPWQubGVmdDshZC5yaWdodC5lKCk7KWQ9ZC5yaWdodDtyZXR1cm4gZC5rZXl9MD5jP2Q9ZC5sZWZ0OjA8YyYmKGU9ZCxkPWQucmlnaHQpfXRocm93IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGZpbmQgcHJlZGVjZXNzb3Iga2V5IGZvciBhIG5vbmV4aXN0ZW50IGtleS4gIFdoYXQgZ2l2ZXM/XCIpO31oLmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YS5lKCl9O2guY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YS5jb3VudCgpfTtoLkljPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmEuSWMoKX07aC5ZYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhLlliKCl9O2guZmE9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudmEuZmEoYSl9O1xuaC5QYj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGVkKHRoaXMudmEsbnVsbCx0aGlzLkphLCExLGEpfTtoLlFiPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBlZCh0aGlzLnZhLGEsdGhpcy5KYSwhMSxiKX07aC5TYj1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgZWQodGhpcy52YSxhLHRoaXMuSmEsITAsYil9O2guaGY9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBlZCh0aGlzLnZhLG51bGwsdGhpcy5KYSwhMCxhKX07ZnVuY3Rpb24gZWQoYSxiLGMsZCxlKXt0aGlzLk5kPWV8fG51bGw7dGhpcy56ZT1kO3RoaXMuTmE9W107Zm9yKGU9MTshYS5lKCk7KWlmKGU9Yj9jKGEua2V5LGIpOjEsZCYmKGUqPS0xKSwwPmUpYT10aGlzLnplP2EubGVmdDphLnJpZ2h0O2Vsc2UgaWYoMD09PWUpe3RoaXMuTmEucHVzaChhKTticmVha31lbHNlIHRoaXMuTmEucHVzaChhKSxhPXRoaXMuemU/YS5yaWdodDphLmxlZnR9XG5mdW5jdGlvbiBQKGEpe2lmKDA9PT1hLk5hLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgYj1hLk5hLnBvcCgpLGM7Yz1hLk5kP2EuTmQoYi5rZXksYi52YWx1ZSk6e2tleTpiLmtleSx2YWx1ZTpiLnZhbHVlfTtpZihhLnplKWZvcihiPWIubGVmdDshYi5lKCk7KWEuTmEucHVzaChiKSxiPWIucmlnaHQ7ZWxzZSBmb3IoYj1iLnJpZ2h0OyFiLmUoKTspYS5OYS5wdXNoKGIpLGI9Yi5sZWZ0O3JldHVybiBjfWZ1bmN0aW9uIGZkKGEpe2lmKDA9PT1hLk5hLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgYjtiPWEuTmE7Yj1iW2IubGVuZ3RoLTFdO3JldHVybiBhLk5kP2EuTmQoYi5rZXksYi52YWx1ZSk6e2tleTpiLmtleSx2YWx1ZTpiLnZhbHVlfX1mdW5jdGlvbiBnZChhLGIsYyxkLGUpe3RoaXMua2V5PWE7dGhpcy52YWx1ZT1iO3RoaXMuY29sb3I9bnVsbCE9Yz9jOiEwO3RoaXMubGVmdD1udWxsIT1kP2Q6Y2Q7dGhpcy5yaWdodD1udWxsIT1lP2U6Y2R9aD1nZC5wcm90b3R5cGU7XG5oLlk9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gbmV3IGdkKG51bGwhPWE/YTp0aGlzLmtleSxudWxsIT1iP2I6dGhpcy52YWx1ZSxudWxsIT1jP2M6dGhpcy5jb2xvcixudWxsIT1kP2Q6dGhpcy5sZWZ0LG51bGwhPWU/ZTp0aGlzLnJpZ2h0KX07aC5jb3VudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxlZnQuY291bnQoKSsxK3RoaXMucmlnaHQuY291bnQoKX07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2guZmE9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubGVmdC5mYShhKXx8YSh0aGlzLmtleSx0aGlzLnZhbHVlKXx8dGhpcy5yaWdodC5mYShhKX07ZnVuY3Rpb24gaGQoYSl7cmV0dXJuIGEubGVmdC5lKCk/YTpoZChhLmxlZnQpfWguSWM9ZnVuY3Rpb24oKXtyZXR1cm4gaGQodGhpcykua2V5fTtoLlliPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmlnaHQuZSgpP3RoaXMua2V5OnRoaXMucmlnaHQuWWIoKX07XG5oLkxhPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlO2U9dGhpcztkPWMoYSxlLmtleSk7ZT0wPmQ/ZS5ZKG51bGwsbnVsbCxudWxsLGUubGVmdC5MYShhLGIsYyksbnVsbCk6MD09PWQ/ZS5ZKG51bGwsYixudWxsLG51bGwsbnVsbCk6ZS5ZKG51bGwsbnVsbCxudWxsLG51bGwsZS5yaWdodC5MYShhLGIsYykpO3JldHVybiBpZChlKX07ZnVuY3Rpb24gamQoYSl7aWYoYS5sZWZ0LmUoKSlyZXR1cm4gY2Q7YS5sZWZ0LmNhKCl8fGEubGVmdC5sZWZ0LmNhKCl8fChhPWtkKGEpKTthPWEuWShudWxsLG51bGwsbnVsbCxqZChhLmxlZnQpLG51bGwpO3JldHVybiBpZChhKX1cbmgucmVtb3ZlPWZ1bmN0aW9uKGEsYil7dmFyIGMsZDtjPXRoaXM7aWYoMD5iKGEsYy5rZXkpKWMubGVmdC5lKCl8fGMubGVmdC5jYSgpfHxjLmxlZnQubGVmdC5jYSgpfHwoYz1rZChjKSksYz1jLlkobnVsbCxudWxsLG51bGwsYy5sZWZ0LnJlbW92ZShhLGIpLG51bGwpO2Vsc2V7Yy5sZWZ0LmNhKCkmJihjPW1kKGMpKTtjLnJpZ2h0LmUoKXx8Yy5yaWdodC5jYSgpfHxjLnJpZ2h0LmxlZnQuY2EoKXx8KGM9bmQoYyksYy5sZWZ0LmxlZnQuY2EoKSYmKGM9bWQoYyksYz1uZChjKSkpO2lmKDA9PT1iKGEsYy5rZXkpKXtpZihjLnJpZ2h0LmUoKSlyZXR1cm4gY2Q7ZD1oZChjLnJpZ2h0KTtjPWMuWShkLmtleSxkLnZhbHVlLG51bGwsbnVsbCxqZChjLnJpZ2h0KSl9Yz1jLlkobnVsbCxudWxsLG51bGwsbnVsbCxjLnJpZ2h0LnJlbW92ZShhLGIpKX1yZXR1cm4gaWQoYyl9O2guY2E9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb2xvcn07XG5mdW5jdGlvbiBpZChhKXthLnJpZ2h0LmNhKCkmJiFhLmxlZnQuY2EoKSYmKGE9b2QoYSkpO2EubGVmdC5jYSgpJiZhLmxlZnQubGVmdC5jYSgpJiYoYT1tZChhKSk7YS5sZWZ0LmNhKCkmJmEucmlnaHQuY2EoKSYmKGE9bmQoYSkpO3JldHVybiBhfWZ1bmN0aW9uIGtkKGEpe2E9bmQoYSk7YS5yaWdodC5sZWZ0LmNhKCkmJihhPWEuWShudWxsLG51bGwsbnVsbCxudWxsLG1kKGEucmlnaHQpKSxhPW9kKGEpLGE9bmQoYSkpO3JldHVybiBhfWZ1bmN0aW9uIG9kKGEpe3JldHVybiBhLnJpZ2h0LlkobnVsbCxudWxsLGEuY29sb3IsYS5ZKG51bGwsbnVsbCwhMCxudWxsLGEucmlnaHQubGVmdCksbnVsbCl9ZnVuY3Rpb24gbWQoYSl7cmV0dXJuIGEubGVmdC5ZKG51bGwsbnVsbCxhLmNvbG9yLG51bGwsYS5ZKG51bGwsbnVsbCwhMCxhLmxlZnQucmlnaHQsbnVsbCkpfVxuZnVuY3Rpb24gbmQoYSl7cmV0dXJuIGEuWShudWxsLG51bGwsIWEuY29sb3IsYS5sZWZ0LlkobnVsbCxudWxsLCFhLmxlZnQuY29sb3IsbnVsbCxudWxsKSxhLnJpZ2h0LlkobnVsbCxudWxsLCFhLnJpZ2h0LmNvbG9yLG51bGwsbnVsbCkpfWZ1bmN0aW9uIHBkKCl7fWg9cGQucHJvdG90eXBlO2guWT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtoLkxhPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBnZChhLGIsbnVsbCl9O2gucmVtb3ZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2guY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gMH07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2guZmE9ZnVuY3Rpb24oKXtyZXR1cm4hMX07aC5JYz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtoLlliPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O2guY2E9ZnVuY3Rpb24oKXtyZXR1cm4hMX07dmFyIGNkPW5ldyBwZDtmdW5jdGlvbiBxZChhLGIpe3RoaXMuRj1hO3kobSh0aGlzLkYpJiZudWxsIT09dGhpcy5GLFwiTGVhZk5vZGUgc2hvdWxkbid0IGJlIGNyZWF0ZWQgd2l0aCBudWxsL3VuZGVmaW5lZCB2YWx1ZS5cIik7dGhpcy5oYT1ifHxNO3JkKHRoaXMuaGEpO3RoaXMudGI9bnVsbH1oPXFkLnByb3RvdHlwZTtoLk09ZnVuY3Rpb24oKXtyZXR1cm4hMH07aC5MPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGF9O2guJD1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IHFkKHRoaXMuRixhKX07aC5LPWZ1bmN0aW9uKGEpe3JldHVyblwiLnByaW9yaXR5XCI9PT1hP3RoaXMuaGE6TX07aC5yYT1mdW5jdGlvbihhKXtyZXR1cm4gYS5lKCk/dGhpczpcIi5wcmlvcml0eVwiPT09SShhKT90aGlzLmhhOk19O2guRGE9ZnVuY3Rpb24oKXtyZXR1cm4hMX07aC5nZj1mdW5jdGlvbigpe3JldHVybiBudWxsfTtcbmguUD1mdW5jdGlvbihhLGIpe3JldHVyblwiLnByaW9yaXR5XCI9PT1hP3RoaXMuJChiKTpiLmUoKSYmXCIucHJpb3JpdHlcIiE9PWE/dGhpczpNLlAoYSxiKS4kKHRoaXMuaGEpfTtoLkQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1JKGEpO2lmKG51bGw9PT1jKXJldHVybiBiO2lmKGIuZSgpJiZcIi5wcmlvcml0eVwiIT09YylyZXR1cm4gdGhpczt5KFwiLnByaW9yaXR5XCIhPT1jfHwxPT09VGMoYSksXCIucHJpb3JpdHkgbXVzdCBiZSB0aGUgbGFzdCB0b2tlbiBpbiBhIHBhdGhcIik7cmV0dXJuIHRoaXMuUChjLE0uRChUKGEpLGIpKX07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2gudmI9ZnVuY3Rpb24oKXtyZXR1cm4gMH07aC5JPWZ1bmN0aW9uKGEpe3JldHVybiBhJiYhdGhpcy5MKCkuZSgpP3tcIi52YWx1ZVwiOnRoaXMuemEoKSxcIi5wcmlvcml0eVwiOnRoaXMuTCgpLkkoKX06dGhpcy56YSgpfTtcbmguaGFzaD1mdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLnRiKXt2YXIgYT1cIlwiO3RoaXMuaGEuZSgpfHwoYSs9XCJwcmlvcml0eTpcIitzZCh0aGlzLmhhLkkoKSkrXCI6XCIpO3ZhciBiPXR5cGVvZiB0aGlzLkYsYT1hKyhiK1wiOlwiKSxhPVwibnVtYmVyXCI9PT1iP2ErQWIodGhpcy5GKTphK3RoaXMuRjt0aGlzLnRiPWliKGEpfXJldHVybiB0aGlzLnRifTtoLnphPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuRn07aC5kZD1mdW5jdGlvbihhKXtpZihhPT09TSlyZXR1cm4gMTtpZihhIGluc3RhbmNlb2YgVylyZXR1cm4tMTt5KGEuTSgpLFwiVW5rbm93biBub2RlIHR5cGVcIik7dmFyIGI9dHlwZW9mIGEuRixjPXR5cGVvZiB0aGlzLkYsZD1HYSh0ZCxiKSxlPUdhKHRkLGMpO3koMDw9ZCxcIlVua25vd24gbGVhZiB0eXBlOiBcIitiKTt5KDA8PWUsXCJVbmtub3duIGxlYWYgdHlwZTogXCIrYyk7cmV0dXJuIGQ9PT1lP1wib2JqZWN0XCI9PT1jPzA6dGhpcy5GPGEuRj8tMTp0aGlzLkY9PT1hLkY/MDoxOmUtZH07XG52YXIgdGQ9W1wib2JqZWN0XCIsXCJib29sZWFuXCIsXCJudW1iZXJcIixcInN0cmluZ1wiXTtxZC5wcm90b3R5cGUuaGI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307cWQucHJvdG90eXBlLkJjPWZ1bmN0aW9uKCl7cmV0dXJuITB9O3FkLnByb3RvdHlwZS5hYT1mdW5jdGlvbihhKXtyZXR1cm4gYT09PXRoaXM/ITA6YS5NKCk/dGhpcy5GPT09YS5GJiZ0aGlzLmhhLmFhKGEuaGEpOiExfTtxZC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLkkoITApKX07ZnVuY3Rpb24gdWQoYSxiKXt0aGlzLnFkPWE7dGhpcy5XYj1ifXVkLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7dmFyIGI9dCh0aGlzLnFkLGEpO2lmKCFiKXRocm93IEVycm9yKFwiTm8gaW5kZXggZGVmaW5lZCBmb3IgXCIrYSk7cmV0dXJuIGI9PT1sYz9udWxsOmJ9O2Z1bmN0aW9uIHZkKGEsYixjKXt2YXIgZD13ZChhLnFkLGZ1bmN0aW9uKGQsZil7dmFyIGc9dChhLldiLGYpO3koZyxcIk1pc3NpbmcgaW5kZXggaW1wbGVtZW50YXRpb24gZm9yIFwiK2YpO2lmKGQ9PT1sYyl7aWYoZy5zZChiLlYpKXtmb3IodmFyIGs9W10sbD1jLlBiKENjKSxuPVAobCk7bjspbi5uYW1lIT1iLm5hbWUmJmsucHVzaChuKSxuPVAobCk7ay5wdXNoKGIpO3JldHVybiB4ZChrLG1jKGcpKX1yZXR1cm4gbGN9Zz1jLmdldChiLm5hbWUpO2s9ZDtnJiYoaz1rLnJlbW92ZShuZXcgTihiLm5hbWUsZykpKTtyZXR1cm4gay5MYShiLGIuVil9KTtyZXR1cm4gbmV3IHVkKGQsYS5XYil9XG5mdW5jdGlvbiB5ZChhLGIsYyl7dmFyIGQ9d2QoYS5xZCxmdW5jdGlvbihhKXtpZihhPT09bGMpcmV0dXJuIGE7dmFyIGQ9Yy5nZXQoYi5uYW1lKTtyZXR1cm4gZD9hLnJlbW92ZShuZXcgTihiLm5hbWUsZCkpOmF9KTtyZXR1cm4gbmV3IHVkKGQsYS5XYil9dmFyIHpkPW5ldyB1ZCh7XCIucHJpb3JpdHlcIjpsY30se1wiLnByaW9yaXR5XCI6TH0pO2Z1bmN0aW9uIFcoYSxiLGMpe3RoaXMubT1hOyh0aGlzLmhhPWIpJiZyZCh0aGlzLmhhKTt0aGlzLnBiPWM7dGhpcy50Yj1udWxsfWg9Vy5wcm90b3R5cGU7aC5NPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2guTD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhhfHxNfTtoLiQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBXKHRoaXMubSxhLHRoaXMucGIpfTtoLks9ZnVuY3Rpb24oYSl7aWYoXCIucHJpb3JpdHlcIj09PWEpcmV0dXJuIHRoaXMuTCgpO2E9dGhpcy5tLmdldChhKTtyZXR1cm4gbnVsbD09PWE/TTphfTtoLnJhPWZ1bmN0aW9uKGEpe3ZhciBiPUkoYSk7cmV0dXJuIG51bGw9PT1iP3RoaXM6dGhpcy5LKGIpLnJhKFQoYSkpfTtoLkRhPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT09dGhpcy5tLmdldChhKX07XG5oLlA9ZnVuY3Rpb24oYSxiKXt5KGIsXCJXZSBzaG91bGQgYWx3YXlzIGJlIHBhc3Npbmcgc25hcHNob3Qgbm9kZXNcIik7aWYoXCIucHJpb3JpdHlcIj09PWEpcmV0dXJuIHRoaXMuJChiKTt2YXIgYz1uZXcgTihhLGIpLGQ7Yi5lKCk/KGQ9dGhpcy5tLnJlbW92ZShhKSxjPXlkKHRoaXMucGIsYyx0aGlzLm0pKTooZD10aGlzLm0uTGEoYSxiKSxjPXZkKHRoaXMucGIsYyx0aGlzLm0pKTtyZXR1cm4gbmV3IFcoZCx0aGlzLmhhLGMpfTtoLkQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1JKGEpO2lmKG51bGw9PT1jKXJldHVybiBiO3koXCIucHJpb3JpdHlcIiE9PUkoYSl8fDE9PT1UYyhhKSxcIi5wcmlvcml0eSBtdXN0IGJlIHRoZSBsYXN0IHRva2VuIGluIGEgcGF0aFwiKTt2YXIgZD10aGlzLksoYykuRChUKGEpLGIpO3JldHVybiB0aGlzLlAoYyxkKX07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubS5lKCl9O2gudmI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tLmNvdW50KCl9O3ZhciBBZD0vXigwfFsxLTldXFxkKikkLztcbmg9Vy5wcm90b3R5cGU7aC5JPWZ1bmN0aW9uKGEpe2lmKHRoaXMuZSgpKXJldHVybiBudWxsO3ZhciBiPXt9LGM9MCxkPTAsZT0hMDt0aGlzLlUoTCxmdW5jdGlvbihmLGcpe2JbZl09Zy5JKGEpO2MrKztlJiZBZC50ZXN0KGYpP2Q9TWF0aC5tYXgoZCxOdW1iZXIoZikpOmU9ITF9KTtpZighYSYmZSYmZDwyKmMpe3ZhciBmPVtdLGc7Zm9yKGcgaW4gYilmW2ddPWJbZ107cmV0dXJuIGZ9YSYmIXRoaXMuTCgpLmUoKSYmKGJbXCIucHJpb3JpdHlcIl09dGhpcy5MKCkuSSgpKTtyZXR1cm4gYn07aC5oYXNoPWZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMudGIpe3ZhciBhPVwiXCI7dGhpcy5MKCkuZSgpfHwoYSs9XCJwcmlvcml0eTpcIitzZCh0aGlzLkwoKS5JKCkpK1wiOlwiKTt0aGlzLlUoTCxmdW5jdGlvbihiLGMpe3ZhciBkPWMuaGFzaCgpO1wiXCIhPT1kJiYoYSs9XCI6XCIrYitcIjpcIitkKX0pO3RoaXMudGI9XCJcIj09PWE/XCJcIjppYihhKX1yZXR1cm4gdGhpcy50Yn07XG5oLmdmPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4oYz1CZCh0aGlzLGMpKT8oYT1kZChjLG5ldyBOKGEsYikpKT9hLm5hbWU6bnVsbDpkZCh0aGlzLm0sYSl9O2Z1bmN0aW9uIEZjKGEsYil7dmFyIGM7Yz0oYz1CZChhLGIpKT8oYz1jLkljKCkpJiZjLm5hbWU6YS5tLkljKCk7cmV0dXJuIGM/bmV3IE4oYyxhLm0uZ2V0KGMpKTpudWxsfWZ1bmN0aW9uIEdjKGEsYil7dmFyIGM7Yz0oYz1CZChhLGIpKT8oYz1jLlliKCkpJiZjLm5hbWU6YS5tLlliKCk7cmV0dXJuIGM/bmV3IE4oYyxhLm0uZ2V0KGMpKTpudWxsfWguVT1mdW5jdGlvbihhLGIpe3ZhciBjPUJkKHRoaXMsYSk7cmV0dXJuIGM/Yy5mYShmdW5jdGlvbihhKXtyZXR1cm4gYihhLm5hbWUsYS5WKX0pOnRoaXMubS5mYShiKX07aC5QYj1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5RYihhLnlkKCksYSl9O1xuaC5RYj1mdW5jdGlvbihhLGIpe3ZhciBjPUJkKHRoaXMsYik7aWYoYylyZXR1cm4gYy5RYihhLGZ1bmN0aW9uKGEpe3JldHVybiBhfSk7Zm9yKHZhciBjPXRoaXMubS5RYihhLm5hbWUsQ2MpLGQ9ZmQoYyk7bnVsbCE9ZCYmMD5iLmNvbXBhcmUoZCxhKTspUChjKSxkPWZkKGMpO3JldHVybiBjfTtoLmhmPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLlNiKGEud2QoKSxhKX07aC5TYj1mdW5jdGlvbihhLGIpe3ZhciBjPUJkKHRoaXMsYik7aWYoYylyZXR1cm4gYy5TYihhLGZ1bmN0aW9uKGEpe3JldHVybiBhfSk7Zm9yKHZhciBjPXRoaXMubS5TYihhLm5hbWUsQ2MpLGQ9ZmQoYyk7bnVsbCE9ZCYmMDxiLmNvbXBhcmUoZCxhKTspUChjKSxkPWZkKGMpO3JldHVybiBjfTtoLmRkPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmUoKT9hLmUoKT8wOi0xOmEuTSgpfHxhLmUoKT8xOmE9PT1wYz8tMTowfTtcbmguaGI9ZnVuY3Rpb24oYSl7aWYoYT09PXJjfHxDZCh0aGlzLnBiLldiLGEudG9TdHJpbmcoKSkpcmV0dXJuIHRoaXM7dmFyIGI9dGhpcy5wYixjPXRoaXMubTt5KGEhPT1yYyxcIktleUluZGV4IGFsd2F5cyBleGlzdHMgYW5kIGlzbid0IG1lYW50IHRvIGJlIGFkZGVkIHRvIHRoZSBJbmRleE1hcC5cIik7Zm9yKHZhciBkPVtdLGU9ITEsYz1jLlBiKENjKSxmPVAoYyk7ZjspZT1lfHxhLnNkKGYuViksZC5wdXNoKGYpLGY9UChjKTtkPWU/eGQoZCxtYyhhKSk6bGM7ZT1hLnRvU3RyaW5nKCk7Yz1EZChiLldiKTtjW2VdPWE7YT1EZChiLnFkKTthW2VdPWQ7cmV0dXJuIG5ldyBXKHRoaXMubSx0aGlzLmhhLG5ldyB1ZChhLGMpKX07aC5CYz1mdW5jdGlvbihhKXtyZXR1cm4gYT09PXJjfHxDZCh0aGlzLnBiLldiLGEudG9TdHJpbmcoKSl9O1xuaC5hYT1mdW5jdGlvbihhKXtpZihhPT09dGhpcylyZXR1cm4hMDtpZihhLk0oKSlyZXR1cm4hMTtpZih0aGlzLkwoKS5hYShhLkwoKSkmJnRoaXMubS5jb3VudCgpPT09YS5tLmNvdW50KCkpe3ZhciBiPXRoaXMuUGIoTCk7YT1hLlBiKEwpO2Zvcih2YXIgYz1QKGIpLGQ9UChhKTtjJiZkOyl7aWYoYy5uYW1lIT09ZC5uYW1lfHwhYy5WLmFhKGQuVikpcmV0dXJuITE7Yz1QKGIpO2Q9UChhKX1yZXR1cm4gbnVsbD09PWMmJm51bGw9PT1kfXJldHVybiExfTtmdW5jdGlvbiBCZChhLGIpe3JldHVybiBiPT09cmM/bnVsbDphLnBiLmdldChiLnRvU3RyaW5nKCkpfWgudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLkkoITApKX07ZnVuY3Rpb24gTyhhLGIpe2lmKG51bGw9PT1hKXJldHVybiBNO3ZhciBjPW51bGw7XCJvYmplY3RcIj09PXR5cGVvZiBhJiZcIi5wcmlvcml0eVwiaW4gYT9jPWFbXCIucHJpb3JpdHlcIl06XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBiJiYoYz1iKTt5KG51bGw9PT1jfHxcInN0cmluZ1wiPT09dHlwZW9mIGN8fFwibnVtYmVyXCI9PT10eXBlb2YgY3x8XCJvYmplY3RcIj09PXR5cGVvZiBjJiZcIi5zdlwiaW4gYyxcIkludmFsaWQgcHJpb3JpdHkgdHlwZSBmb3VuZDogXCIrdHlwZW9mIGMpO1wib2JqZWN0XCI9PT10eXBlb2YgYSYmXCIudmFsdWVcImluIGEmJm51bGwhPT1hW1wiLnZhbHVlXCJdJiYoYT1hW1wiLnZhbHVlXCJdKTtpZihcIm9iamVjdFwiIT09dHlwZW9mIGF8fFwiLnN2XCJpbiBhKXJldHVybiBuZXcgcWQoYSxPKGMpKTtpZihhIGluc3RhbmNlb2YgQXJyYXkpe3ZhciBkPU0sZT1hO0EoZSxmdW5jdGlvbihhLGIpe2lmKHMoZSxiKSYmXCIuXCIhPT1iLnN1YnN0cmluZygwLDEpKXt2YXIgYz1PKGEpO2lmKGMuTSgpfHwhYy5lKCkpZD1cbmQuUChiLGMpfX0pO3JldHVybiBkLiQoTyhjKSl9dmFyIGY9W10sZz0hMSxrPWE7dWEoayxmdW5jdGlvbihhKXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGF8fFwiLlwiIT09YS5zdWJzdHJpbmcoMCwxKSl7dmFyIGI9TyhrW2FdKTtiLmUoKXx8KGc9Z3x8IWIuTCgpLmUoKSxmLnB1c2gobmV3IE4oYSxiKSkpfX0pO3ZhciBsPXhkKGYsaWMsZnVuY3Rpb24oYSl7cmV0dXJuIGEubmFtZX0samMpO2lmKGcpe3ZhciBuPXhkKGYsbWMoTCkpO3JldHVybiBuZXcgVyhsLE8oYyksbmV3IHVkKHtcIi5wcmlvcml0eVwiOm59LHtcIi5wcmlvcml0eVwiOkx9KSl9cmV0dXJuIG5ldyBXKGwsTyhjKSx6ZCl9dmFyIEVkPU1hdGgubG9nKDIpO2Z1bmN0aW9uIEZkKGEpe3RoaXMuY291bnQ9cGFyc2VJbnQoTWF0aC5sb2coYSsxKS9FZCwxMCk7dGhpcy5hZj10aGlzLmNvdW50LTE7dGhpcy5OZj1hKzEmcGFyc2VJbnQoQXJyYXkodGhpcy5jb3VudCsxKS5qb2luKFwiMVwiKSwyKX1cbmZ1bmN0aW9uIEdkKGEpe3ZhciBiPSEoYS5OZiYxPDxhLmFmKTthLmFmLS07cmV0dXJuIGJ9XG5mdW5jdGlvbiB4ZChhLGIsYyxkKXtmdW5jdGlvbiBlKGIsZCl7dmFyIGY9ZC1iO2lmKDA9PWYpcmV0dXJuIG51bGw7aWYoMT09Zil7dmFyIG49YVtiXSx1PWM/YyhuKTpuO3JldHVybiBuZXcgZ2QodSxuLlYsITEsbnVsbCxudWxsKX12YXIgbj1wYXJzZUludChmLzIsMTApK2IsZj1lKGIsbikseD1lKG4rMSxkKSxuPWFbbl0sdT1jP2Mobik6bjtyZXR1cm4gbmV3IGdkKHUsbi5WLCExLGYseCl9YS5zb3J0KGIpO3ZhciBmPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGQoYixnKXt2YXIgaz11LWIseD11O3UtPWI7dmFyIHg9ZShrKzEseCksaz1hW2tdLEY9Yz9jKGspOmsseD1uZXcgZ2QoRixrLlYsZyxudWxsLHgpO2Y/Zi5sZWZ0PXg6bj14O2Y9eH1mb3IodmFyIGY9bnVsbCxuPW51bGwsdT1hLmxlbmd0aCx4PTA7eDxiLmNvdW50OysreCl7dmFyIEY9R2QoYiksbGQ9TWF0aC5wb3coMixiLmNvdW50LSh4KzEpKTtGP2QobGQsITEpOihkKGxkLCExKSxkKGxkLCEwKSl9cmV0dXJuIG59KG5ldyBGZChhLmxlbmd0aCkpO1xucmV0dXJuIG51bGwhPT1mP25ldyBiZChkfHxiLGYpOm5ldyBiZChkfHxiKX1mdW5jdGlvbiBzZChhKXtyZXR1cm5cIm51bWJlclwiPT09dHlwZW9mIGE/XCJudW1iZXI6XCIrQWIoYSk6XCJzdHJpbmc6XCIrYX1mdW5jdGlvbiByZChhKXtpZihhLk0oKSl7dmFyIGI9YS5JKCk7eShcInN0cmluZ1wiPT09dHlwZW9mIGJ8fFwibnVtYmVyXCI9PT10eXBlb2YgYnx8XCJvYmplY3RcIj09PXR5cGVvZiBiJiZzKGIsXCIuc3ZcIiksXCJQcmlvcml0eSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlci5cIil9ZWxzZSB5KGE9PT1wY3x8YS5lKCksXCJwcmlvcml0eSBvZiB1bmV4cGVjdGVkIHR5cGUuXCIpO3koYT09PXBjfHxhLkwoKS5lKCksXCJQcmlvcml0eSBub2RlcyBjYW4ndCBoYXZlIGEgcHJpb3JpdHkgb2YgdGhlaXIgb3duLlwiKX12YXIgTT1uZXcgVyhuZXcgYmQoamMpLG51bGwsemQpO2Z1bmN0aW9uIEhkKCl7Vy5jYWxsKHRoaXMsbmV3IGJkKGpjKSxNLHpkKX1tYShIZCxXKTtoPUhkLnByb3RvdHlwZTtcbmguZGQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT10aGlzPzA6MX07aC5hYT1mdW5jdGlvbihhKXtyZXR1cm4gYT09PXRoaXN9O2guTD1mdW5jdGlvbigpe3Rocm93IGZiKFwiV2h5IGlzIHRoaXMgY2FsbGVkP1wiKTt9O2guSz1mdW5jdGlvbigpe3JldHVybiBNfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4hMX07dmFyIHBjPW5ldyBIZCxuYz1uZXcgTihcIltNSU5fTkFNRV1cIixNKSx0Yz1uZXcgTihcIltNQVhfTkFNRV1cIixwYyk7ZnVuY3Rpb24gRChhLGIsYyl7dGhpcy5BPWE7dGhpcy5XPWI7dGhpcy5nPWN9RC5wcm90b3R5cGUuST1mdW5jdGlvbigpe0UoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QudmFsXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuSSgpfTtELnByb3RvdHlwZS52YWw9RC5wcm90b3R5cGUuSTtELnByb3RvdHlwZS5jZj1mdW5jdGlvbigpe0UoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZXhwb3J0VmFsXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuSSghMCl9O0QucHJvdG90eXBlLmV4cG9ydFZhbD1ELnByb3RvdHlwZS5jZjtELnByb3RvdHlwZS5XZj1mdW5jdGlvbigpe0UoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZXhpc3RzXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiF0aGlzLkEuZSgpfTtELnByb3RvdHlwZS5leGlzdHM9RC5wcm90b3R5cGUuV2Y7XG5ELnByb3RvdHlwZS51PWZ1bmN0aW9uKGEpe0UoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuY2hpbGRcIiwwLDEsYXJndW1lbnRzLmxlbmd0aCk7Z2EoYSkmJihhPVN0cmluZyhhKSk7WWIoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuY2hpbGRcIixhKTt2YXIgYj1uZXcgUyhhKSxjPXRoaXMuVy51KGIpO3JldHVybiBuZXcgRCh0aGlzLkEucmEoYiksYyxMKX07RC5wcm90b3R5cGUuY2hpbGQ9RC5wcm90b3R5cGUudTtELnByb3RvdHlwZS5EYT1mdW5jdGlvbihhKXtFKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90Lmhhc0NoaWxkXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO1liKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90Lmhhc0NoaWxkXCIsYSk7dmFyIGI9bmV3IFMoYSk7cmV0dXJuIXRoaXMuQS5yYShiKS5lKCl9O0QucHJvdG90eXBlLmhhc0NoaWxkPUQucHJvdG90eXBlLkRhO1xuRC5wcm90b3R5cGUuTD1mdW5jdGlvbigpe0UoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZ2V0UHJpb3JpdHlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuQS5MKCkuSSgpfTtELnByb3RvdHlwZS5nZXRQcmlvcml0eT1ELnByb3RvdHlwZS5MO0QucHJvdG90eXBlLmZvckVhY2g9ZnVuY3Rpb24oYSl7RShcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5mb3JFYWNoXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO0goXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZm9yRWFjaFwiLDEsYSwhMSk7aWYodGhpcy5BLk0oKSlyZXR1cm4hMTt2YXIgYj10aGlzO3JldHVybiEhdGhpcy5BLlUodGhpcy5nLGZ1bmN0aW9uKGMsZCl7cmV0dXJuIGEobmV3IEQoZCxiLlcudShjKSxMKSl9KX07RC5wcm90b3R5cGUuZm9yRWFjaD1ELnByb3RvdHlwZS5mb3JFYWNoO1xuRC5wcm90b3R5cGUubWQ9ZnVuY3Rpb24oKXtFKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90Lmhhc0NoaWxkcmVuXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuTSgpPyExOiF0aGlzLkEuZSgpfTtELnByb3RvdHlwZS5oYXNDaGlsZHJlbj1ELnByb3RvdHlwZS5tZDtELnByb3RvdHlwZS5uYW1lPWZ1bmN0aW9uKCl7eihcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5uYW1lKCkgYmVpbmcgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBGaXJlYmFzZS5EYXRhU25hcHNob3Qua2V5KCkgaW5zdGVhZC5cIik7RShcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5uYW1lXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLmtleSgpfTtELnByb3RvdHlwZS5uYW1lPUQucHJvdG90eXBlLm5hbWU7RC5wcm90b3R5cGUua2V5PWZ1bmN0aW9uKCl7RShcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5rZXlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuVy5rZXkoKX07XG5ELnByb3RvdHlwZS5rZXk9RC5wcm90b3R5cGUua2V5O0QucHJvdG90eXBlLnZiPWZ1bmN0aW9uKCl7RShcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5udW1DaGlsZHJlblwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLnZiKCl9O0QucHJvdG90eXBlLm51bUNoaWxkcmVuPUQucHJvdG90eXBlLnZiO0QucHJvdG90eXBlLmRjPWZ1bmN0aW9uKCl7RShcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5yZWZcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuV307RC5wcm90b3R5cGUucmVmPUQucHJvdG90eXBlLmRjO2Z1bmN0aW9uIElkKGEpe3koZWEoYSkmJjA8YS5sZW5ndGgsXCJSZXF1aXJlcyBhIG5vbi1lbXB0eSBhcnJheVwiKTt0aGlzLkZmPWE7dGhpcy5HYz17fX1JZC5wcm90b3R5cGUuJGQ9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9dGhpcy5HY1thXXx8W10sZD0wO2Q8Yy5sZW5ndGg7ZCsrKWNbZF0ucmMuYXBwbHkoY1tkXS5LYSxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpfTtJZC5wcm90b3R5cGUud2I9ZnVuY3Rpb24oYSxiLGMpe0pkKHRoaXMsYSk7dGhpcy5HY1thXT10aGlzLkdjW2FdfHxbXTt0aGlzLkdjW2FdLnB1c2goe3JjOmIsS2E6Y30pOyhhPXRoaXMudWUoYSkpJiZiLmFwcGx5KGMsYSl9O0lkLnByb3RvdHlwZS4kYj1mdW5jdGlvbihhLGIsYyl7SmQodGhpcyxhKTthPXRoaXMuR2NbYV18fFtdO2Zvcih2YXIgZD0wO2Q8YS5sZW5ndGg7ZCsrKWlmKGFbZF0ucmM9PT1iJiYoIWN8fGM9PT1hW2RdLkthKSl7YS5zcGxpY2UoZCwxKTticmVha319O1xuZnVuY3Rpb24gSmQoYSxiKXt5KE1hKGEuRmYsZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1ifSksXCJVbmtub3duIGV2ZW50OiBcIitiKX07ZnVuY3Rpb24gS2QoKXtJZC5jYWxsKHRoaXMsW1widmlzaWJsZVwiXSk7dmFyIGEsYjtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXImJihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50LmhpZGRlbj8oYj1cInZpc2liaWxpdHljaGFuZ2VcIixhPVwiaGlkZGVuXCIpOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQubW96SGlkZGVuPyhiPVwibW96dmlzaWJpbGl0eWNoYW5nZVwiLGE9XCJtb3pIaWRkZW5cIik6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudC5tc0hpZGRlbj8oYj1cIm1zdmlzaWJpbGl0eWNoYW5nZVwiLGE9XCJtc0hpZGRlblwiKTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50LndlYmtpdEhpZGRlbiYmKGI9XCJ3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlXCIsYT1cIndlYmtpdEhpZGRlblwiKSk7dGhpcy5uYz0hMDtpZihiKXt2YXIgYz10aGlzO2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoYixcbmZ1bmN0aW9uKCl7dmFyIGI9IWRvY3VtZW50W2FdO2IhPT1jLm5jJiYoYy5uYz1iLGMuJGQoXCJ2aXNpYmxlXCIsYikpfSwhMSl9fW1hKEtkLElkKTtjYShLZCk7S2QucHJvdG90eXBlLnVlPWZ1bmN0aW9uKGEpe3koXCJ2aXNpYmxlXCI9PT1hLFwiVW5rbm93biBldmVudCB0eXBlOiBcIithKTtyZXR1cm5bdGhpcy5uY119O2Z1bmN0aW9uIEEoYSxiKXtmb3IodmFyIGMgaW4gYSliLmNhbGwodm9pZCAwLGFbY10sYyxhKX1mdW5jdGlvbiB3ZChhLGIpe3ZhciBjPXt9LGQ7Zm9yKGQgaW4gYSljW2RdPWIuY2FsbCh2b2lkIDAsYVtkXSxkLGEpO3JldHVybiBjfWZ1bmN0aW9uIExiKGEsYil7Zm9yKHZhciBjIGluIGEpaWYoIWIuY2FsbCh2b2lkIDAsYVtjXSxjLGEpKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIEpiKGEpe3ZhciBiPTAsYztmb3IoYyBpbiBhKWIrKztyZXR1cm4gYn1mdW5jdGlvbiBLYihhKXtmb3IodmFyIGIgaW4gYSlyZXR1cm4gYn1mdW5jdGlvbiBMZChhKXt2YXIgYj1bXSxjPTAsZDtmb3IoZCBpbiBhKWJbYysrXT1hW2RdO3JldHVybiBifWZ1bmN0aW9uIE1kKGEpe3ZhciBiPVtdLGM9MCxkO2ZvcihkIGluIGEpYltjKytdPWQ7cmV0dXJuIGJ9ZnVuY3Rpb24gQ2QoYSxiKXtmb3IodmFyIGMgaW4gYSlpZihhW2NdPT1iKXJldHVybiEwO3JldHVybiExfVxuZnVuY3Rpb24gTmQoYSxiLGMpe2Zvcih2YXIgZCBpbiBhKWlmKGIuY2FsbChjLGFbZF0sZCxhKSlyZXR1cm4gZH1mdW5jdGlvbiBPZChhLGIpe3ZhciBjPU5kKGEsYix2b2lkIDApO3JldHVybiBjJiZhW2NdfWZ1bmN0aW9uIFBkKGEpe2Zvcih2YXIgYiBpbiBhKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIFFkKGEsYil7cmV0dXJuIGIgaW4gYT9hW2JdOnZvaWQgMH1mdW5jdGlvbiBEZChhKXt2YXIgYj17fSxjO2ZvcihjIGluIGEpYltjXT1hW2NdO3JldHVybiBifXZhciBSZD1cImNvbnN0cnVjdG9yIGhhc093blByb3BlcnR5IGlzUHJvdG90eXBlT2YgcHJvcGVydHlJc0VudW1lcmFibGUgdG9Mb2NhbGVTdHJpbmcgdG9TdHJpbmcgdmFsdWVPZlwiLnNwbGl0KFwiIFwiKTtcbmZ1bmN0aW9uIFNkKGEsYil7Zm9yKHZhciBjLGQsZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe2Q9YXJndW1lbnRzW2VdO2ZvcihjIGluIGQpYVtjXT1kW2NdO2Zvcih2YXIgZj0wO2Y8UmQubGVuZ3RoO2YrKyljPVJkW2ZdLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkLGMpJiYoYVtjXT1kW2NdKX19O2Z1bmN0aW9uIFRkKCl7dGhpcy51Yz17fX1mdW5jdGlvbiBVZChhLGIsYyl7bShjKXx8KGM9MSk7cyhhLnVjLGIpfHwoYS51Y1tiXT0wKTthLnVjW2JdKz1jfVRkLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gRGQodGhpcy51Yyl9O2Z1bmN0aW9uIFZkKGEpe3RoaXMuUGY9YTt0aGlzLnRkPW51bGx9VmQucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuUGYuZ2V0KCksYj1EZChhKTtpZih0aGlzLnRkKWZvcih2YXIgYyBpbiB0aGlzLnRkKWJbY10tPXRoaXMudGRbY107dGhpcy50ZD1hO3JldHVybiBifTtmdW5jdGlvbiBXZChhLGIpe3RoaXMuemY9e307dGhpcy5VZD1uZXcgVmQoYSk7dGhpcy5TPWI7dmFyIGM9MUU0KzJFNCpNYXRoLnJhbmRvbSgpO3NldFRpbWVvdXQocSh0aGlzLnRmLHRoaXMpLE1hdGguZmxvb3IoYykpfVdkLnByb3RvdHlwZS50Zj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuVWQuZ2V0KCksYj17fSxjPSExLGQ7Zm9yKGQgaW4gYSkwPGFbZF0mJnModGhpcy56ZixkKSYmKGJbZF09YVtkXSxjPSEwKTtjJiYoYT10aGlzLlMsYS5qYSYmKGI9e2M6Yn0sYS5mKFwicmVwb3J0U3RhdHNcIixiKSxhLkJhKFwic1wiLGIpKSk7c2V0VGltZW91dChxKHRoaXMudGYsdGhpcyksTWF0aC5mbG9vcig2RTUqTWF0aC5yYW5kb20oKSkpfTt2YXIgWGQ9e30sWWQ9e307ZnVuY3Rpb24gWmQoYSl7YT1hLnRvU3RyaW5nKCk7WGRbYV18fChYZFthXT1uZXcgVGQpO3JldHVybiBYZFthXX1mdW5jdGlvbiAkZChhLGIpe3ZhciBjPWEudG9TdHJpbmcoKTtZZFtjXXx8KFlkW2NdPWIoKSk7cmV0dXJuIFlkW2NdfTt2YXIgYWU9bnVsbDtcInVuZGVmaW5lZFwiIT09dHlwZW9mIE1veldlYlNvY2tldD9hZT1Nb3pXZWJTb2NrZXQ6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBXZWJTb2NrZXQmJihhZT1XZWJTb2NrZXQpO2Z1bmN0aW9uIGJlKGEsYixjKXt0aGlzLm1lPWE7dGhpcy5mPW9iKHRoaXMubWUpO3RoaXMuZnJhbWVzPXRoaXMuQ2M9bnVsbDt0aGlzLmpiPXRoaXMua2I9dGhpcy5VZT0wO3RoaXMuUmE9WmQoYik7dGhpcy4kYT0oYi5CYj9cIndzczovL1wiOlwid3M6Ly9cIikrYi5NYStcIi8ud3M/dj01XCI7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBsb2NhdGlvbiYmbG9jYXRpb24uaHJlZiYmLTEhPT1sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJmaXJlYmFzZWlvLmNvbVwiKSYmKHRoaXMuJGErPVwiJnI9ZlwiKTtiLmhvc3QhPT1iLk1hJiYodGhpcy4kYT10aGlzLiRhK1wiJm5zPVwiK2IudWIpO2MmJih0aGlzLiRhPXRoaXMuJGErXCImcz1cIitjKX12YXIgY2U7XG5iZS5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIpe3RoaXMuZmI9Yjt0aGlzLmhnPWE7dGhpcy5mKFwiV2Vic29ja2V0IGNvbm5lY3RpbmcgdG8gXCIrdGhpcy4kYSk7dGhpcy55Yz0hMTt6YS5zZXQoXCJwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZVwiLCEwKTt0cnl7dGhpcy51YT1uZXcgYWUodGhpcy4kYSl9Y2F0Y2goYyl7dGhpcy5mKFwiRXJyb3IgaW5zdGFudGlhdGluZyBXZWJTb2NrZXQuXCIpO3ZhciBkPWMubWVzc2FnZXx8Yy5kYXRhO2QmJnRoaXMuZihkKTt0aGlzLmViKCk7cmV0dXJufXZhciBlPXRoaXM7dGhpcy51YS5vbm9wZW49ZnVuY3Rpb24oKXtlLmYoXCJXZWJzb2NrZXQgY29ubmVjdGVkLlwiKTtlLnljPSEwfTt0aGlzLnVhLm9uY2xvc2U9ZnVuY3Rpb24oKXtlLmYoXCJXZWJzb2NrZXQgY29ubmVjdGlvbiB3YXMgZGlzY29ubmVjdGVkLlwiKTtlLnVhPW51bGw7ZS5lYigpfTt0aGlzLnVhLm9ubWVzc2FnZT1mdW5jdGlvbihhKXtpZihudWxsIT09ZS51YSlpZihhPWEuZGF0YSxlLmpiKz1cbmEubGVuZ3RoLFVkKGUuUmEsXCJieXRlc19yZWNlaXZlZFwiLGEubGVuZ3RoKSxkZShlKSxudWxsIT09ZS5mcmFtZXMpZWUoZSxhKTtlbHNle2E6e3kobnVsbD09PWUuZnJhbWVzLFwiV2UgYWxyZWFkeSBoYXZlIGEgZnJhbWUgYnVmZmVyXCIpO2lmKDY+PWEubGVuZ3RoKXt2YXIgYj1OdW1iZXIoYSk7aWYoIWlzTmFOKGIpKXtlLlVlPWI7ZS5mcmFtZXM9W107YT1udWxsO2JyZWFrIGF9fWUuVWU9MTtlLmZyYW1lcz1bXX1udWxsIT09YSYmZWUoZSxhKX19O3RoaXMudWEub25lcnJvcj1mdW5jdGlvbihhKXtlLmYoXCJXZWJTb2NrZXQgZXJyb3IuICBDbG9zaW5nIGNvbm5lY3Rpb24uXCIpOyhhPWEubWVzc2FnZXx8YS5kYXRhKSYmZS5mKGEpO2UuZWIoKX19O2JlLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe307XG5iZS5pc0F2YWlsYWJsZT1mdW5jdGlvbigpe3ZhciBhPSExO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IudXNlckFnZW50KXt2YXIgYj1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkIChbMC05XXswLH1cXC5bMC05XXswLH0pLyk7YiYmMTxiLmxlbmd0aCYmNC40PnBhcnNlRmxvYXQoYlsxXSkmJihhPSEwKX1yZXR1cm4hYSYmbnVsbCE9PWFlJiYhY2V9O2JlLnJlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHk9MjtiZS5oZWFsdGh5VGltZW91dD0zRTQ7aD1iZS5wcm90b3R5cGU7aC52ZD1mdW5jdGlvbigpe3phLnJlbW92ZShcInByZXZpb3VzX3dlYnNvY2tldF9mYWlsdXJlXCIpfTtmdW5jdGlvbiBlZShhLGIpe2EuZnJhbWVzLnB1c2goYik7aWYoYS5mcmFtZXMubGVuZ3RoPT1hLlVlKXt2YXIgYz1hLmZyYW1lcy5qb2luKFwiXCIpO2EuZnJhbWVzPW51bGw7Yz10YShjKTthLmhnKGMpfX1cbmguc2VuZD1mdW5jdGlvbihhKXtkZSh0aGlzKTthPXIoYSk7dGhpcy5rYis9YS5sZW5ndGg7VWQodGhpcy5SYSxcImJ5dGVzX3NlbnRcIixhLmxlbmd0aCk7YT15YihhLDE2Mzg0KTsxPGEubGVuZ3RoJiZ0aGlzLnVhLnNlbmQoU3RyaW5nKGEubGVuZ3RoKSk7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspdGhpcy51YS5zZW5kKGFbYl0pfTtoLlVjPWZ1bmN0aW9uKCl7dGhpcy5yYj0hMDt0aGlzLkNjJiYoY2xlYXJJbnRlcnZhbCh0aGlzLkNjKSx0aGlzLkNjPW51bGwpO3RoaXMudWEmJih0aGlzLnVhLmNsb3NlKCksdGhpcy51YT1udWxsKX07aC5lYj1mdW5jdGlvbigpe3RoaXMucmJ8fCh0aGlzLmYoXCJXZWJTb2NrZXQgaXMgY2xvc2luZyBpdHNlbGZcIiksdGhpcy5VYygpLHRoaXMuZmImJih0aGlzLmZiKHRoaXMueWMpLHRoaXMuZmI9bnVsbCkpfTtoLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy5yYnx8KHRoaXMuZihcIldlYlNvY2tldCBpcyBiZWluZyBjbG9zZWRcIiksdGhpcy5VYygpKX07XG5mdW5jdGlvbiBkZShhKXtjbGVhckludGVydmFsKGEuQ2MpO2EuQ2M9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXthLnVhJiZhLnVhLnNlbmQoXCIwXCIpO2RlKGEpfSxNYXRoLmZsb29yKDQ1RTMpKX07ZnVuY3Rpb24gZmUoYSl7dGhpcy5hYz1hO3RoaXMuSGQ9W107dGhpcy5KYj0wO3RoaXMubGU9LTE7dGhpcy54Yj1udWxsfWZ1bmN0aW9uIGdlKGEsYixjKXthLmxlPWI7YS54Yj1jO2EubGU8YS5KYiYmKGEueGIoKSxhLnhiPW51bGwpfWZ1bmN0aW9uIGhlKGEsYixjKXtmb3IoYS5IZFtiXT1jO2EuSGRbYS5KYl07KXt2YXIgZD1hLkhkW2EuSmJdO2RlbGV0ZSBhLkhkW2EuSmJdO2Zvcih2YXIgZT0wO2U8ZC5sZW5ndGg7KytlKWlmKGRbZV0pe3ZhciBmPWE7Q2IoZnVuY3Rpb24oKXtmLmFjKGRbZV0pfSl9aWYoYS5KYj09PWEubGUpe2EueGImJihjbGVhclRpbWVvdXQoYS54YiksYS54YigpLGEueGI9bnVsbCk7YnJlYWt9YS5KYisrfX07ZnVuY3Rpb24gaWUoKXt0aGlzLnNldD17fX1oPWllLnByb3RvdHlwZTtoLmFkZD1mdW5jdGlvbihhLGIpe3RoaXMuc2V0W2FdPW51bGwhPT1iP2I6ITB9O2guY29udGFpbnM9ZnVuY3Rpb24oYSl7cmV0dXJuIHModGhpcy5zZXQsYSl9O2guZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmNvbnRhaW5zKGEpP3RoaXMuc2V0W2FdOnZvaWQgMH07aC5yZW1vdmU9ZnVuY3Rpb24oYSl7ZGVsZXRlIHRoaXMuc2V0W2FdfTtoLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5zZXQ9e319O2guZT1mdW5jdGlvbigpe3JldHVybiBQZCh0aGlzLnNldCl9O2guY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gSmIodGhpcy5zZXQpfTtmdW5jdGlvbiBqZShhLGIpe0EoYS5zZXQsZnVuY3Rpb24oYSxkKXtiKGQsYSl9KX07ZnVuY3Rpb24ga2UoYSxiLGMpe3RoaXMubWU9YTt0aGlzLmY9b2IoYSk7dGhpcy5qYj10aGlzLmtiPTA7dGhpcy5SYT1aZChiKTt0aGlzLlJkPWM7dGhpcy55Yz0hMTt0aGlzLlpjPWZ1bmN0aW9uKGEpe2IuaG9zdCE9PWIuTWEmJihhLm5zPWIudWIpO3ZhciBjPVtdLGY7Zm9yKGYgaW4gYSlhLmhhc093blByb3BlcnR5KGYpJiZjLnB1c2goZitcIj1cIithW2ZdKTtyZXR1cm4oYi5CYj9cImh0dHBzOi8vXCI6XCJodHRwOi8vXCIpK2IuTWErXCIvLmxwP1wiK2Muam9pbihcIiZcIil9fXZhciBsZSxtZTtcbmtlLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYil7dGhpcy4kZT0wO3RoaXMuZ2E9Yjt0aGlzLm1mPW5ldyBmZShhKTt0aGlzLnJiPSExO3ZhciBjPXRoaXM7dGhpcy5tYj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5mKFwiVGltZWQgb3V0IHRyeWluZyB0byBjb25uZWN0LlwiKTtjLmViKCk7Yy5tYj1udWxsfSxNYXRoLmZsb29yKDNFNCkpO3RiKGZ1bmN0aW9uKCl7aWYoIWMucmIpe2MuUGE9bmV3IG5lKGZ1bmN0aW9uKGEsYixkLGssbCl7b2UoYyxhcmd1bWVudHMpO2lmKGMuUGEpaWYoYy5tYiYmKGNsZWFyVGltZW91dChjLm1iKSxjLm1iPW51bGwpLGMueWM9ITAsXCJzdGFydFwiPT1hKWMuaWQ9YixjLnJmPWQ7ZWxzZSBpZihcImNsb3NlXCI9PT1hKWI/KGMuUGEuUGQ9ITEsZ2UoYy5tZixiLGZ1bmN0aW9uKCl7Yy5lYigpfSkpOmMuZWIoKTtlbHNlIHRocm93IEVycm9yKFwiVW5yZWNvZ25pemVkIGNvbW1hbmQgcmVjZWl2ZWQ6IFwiK2EpO30sZnVuY3Rpb24oYSxiKXtvZShjLGFyZ3VtZW50cyk7XG5oZShjLm1mLGEsYil9LGZ1bmN0aW9uKCl7Yy5lYigpfSxjLlpjKTt2YXIgYT17c3RhcnQ6XCJ0XCJ9O2Euc2VyPU1hdGguZmxvb3IoMUU4Kk1hdGgucmFuZG9tKCkpO2MuUGEuYWUmJihhLmNiPWMuUGEuYWUpO2Eudj1cIjVcIjtjLlJkJiYoYS5zPWMuUmQpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgbG9jYXRpb24mJmxvY2F0aW9uLmhyZWYmJi0xIT09bG9jYXRpb24uaHJlZi5pbmRleE9mKFwiZmlyZWJhc2Vpby5jb21cIikmJihhLnI9XCJmXCIpO2E9Yy5aYyhhKTtjLmYoXCJDb25uZWN0aW5nIHZpYSBsb25nLXBvbGwgdG8gXCIrYSk7cGUoYy5QYSxhLGZ1bmN0aW9uKCl7fSl9fSl9O1xua2UucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5QYSxiPXRoaXMucmY7YS5jZz10aGlzLmlkO2EuZGc9Yjtmb3IoYS5mZT0hMDtxZShhKTspO2E9dGhpcy5pZDtiPXRoaXMucmY7dGhpcy5aYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO3ZhciBjPXtkZnJhbWU6XCJ0XCJ9O2MuaWQ9YTtjLnB3PWI7dGhpcy5aYi5zcmM9dGhpcy5aYyhjKTt0aGlzLlpiLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLlpiKX07a2UuaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hbWUmJiEoXCJvYmplY3RcIj09PXR5cGVvZiB3aW5kb3cmJndpbmRvdy5jaHJvbWUmJndpbmRvdy5jaHJvbWUuZXh0ZW5zaW9uJiYhL15jaHJvbWUvLnRlc3Qod2luZG93LmxvY2F0aW9uLmhyZWYpKSYmIShcIm9iamVjdFwiPT09dHlwZW9mIFdpbmRvd3MmJlwib2JqZWN0XCI9PT10eXBlb2YgV2luZG93cy5GZykmJihsZXx8ITApfTtoPWtlLnByb3RvdHlwZTtcbmgudmQ9ZnVuY3Rpb24oKXt9O2guVWM9ZnVuY3Rpb24oKXt0aGlzLnJiPSEwO3RoaXMuUGEmJih0aGlzLlBhLmNsb3NlKCksdGhpcy5QYT1udWxsKTt0aGlzLlpiJiYoZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLlpiKSx0aGlzLlpiPW51bGwpO3RoaXMubWImJihjbGVhclRpbWVvdXQodGhpcy5tYiksdGhpcy5tYj1udWxsKX07aC5lYj1mdW5jdGlvbigpe3RoaXMucmJ8fCh0aGlzLmYoXCJMb25ncG9sbCBpcyBjbG9zaW5nIGl0c2VsZlwiKSx0aGlzLlVjKCksdGhpcy5nYSYmKHRoaXMuZ2EodGhpcy55YyksdGhpcy5nYT1udWxsKSl9O2guY2xvc2U9ZnVuY3Rpb24oKXt0aGlzLnJifHwodGhpcy5mKFwiTG9uZ3BvbGwgaXMgYmVpbmcgY2xvc2VkLlwiKSx0aGlzLlVjKCkpfTtcbmguc2VuZD1mdW5jdGlvbihhKXthPXIoYSk7dGhpcy5rYis9YS5sZW5ndGg7VWQodGhpcy5SYSxcImJ5dGVzX3NlbnRcIixhLmxlbmd0aCk7YT1qYihhKTthPWNiKGEsITApO2E9eWIoYSwxODQwKTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5QYTtjLlFjLnB1c2goe3VnOnRoaXMuJGUsQ2c6YS5sZW5ndGgsYmY6YVtiXX0pO2MuZmUmJnFlKGMpO3RoaXMuJGUrK319O2Z1bmN0aW9uIG9lKGEsYil7dmFyIGM9cihiKS5sZW5ndGg7YS5qYis9YztVZChhLlJhLFwiYnl0ZXNfcmVjZWl2ZWRcIixjKX1cbmZ1bmN0aW9uIG5lKGEsYixjLGQpe3RoaXMuWmM9ZDt0aGlzLmZiPWM7dGhpcy5KZT1uZXcgaWU7dGhpcy5RYz1bXTt0aGlzLm9lPU1hdGguZmxvb3IoMUU4Kk1hdGgucmFuZG9tKCkpO3RoaXMuUGQ9ITA7dGhpcy5hZT1lYigpO3dpbmRvd1tcInBMUENvbW1hbmRcIit0aGlzLmFlXT1hO3dpbmRvd1tcInBSVExQQ0JcIit0aGlzLmFlXT1iO2E9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTthLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7aWYoZG9jdW1lbnQuYm9keSl7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTt0cnl7YS5jb250ZW50V2luZG93LmRvY3VtZW50fHxoYihcIk5vIElFIGRvbWFpbiBzZXR0aW5nIHJlcXVpcmVkXCIpfWNhdGNoKGUpe2Euc3JjPVwiamF2YXNjcmlwdDp2b2lkKChmdW5jdGlvbigpe2RvY3VtZW50Lm9wZW4oKTtkb2N1bWVudC5kb21haW49J1wiK2RvY3VtZW50LmRvbWFpbitcIic7ZG9jdW1lbnQuY2xvc2UoKTt9KSgpKVwifX1lbHNlIHRocm93XCJEb2N1bWVudCBib2R5IGhhcyBub3QgaW5pdGlhbGl6ZWQuIFdhaXQgdG8gaW5pdGlhbGl6ZSBGaXJlYmFzZSB1bnRpbCBhZnRlciB0aGUgZG9jdW1lbnQgaXMgcmVhZHkuXCI7XG5hLmNvbnRlbnREb2N1bWVudD9hLmFiPWEuY29udGVudERvY3VtZW50OmEuY29udGVudFdpbmRvdz9hLmFiPWEuY29udGVudFdpbmRvdy5kb2N1bWVudDphLmRvY3VtZW50JiYoYS5hYj1hLmRvY3VtZW50KTt0aGlzLkFhPWE7YT1cIlwiO3RoaXMuQWEuc3JjJiZcImphdmFzY3JpcHQ6XCI9PT10aGlzLkFhLnNyYy5zdWJzdHIoMCwxMSkmJihhPSc8c2NyaXB0PmRvY3VtZW50LmRvbWFpbj1cIicrZG9jdW1lbnQuZG9tYWluKydcIjtcXHgzYy9zY3JpcHQ+Jyk7YT1cIjxodG1sPjxib2R5PlwiK2ErXCI8L2JvZHk+PC9odG1sPlwiO3RyeXt0aGlzLkFhLmFiLm9wZW4oKSx0aGlzLkFhLmFiLndyaXRlKGEpLHRoaXMuQWEuYWIuY2xvc2UoKX1jYXRjaChmKXtoYihcImZyYW1lIHdyaXRpbmcgZXhjZXB0aW9uXCIpLGYuc3RhY2smJmhiKGYuc3RhY2spLGhiKGYpfX1cbm5lLnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbigpe3RoaXMuZmU9ITE7aWYodGhpcy5BYSl7dGhpcy5BYS5hYi5ib2R5LmlubmVySFRNTD1cIlwiO3ZhciBhPXRoaXM7c2V0VGltZW91dChmdW5jdGlvbigpe251bGwhPT1hLkFhJiYoZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhLkFhKSxhLkFhPW51bGwpfSxNYXRoLmZsb29yKDApKX12YXIgYj10aGlzLmZiO2ImJih0aGlzLmZiPW51bGwsYigpKX07XG5mdW5jdGlvbiBxZShhKXtpZihhLmZlJiZhLlBkJiZhLkplLmNvdW50KCk8KDA8YS5RYy5sZW5ndGg/MjoxKSl7YS5vZSsrO3ZhciBiPXt9O2IuaWQ9YS5jZztiLnB3PWEuZGc7Yi5zZXI9YS5vZTtmb3IodmFyIGI9YS5aYyhiKSxjPVwiXCIsZD0wOzA8YS5RYy5sZW5ndGg7KWlmKDE4NzA+PWEuUWNbMF0uYmYubGVuZ3RoKzMwK2MubGVuZ3RoKXt2YXIgZT1hLlFjLnNoaWZ0KCksYz1jK1wiJnNlZ1wiK2QrXCI9XCIrZS51ZytcIiZ0c1wiK2QrXCI9XCIrZS5DZytcIiZkXCIrZCtcIj1cIitlLmJmO2QrK31lbHNlIGJyZWFrO3JlKGEsYitjLGEub2UpO3JldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIHJlKGEsYixjKXtmdW5jdGlvbiBkKCl7YS5KZS5yZW1vdmUoYyk7cWUoYSl9YS5KZS5hZGQoYyk7dmFyIGU9c2V0VGltZW91dChkLE1hdGguZmxvb3IoMjVFMykpO3BlKGEsYixmdW5jdGlvbigpe2NsZWFyVGltZW91dChlKTtkKCl9KX1cbmZ1bmN0aW9uIHBlKGEsYixjKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dHJ5e2lmKGEuUGQpe3ZhciBkPWEuQWEuYWIuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtkLnR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIjtkLmFzeW5jPSEwO2Quc3JjPWI7ZC5vbmxvYWQ9ZC5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXt2YXIgYT1kLnJlYWR5U3RhdGU7YSYmXCJsb2FkZWRcIiE9PWEmJlwiY29tcGxldGVcIiE9PWF8fChkLm9ubG9hZD1kLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsLGQucGFyZW50Tm9kZSYmZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpLGMoKSl9O2Qub25lcnJvcj1mdW5jdGlvbigpe2hiKFwiTG9uZy1wb2xsIHNjcmlwdCBmYWlsZWQgdG8gbG9hZDogXCIrYik7YS5QZD0hMTthLmNsb3NlKCl9O2EuQWEuYWIuYm9keS5hcHBlbmRDaGlsZChkKX19Y2F0Y2goZSl7fX0sTWF0aC5mbG9vcigxKSl9O2Z1bmN0aW9uIHNlKGEpe3RlKHRoaXMsYSl9dmFyIHVlPVtrZSxiZV07ZnVuY3Rpb24gdGUoYSxiKXt2YXIgYz1iZSYmYmUuaXNBdmFpbGFibGUoKSxkPWMmJiEoemEubGZ8fCEwPT09emEuZ2V0KFwicHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmVcIikpO2IuRWcmJihjfHx6KFwid3NzOi8vIFVSTCB1c2VkLCBidXQgYnJvd3NlciBpc24ndCBrbm93biB0byBzdXBwb3J0IHdlYnNvY2tldHMuICBUcnlpbmcgYW55d2F5LlwiKSxkPSEwKTtpZihkKWEuWGM9W2JlXTtlbHNle3ZhciBlPWEuWGM9W107emIodWUsZnVuY3Rpb24oYSxiKXtiJiZiLmlzQXZhaWxhYmxlKCkmJmUucHVzaChiKX0pfX1mdW5jdGlvbiB2ZShhKXtpZigwPGEuWGMubGVuZ3RoKXJldHVybiBhLlhjWzBdO3Rocm93IEVycm9yKFwiTm8gdHJhbnNwb3J0cyBhdmFpbGFibGVcIik7fTtmdW5jdGlvbiB3ZShhLGIsYyxkLGUsZil7dGhpcy5pZD1hO3RoaXMuZj1vYihcImM6XCIrdGhpcy5pZCtcIjpcIik7dGhpcy5hYz1jO3RoaXMuS2M9ZDt0aGlzLmdhPWU7dGhpcy5IZT1mO3RoaXMuTz1iO3RoaXMuR2Q9W107dGhpcy5ZZT0wO3RoaXMuQWY9bmV3IHNlKGIpO3RoaXMuUWE9MDt0aGlzLmYoXCJDb25uZWN0aW9uIGNyZWF0ZWRcIik7eGUodGhpcyl9XG5mdW5jdGlvbiB4ZShhKXt2YXIgYj12ZShhLkFmKTthLko9bmV3IGIoXCJjOlwiK2EuaWQrXCI6XCIrYS5ZZSsrLGEuTyk7YS5MZT1iLnJlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHl8fDA7dmFyIGM9eWUoYSxhLkopLGQ9emUoYSxhLkopO2EuWWM9YS5KO2EuVGM9YS5KO2EuQz1udWxsO2Euc2I9ITE7c2V0VGltZW91dChmdW5jdGlvbigpe2EuSiYmYS5KLm9wZW4oYyxkKX0sTWF0aC5mbG9vcigwKSk7Yj1iLmhlYWx0aHlUaW1lb3V0fHwwOzA8YiYmKGEub2Q9c2V0VGltZW91dChmdW5jdGlvbigpe2Eub2Q9bnVsbDthLnNifHwoYS5KJiYxMDI0MDA8YS5KLmpiPyhhLmYoXCJDb25uZWN0aW9uIGV4Y2VlZGVkIGhlYWx0aHkgdGltZW91dCBidXQgaGFzIHJlY2VpdmVkIFwiK2EuSi5qYitcIiBieXRlcy4gIE1hcmtpbmcgY29ubmVjdGlvbiBoZWFsdGh5LlwiKSxhLnNiPSEwLGEuSi52ZCgpKTphLkomJjEwMjQwPGEuSi5rYj9hLmYoXCJDb25uZWN0aW9uIGV4Y2VlZGVkIGhlYWx0aHkgdGltZW91dCBidXQgaGFzIHNlbnQgXCIrXG5hLkoua2IrXCIgYnl0ZXMuICBMZWF2aW5nIGNvbm5lY3Rpb24gYWxpdmUuXCIpOihhLmYoXCJDbG9zaW5nIHVuaGVhbHRoeSBjb25uZWN0aW9uIGFmdGVyIHRpbWVvdXQuXCIpLGEuY2xvc2UoKSkpfSxNYXRoLmZsb29yKGIpKSl9ZnVuY3Rpb24gemUoYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7Yj09PWEuSj8oYS5KPW51bGwsY3x8MCE9PWEuUWE/MT09PWEuUWEmJmEuZihcIlJlYWx0aW1lIGNvbm5lY3Rpb24gbG9zdC5cIik6KGEuZihcIlJlYWx0aW1lIGNvbm5lY3Rpb24gZmFpbGVkLlwiKSxcInMtXCI9PT1hLk8uTWEuc3Vic3RyKDAsMikmJih6YS5yZW1vdmUoXCJob3N0OlwiK2EuTy5ob3N0KSxhLk8uTWE9YS5PLmhvc3QpKSxhLmNsb3NlKCkpOmI9PT1hLkM/KGEuZihcIlNlY29uZGFyeSBjb25uZWN0aW9uIGxvc3QuXCIpLGM9YS5DLGEuQz1udWxsLGEuWWMhPT1jJiZhLlRjIT09Y3x8YS5jbG9zZSgpKTphLmYoXCJjbG9zaW5nIGFuIG9sZCBjb25uZWN0aW9uXCIpfX1cbmZ1bmN0aW9uIHllKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGMpe2lmKDIhPWEuUWEpaWYoYj09PWEuVGMpe3ZhciBkPXdiKFwidFwiLGMpO2M9d2IoXCJkXCIsYyk7aWYoXCJjXCI9PWQpe2lmKGQ9d2IoXCJ0XCIsYyksXCJkXCJpbiBjKWlmKGM9Yy5kLFwiaFwiPT09ZCl7dmFyIGQ9Yy50cyxlPWMudixmPWMuaDthLlJkPWMucztCYShhLk8sZik7MD09YS5RYSYmKGEuSi5zdGFydCgpLEFlKGEsYS5KLGQpLFwiNVwiIT09ZSYmeihcIlByb3RvY29sIHZlcnNpb24gbWlzbWF0Y2ggZGV0ZWN0ZWRcIiksYz1hLkFmLChjPTE8Yy5YYy5sZW5ndGg/Yy5YY1sxXTpudWxsKSYmQmUoYSxjKSl9ZWxzZSBpZihcIm5cIj09PWQpe2EuZihcInJlY3ZkIGVuZCB0cmFuc21pc3Npb24gb24gcHJpbWFyeVwiKTthLlRjPWEuQztmb3IoYz0wO2M8YS5HZC5sZW5ndGg7KytjKWEuQ2QoYS5HZFtjXSk7YS5HZD1bXTtDZShhKX1lbHNlXCJzXCI9PT1kPyhhLmYoXCJDb25uZWN0aW9uIHNodXRkb3duIGNvbW1hbmQgcmVjZWl2ZWQuIFNodXR0aW5nIGRvd24uLi5cIiksXG5hLkhlJiYoYS5IZShjKSxhLkhlPW51bGwpLGEuZ2E9bnVsbCxhLmNsb3NlKCkpOlwiclwiPT09ZD8oYS5mKFwiUmVzZXQgcGFja2V0IHJlY2VpdmVkLiAgTmV3IGhvc3Q6IFwiK2MpLEJhKGEuTyxjKSwxPT09YS5RYT9hLmNsb3NlKCk6KERlKGEpLHhlKGEpKSk6XCJlXCI9PT1kP3BiKFwiU2VydmVyIEVycm9yOiBcIitjKTpcIm9cIj09PWQ/KGEuZihcImdvdCBwb25nIG9uIHByaW1hcnkuXCIpLEVlKGEpLEZlKGEpKTpwYihcIlVua25vd24gY29udHJvbCBwYWNrZXQgY29tbWFuZDogXCIrZCl9ZWxzZVwiZFwiPT1kJiZhLkNkKGMpfWVsc2UgaWYoYj09PWEuQylpZihkPXdiKFwidFwiLGMpLGM9d2IoXCJkXCIsYyksXCJjXCI9PWQpXCJ0XCJpbiBjJiYoYz1jLnQsXCJhXCI9PT1jP0dlKGEpOlwiclwiPT09Yz8oYS5mKFwiR290IGEgcmVzZXQgb24gc2Vjb25kYXJ5LCBjbG9zaW5nIGl0XCIpLGEuQy5jbG9zZSgpLGEuWWMhPT1hLkMmJmEuVGMhPT1hLkN8fGEuY2xvc2UoKSk6XCJvXCI9PT1jJiYoYS5mKFwiZ290IHBvbmcgb24gc2Vjb25kYXJ5LlwiKSxcbmEueWYtLSxHZShhKSkpO2Vsc2UgaWYoXCJkXCI9PWQpYS5HZC5wdXNoKGMpO2Vsc2UgdGhyb3cgRXJyb3IoXCJVbmtub3duIHByb3RvY29sIGxheWVyOiBcIitkKTtlbHNlIGEuZihcIm1lc3NhZ2Ugb24gb2xkIGNvbm5lY3Rpb25cIil9fXdlLnByb3RvdHlwZS5CYT1mdW5jdGlvbihhKXtIZSh0aGlzLHt0OlwiZFwiLGQ6YX0pfTtmdW5jdGlvbiBDZShhKXthLlljPT09YS5DJiZhLlRjPT09YS5DJiYoYS5mKFwiY2xlYW5pbmcgdXAgYW5kIHByb21vdGluZyBhIGNvbm5lY3Rpb246IFwiK2EuQy5tZSksYS5KPWEuQyxhLkM9bnVsbCl9XG5mdW5jdGlvbiBHZShhKXswPj1hLnlmPyhhLmYoXCJTZWNvbmRhcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LlwiKSxhLnNiPSEwLGEuQy52ZCgpLGEuQy5zdGFydCgpLGEuZihcInNlbmRpbmcgY2xpZW50IGFjayBvbiBzZWNvbmRhcnlcIiksYS5DLnNlbmQoe3Q6XCJjXCIsZDp7dDpcImFcIixkOnt9fX0pLGEuZihcIkVuZGluZyB0cmFuc21pc3Npb24gb24gcHJpbWFyeVwiKSxhLkouc2VuZCh7dDpcImNcIixkOnt0OlwiblwiLGQ6e319fSksYS5ZYz1hLkMsQ2UoYSkpOihhLmYoXCJzZW5kaW5nIHBpbmcgb24gc2Vjb25kYXJ5LlwiKSxhLkMuc2VuZCh7dDpcImNcIixkOnt0OlwicFwiLGQ6e319fSkpfXdlLnByb3RvdHlwZS5DZD1mdW5jdGlvbihhKXtFZSh0aGlzKTt0aGlzLmFjKGEpfTtmdW5jdGlvbiBFZShhKXthLnNifHwoYS5MZS0tLDA+PWEuTGUmJihhLmYoXCJQcmltYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cIiksYS5zYj0hMCxhLkoudmQoKSkpfVxuZnVuY3Rpb24gQmUoYSxiKXthLkM9bmV3IGIoXCJjOlwiK2EuaWQrXCI6XCIrYS5ZZSsrLGEuTyxhLlJkKTthLnlmPWIucmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeXx8MDthLkMub3Blbih5ZShhLGEuQyksemUoYSxhLkMpKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5DJiYoYS5mKFwiVGltZWQgb3V0IHRyeWluZyB0byB1cGdyYWRlLlwiKSxhLkMuY2xvc2UoKSl9LE1hdGguZmxvb3IoNkU0KSl9ZnVuY3Rpb24gQWUoYSxiLGMpe2EuZihcIlJlYWx0aW1lIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQuXCIpO2EuSj1iO2EuUWE9MTthLktjJiYoYS5LYyhjKSxhLktjPW51bGwpOzA9PT1hLkxlPyhhLmYoXCJQcmltYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cIiksYS5zYj0hMCk6c2V0VGltZW91dChmdW5jdGlvbigpe0ZlKGEpfSxNYXRoLmZsb29yKDVFMykpfVxuZnVuY3Rpb24gRmUoYSl7YS5zYnx8MSE9PWEuUWF8fChhLmYoXCJzZW5kaW5nIHBpbmcgb24gcHJpbWFyeS5cIiksSGUoYSx7dDpcImNcIixkOnt0OlwicFwiLGQ6e319fSkpfWZ1bmN0aW9uIEhlKGEsYil7aWYoMSE9PWEuUWEpdGhyb3dcIkNvbm5lY3Rpb24gaXMgbm90IGNvbm5lY3RlZFwiO2EuWWMuc2VuZChiKX13ZS5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oKXsyIT09dGhpcy5RYSYmKHRoaXMuZihcIkNsb3NpbmcgcmVhbHRpbWUgY29ubmVjdGlvbi5cIiksdGhpcy5RYT0yLERlKHRoaXMpLHRoaXMuZ2EmJih0aGlzLmdhKCksdGhpcy5nYT1udWxsKSl9O2Z1bmN0aW9uIERlKGEpe2EuZihcIlNodXR0aW5nIGRvd24gYWxsIGNvbm5lY3Rpb25zXCIpO2EuSiYmKGEuSi5jbG9zZSgpLGEuSj1udWxsKTthLkMmJihhLkMuY2xvc2UoKSxhLkM9bnVsbCk7YS5vZCYmKGNsZWFyVGltZW91dChhLm9kKSxhLm9kPW51bGwpfTtmdW5jdGlvbiBJZSgpe0lkLmNhbGwodGhpcyxbXCJvbmxpbmVcIl0pO3RoaXMuTGM9ITA7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpe3ZhciBhPXRoaXM7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIixmdW5jdGlvbigpe2EuTGN8fGEuJGQoXCJvbmxpbmVcIiwhMCk7YS5MYz0hMH0sITEpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLGZ1bmN0aW9uKCl7YS5MYyYmYS4kZChcIm9ubGluZVwiLCExKTthLkxjPSExfSwhMSl9fW1hKEllLElkKTtjYShJZSk7SWUucHJvdG90eXBlLnVlPWZ1bmN0aW9uKGEpe3koXCJvbmxpbmVcIj09PWEsXCJVbmtub3duIGV2ZW50IHR5cGU6IFwiK2EpO3JldHVyblt0aGlzLkxjXX07ZnVuY3Rpb24gSmUoYSl7dmFyIGI9e30sYz17fSxkPXt9LGU9XCJcIjt0cnl7dmFyIGY9YS5zcGxpdChcIi5cIiksYj10YShnYihmWzBdKXx8XCJcIiksYz10YShnYihmWzFdKXx8XCJcIiksZT1mWzJdLGQ9Yy5kfHx7fTtkZWxldGUgYy5kfWNhdGNoKGcpe31yZXR1cm57SGc6YixrZTpjLGRhdGE6ZCx5ZzplfX1mdW5jdGlvbiBLZShhKXthPUplKGEpLmtlO3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmYS5oYXNPd25Qcm9wZXJ0eShcImlhdFwiKT90KGEsXCJpYXRcIik6bnVsbH1mdW5jdGlvbiBMZShhKXthPUplKGEpO3ZhciBiPWEua2U7cmV0dXJuISFhLnlnJiYhIWImJlwib2JqZWN0XCI9PT10eXBlb2YgYiYmYi5oYXNPd25Qcm9wZXJ0eShcImlhdFwiKX07ZnVuY3Rpb24gTWUoYSxiLGMsZCl7dGhpcy5pZD1OZSsrO3RoaXMuZj1vYihcInA6XCIrdGhpcy5pZCtcIjpcIik7dGhpcy5EYj0hMDt0aGlzLnRhPXt9O3RoaXMubGE9W107dGhpcy5OYz0wO3RoaXMuSmM9W107dGhpcy5qYT0hMTt0aGlzLldhPTFFMzt0aGlzLnhkPTNFNTt0aGlzLkRkPWI7dGhpcy5CZD1jO3RoaXMuSWU9ZDt0aGlzLk89YTt0aGlzLlBlPW51bGw7dGhpcy5TYz17fTt0aGlzLnRnPTA7dGhpcy5EYz10aGlzLkFlPW51bGw7T2UodGhpcywwKTtLZC5PYigpLndiKFwidmlzaWJsZVwiLHRoaXMua2csdGhpcyk7LTE9PT1hLmhvc3QuaW5kZXhPZihcImZibG9jYWxcIikmJkllLk9iKCkud2IoXCJvbmxpbmVcIix0aGlzLmlnLHRoaXMpfXZhciBOZT0wLFBlPTA7aD1NZS5wcm90b3R5cGU7XG5oLkJhPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD0rK3RoaXMudGc7YT17cjpkLGE6YSxiOmJ9O3RoaXMuZihyKGEpKTt5KHRoaXMuamEsXCJzZW5kUmVxdWVzdCBjYWxsIHdoZW4gd2UncmUgbm90IGNvbm5lY3RlZCBub3QgYWxsb3dlZC5cIik7dGhpcy5PYS5CYShhKTtjJiYodGhpcy5TY1tkXT1jKX07ZnVuY3Rpb24gUWUoYSxiLGMsZCxlKXt2YXIgZj1iLkZhKCksZz1iLnBhdGgudG9TdHJpbmcoKTthLmYoXCJMaXN0ZW4gY2FsbGVkIGZvciBcIitnK1wiIFwiK2YpO2EudGFbZ109YS50YVtnXXx8e307eSghYS50YVtnXVtmXSxcImxpc3RlbigpIGNhbGxlZCB0d2ljZSBmb3Igc2FtZSBwYXRoL3F1ZXJ5SWQuXCIpO2I9e0g6ZSxuZDpjLHFnOkxjKGIubiksdGFnOmR9O2EudGFbZ11bZl09YjthLmphJiZSZShhLGcsZixiKX1cbmZ1bmN0aW9uIFJlKGEsYixjLGQpe2EuZihcIkxpc3RlbiBvbiBcIitiK1wiIGZvciBcIitjKTt2YXIgZT17cDpifTtkLnRhZyYmKGUucT1kLnFnLGUudD1kLnRhZyk7ZS5oPWQubmQoKTthLkJhKFwicVwiLGUsZnVuY3Rpb24oZSl7aWYoKGEudGFbYl0mJmEudGFbYl1bY10pPT09ZCl7YS5mKFwibGlzdGVuIHJlc3BvbnNlXCIsZSk7dmFyIGc9ZS5zO1wib2tcIiE9PWcmJlNlKGEsYixjKTtlPWUuZDtkLkgmJmQuSChnLGUpfX0pfWguUT1mdW5jdGlvbihhLGIsYyl7dGhpcy5JYj17UmY6YSxkZjohMSxyYzpiLGFkOmN9O3RoaXMuZihcIkF1dGhlbnRpY2F0aW5nIHVzaW5nIGNyZWRlbnRpYWw6IFwiK2EpO1RlKHRoaXMpOyhiPTQwPT1hLmxlbmd0aCl8fChhPUplKGEpLmtlLGI9XCJvYmplY3RcIj09PXR5cGVvZiBhJiYhMD09PXQoYSxcImFkbWluXCIpKTtiJiYodGhpcy5mKFwiQWRtaW4gYXV0aCBjcmVkZW50aWFsIGRldGVjdGVkLiAgUmVkdWNpbmcgbWF4IHJlY29ubmVjdCB0aW1lLlwiKSx0aGlzLnhkPTNFNCl9O1xuaC5WZT1mdW5jdGlvbihhKXtkZWxldGUgdGhpcy5JYjt0aGlzLmphJiZ0aGlzLkJhKFwidW5hdXRoXCIse30sZnVuY3Rpb24oYil7YShiLnMsYi5kKX0pfTtmdW5jdGlvbiBUZShhKXt2YXIgYj1hLkliO2EuamEmJmImJmEuQmEoXCJhdXRoXCIse2NyZWQ6Yi5SZn0sZnVuY3Rpb24oYyl7dmFyIGQ9Yy5zO2M9Yy5kfHxcImVycm9yXCI7XCJva1wiIT09ZCYmYS5JYj09PWImJmRlbGV0ZSBhLkliO2IuZGY/XCJva1wiIT09ZCYmYi5hZCYmYi5hZChkLGMpOihiLmRmPSEwLGIucmMmJmIucmMoZCxjKSl9KX1mdW5jdGlvbiBVZShhLGIsYyxkKXthLmphP1ZlKGEsXCJvXCIsYixjLGQpOmEuSmMucHVzaCh7UGM6YixhY3Rpb246XCJvXCIsZGF0YTpjLEg6ZH0pfWZ1bmN0aW9uIFdlKGEsYixjLGQpe2EuamE/VmUoYSxcIm9tXCIsYixjLGQpOmEuSmMucHVzaCh7UGM6YixhY3Rpb246XCJvbVwiLGRhdGE6YyxIOmR9KX1cbmguR2U9ZnVuY3Rpb24oYSxiKXt0aGlzLmphP1ZlKHRoaXMsXCJvY1wiLGEsbnVsbCxiKTp0aGlzLkpjLnB1c2goe1BjOmEsYWN0aW9uOlwib2NcIixkYXRhOm51bGwsSDpifSl9O2Z1bmN0aW9uIFZlKGEsYixjLGQsZSl7Yz17cDpjLGQ6ZH07YS5mKFwib25EaXNjb25uZWN0IFwiK2IsYyk7YS5CYShiLGMsZnVuY3Rpb24oYSl7ZSYmc2V0VGltZW91dChmdW5jdGlvbigpe2UoYS5zLGEuZCl9LE1hdGguZmxvb3IoMCkpfSl9aC5wdXQ9ZnVuY3Rpb24oYSxiLGMsZCl7WGUodGhpcyxcInBcIixhLGIsYyxkKX07ZnVuY3Rpb24gWWUoYSxiLGMsZCl7WGUoYSxcIm1cIixiLGMsZCx2b2lkIDApfWZ1bmN0aW9uIFhlKGEsYixjLGQsZSxmKXtkPXtwOmMsZDpkfTttKGYpJiYoZC5oPWYpO2EubGEucHVzaCh7YWN0aW9uOmIsdWY6ZCxIOmV9KTthLk5jKys7Yj1hLmxhLmxlbmd0aC0xO2EuamE/WmUoYSxiKTphLmYoXCJCdWZmZXJpbmcgcHV0OiBcIitjKX1cbmZ1bmN0aW9uIFplKGEsYil7dmFyIGM9YS5sYVtiXS5hY3Rpb24sZD1hLmxhW2JdLnVmLGU9YS5sYVtiXS5IO2EubGFbYl0ucmc9YS5qYTthLkJhKGMsZCxmdW5jdGlvbihkKXthLmYoYytcIiByZXNwb25zZVwiLGQpO2RlbGV0ZSBhLmxhW2JdO2EuTmMtLTswPT09YS5OYyYmKGEubGE9W10pO2UmJmUoZC5zLGQuZCl9KX1cbmguQ2Q9ZnVuY3Rpb24oYSl7aWYoXCJyXCJpbiBhKXt0aGlzLmYoXCJmcm9tIHNlcnZlcjogXCIrcihhKSk7dmFyIGI9YS5yLGM9dGhpcy5TY1tiXTtjJiYoZGVsZXRlIHRoaXMuU2NbYl0sYyhhLmIpKX1lbHNle2lmKFwiZXJyb3JcImluIGEpdGhyb3dcIkEgc2VydmVyLXNpZGUgZXJyb3IgaGFzIG9jY3VycmVkOiBcIithLmVycm9yO1wiYVwiaW4gYSYmKGI9YS5hLGM9YS5iLHRoaXMuZihcImhhbmRsZVNlcnZlck1lc3NhZ2VcIixiLGMpLFwiZFwiPT09Yj90aGlzLkRkKGMucCxjLmQsITEsYy50KTpcIm1cIj09PWI/dGhpcy5EZChjLnAsYy5kLCEwLGMudCk6XCJjXCI9PT1iPyRlKHRoaXMsYy5wLGMucSk6XCJhY1wiPT09Yj8oYT1jLnMsYj1jLmQsYz10aGlzLkliLGRlbGV0ZSB0aGlzLkliLGMmJmMuYWQmJmMuYWQoYSxiKSk6XCJzZFwiPT09Yj90aGlzLlBlP3RoaXMuUGUoYyk6XCJtc2dcImluIGMmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSYmY29uc29sZS5sb2coXCJGSVJFQkFTRTogXCIrYy5tc2cucmVwbGFjZShcIlxcblwiLFxuXCJcXG5GSVJFQkFTRTogXCIpKTpwYihcIlVucmVjb2duaXplZCBhY3Rpb24gcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6IFwiK3IoYikrXCJcXG5BcmUgeW91IHVzaW5nIHRoZSBsYXRlc3QgY2xpZW50P1wiKSl9fTtoLktjPWZ1bmN0aW9uKGEpe3RoaXMuZihcImNvbm5lY3Rpb24gcmVhZHlcIik7dGhpcy5qYT0hMDt0aGlzLkRjPShuZXcgRGF0ZSkuZ2V0VGltZSgpO3RoaXMuSWUoe3NlcnZlclRpbWVPZmZzZXQ6YS0obmV3IERhdGUpLmdldFRpbWUoKX0pO2FmKHRoaXMpO3RoaXMuQmQoITApfTtmdW5jdGlvbiBPZShhLGIpe3koIWEuT2EsXCJTY2hlZHVsaW5nIGEgY29ubmVjdCB3aGVuIHdlJ3JlIGFscmVhZHkgY29ubmVjdGVkL2luZz9cIik7YS5LYiYmY2xlYXJUaW1lb3V0KGEuS2IpO2EuS2I9c2V0VGltZW91dChmdW5jdGlvbigpe2EuS2I9bnVsbDtiZihhKX0sTWF0aC5mbG9vcihiKSl9XG5oLmtnPWZ1bmN0aW9uKGEpe2EmJiF0aGlzLm5jJiZ0aGlzLldhPT09dGhpcy54ZCYmKHRoaXMuZihcIldpbmRvdyBiZWNhbWUgdmlzaWJsZS4gIFJlZHVjaW5nIGRlbGF5LlwiKSx0aGlzLldhPTFFMyx0aGlzLk9hfHxPZSh0aGlzLDApKTt0aGlzLm5jPWF9O2guaWc9ZnVuY3Rpb24oYSl7YT8odGhpcy5mKFwiQnJvd3NlciB3ZW50IG9ubGluZS4gIFJlY29ubmVjdGluZy5cIiksdGhpcy5XYT0xRTMsdGhpcy5EYj0hMCx0aGlzLk9hfHxPZSh0aGlzLDApKToodGhpcy5mKFwiQnJvd3NlciB3ZW50IG9mZmxpbmUuICBLaWxsaW5nIGNvbm5lY3Rpb247IGRvbid0IHJlY29ubmVjdC5cIiksdGhpcy5EYj0hMSx0aGlzLk9hJiZ0aGlzLk9hLmNsb3NlKCkpfTtcbmgub2Y9ZnVuY3Rpb24oKXt0aGlzLmYoXCJkYXRhIGNsaWVudCBkaXNjb25uZWN0ZWRcIik7dGhpcy5qYT0hMTt0aGlzLk9hPW51bGw7Zm9yKHZhciBhPTA7YTx0aGlzLmxhLmxlbmd0aDthKyspe3ZhciBiPXRoaXMubGFbYV07YiYmXCJoXCJpbiBiLnVmJiZiLnJnJiYoYi5IJiZiLkgoXCJkaXNjb25uZWN0XCIpLGRlbGV0ZSB0aGlzLmxhW2FdLHRoaXMuTmMtLSl9MD09PXRoaXMuTmMmJih0aGlzLmxhPVtdKTtpZih0aGlzLkRiKXRoaXMubmM/dGhpcy5EYyYmKDNFNDwobmV3IERhdGUpLmdldFRpbWUoKS10aGlzLkRjJiYodGhpcy5XYT0xRTMpLHRoaXMuRGM9bnVsbCk6KHRoaXMuZihcIldpbmRvdyBpc24ndCB2aXNpYmxlLiAgRGVsYXlpbmcgcmVjb25uZWN0LlwiKSx0aGlzLldhPXRoaXMueGQsdGhpcy5BZT0obmV3IERhdGUpLmdldFRpbWUoKSksYT1NYXRoLm1heCgwLHRoaXMuV2EtKChuZXcgRGF0ZSkuZ2V0VGltZSgpLXRoaXMuQWUpKSxhKj1NYXRoLnJhbmRvbSgpLHRoaXMuZihcIlRyeWluZyB0byByZWNvbm5lY3QgaW4gXCIrXG5hK1wibXNcIiksT2UodGhpcyxhKSx0aGlzLldhPU1hdGgubWluKHRoaXMueGQsMS4zKnRoaXMuV2EpO2Vsc2UgZm9yKHZhciBjIGluIHRoaXMuU2MpZGVsZXRlIHRoaXMuU2NbY107dGhpcy5CZCghMSl9O2Z1bmN0aW9uIGJmKGEpe2lmKGEuRGIpe2EuZihcIk1ha2luZyBhIGNvbm5lY3Rpb24gYXR0ZW1wdFwiKTthLkFlPShuZXcgRGF0ZSkuZ2V0VGltZSgpO2EuRGM9bnVsbDt2YXIgYj1xKGEuQ2QsYSksYz1xKGEuS2MsYSksZD1xKGEub2YsYSksZT1hLmlkK1wiOlwiK1BlKys7YS5PYT1uZXcgd2UoZSxhLk8sYixjLGQsZnVuY3Rpb24oYil7eihiK1wiIChcIithLk8udG9TdHJpbmcoKStcIilcIik7YS5EYj0hMX0pfX1oLnFiPWZ1bmN0aW9uKCl7dGhpcy5EYj0hMTt0aGlzLk9hP3RoaXMuT2EuY2xvc2UoKToodGhpcy5LYiYmKGNsZWFyVGltZW91dCh0aGlzLktiKSx0aGlzLktiPW51bGwpLHRoaXMuamEmJnRoaXMub2YoKSl9O1xuaC5pYz1mdW5jdGlvbigpe3RoaXMuRGI9ITA7dGhpcy5XYT0xRTM7dGhpcy5PYXx8T2UodGhpcywwKX07ZnVuY3Rpb24gJGUoYSxiLGMpe2M9Yz9KYShjLGZ1bmN0aW9uKGEpe3JldHVybiB4YihhKX0pLmpvaW4oXCIkXCIpOlwiZGVmYXVsdFwiOyhhPVNlKGEsYixjKSkmJmEuSCYmYS5IKFwicGVybWlzc2lvbl9kZW5pZWRcIil9ZnVuY3Rpb24gU2UoYSxiLGMpe2I9KG5ldyBTKGIpKS50b1N0cmluZygpO3ZhciBkO20oYS50YVtiXSk/KGQ9YS50YVtiXVtjXSxkZWxldGUgYS50YVtiXVtjXSwwPT09SmIoYS50YVtiXSkmJmRlbGV0ZSBhLnRhW2JdKTpkPXZvaWQgMDtyZXR1cm4gZH1cbmZ1bmN0aW9uIGFmKGEpe1RlKGEpO0EoYS50YSxmdW5jdGlvbihiLGQpe0EoYixmdW5jdGlvbihiLGMpe1JlKGEsZCxjLGIpfSl9KTtmb3IodmFyIGI9MDtiPGEubGEubGVuZ3RoO2IrKylhLmxhW2JdJiZaZShhLGIpO2Zvcig7YS5KYy5sZW5ndGg7KWI9YS5KYy5zaGlmdCgpLFZlKGEsYi5hY3Rpb24sYi5QYyxiLmRhdGEsYi5IKX07ZnVuY3Rpb24gY2YoKXt0aGlzLm09dGhpcy5GPW51bGx9Y2YucHJvdG90eXBlLmVjPWZ1bmN0aW9uKGEsYil7aWYoYS5lKCkpdGhpcy5GPWIsdGhpcy5tPW51bGw7ZWxzZSBpZihudWxsIT09dGhpcy5GKXRoaXMuRj10aGlzLkYuRChhLGIpO2Vsc2V7bnVsbD09dGhpcy5tJiYodGhpcy5tPW5ldyBpZSk7dmFyIGM9SShhKTt0aGlzLm0uY29udGFpbnMoYyl8fHRoaXMubS5hZGQoYyxuZXcgY2YpO2M9dGhpcy5tLmdldChjKTthPVQoYSk7Yy5lYyhhLGIpfX07XG5mdW5jdGlvbiBkZihhLGIpe2lmKGIuZSgpKXJldHVybiBhLkY9bnVsbCxhLm09bnVsbCwhMDtpZihudWxsIT09YS5GKXtpZihhLkYuTSgpKXJldHVybiExO3ZhciBjPWEuRjthLkY9bnVsbDtjLlUoTCxmdW5jdGlvbihiLGMpe2EuZWMobmV3IFMoYiksYyl9KTtyZXR1cm4gZGYoYSxiKX1yZXR1cm4gbnVsbCE9PWEubT8oYz1JKGIpLGI9VChiKSxhLm0uY29udGFpbnMoYykmJmRmKGEubS5nZXQoYyksYikmJmEubS5yZW1vdmUoYyksYS5tLmUoKT8oYS5tPW51bGwsITApOiExKTohMH1mdW5jdGlvbiBlZihhLGIsYyl7bnVsbCE9PWEuRj9jKGIsYS5GKTphLlUoZnVuY3Rpb24oYSxlKXt2YXIgZj1uZXcgUyhiLnRvU3RyaW5nKCkrXCIvXCIrYSk7ZWYoZSxmLGMpfSl9Y2YucHJvdG90eXBlLlU9ZnVuY3Rpb24oYSl7bnVsbCE9PXRoaXMubSYmamUodGhpcy5tLGZ1bmN0aW9uKGIsYyl7YShiLGMpfSl9O2Z1bmN0aW9uIGZmKCl7dGhpcy5PZD1NfWZmLnByb3RvdHlwZS5qPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLk9kLnJhKGEpfTtmZi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5PZC50b1N0cmluZygpfTtmdW5jdGlvbiBnZigpe3RoaXMub2I9W119ZnVuY3Rpb24gaGYoYSxiKXtmb3IodmFyIGM9bnVsbCxkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBlPWJbZF0sZj1lLlJiKCk7bnVsbD09PWN8fGYuYWEoYy5SYigpKXx8KGEub2IucHVzaChjKSxjPW51bGwpO251bGw9PT1jJiYoYz1uZXcgamYoZikpO2MuYWRkKGUpfWMmJmEub2IucHVzaChjKX1mdW5jdGlvbiBTYyhhLGIsYyl7aGYoYSxjKTtrZihhLGZ1bmN0aW9uKGEpe3JldHVybiBhLmFhKGIpfSl9ZnVuY3Rpb24gbGYoYSxiLGMpe2hmKGEsYyk7a2YoYSxmdW5jdGlvbihhKXtyZXR1cm4gYS5jb250YWlucyhiKXx8Yi5jb250YWlucyhhKX0pfVxuZnVuY3Rpb24ga2YoYSxiKXtmb3IodmFyIGM9ITAsZD0wO2Q8YS5vYi5sZW5ndGg7ZCsrKXt2YXIgZT1hLm9iW2RdO2lmKGUpaWYoZT1lLlJiKCksYihlKSl7Zm9yKHZhciBlPWEub2JbZF0sZj0wO2Y8ZS5sZC5sZW5ndGg7ZisrKXt2YXIgZz1lLmxkW2ZdO2lmKG51bGwhPT1nKXtlLmxkW2ZdPW51bGw7dmFyIGs9Zy5NYigpO2xiJiZoYihcImV2ZW50OiBcIitnLnRvU3RyaW5nKCkpO0NiKGspfX1hLm9iW2RdPW51bGx9ZWxzZSBjPSExfWMmJihhLm9iPVtdKX1mdW5jdGlvbiBqZihhKXt0aGlzLkVhPWE7dGhpcy5sZD1bXX1qZi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEpe3RoaXMubGQucHVzaChhKX07amYucHJvdG90eXBlLlJiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuRWF9O3ZhciBtZj1cImF1dGguZmlyZWJhc2UuY29tXCI7ZnVuY3Rpb24gbmYoYSxiLGMpe3RoaXMuY2Q9YXx8e307dGhpcy5aZD1ifHx7fTt0aGlzLlhhPWN8fHt9O3RoaXMuY2QucmVtZW1iZXJ8fCh0aGlzLmNkLnJlbWVtYmVyPVwiZGVmYXVsdFwiKX12YXIgb2Y9W1wicmVtZW1iZXJcIixcInJlZGlyZWN0VG9cIl07ZnVuY3Rpb24gcGYoYSl7dmFyIGI9e30sYz17fTt1YShhfHx7fSxmdW5jdGlvbihhLGUpezA8PUdhKG9mLGEpP2JbYV09ZTpjW2FdPWV9KTtyZXR1cm4gbmV3IG5mKGIse30sYyl9O3ZhciBxZj17TkVUV09SS19FUlJPUjpcIlVuYWJsZSB0byBjb250YWN0IHRoZSBGaXJlYmFzZSBzZXJ2ZXIuXCIsU0VSVkVSX0VSUk9SOlwiQW4gdW5rbm93biBzZXJ2ZXIgZXJyb3Igb2NjdXJyZWQuXCIsVFJBTlNQT1JUX1VOQVZBSUxBQkxFOlwiVGhlcmUgYXJlIG5vIGxvZ2luIHRyYW5zcG9ydHMgYXZhaWxhYmxlIGZvciB0aGUgcmVxdWVzdGVkIG1ldGhvZC5cIixSRVFVRVNUX0lOVEVSUlVQVEVEOlwiVGhlIGJyb3dzZXIgcmVkaXJlY3RlZCB0aGUgcGFnZSBiZWZvcmUgdGhlIGxvZ2luIHJlcXVlc3QgY291bGQgY29tcGxldGUuXCIsVVNFUl9DQU5DRUxMRUQ6XCJUaGUgdXNlciBjYW5jZWxsZWQgYXV0aGVudGljYXRpb24uXCJ9O2Z1bmN0aW9uIFgoYSl7dmFyIGI9RXJyb3IodChxZixhKSxhKTtiLmNvZGU9YTtyZXR1cm4gYn07ZnVuY3Rpb24gcmYoKXt2YXIgYT13aW5kb3cub3BlbmVyLmZyYW1lcyxiO2ZvcihiPWEubGVuZ3RoLTE7MDw9YjtiLS0pdHJ5e2lmKGFbYl0ubG9jYXRpb24ucHJvdG9jb2w9PT13aW5kb3cubG9jYXRpb24ucHJvdG9jb2wmJmFbYl0ubG9jYXRpb24uaG9zdD09PXdpbmRvdy5sb2NhdGlvbi5ob3N0JiZcIl9fd2luY2hhbl9yZWxheV9mcmFtZVwiPT09YVtiXS5uYW1lKXJldHVybiBhW2JdfWNhdGNoKGMpe31yZXR1cm4gbnVsbH1mdW5jdGlvbiBzZihhLGIsYyl7YS5hdHRhY2hFdmVudD9hLmF0dGFjaEV2ZW50KFwib25cIitiLGMpOmEuYWRkRXZlbnRMaXN0ZW5lciYmYS5hZGRFdmVudExpc3RlbmVyKGIsYywhMSl9ZnVuY3Rpb24gdGYoYSxiLGMpe2EuZGV0YWNoRXZlbnQ/YS5kZXRhY2hFdmVudChcIm9uXCIrYixjKTphLnJlbW92ZUV2ZW50TGlzdGVuZXImJmEucmVtb3ZlRXZlbnRMaXN0ZW5lcihiLGMsITEpfVxuZnVuY3Rpb24gdWYoYSl7L15odHRwcz86XFwvXFwvLy50ZXN0KGEpfHwoYT13aW5kb3cubG9jYXRpb24uaHJlZik7dmFyIGI9L14oaHR0cHM/OlxcL1xcL1tcXC1fYS16QS1aXFwuMC05Ol0rKS8uZXhlYyhhKTtyZXR1cm4gYj9iWzFdOmF9ZnVuY3Rpb24gdmYoYSl7dmFyIGI9XCJcIjt0cnl7YT1hLnJlcGxhY2UoXCIjXCIsXCJcIik7dmFyIGM9e30sZD1hLnJlcGxhY2UoL15cXD8vLFwiXCIpLnNwbGl0KFwiJlwiKTtmb3IoYT0wO2E8ZC5sZW5ndGg7YSsrKWlmKGRbYV0pe3ZhciBlPWRbYV0uc3BsaXQoXCI9XCIpO2NbZVswXV09ZVsxXX1jJiZzKGMsXCJfX2ZpcmViYXNlX3JlcXVlc3Rfa2V5XCIpJiYoYj10KGMsXCJfX2ZpcmViYXNlX3JlcXVlc3Rfa2V5XCIpKX1jYXRjaChmKXt9cmV0dXJuIGJ9XG5mdW5jdGlvbiB3ZihhKXt2YXIgYj1bXSxjO2ZvcihjIGluIGEpaWYocyhhLGMpKXt2YXIgZD10KGEsYyk7aWYoZWEoZCkpZm9yKHZhciBlPTA7ZTxkLmxlbmd0aDtlKyspYi5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChjKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQoZFtlXSkpO2Vsc2UgYi5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChjKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQodChhLGMpKSl9cmV0dXJuIGI/XCImXCIrYi5qb2luKFwiJlwiKTpcIlwifWZ1bmN0aW9uIHhmKCl7dmFyIGE9cmIobWYpO3JldHVybiBhLnNjaGVtZStcIjovL1wiK2EuaG9zdCtcIi92MlwifWZ1bmN0aW9uIHlmKGEpe3JldHVybiB4ZigpK1wiL1wiK2ErXCIvYXV0aC9jaGFubmVsXCJ9O2Z1bmN0aW9uIHpmKCl7cmV0dXJuISEod2luZG93LmNvcmRvdmF8fHdpbmRvdy5waG9uZWdhcHx8d2luZG93LlBob25lR2FwKSYmL2lvc3xpcGhvbmV8aXBvZHxpcGFkfGFuZHJvaWR8YmxhY2tiZXJyeXxpZW1vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCl9ZnVuY3Rpb24gQWYoKXt2YXIgYT1uYXZpZ2F0b3IudXNlckFnZW50O2lmKFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCI9PT1uYXZpZ2F0b3IuYXBwTmFtZSl7aWYoKGE9YS5tYXRjaCgvTVNJRSAoWzAtOV17MSx9W1xcLjAtOV17MCx9KS8pKSYmMTxhLmxlbmd0aClyZXR1cm4gODw9cGFyc2VGbG9hdChhWzFdKX1lbHNlIGlmKC0xPGEuaW5kZXhPZihcIlRyaWRlbnRcIikmJihhPWEubWF0Y2goL3J2OihbMC05XXsyLDJ9W1xcLjAtOV17MCx9KS8pKSYmMTxhLmxlbmd0aClyZXR1cm4gODw9cGFyc2VGbG9hdChhWzFdKTtyZXR1cm4hMX07ZnVuY3Rpb24gQmYoYSl7YS5tZXRob2R8fChhLm1ldGhvZD1cIkdFVFwiKTthLmhlYWRlcnN8fChhLmhlYWRlcnM9e30pO2EuaGVhZGVycy5jb250ZW50X3R5cGV8fChhLmhlYWRlcnMuY29udGVudF90eXBlPVwiYXBwbGljYXRpb24vanNvblwiKTthLmhlYWRlcnMuY29udGVudF90eXBlPWEuaGVhZGVycy5jb250ZW50X3R5cGUudG9Mb3dlckNhc2UoKTt0aGlzLm9wdGlvbnM9YX1cbkJmLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKCl7YyYmKGMoWChcIlJFUVVFU1RfSU5URVJSVVBURURcIikpLGM9bnVsbCl9dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0LGY9dGhpcy5vcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpLGc7c2Yod2luZG93LFwiYmVmb3JldW5sb2FkXCIsZCk7ZS5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZihjJiY0PT09ZS5yZWFkeVN0YXRlKXt2YXIgYTtpZigyMDA8PWUuc3RhdHVzJiYzMDA+ZS5zdGF0dXMpe3RyeXthPXRhKGUucmVzcG9uc2VUZXh0KX1jYXRjaChiKXt9YyhudWxsLGEpfWVsc2UgNTAwPD1lLnN0YXR1cyYmNjAwPmUuc3RhdHVzP2MoWChcIlNFUlZFUl9FUlJPUlwiKSk6YyhYKFwiTkVUV09SS19FUlJPUlwiKSk7Yz1udWxsO3RmKHdpbmRvdyxcImJlZm9yZXVubG9hZFwiLGQpfX07aWYoXCJHRVRcIj09PWYpYSs9KC9cXD8vLnRlc3QoYSk/XCJcIjpcIj9cIikrd2YoYiksZz1udWxsO2Vsc2V7dmFyIGs9dGhpcy5vcHRpb25zLmhlYWRlcnMuY29udGVudF90eXBlO1xuXCJhcHBsaWNhdGlvbi9qc29uXCI9PT1rJiYoZz1yKGIpKTtcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiPT09ayYmKGc9d2YoYikpfWUub3BlbihmLGEsITApO2E9e1wiWC1SZXF1ZXN0ZWQtV2l0aFwiOlwiWE1MSHR0cFJlcXVlc3RcIixBY2NlcHQ6XCJhcHBsaWNhdGlvbi9qc29uO3RleHQvcGxhaW5cIn07U2QoYSx0aGlzLm9wdGlvbnMuaGVhZGVycyk7Zm9yKHZhciBsIGluIGEpZS5zZXRSZXF1ZXN0SGVhZGVyKGwsYVtsXSk7ZS5zZW5kKGcpfTtCZi5pc0F2YWlsYWJsZT1mdW5jdGlvbigpe3JldHVybiEhd2luZG93LlhNTEh0dHBSZXF1ZXN0JiZcInN0cmluZ1wiPT09dHlwZW9mKG5ldyBYTUxIdHRwUmVxdWVzdCkucmVzcG9uc2VUeXBlJiYoIShuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9NU0lFLyl8fG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1RyaWRlbnQvKSl8fEFmKCkpfTtCZi5wcm90b3R5cGUudGM9ZnVuY3Rpb24oKXtyZXR1cm5cImpzb25cIn07ZnVuY3Rpb24gQ2YoYSl7dGhpcy5nYz1GYSgpK0ZhKCkrRmEoKTt0aGlzLnBmPWF9XG5DZi5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZCgpe2MmJihjKFgoXCJVU0VSX0NBTkNFTExFRFwiKSksYz1udWxsKX12YXIgZT10aGlzLGY9cmIobWYpLGc7Yi5yZXF1ZXN0SWQ9dGhpcy5nYztiLnJlZGlyZWN0VG89Zi5zY2hlbWUrXCI6Ly9cIitmLmhvc3QrXCIvYmxhbmsvcGFnZS5odG1sXCI7YSs9L1xcPy8udGVzdChhKT9cIlwiOlwiP1wiO2ErPXdmKGIpOyhnPXdpbmRvdy5vcGVuKGEsXCJfYmxhbmtcIixcImxvY2F0aW9uPW5vXCIpKSYmaGEoZy5hZGRFdmVudExpc3RlbmVyKT8oZy5hZGRFdmVudExpc3RlbmVyKFwibG9hZHN0YXJ0XCIsZnVuY3Rpb24oYSl7dmFyIGI7aWYoYj1hJiZhLnVybClhOnt2YXIgbj1hLnVybDt0cnl7dmFyIHU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7dS5ocmVmPW47Yj11Lmhvc3Q9PT1mLmhvc3QmJlwiL2JsYW5rL3BhZ2UuaHRtbFwiPT09dS5wYXRobmFtZTticmVhayBhfWNhdGNoKHgpe31iPSExfWImJihhPXZmKGEudXJsKSxnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJleGl0XCIsXG5kKSxnLmNsb3NlKCksYT1uZXcgbmYobnVsbCxudWxsLHtyZXF1ZXN0SWQ6ZS5nYyxyZXF1ZXN0S2V5OmF9KSxlLnBmLnJlcXVlc3RXaXRoQ3JlZGVudGlhbChcIi9hdXRoL3Nlc3Npb25cIixhLGMpLGM9bnVsbCl9KSxnLmFkZEV2ZW50TGlzdGVuZXIoXCJleGl0XCIsZCkpOmMoWChcIlRSQU5TUE9SVF9VTkFWQUlMQUJMRVwiKSl9O0NmLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHpmKCl9O0NmLnByb3RvdHlwZS50Yz1mdW5jdGlvbigpe3JldHVyblwicmVkaXJlY3RcIn07ZnVuY3Rpb24gRGYoYSl7aWYoIWEud2luZG93X2ZlYXR1cmVzfHwtMSE9PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkZlbm5lYy9cIil8fC0xIT09bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveC9cIikmJi0xIT09bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiQW5kcm9pZFwiKSlhLndpbmRvd19mZWF0dXJlcz12b2lkIDA7YS53aW5kb3dfbmFtZXx8KGEud2luZG93X25hbWU9XCJfYmxhbmtcIik7dGhpcy5vcHRpb25zPWF9XG5EZi5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXtnJiYoZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChnKSxnPXZvaWQgMCk7dSYmKHU9Y2xlYXJJbnRlcnZhbCh1KSk7dGYod2luZG93LFwibWVzc2FnZVwiLGUpO3RmKHdpbmRvdyxcInVubG9hZFwiLGQpO2lmKG4mJiFhKXRyeXtuLmNsb3NlKCl9Y2F0Y2goYil7ay5wb3N0TWVzc2FnZShcImRpZVwiLGwpfW49az12b2lkIDB9ZnVuY3Rpb24gZShhKXtpZihhLm9yaWdpbj09PWwpdHJ5e3ZhciBiPXRhKGEuZGF0YSk7XCJyZWFkeVwiPT09Yi5hP2sucG9zdE1lc3NhZ2UoeCxsKTpcImVycm9yXCI9PT1iLmE/KGQoITEpLGMmJihjKGIuZCksYz1udWxsKSk6XCJyZXNwb25zZVwiPT09Yi5hJiYoZChiLmZvcmNlS2VlcFdpbmRvd09wZW4pLGMmJihjKG51bGwsYi5kKSxjPW51bGwpKX1jYXRjaChlKXt9fXZhciBmPUFmKCksZyxrO2lmKCF0aGlzLm9wdGlvbnMucmVsYXlfdXJsKXJldHVybiBjKEVycm9yKFwiaW52YWxpZCBhcmd1bWVudHM6IG9yaWdpbiBvZiB1cmwgYW5kIHJlbGF5X3VybCBtdXN0IG1hdGNoXCIpKTtcbnZhciBsPXVmKGEpO2lmKGwhPT11Zih0aGlzLm9wdGlvbnMucmVsYXlfdXJsKSljJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YyhFcnJvcihcImludmFsaWQgYXJndW1lbnRzOiBvcmlnaW4gb2YgdXJsIGFuZCByZWxheV91cmwgbXVzdCBtYXRjaFwiKSl9LDApO2Vsc2V7ZiYmKGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKSxnLnNldEF0dHJpYnV0ZShcInNyY1wiLHRoaXMub3B0aW9ucy5yZWxheV91cmwpLGcuc3R5bGUuZGlzcGxheT1cIm5vbmVcIixnLnNldEF0dHJpYnV0ZShcIm5hbWVcIixcIl9fd2luY2hhbl9yZWxheV9mcmFtZVwiKSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGcpLGs9Zy5jb250ZW50V2luZG93KTthKz0oL1xcPy8udGVzdChhKT9cIlwiOlwiP1wiKSt3ZihiKTt2YXIgbj13aW5kb3cub3BlbihhLHRoaXMub3B0aW9ucy53aW5kb3dfbmFtZSx0aGlzLm9wdGlvbnMud2luZG93X2ZlYXR1cmVzKTtrfHwoaz1uKTt2YXIgdT1zZXRJbnRlcnZhbChmdW5jdGlvbigpe24mJm4uY2xvc2VkJiZcbihkKCExKSxjJiYoYyhYKFwiVVNFUl9DQU5DRUxMRURcIikpLGM9bnVsbCkpfSw1MDApLHg9cih7YTpcInJlcXVlc3RcIixkOmJ9KTtzZih3aW5kb3csXCJ1bmxvYWRcIixkKTtzZih3aW5kb3csXCJtZXNzYWdlXCIsZSl9fTtcbkRmLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuXCJwb3N0TWVzc2FnZVwiaW4gd2luZG93JiYhL15maWxlOlxcLy8udGVzdChsb2NhdGlvbi5ocmVmKSYmISh6ZigpfHxuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9XaW5kb3dzIFBob25lLyl8fHdpbmRvdy5XaW5kb3dzJiYvXm1zLWFwcHg6Ly50ZXN0KGxvY2F0aW9uLmhyZWYpfHxuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpL2kpfHxuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DcmlPUy8pfHxuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9Ud2l0dGVyIGZvciBpUGhvbmUvKXx8bmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRkJBTlxcL0ZCSU9TLyl8fHdpbmRvdy5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkmJiFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9QaGFudG9tSlMvKX07RGYucHJvdG90eXBlLnRjPWZ1bmN0aW9uKCl7cmV0dXJuXCJwb3B1cFwifTtmdW5jdGlvbiBFZihhKXthLmNhbGxiYWNrX3BhcmFtZXRlcnx8KGEuY2FsbGJhY2tfcGFyYW1ldGVyPVwiY2FsbGJhY2tcIik7dGhpcy5vcHRpb25zPWE7d2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucD13aW5kb3cuX19maXJlYmFzZV9hdXRoX2pzb25wfHx7fX1cbkVmLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKCl7YyYmKGMoWChcIlJFUVVFU1RfSU5URVJSVVBURURcIikpLGM9bnVsbCl9ZnVuY3Rpb24gZSgpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt3aW5kb3cuX19maXJlYmFzZV9hdXRoX2pzb25wW2ZdPXZvaWQgMDtQZCh3aW5kb3cuX19maXJlYmFzZV9hdXRoX2pzb25wKSYmKHdpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnA9dm9pZCAwKTt0cnl7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZik7YSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpfWNhdGNoKGIpe319LDEpO3RmKHdpbmRvdyxcImJlZm9yZXVubG9hZFwiLGQpfXZhciBmPVwiZm5cIisobmV3IERhdGUpLmdldFRpbWUoKStNYXRoLmZsb29yKDk5OTk5Kk1hdGgucmFuZG9tKCkpO2JbdGhpcy5vcHRpb25zLmNhbGxiYWNrX3BhcmFtZXRlcl09XCJfX2ZpcmViYXNlX2F1dGhfanNvbnAuXCIrZjthKz0oL1xcPy8udGVzdChhKT9cIlwiOlwiP1wiKSt3ZihiKTtcbnNmKHdpbmRvdyxcImJlZm9yZXVubG9hZFwiLGQpO3dpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnBbZl09ZnVuY3Rpb24oYSl7YyYmKGMobnVsbCxhKSxjPW51bGwpO2UoKX07RmYoZixhLGMpfTtcbmZ1bmN0aW9uIEZmKGEsYixjKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dHJ5e3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7ZC50eXBlPVwidGV4dC9qYXZhc2NyaXB0XCI7ZC5pZD1hO2QuYXN5bmM9ITA7ZC5zcmM9YjtkLm9uZXJyb3I9ZnVuY3Rpb24oKXt2YXIgYj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKTtudWxsIT09YiYmYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpO2MmJmMoWChcIk5FVFdPUktfRVJST1JcIikpfTt2YXIgZT1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIik7KGUmJjAhPWUubGVuZ3RoP2VbMF06ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5hcHBlbmRDaGlsZChkKX1jYXRjaChmKXtjJiZjKFgoXCJORVRXT1JLX0VSUk9SXCIpKX19LDApfUVmLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIXpmKCl9O0VmLnByb3RvdHlwZS50Yz1mdW5jdGlvbigpe3JldHVyblwianNvblwifTtmdW5jdGlvbiBHZihhLGIpe3RoaXMuS2U9W1wic2Vzc2lvblwiLGEuSWQsYS51Yl0uam9pbihcIjpcIik7dGhpcy5XZD1ifUdmLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXtpZighYilpZih0aGlzLldkLmxlbmd0aCliPXRoaXMuV2RbMF07ZWxzZSB0aHJvdyBFcnJvcihcImZiLmxvZ2luLlNlc3Npb25NYW5hZ2VyIDogTm8gc3RvcmFnZSBvcHRpb25zIGF2YWlsYWJsZSFcIik7Yi5zZXQodGhpcy5LZSxhKX07R2YucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe3ZhciBhPUphKHRoaXMuV2QscSh0aGlzLlpmLHRoaXMpKSxhPUlhKGEsZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPT1hfSk7UWEoYSxmdW5jdGlvbihhLGMpe3JldHVybiBLZShjLnRva2VuKS1LZShhLnRva2VuKX0pO3JldHVybiAwPGEubGVuZ3RoP2Euc2hpZnQoKTpudWxsfTtHZi5wcm90b3R5cGUuWmY9ZnVuY3Rpb24oYSl7dHJ5e3ZhciBiPWEuZ2V0KHRoaXMuS2UpO2lmKGImJmIudG9rZW4pcmV0dXJuIGJ9Y2F0Y2goYyl7fXJldHVybiBudWxsfTtcbkdmLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7SGEodGhpcy5XZCxmdW5jdGlvbihiKXtiLnJlbW92ZShhLktlKX0pfTtmdW5jdGlvbiBIZihhKXt0aGlzLmdjPUZhKCkrRmEoKStGYSgpO3RoaXMucGY9YX1IZi5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIpe3Yuc2V0KFwicmVkaXJlY3RfcmVxdWVzdF9pZFwiLHRoaXMuZ2MpO3Yuc2V0KFwicmVkaXJlY3RfcmVxdWVzdF9pZFwiLHRoaXMuZ2MpO2IucmVxdWVzdElkPXRoaXMuZ2M7Yi5yZWRpcmVjdFRvPWIucmVkaXJlY3RUb3x8d2luZG93LmxvY2F0aW9uLmhyZWY7YSs9KC9cXD8vLnRlc3QoYSk/XCJcIjpcIj9cIikrd2YoYik7d2luZG93LmxvY2F0aW9uPWF9O0hmLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIS9eZmlsZTpcXC8vLnRlc3QobG9jYXRpb24uaHJlZikmJiF6ZigpfTtIZi5wcm90b3R5cGUudGM9ZnVuY3Rpb24oKXtyZXR1cm5cInJlZGlyZWN0XCJ9O2Z1bmN0aW9uIElmKGEsYixjLGQpe0lkLmNhbGwodGhpcyxbXCJhdXRoX3N0YXR1c1wiXSk7dGhpcy5PPWE7dGhpcy5YZT1iO3RoaXMuRGc9Yzt0aGlzLkZlPWQ7dGhpcy5qYz1uZXcgR2YoYSxbemEsdl0pO3RoaXMuaWI9bnVsbDtKZih0aGlzKX1tYShJZixJZCk7aD1JZi5wcm90b3R5cGU7aC5yZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlifHxudWxsfTtmdW5jdGlvbiBKZihhKXt2LmdldChcInJlZGlyZWN0X3JlcXVlc3RfaWRcIikmJktmKGEpO3ZhciBiPWEuamMuZ2V0KCk7YiYmYi50b2tlbj8oTGYoYSxiKSxhLlhlKGIudG9rZW4sZnVuY3Rpb24oYyxkKXtNZihhLGMsZCwhMSxiLnRva2VuLGIpfSxmdW5jdGlvbihiLGQpe05mKGEsXCJyZXN1bWVTZXNzaW9uKClcIixiLGQpfSkpOkxmKGEsbnVsbCl9XG5mdW5jdGlvbiBPZihhLGIsYyxkLGUsZil7XCJmaXJlYmFzZWlvLWRlbW8uY29tXCI9PT1hLk8uZG9tYWluJiZ6KFwiRmlyZWJhc2UgYXV0aGVudGljYXRpb24gaXMgbm90IHN1cHBvcnRlZCBvbiBkZW1vIEZpcmViYXNlcyAoKi5maXJlYmFzZWlvLWRlbW8uY29tKS4gVG8gc2VjdXJlIHlvdXIgRmlyZWJhc2UsIGNyZWF0ZSBhIHByb2R1Y3Rpb24gRmlyZWJhc2UgYXQgaHR0cHM6Ly93d3cuZmlyZWJhc2UuY29tLlwiKTthLlhlKGIsZnVuY3Rpb24oZixrKXtNZihhLGYsaywhMCxiLGMsZHx8e30sZSl9LGZ1bmN0aW9uKGIsYyl7TmYoYSxcImF1dGgoKVwiLGIsYyxmKX0pfWZ1bmN0aW9uIFBmKGEsYil7YS5qYy5jbGVhcigpO0xmKGEsbnVsbCk7YS5EZyhmdW5jdGlvbihhLGQpe2lmKFwib2tcIj09PWEpQihiLG51bGwpO2Vsc2V7dmFyIGU9KGF8fFwiZXJyb3JcIikudG9VcHBlckNhc2UoKSxmPWU7ZCYmKGYrPVwiOiBcIitkKTtmPUVycm9yKGYpO2YuY29kZT1lO0IoYixmKX19KX1cbmZ1bmN0aW9uIE1mKGEsYixjLGQsZSxmLGcsayl7XCJva1wiPT09Yj8oZCYmKGI9Yy5hdXRoLGYuYXV0aD1iLGYuZXhwaXJlcz1jLmV4cGlyZXMsZi50b2tlbj1MZShlKT9lOlwiXCIsYz1udWxsLGImJnMoYixcInVpZFwiKT9jPXQoYixcInVpZFwiKTpzKGYsXCJ1aWRcIikmJihjPXQoZixcInVpZFwiKSksZi51aWQ9YyxjPVwiY3VzdG9tXCIsYiYmcyhiLFwicHJvdmlkZXJcIik/Yz10KGIsXCJwcm92aWRlclwiKTpzKGYsXCJwcm92aWRlclwiKSYmKGM9dChmLFwicHJvdmlkZXJcIikpLGYucHJvdmlkZXI9YyxhLmpjLmNsZWFyKCksTGUoZSkmJihnPWd8fHt9LGM9emEsXCJzZXNzaW9uT25seVwiPT09Zy5yZW1lbWJlciYmKGM9diksXCJub25lXCIhPT1nLnJlbWVtYmVyJiZhLmpjLnNldChmLGMpKSxMZihhLGYpKSxCKGssbnVsbCxmKSk6KGEuamMuY2xlYXIoKSxMZihhLG51bGwpLGY9YT0oYnx8XCJlcnJvclwiKS50b1VwcGVyQ2FzZSgpLGMmJihmKz1cIjogXCIrYyksZj1FcnJvcihmKSxmLmNvZGU9YSxCKGssZikpfVxuZnVuY3Rpb24gTmYoYSxiLGMsZCxlKXt6KGIrXCIgd2FzIGNhbmNlbGVkOiBcIitkKTthLmpjLmNsZWFyKCk7TGYoYSxudWxsKTthPUVycm9yKGQpO2EuY29kZT1jLnRvVXBwZXJDYXNlKCk7QihlLGEpfWZ1bmN0aW9uIFFmKGEsYixjLGQsZSl7UmYoYSk7Yz1uZXcgbmYoZHx8e30se30sY3x8e30pO1NmKGEsW0JmLEVmXSxcIi9hdXRoL1wiK2IsYyxlKX1cbmZ1bmN0aW9uIFRmKGEsYixjLGQpe1JmKGEpO3ZhciBlPVtEZixDZl07Yz1wZihjKTtcImFub255bW91c1wiPT09Ynx8XCJwYXNzd29yZFwiPT09Yj9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7QihkLFgoXCJUUkFOU1BPUlRfVU5BVkFJTEFCTEVcIikpfSwwKTooYy5aZC53aW5kb3dfZmVhdHVyZXM9XCJtZW51YmFyPXllcyxtb2RhbD15ZXMsYWx3YXlzUmFpc2VkPXllc2xvY2F0aW9uPXllcyxyZXNpemFibGU9eWVzLHNjcm9sbGJhcnM9eWVzLHN0YXR1cz15ZXMsaGVpZ2h0PTYyNSx3aWR0aD02MjUsdG9wPVwiKyhcIm9iamVjdFwiPT09dHlwZW9mIHNjcmVlbj8uNSooc2NyZWVuLmhlaWdodC02MjUpOjApK1wiLGxlZnQ9XCIrKFwib2JqZWN0XCI9PT10eXBlb2Ygc2NyZWVuPy41KihzY3JlZW4ud2lkdGgtNjI1KTowKSxjLlpkLnJlbGF5X3VybD15ZihhLk8udWIpLGMuWmQucmVxdWVzdFdpdGhDcmVkZW50aWFsPXEoYS5oYyxhKSxTZihhLGUsXCIvYXV0aC9cIitiLGMsZCkpfVxuZnVuY3Rpb24gS2YoYSl7dmFyIGI9di5nZXQoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIpO2lmKGIpe3ZhciBjPXYuZ2V0KFwicmVkaXJlY3RfY2xpZW50X29wdGlvbnNcIik7di5yZW1vdmUoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIpO3YucmVtb3ZlKFwicmVkaXJlY3RfY2xpZW50X29wdGlvbnNcIik7dmFyIGQ9W0JmLEVmXSxiPXtyZXF1ZXN0SWQ6YixyZXF1ZXN0S2V5OnZmKGRvY3VtZW50LmxvY2F0aW9uLmhhc2gpfSxjPW5ldyBuZihjLHt9LGIpO3RyeXtkb2N1bWVudC5sb2NhdGlvbi5oYXNoPWRvY3VtZW50LmxvY2F0aW9uLmhhc2gucmVwbGFjZSgvJl9fZmlyZWJhc2VfcmVxdWVzdF9rZXk9KFthLXpBLXowLTldKikvLFwiXCIpfWNhdGNoKGUpe31TZihhLGQsXCIvYXV0aC9zZXNzaW9uXCIsYyl9fWgubmU9ZnVuY3Rpb24oYSxiKXtSZih0aGlzKTt2YXIgYz1wZihhKTtjLlhhLl9tZXRob2Q9XCJQT1NUXCI7dGhpcy5oYyhcIi91c2Vyc1wiLGMsZnVuY3Rpb24oYSxjKXthP0IoYixhKTpCKGIsYSxjKX0pfTtcbmguTWU9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO1JmKHRoaXMpO3ZhciBkPVwiL3VzZXJzL1wiK2VuY29kZVVSSUNvbXBvbmVudChhLmVtYWlsKSxlPXBmKGEpO2UuWGEuX21ldGhvZD1cIkRFTEVURVwiO3RoaXMuaGMoZCxlLGZ1bmN0aW9uKGEsZCl7IWEmJmQmJmQudWlkJiZjLmliJiZjLmliLnVpZCYmYy5pYi51aWQ9PT1kLnVpZCYmUGYoYyk7QihiLGEpfSl9O2guamU9ZnVuY3Rpb24oYSxiKXtSZih0aGlzKTt2YXIgYz1cIi91c2Vycy9cIitlbmNvZGVVUklDb21wb25lbnQoYS5lbWFpbCkrXCIvcGFzc3dvcmRcIixkPXBmKGEpO2QuWGEuX21ldGhvZD1cIlBVVFwiO2QuWGEucGFzc3dvcmQ9YS5uZXdQYXNzd29yZDt0aGlzLmhjKGMsZCxmdW5jdGlvbihhKXtCKGIsYSl9KX07XG5oLmllPWZ1bmN0aW9uKGEsYil7UmYodGhpcyk7dmFyIGM9XCIvdXNlcnMvXCIrZW5jb2RlVVJJQ29tcG9uZW50KGEub2xkRW1haWwpK1wiL2VtYWlsXCIsZD1wZihhKTtkLlhhLl9tZXRob2Q9XCJQVVRcIjtkLlhhLmVtYWlsPWEubmV3RW1haWw7ZC5YYS5wYXNzd29yZD1hLnBhc3N3b3JkO3RoaXMuaGMoYyxkLGZ1bmN0aW9uKGEpe0IoYixhKX0pfTtoLk5lPWZ1bmN0aW9uKGEsYil7UmYodGhpcyk7dmFyIGM9XCIvdXNlcnMvXCIrZW5jb2RlVVJJQ29tcG9uZW50KGEuZW1haWwpK1wiL3Bhc3N3b3JkXCIsZD1wZihhKTtkLlhhLl9tZXRob2Q9XCJQT1NUXCI7dGhpcy5oYyhjLGQsZnVuY3Rpb24oYSl7QihiLGEpfSl9O2guaGM9ZnVuY3Rpb24oYSxiLGMpe1VmKHRoaXMsW0JmLEVmXSxhLGIsYyl9O1xuZnVuY3Rpb24gU2YoYSxiLGMsZCxlKXtVZihhLGIsYyxkLGZ1bmN0aW9uKGIsYyl7IWImJmMmJmMudG9rZW4mJmMudWlkP09mKGEsYy50b2tlbixjLGQuY2QsZnVuY3Rpb24oYSxiKXthP0IoZSxhKTpCKGUsbnVsbCxiKX0pOkIoZSxifHxYKFwiVU5LTk9XTl9FUlJPUlwiKSl9KX1cbmZ1bmN0aW9uIFVmKGEsYixjLGQsZSl7Yj1JYShiLGZ1bmN0aW9uKGEpe3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhLmlzQXZhaWxhYmxlJiZhLmlzQXZhaWxhYmxlKCl9KTswPT09Yi5sZW5ndGg/c2V0VGltZW91dChmdW5jdGlvbigpe0IoZSxYKFwiVFJBTlNQT1JUX1VOQVZBSUxBQkxFXCIpKX0sMCk6KGI9bmV3IChiLnNoaWZ0KCkpKGQuWmQpLGQ9dmEoZC5YYSksZC52PVwianMtMi4yLjBcIixkLnRyYW5zcG9ydD1iLnRjKCksZC5zdXBwcmVzc19zdGF0dXNfY29kZXM9ITAsYT14ZigpK1wiL1wiK2EuTy51YitjLGIub3BlbihhLGQsZnVuY3Rpb24oYSxiKXtpZihhKUIoZSxhKTtlbHNlIGlmKGImJmIuZXJyb3Ipe3ZhciBjPUVycm9yKGIuZXJyb3IubWVzc2FnZSk7Yy5jb2RlPWIuZXJyb3IuY29kZTtjLmRldGFpbHM9Yi5lcnJvci5kZXRhaWxzO0IoZSxjKX1lbHNlIEIoZSxudWxsLGIpfSkpfVxuZnVuY3Rpb24gTGYoYSxiKXt2YXIgYz1udWxsIT09YS5pYnx8bnVsbCE9PWI7YS5pYj1iO2MmJmEuJGQoXCJhdXRoX3N0YXR1c1wiLGIpO2EuRmUobnVsbCE9PWIpfWgudWU9ZnVuY3Rpb24oYSl7eShcImF1dGhfc3RhdHVzXCI9PT1hLCdpbml0aWFsIGV2ZW50IG11c3QgYmUgb2YgdHlwZSBcImF1dGhfc3RhdHVzXCInKTtyZXR1cm5bdGhpcy5pYl19O2Z1bmN0aW9uIFJmKGEpe3ZhciBiPWEuTztpZihcImZpcmViYXNlaW8uY29tXCIhPT1iLmRvbWFpbiYmXCJmaXJlYmFzZWlvLWRlbW8uY29tXCIhPT1iLmRvbWFpbiYmXCJhdXRoLmZpcmViYXNlLmNvbVwiPT09bWYpdGhyb3cgRXJyb3IoXCJUaGlzIGN1c3RvbSBGaXJlYmFzZSBzZXJ2ZXIgKCdcIithLk8uZG9tYWluK1wiJykgZG9lcyBub3Qgc3VwcG9ydCBkZWxlZ2F0ZWQgbG9naW4uXCIpO307ZnVuY3Rpb24gVmYoYSxiKXtyZXR1cm4gYSYmXCJvYmplY3RcIj09PXR5cGVvZiBhPyh5KFwiLnN2XCJpbiBhLFwiVW5leHBlY3RlZCBsZWFmIG5vZGUgb3IgcHJpb3JpdHkgY29udGVudHNcIiksYlthW1wiLnN2XCJdXSk6YX1mdW5jdGlvbiBXZihhLGIpe3ZhciBjPW5ldyBjZjtlZihhLG5ldyBTKFwiXCIpLGZ1bmN0aW9uKGEsZSl7Yy5lYyhhLFhmKGUsYikpfSk7cmV0dXJuIGN9ZnVuY3Rpb24gWGYoYSxiKXt2YXIgYz1hLkwoKS5JKCksYz1WZihjLGIpLGQ7aWYoYS5NKCkpe3ZhciBlPVZmKGEuemEoKSxiKTtyZXR1cm4gZSE9PWEuemEoKXx8YyE9PWEuTCgpLkkoKT9uZXcgcWQoZSxPKGMpKTphfWQ9YTtjIT09YS5MKCkuSSgpJiYoZD1kLiQobmV3IHFkKGMpKSk7YS5VKEwsZnVuY3Rpb24oYSxjKXt2YXIgZT1YZihjLGIpO2UhPT1jJiYoZD1kLlAoYSxlKSl9KTtyZXR1cm4gZH07ZnVuY3Rpb24gWWYoYSxiKXt0aGlzLnZhbHVlPWE7dGhpcy5jaGlsZHJlbj1ifHxaZn12YXIgWmY9bmV3IGJkKGZ1bmN0aW9uKGEsYil7cmV0dXJuIGE9PT1iPzA6YTxiPy0xOjF9KSwkZj1uZXcgWWYobnVsbCk7ZnVuY3Rpb24gYWcoYSl7dmFyIGI9JGY7QShhLGZ1bmN0aW9uKGEsZCl7Yj1iLnNldChuZXcgUyhkKSxhKX0pO3JldHVybiBifWg9WWYucHJvdG90eXBlO2guZT1mdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy52YWx1ZSYmdGhpcy5jaGlsZHJlbi5lKCl9O2Z1bmN0aW9uIGJnKGEsYixjKXtpZihudWxsIT1hLnZhbHVlJiZjKGEudmFsdWUpKXJldHVybntwYXRoOlUsdmFsdWU6YS52YWx1ZX07aWYoYi5lKCkpcmV0dXJuIG51bGw7dmFyIGQ9SShiKTthPWEuY2hpbGRyZW4uZ2V0KGQpO3JldHVybiBudWxsIT09YT8oYj1iZyhhLFQoYiksYyksbnVsbCE9Yj97cGF0aDoobmV3IFMoZCkpLnUoYi5wYXRoKSx2YWx1ZTpiLnZhbHVlfTpudWxsKTpudWxsfVxuZnVuY3Rpb24gY2coYSxiKXtyZXR1cm4gYmcoYSxiLGZ1bmN0aW9uKCl7cmV0dXJuITB9KX1oLnN1YnRyZWU9ZnVuY3Rpb24oYSl7aWYoYS5lKCkpcmV0dXJuIHRoaXM7dmFyIGI9dGhpcy5jaGlsZHJlbi5nZXQoSShhKSk7cmV0dXJuIG51bGwhPT1iP2Iuc3VidHJlZShUKGEpKTokZn07aC5zZXQ9ZnVuY3Rpb24oYSxiKXtpZihhLmUoKSlyZXR1cm4gbmV3IFlmKGIsdGhpcy5jaGlsZHJlbik7dmFyIGM9SShhKSxkPSh0aGlzLmNoaWxkcmVuLmdldChjKXx8JGYpLnNldChUKGEpLGIpLGM9dGhpcy5jaGlsZHJlbi5MYShjLGQpO3JldHVybiBuZXcgWWYodGhpcy52YWx1ZSxjKX07XG5oLnJlbW92ZT1mdW5jdGlvbihhKXtpZihhLmUoKSlyZXR1cm4gdGhpcy5jaGlsZHJlbi5lKCk/JGY6bmV3IFlmKG51bGwsdGhpcy5jaGlsZHJlbik7dmFyIGI9SShhKSxjPXRoaXMuY2hpbGRyZW4uZ2V0KGIpO3JldHVybiBjPyhhPWMucmVtb3ZlKFQoYSkpLGI9YS5lKCk/dGhpcy5jaGlsZHJlbi5yZW1vdmUoYik6dGhpcy5jaGlsZHJlbi5MYShiLGEpLG51bGw9PT10aGlzLnZhbHVlJiZiLmUoKT8kZjpuZXcgWWYodGhpcy52YWx1ZSxiKSk6dGhpc307aC5nZXQ9ZnVuY3Rpb24oYSl7aWYoYS5lKCkpcmV0dXJuIHRoaXMudmFsdWU7dmFyIGI9dGhpcy5jaGlsZHJlbi5nZXQoSShhKSk7cmV0dXJuIGI/Yi5nZXQoVChhKSk6bnVsbH07XG5mdW5jdGlvbiBkZyhhLGIsYyl7aWYoYi5lKCkpcmV0dXJuIGM7dmFyIGQ9SShiKTtiPWRnKGEuY2hpbGRyZW4uZ2V0KGQpfHwkZixUKGIpLGMpO2Q9Yi5lKCk/YS5jaGlsZHJlbi5yZW1vdmUoZCk6YS5jaGlsZHJlbi5MYShkLGIpO3JldHVybiBuZXcgWWYoYS52YWx1ZSxkKX1mdW5jdGlvbiBlZyhhLGIpe3JldHVybiBmZyhhLFUsYil9ZnVuY3Rpb24gZmcoYSxiLGMpe3ZhciBkPXt9O2EuY2hpbGRyZW4uZmEoZnVuY3Rpb24oYSxmKXtkW2FdPWZnKGYsYi51KGEpLGMpfSk7cmV0dXJuIGMoYixhLnZhbHVlLGQpfWZ1bmN0aW9uIGdnKGEsYixjKXtyZXR1cm4gaGcoYSxiLFUsYyl9ZnVuY3Rpb24gaGcoYSxiLGMsZCl7dmFyIGU9YS52YWx1ZT9kKGMsYS52YWx1ZSk6ITE7aWYoZSlyZXR1cm4gZTtpZihiLmUoKSlyZXR1cm4gbnVsbDtlPUkoYik7cmV0dXJuKGE9YS5jaGlsZHJlbi5nZXQoZSkpP2hnKGEsVChiKSxjLnUoZSksZCk6bnVsbH1cbmZ1bmN0aW9uIGlnKGEsYixjKXtpZighYi5lKCkpe3ZhciBkPSEwO2EudmFsdWUmJihkPWMoVSxhLnZhbHVlKSk7ITA9PT1kJiYoZD1JKGIpLChhPWEuY2hpbGRyZW4uZ2V0KGQpKSYmamcoYSxUKGIpLFUudShkKSxjKSl9fWZ1bmN0aW9uIGpnKGEsYixjLGQpe2lmKGIuZSgpKXJldHVybiBhO2EudmFsdWUmJmQoYyxhLnZhbHVlKTt2YXIgZT1JKGIpO3JldHVybihhPWEuY2hpbGRyZW4uZ2V0KGUpKT9qZyhhLFQoYiksYy51KGUpLGQpOiRmfWZ1bmN0aW9uIGtnKGEsYil7bGcoYSxVLGIpfWZ1bmN0aW9uIGxnKGEsYixjKXthLmNoaWxkcmVuLmZhKGZ1bmN0aW9uKGEsZSl7bGcoZSxiLnUoYSksYyl9KTthLnZhbHVlJiZjKGIsYS52YWx1ZSl9ZnVuY3Rpb24gbWcoYSxiKXthLmNoaWxkcmVuLmZhKGZ1bmN0aW9uKGEsZCl7ZC52YWx1ZSYmYihhLGQudmFsdWUpfSl9XG5oLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9e307a2codGhpcyxmdW5jdGlvbihiLGMpe2FbYi50b1N0cmluZygpXT1jLnRvU3RyaW5nKCl9KTtyZXR1cm4gcihhKX07ZnVuY3Rpb24gbmcoYSxiKXt0aGlzLmNlPWE7dGhpcy5PZj1ifWZ1bmN0aW9uIG9nKGEpe3RoaXMuRz1hfVxub2cucHJvdG90eXBlLllhPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW5ldyBCYyxmO2lmKGIudHlwZT09PXBnKWIuc291cmNlLnFlP2M9cWcodGhpcyxhLGIucGF0aCxiLkdhLGMsZCxlKTooeShiLnNvdXJjZS5lZixcIlVua25vd24gc291cmNlLlwiKSxmPWIuc291cmNlLlRlLGM9cmcodGhpcyxhLGIucGF0aCxiLkdhLGMsZCxmLGUpKTtlbHNlIGlmKGIudHlwZT09PXNnKWIuc291cmNlLnFlP2M9dGcodGhpcyxhLGIucGF0aCxiLmNoaWxkcmVuLGMsZCxlKTooeShiLnNvdXJjZS5lZixcIlVua25vd24gc291cmNlLlwiKSxmPWIuc291cmNlLlRlLGM9dWcodGhpcyxhLGIucGF0aCxiLmNoaWxkcmVuLGMsZCxmLGUpKTtlbHNlIGlmKGIudHlwZT09PXZnKWlmKGIuT2UpaWYoZj1iLnBhdGgsbnVsbCE9Yy5rYyhmKSljPWE7ZWxzZXtiPW5ldyB4YyhjLGEsZCk7ZD1hLkIuaigpO2lmKGYuZSgpfHxcIi5wcmlvcml0eVwiPT09SShmKSl3ZyhhLm8oKSk/Yj1jLnBhKEFjKGEpKTooYj1hLm8oKS5qKCksXG55KGIgaW5zdGFuY2VvZiBXLFwic2VydmVyQ2hpbGRyZW4gd291bGQgYmUgY29tcGxldGUgaWYgbGVhZiBub2RlXCIpLGI9Yy5xYyhiKSksYj10aGlzLkcub2EoZCxiLGUpO2Vsc2V7Zj1JKGYpO3ZhciBnPWMuVGEoZixhLm8oKSk7bnVsbD09ZyYmeWMoYS5vKCksZikmJihnPWQuSyhmKSk7Yj1udWxsIT1nP3RoaXMuRy5EKGQsZixnLGIsZSk6YS5CLmooKS5EYShmKT90aGlzLkcuRChkLGYsTSxiLGUpOmQ7Yi5lKCkmJndnKGEubygpKSYmKGQ9Yy5wYShBYyhhKSksZC5NKCkmJihiPXRoaXMuRy5vYShiLGQsZSkpKX1kPXdnKGEubygpKXx8bnVsbCE9Yy5rYyhVKTtjPXhnKGEsYixkLHRoaXMuRy5DYSgpKX1lbHNlIGM9eWcodGhpcyxhLGIucGF0aCxjLGQsZSk7ZWxzZSBpZihiLnR5cGU9PT16ZylkPWIucGF0aCxiPWEubygpLGY9Yi5qKCksZz1iLlp8fGQuZSgpLGM9QWcodGhpcyxuZXcgQmcoYS5CLG5ldyB6YyhmLGcsYi5MYikpLGQsYyx3YyxlKTtlbHNlIHRocm93IGZiKFwiVW5rbm93biBvcGVyYXRpb24gdHlwZTogXCIrXG5iLnR5cGUpO2U9TGQoZS5aYSk7ZD1jO2I9ZC5CO2IuWiYmKGY9Yi5qKCkuTSgpfHxiLmooKS5lKCksZz1DZyhhKSwoMDxlLmxlbmd0aHx8IWEuQi5afHxmJiYhYi5qKCkuYWEoZyl8fCFiLmooKS5MKCkuYWEoZy5MKCkpKSYmZS5wdXNoKEZiKENnKGQpKSkpO3JldHVybiBuZXcgbmcoYyxlKX07XG5mdW5jdGlvbiBBZyhhLGIsYyxkLGUsZil7dmFyIGc9Yi5CO2lmKG51bGwhPWQua2MoYykpcmV0dXJuIGI7dmFyIGs7aWYoYy5lKCkpeSh3ZyhiLm8oKSksXCJJZiBjaGFuZ2UgcGF0aCBpcyBlbXB0eSwgd2UgbXVzdCBoYXZlIGNvbXBsZXRlIHNlcnZlciBkYXRhXCIpLGIubygpLkxiPyhlPUFjKGIpLGQ9ZC5xYyhlIGluc3RhbmNlb2YgVz9lOk0pKTpkPWQucGEoQWMoYikpLGY9YS5HLm9hKGIuQi5qKCksZCxmKTtlbHNle3ZhciBsPUkoYyk7aWYoXCIucHJpb3JpdHlcIj09bCl5KDE9PVRjKGMpLFwiQ2FuJ3QgaGF2ZSBhIHByaW9yaXR5IHdpdGggYWRkaXRpb25hbCBwYXRoIGNvbXBvbmVudHNcIiksZj1nLmooKSxrPWIubygpLmooKSxkPWQuJGMoYyxmLGspLGY9bnVsbCE9ZD9hLkcuJChmLGQpOmcuaigpO2Vsc2V7dmFyIG49VChjKTt5YyhnLGwpPyhrPWIubygpLmooKSxkPWQuJGMoYyxnLmooKSxrKSxkPW51bGwhPWQ/Zy5qKCkuSyhsKS5EKG4sZCk6Zy5qKCkuSyhsKSk6ZD1kLlRhKGwsYi5vKCkpO1xuZj1udWxsIT1kP2EuRy5EKGcuaigpLGwsZCxlLGYpOmcuaigpfX1yZXR1cm4geGcoYixmLGcuWnx8Yy5lKCksYS5HLkNhKCkpfWZ1bmN0aW9uIHJnKGEsYixjLGQsZSxmLGcsayl7dmFyIGw9Yi5vKCk7Zz1nP2EuRzphLkcuTmIoKTtpZihjLmUoKSlkPWcub2EobC5qKCksZCxudWxsKTtlbHNlIGlmKGcuQ2EoKSYmIWwuTGIpZD1sLmooKS5EKGMsZCksZD1nLm9hKGwuaigpLGQsbnVsbCk7ZWxzZXt2YXIgbj1JKGMpO2lmKChjLmUoKT8hbC5afHxsLkxiOiF5YyhsLEkoYykpKSYmMTxUYyhjKSlyZXR1cm4gYjtkPWwuaigpLksobikuRChUKGMpLGQpO2Q9XCIucHJpb3JpdHlcIj09bj9nLiQobC5qKCksZCk6Zy5EKGwuaigpLG4sZCx3YyxudWxsKX1sPWwuWnx8Yy5lKCk7Yj1uZXcgQmcoYi5CLG5ldyB6YyhkLGwsZy5DYSgpKSk7cmV0dXJuIEFnKGEsYixjLGUsbmV3IHhjKGUsYixmKSxrKX1cbmZ1bmN0aW9uIHFnKGEsYixjLGQsZSxmLGcpe3ZhciBrPWIuQjtlPW5ldyB4YyhlLGIsZik7aWYoYy5lKCkpZz1hLkcub2EoYi5CLmooKSxkLGcpLGE9eGcoYixnLCEwLGEuRy5DYSgpKTtlbHNlIGlmKGY9SShjKSxcIi5wcmlvcml0eVwiPT09ZilnPWEuRy4kKGIuQi5qKCksZCksYT14ZyhiLGcsay5aLGsuTGIpO2Vsc2V7dmFyIGw9VChjKTtjPWsuaigpLksoZik7aWYoIWwuZSgpKXt2YXIgbj1lLmZmKGYpO2Q9bnVsbCE9bj9cIi5wcmlvcml0eVwiPT09VWMobCkmJm4ucmEobC5wYXJlbnQoKSkuZSgpP246bi5EKGwsZCk6TX1jLmFhKGQpP2E9YjooZz1hLkcuRChrLmooKSxmLGQsZSxnKSxhPXhnKGIsZyxrLlosYS5HLkNhKCkpKX1yZXR1cm4gYX1cbmZ1bmN0aW9uIHRnKGEsYixjLGQsZSxmLGcpe3ZhciBrPWI7a2coZCxmdW5jdGlvbihkLG4pe3ZhciB1PWMudShkKTt5YyhiLkIsSSh1KSkmJihrPXFnKGEsayx1LG4sZSxmLGcpKX0pO2tnKGQsZnVuY3Rpb24oZCxuKXt2YXIgdT1jLnUoZCk7eWMoYi5CLEkodSkpfHwoaz1xZyhhLGssdSxuLGUsZixnKSl9KTtyZXR1cm4ga31mdW5jdGlvbiBEZyhhLGIpe2tnKGIsZnVuY3Rpb24oYixkKXthPWEuRChiLGQpfSk7cmV0dXJuIGF9XG5mdW5jdGlvbiB1ZyhhLGIsYyxkLGUsZixnLGspe2lmKGIubygpLmooKS5lKCkmJiF3ZyhiLm8oKSkpcmV0dXJuIGI7dmFyIGw9YjtjPWMuZSgpP2Q6ZGcoJGYsYyxkKTt2YXIgbj1iLm8oKS5qKCk7Yy5jaGlsZHJlbi5mYShmdW5jdGlvbihjLGQpe2lmKG4uRGEoYykpe3ZhciBGPWIubygpLmooKS5LKGMpLEY9RGcoRixkKTtsPXJnKGEsbCxuZXcgUyhjKSxGLGUsZixnLGspfX0pO2MuY2hpbGRyZW4uZmEoZnVuY3Rpb24oYyxkKXt2YXIgRj0hd2coYi5vKCkpJiZudWxsPT1kLnZhbHVlO24uRGEoYyl8fEZ8fChGPWIubygpLmooKS5LKGMpLEY9RGcoRixkKSxsPXJnKGEsbCxuZXcgUyhjKSxGLGUsZixnLGspKX0pO3JldHVybiBsfVxuZnVuY3Rpb24geWcoYSxiLGMsZCxlLGYpe2lmKG51bGwhPWQua2MoYykpcmV0dXJuIGI7dmFyIGc9bmV3IHhjKGQsYixlKSxrPWU9Yi5CLmooKTtpZih3ZyhiLm8oKSkpe2lmKGMuZSgpKWU9ZC5wYShBYyhiKSksaz1hLkcub2EoYi5CLmooKSxlLGYpO2Vsc2UgaWYoXCIucHJpb3JpdHlcIj09PUkoYykpe3ZhciBsPWQuVGEoSShjKSxiLm8oKSk7bnVsbD09bHx8ZS5lKCl8fGUuTCgpLmFhKGwpfHwoaz1hLkcuJChlLGwpKX1lbHNlIGw9SShjKSxlPWQuVGEobCxiLm8oKSksbnVsbCE9ZSYmKGs9YS5HLkQoYi5CLmooKSxsLGUsZyxmKSk7ZT0hMH1lbHNlIGlmKGIuQi5afHxjLmUoKSlrPWUsZT1iLkIuaigpLGUuTSgpfHxlLlUoTCxmdW5jdGlvbihjKXt2YXIgZT1kLlRhKGMsYi5vKCkpO251bGwhPWUmJihrPWEuRy5EKGssYyxlLGcsZikpfSksZT1iLkIuWjtlbHNle2w9SShjKTtpZigxPT1UYyhjKXx8eWMoYi5CLGwpKWM9ZC5UYShsLGIubygpKSxudWxsIT1jJiYoaz1hLkcuRChlLGwsYyxcbmcsZikpO2U9ITF9cmV0dXJuIHhnKGIsayxlLGEuRy5DYSgpKX07ZnVuY3Rpb24gRWcoYSl7dGhpcy5XPWE7dGhpcy5nPWEubi5nfWZ1bmN0aW9uIEZnKGEsYixjLGQpe3ZhciBlPVtdLGY9W107SGEoYixmdW5jdGlvbihiKXtcImNoaWxkX2NoYW5nZWRcIj09PWIudHlwZSYmYS5nLndlKGIuRWUsYi5IYSkmJmYucHVzaChuZXcgQyhcImNoaWxkX21vdmVkXCIsYi5IYSxiLlVhKSl9KTtHZyhhLGUsXCJjaGlsZF9yZW1vdmVkXCIsYixkLGMpO0dnKGEsZSxcImNoaWxkX2FkZGVkXCIsYixkLGMpO0dnKGEsZSxcImNoaWxkX21vdmVkXCIsZixkLGMpO0dnKGEsZSxcImNoaWxkX2NoYW5nZWRcIixiLGQsYyk7R2coYSxlLEdiLGIsZCxjKTtyZXR1cm4gZX1mdW5jdGlvbiBHZyhhLGIsYyxkLGUsZil7ZD1JYShkLGZ1bmN0aW9uKGEpe3JldHVybiBhLnR5cGU9PT1jfSk7UWEoZCxxKGEuUWYsYSkpO0hhKGQsZnVuY3Rpb24oYyl7dmFyIGQ9SGcoYSxjLGYpO0hhKGUsZnVuY3Rpb24oZSl7ZS53ZihjLnR5cGUpJiZiLnB1c2goZS5jcmVhdGVFdmVudChkLGEuVykpfSl9KX1cbmZ1bmN0aW9uIEhnKGEsYixjKXtcInZhbHVlXCIhPT1iLnR5cGUmJlwiY2hpbGRfcmVtb3ZlZFwiIT09Yi50eXBlJiYoYi5LZD1jLmdmKGIuVWEsYi5IYSxhLmcpKTtyZXR1cm4gYn1FZy5wcm90b3R5cGUuUWY9ZnVuY3Rpb24oYSxiKXtpZihudWxsPT1hLlVhfHxudWxsPT1iLlVhKXRocm93IGZiKFwiU2hvdWxkIG9ubHkgY29tcGFyZSBjaGlsZF8gZXZlbnRzLlwiKTtyZXR1cm4gdGhpcy5nLmNvbXBhcmUobmV3IE4oYS5VYSxhLkhhKSxuZXcgTihiLlVhLGIuSGEpKX07ZnVuY3Rpb24gemMoYSxiLGMpe3RoaXMuQT1hO3RoaXMuWj1iO3RoaXMuTGI9Y31mdW5jdGlvbiB3ZyhhKXtyZXR1cm4gYS5afWZ1bmN0aW9uIHljKGEsYil7cmV0dXJuIGEuWiYmIWEuTGJ8fGEuQS5EYShiKX16Yy5wcm90b3R5cGUuaj1mdW5jdGlvbigpe3JldHVybiB0aGlzLkF9O2Z1bmN0aW9uIEJnKGEsYil7dGhpcy5CPWE7dGhpcy5RZD1ifWZ1bmN0aW9uIHhnKGEsYixjLGQpe3JldHVybiBuZXcgQmcobmV3IHpjKGIsYyxkKSxhLlFkKX1mdW5jdGlvbiBDZyhhKXtyZXR1cm4gYS5CLlo/YS5CLmooKTpudWxsfUJnLnByb3RvdHlwZS5vPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuUWR9O2Z1bmN0aW9uIEFjKGEpe3JldHVybiBhLlFkLlo/YS5RZC5qKCk6bnVsbH07ZnVuY3Rpb24gSWcoYSxiKXt0aGlzLlc9YTt2YXIgYz1hLm4sZD1uZXcgYmMoYy5nKSxjPU1jKGMpP25ldyBiYyhjLmcpOmMua2E/bmV3IERjKGMpOm5ldyBkYyhjKTt0aGlzLnNmPW5ldyBvZyhjKTt2YXIgZT1iLm8oKSxmPWIuQixnPWQub2EoTSxlLmooKSxudWxsKSxrPWMub2EoTSxmLmooKSxudWxsKTt0aGlzLklhPW5ldyBCZyhuZXcgemMoayxmLlosYy5DYSgpKSxuZXcgemMoZyxlLlosZC5DYSgpKSk7dGhpcy5WYT1bXTt0aGlzLlVmPW5ldyBFZyhhKX1mdW5jdGlvbiBKZyhhKXtyZXR1cm4gYS5XfWg9SWcucHJvdG90eXBlO2gubz1mdW5jdGlvbigpe3JldHVybiB0aGlzLklhLm8oKS5qKCl9O2guYmI9ZnVuY3Rpb24oYSl7dmFyIGI9QWModGhpcy5JYSk7cmV0dXJuIGImJihNYyh0aGlzLlcubil8fCFhLmUoKSYmIWIuSyhJKGEpKS5lKCkpP2IucmEoYSk6bnVsbH07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLlZhLmxlbmd0aH07aC5HYj1mdW5jdGlvbihhKXt0aGlzLlZhLnB1c2goYSl9O1xuaC5nYj1mdW5jdGlvbihhLGIpe3ZhciBjPVtdO2lmKGIpe3kobnVsbD09YSxcIkEgY2FuY2VsIHNob3VsZCBjYW5jZWwgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMuXCIpO3ZhciBkPXRoaXMuVy5wYXRoO0hhKHRoaXMuVmEsZnVuY3Rpb24oYSl7KGE9YS5aZShiLGQpKSYmYy5wdXNoKGEpfSl9aWYoYSl7Zm9yKHZhciBlPVtdLGY9MDtmPHRoaXMuVmEubGVuZ3RoOysrZil7dmFyIGc9dGhpcy5WYVtmXTtpZighZy5tYXRjaGVzKGEpKWUucHVzaChnKTtlbHNlIGlmKGEuamYoKSl7ZT1lLmNvbmNhdCh0aGlzLlZhLnNsaWNlKGYrMSkpO2JyZWFrfX10aGlzLlZhPWV9ZWxzZSB0aGlzLlZhPVtdO3JldHVybiBjfTtcbmguWWE9ZnVuY3Rpb24oYSxiLGMpe2EudHlwZT09PXNnJiZudWxsIT09YS5zb3VyY2UuemImJih5KEFjKHRoaXMuSWEpLFwiV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgZnVsbCBjYWNoZSBiZWZvcmUgaGFuZGxpbmcgbWVyZ2VzXCIpLHkoQ2codGhpcy5JYSksXCJNaXNzaW5nIGV2ZW50IGNhY2hlLCBldmVuIHRob3VnaCB3ZSBoYXZlIGEgc2VydmVyIGNhY2hlXCIpKTt2YXIgZD10aGlzLklhO2E9dGhpcy5zZi5ZYShkLGEsYixjKTtiPXRoaXMuc2Y7Yz1hLmNlO3koYy5CLmooKS5CYyhiLkcuZyksXCJFdmVudCBzbmFwIG5vdCBpbmRleGVkXCIpO3koYy5vKCkuaigpLkJjKGIuRy5nKSxcIlNlcnZlciBzbmFwIG5vdCBpbmRleGVkXCIpO3kod2coYS5jZS5vKCkpfHwhd2coZC5vKCkpLFwiT25jZSBhIHNlcnZlciBzbmFwIGlzIGNvbXBsZXRlLCBpdCBzaG91bGQgbmV2ZXIgZ28gYmFja1wiKTt0aGlzLklhPWEuY2U7cmV0dXJuIEtnKHRoaXMsYS5PZixhLmNlLkIuaigpLG51bGwpfTtcbmZ1bmN0aW9uIExnKGEsYil7dmFyIGM9YS5JYS5CLGQ9W107Yy5qKCkuTSgpfHxjLmooKS5VKEwsZnVuY3Rpb24oYSxiKXtkLnB1c2gobmV3IEMoXCJjaGlsZF9hZGRlZFwiLGIsYSkpfSk7Yy5aJiZkLnB1c2goRmIoYy5qKCkpKTtyZXR1cm4gS2coYSxkLGMuaigpLGIpfWZ1bmN0aW9uIEtnKGEsYixjLGQpe3JldHVybiBGZyhhLlVmLGIsYyxkP1tkXTphLlZhKX07ZnVuY3Rpb24gTWcoKXt0aGlzLndhPXt9fWg9TWcucHJvdG90eXBlO2guZT1mdW5jdGlvbigpe3JldHVybiBQZCh0aGlzLndhKX07aC5ZYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS5zb3VyY2UuemI7aWYobnVsbCE9PWQpcmV0dXJuIGQ9dCh0aGlzLndhLGQpLHkobnVsbCE9ZCxcIlN5bmNUcmVlIGdhdmUgdXMgYW4gb3AgZm9yIGFuIGludmFsaWQgcXVlcnkuXCIpLGQuWWEoYSxiLGMpO3ZhciBlPVtdO0EodGhpcy53YSxmdW5jdGlvbihkKXtlPWUuY29uY2F0KGQuWWEoYSxiLGMpKX0pO3JldHVybiBlfTtoLkdiPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9YS5GYSgpLGc9dCh0aGlzLndhLGYpO2lmKCFnKXt2YXIgZz1jLnBhKGU/ZDpudWxsKSxrPSExO2c/az0hMDooZz1kIGluc3RhbmNlb2YgVz9jLnFjKGQpOk0saz0hMSk7Zz1uZXcgSWcoYSxuZXcgQmcobmV3IHpjKGcsaywhMSksbmV3IHpjKGQsZSwhMSkpKTt0aGlzLndhW2ZdPWd9Zy5HYihiKTtyZXR1cm4gTGcoZyxiKX07XG5oLmdiPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLkZhKCksZT1bXSxmPVtdLGc9bnVsbCE9TmcodGhpcyk7aWYoXCJkZWZhdWx0XCI9PT1kKXt2YXIgaz10aGlzO0EodGhpcy53YSxmdW5jdGlvbihhLGQpe2Y9Zi5jb25jYXQoYS5nYihiLGMpKTthLmUoKSYmKGRlbGV0ZSBrLndhW2RdLE1jKGEuVy5uKXx8ZS5wdXNoKGEuVykpfSl9ZWxzZXt2YXIgbD10KHRoaXMud2EsZCk7bCYmKGY9Zi5jb25jYXQobC5nYihiLGMpKSxsLmUoKSYmKGRlbGV0ZSB0aGlzLndhW2RdLE1jKGwuVy5uKXx8ZS5wdXNoKGwuVykpKX1nJiZudWxsPT1OZyh0aGlzKSYmZS5wdXNoKG5ldyBSKGEuayxhLnBhdGgpKTtyZXR1cm57c2c6ZSxWZjpmfX07ZnVuY3Rpb24gT2coYSl7cmV0dXJuIElhKExkKGEud2EpLGZ1bmN0aW9uKGEpe3JldHVybiFNYyhhLlcubil9KX1oLmJiPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7QSh0aGlzLndhLGZ1bmN0aW9uKGMpe2I9Ynx8Yy5iYihhKX0pO3JldHVybiBifTtcbmZ1bmN0aW9uIFBnKGEsYil7aWYoTWMoYi5uKSlyZXR1cm4gTmcoYSk7dmFyIGM9Yi5GYSgpO3JldHVybiB0KGEud2EsYyl9ZnVuY3Rpb24gTmcoYSl7cmV0dXJuIE9kKGEud2EsZnVuY3Rpb24oYSl7cmV0dXJuIE1jKGEuVy5uKX0pfHxudWxsfTtmdW5jdGlvbiBRZyhhKXt0aGlzLlg9YX12YXIgUmc9bmV3IFFnKG5ldyBZZihudWxsKSk7ZnVuY3Rpb24gU2coYSxiLGMpe2lmKGIuZSgpKXJldHVybiBuZXcgUWcobmV3IFlmKGMpKTt2YXIgZD1jZyhhLlgsYik7aWYobnVsbCE9ZCl7dmFyIGU9ZC5wYXRoLGQ9ZC52YWx1ZTtiPVYoZSxiKTtkPWQuRChiLGMpO3JldHVybiBuZXcgUWcoYS5YLnNldChlLGQpKX1hPWRnKGEuWCxiLG5ldyBZZihjKSk7cmV0dXJuIG5ldyBRZyhhKX1mdW5jdGlvbiBUZyhhLGIsYyl7dmFyIGQ9YTt1YShjLGZ1bmN0aW9uKGEsYyl7ZD1TZyhkLGIudShhKSxjKX0pO3JldHVybiBkfVFnLnByb3RvdHlwZS5MZD1mdW5jdGlvbihhKXtpZihhLmUoKSlyZXR1cm4gUmc7YT1kZyh0aGlzLlgsYSwkZik7cmV0dXJuIG5ldyBRZyhhKX07ZnVuY3Rpb24gVWcoYSxiKXt2YXIgYz1jZyhhLlgsYik7cmV0dXJuIG51bGwhPWM/YS5YLmdldChjLnBhdGgpLnJhKFYoYy5wYXRoLGIpKTpudWxsfVxuZnVuY3Rpb24gVmcoYSl7dmFyIGI9W10sYz1hLlgudmFsdWU7bnVsbCE9Yz9jLk0oKXx8Yy5VKEwsZnVuY3Rpb24oYSxjKXtiLnB1c2gobmV3IE4oYSxjKSl9KTphLlguY2hpbGRyZW4uZmEoZnVuY3Rpb24oYSxjKXtudWxsIT1jLnZhbHVlJiZiLnB1c2gobmV3IE4oYSxjLnZhbHVlKSl9KTtyZXR1cm4gYn1mdW5jdGlvbiBXZyhhLGIpe2lmKGIuZSgpKXJldHVybiBhO3ZhciBjPVVnKGEsYik7cmV0dXJuIG51bGwhPWM/bmV3IFFnKG5ldyBZZihjKSk6bmV3IFFnKGEuWC5zdWJ0cmVlKGIpKX1RZy5wcm90b3R5cGUuZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLlguZSgpfTtRZy5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oYSl7cmV0dXJuIFhnKFUsdGhpcy5YLGEpfTtcbmZ1bmN0aW9uIFhnKGEsYixjKXtpZihudWxsIT1iLnZhbHVlKXJldHVybiBjLkQoYSxiLnZhbHVlKTt2YXIgZD1udWxsO2IuY2hpbGRyZW4uZmEoZnVuY3Rpb24oYixmKXtcIi5wcmlvcml0eVwiPT09Yj8oeShudWxsIT09Zi52YWx1ZSxcIlByaW9yaXR5IHdyaXRlcyBtdXN0IGFsd2F5cyBiZSBsZWFmIG5vZGVzXCIpLGQ9Zi52YWx1ZSk6Yz1YZyhhLnUoYiksZixjKX0pO2MucmEoYSkuZSgpfHxudWxsPT09ZHx8KGM9Yy5EKGEudShcIi5wcmlvcml0eVwiKSxkKSk7cmV0dXJuIGN9O2Z1bmN0aW9uIFlnKCl7dGhpcy5UPVJnO3RoaXMueGE9W107dGhpcy5FYz0tMX1oPVlnLnByb3RvdHlwZTtcbmguTGQ9ZnVuY3Rpb24oYSl7dmFyIGI9TmEodGhpcy54YSxmdW5jdGlvbihiKXtyZXR1cm4gYi5kZT09PWF9KTt5KDA8PWIsXCJyZW1vdmVXcml0ZSBjYWxsZWQgd2l0aCBub25leGlzdGVudCB3cml0ZUlkLlwiKTt2YXIgYz10aGlzLnhhW2JdO3RoaXMueGEuc3BsaWNlKGIsMSk7Zm9yKHZhciBkPWMudmlzaWJsZSxlPSExLGY9dGhpcy54YS5sZW5ndGgtMTtkJiYwPD1mOyl7dmFyIGc9dGhpcy54YVtmXTtnLnZpc2libGUmJihmPj1iJiZaZyhnLGMucGF0aCk/ZD0hMTpjLnBhdGguY29udGFpbnMoZy5wYXRoKSYmKGU9ITApKTtmLS19aWYoZCl7aWYoZSl0aGlzLlQ9JGcodGhpcy54YSxhaCxVKSx0aGlzLkVjPTA8dGhpcy54YS5sZW5ndGg/dGhpcy54YVt0aGlzLnhhLmxlbmd0aC0xXS5kZTotMTtlbHNlIGlmKGMuR2EpdGhpcy5UPXRoaXMuVC5MZChjLnBhdGgpO2Vsc2V7dmFyIGs9dGhpcztBKGMuY2hpbGRyZW4sZnVuY3Rpb24oYSxiKXtrLlQ9ay5ULkxkKGMucGF0aC51KGIpKX0pfXJldHVybiBjLnBhdGh9cmV0dXJuIG51bGx9O1xuaC5wYT1mdW5jdGlvbihhLGIsYyxkKXtpZihjfHxkKXt2YXIgZT1XZyh0aGlzLlQsYSk7cmV0dXJuIWQmJmUuZSgpP2I6ZHx8bnVsbCE9Ynx8bnVsbCE9VWcoZSxVKT8oZT0kZyh0aGlzLnhhLGZ1bmN0aW9uKGIpe3JldHVybihiLnZpc2libGV8fGQpJiYoIWN8fCEoMDw9R2EoYyxiLmRlKSkpJiYoYi5wYXRoLmNvbnRhaW5zKGEpfHxhLmNvbnRhaW5zKGIucGF0aCkpfSxhKSxiPWJ8fE0sZS5hcHBseShiKSk6bnVsbH1lPVVnKHRoaXMuVCxhKTtpZihudWxsIT1lKXJldHVybiBlO2U9V2codGhpcy5ULGEpO3JldHVybiBlLmUoKT9iOm51bGwhPWJ8fG51bGwhPVVnKGUsVSk/KGI9Ynx8TSxlLmFwcGx5KGIpKTpudWxsfTtcbmgucWM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1NLGQ9VWcodGhpcy5ULGEpO2lmKGQpZC5NKCl8fGQuVShMLGZ1bmN0aW9uKGEsYil7Yz1jLlAoYSxiKX0pO2Vsc2UgaWYoYil7dmFyIGU9V2codGhpcy5ULGEpO2IuVShMLGZ1bmN0aW9uKGEsYil7dmFyIGQ9V2coZSxuZXcgUyhhKSkuYXBwbHkoYik7Yz1jLlAoYSxkKX0pO0hhKFZnKGUpLGZ1bmN0aW9uKGEpe2M9Yy5QKGEubmFtZSxhLlYpfSl9ZWxzZSBlPVdnKHRoaXMuVCxhKSxIYShWZyhlKSxmdW5jdGlvbihhKXtjPWMuUChhLm5hbWUsYS5WKX0pO3JldHVybiBjfTtoLiRjPWZ1bmN0aW9uKGEsYixjLGQpe3koY3x8ZCxcIkVpdGhlciBleGlzdGluZ0V2ZW50U25hcCBvciBleGlzdGluZ1NlcnZlclNuYXAgbXVzdCBleGlzdFwiKTthPWEudShiKTtpZihudWxsIT1VZyh0aGlzLlQsYSkpcmV0dXJuIG51bGw7YT1XZyh0aGlzLlQsYSk7cmV0dXJuIGEuZSgpP2QucmEoYik6YS5hcHBseShkLnJhKGIpKX07XG5oLlRhPWZ1bmN0aW9uKGEsYixjKXthPWEudShiKTt2YXIgZD1VZyh0aGlzLlQsYSk7cmV0dXJuIG51bGwhPWQ/ZDp5YyhjLGIpP1dnKHRoaXMuVCxhKS5hcHBseShjLmooKS5LKGIpKTpudWxsfTtoLmtjPWZ1bmN0aW9uKGEpe3JldHVybiBVZyh0aGlzLlQsYSl9O2guaGU9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnO2E9V2codGhpcy5ULGEpO2c9VWcoYSxVKTtpZihudWxsPT1nKWlmKG51bGwhPWIpZz1hLmFwcGx5KGIpO2Vsc2UgcmV0dXJuW107Zz1nLmhiKGYpO2lmKGcuZSgpfHxnLk0oKSlyZXR1cm5bXTtiPVtdO2E9bWMoZik7ZT1lP2cuU2IoYyxmKTpnLlFiKGMsZik7Zm9yKGY9UChlKTtmJiZiLmxlbmd0aDxkOykwIT09YShmLGMpJiZiLnB1c2goZiksZj1QKGUpO3JldHVybiBifTtcbmZ1bmN0aW9uIFpnKGEsYil7cmV0dXJuIGEuR2E/YS5wYXRoLmNvbnRhaW5zKGIpOiEhTmQoYS5jaGlsZHJlbixmdW5jdGlvbihjLGQpe3JldHVybiBhLnBhdGgudShkKS5jb250YWlucyhiKX0pfWZ1bmN0aW9uIGFoKGEpe3JldHVybiBhLnZpc2libGV9XG5mdW5jdGlvbiAkZyhhLGIsYyl7Zm9yKHZhciBkPVJnLGU9MDtlPGEubGVuZ3RoOysrZSl7dmFyIGY9YVtlXTtpZihiKGYpKXt2YXIgZz1mLnBhdGg7aWYoZi5HYSljLmNvbnRhaW5zKGcpPyhnPVYoYyxnKSxkPVNnKGQsZyxmLkdhKSk6Zy5jb250YWlucyhjKSYmKGc9VihnLGMpLGQ9U2coZCxVLGYuR2EucmEoZykpKTtlbHNlIGlmKGYuY2hpbGRyZW4paWYoYy5jb250YWlucyhnKSlnPVYoYyxnKSxkPVRnKGQsZyxmLmNoaWxkcmVuKTtlbHNle2lmKGcuY29udGFpbnMoYykpaWYoZz1WKGcsYyksZy5lKCkpZD1UZyhkLFUsZi5jaGlsZHJlbik7ZWxzZSBpZihmPXQoZi5jaGlsZHJlbixJKGcpKSlmPWYucmEoVChnKSksZD1TZyhkLFUsZil9ZWxzZSB0aHJvdyBmYihcIldyaXRlUmVjb3JkIHNob3VsZCBoYXZlIC5zbmFwIG9yIC5jaGlsZHJlblwiKTt9fXJldHVybiBkfWZ1bmN0aW9uIGJoKGEsYil7dGhpcy5FYj1hO3RoaXMuWD1ifWg9YmgucHJvdG90eXBlO1xuaC5wYT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMuWC5wYSh0aGlzLkViLGEsYixjKX07aC5xYz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5YLnFjKHRoaXMuRWIsYSl9O2guJGM9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLlguJGModGhpcy5FYixhLGIsYyl9O2gua2M9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuWC5rYyh0aGlzLkViLnUoYSkpfTtoLmhlPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHRoaXMuWC5oZSh0aGlzLkViLGEsYixjLGQsZSl9O2guVGE9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5YLlRhKHRoaXMuRWIsYSxiKX07aC51PWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYmgodGhpcy5FYi51KGEpLHRoaXMuWCl9O2Z1bmN0aW9uIGNoKGEsYixjKXt0aGlzLnR5cGU9cGc7dGhpcy5zb3VyY2U9YTt0aGlzLnBhdGg9Yjt0aGlzLkdhPWN9Y2gucHJvdG90eXBlLk1jPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnBhdGguZSgpP25ldyBjaCh0aGlzLnNvdXJjZSxVLHRoaXMuR2EuSyhhKSk6bmV3IGNoKHRoaXMuc291cmNlLFQodGhpcy5wYXRoKSx0aGlzLkdhKX07Y2gucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIG92ZXJ3cml0ZTogXCIrdGhpcy5HYS50b1N0cmluZygpK1wiKVwifTtmdW5jdGlvbiBkaChhLGIpe3RoaXMudHlwZT12Zzt0aGlzLnNvdXJjZT1laDt0aGlzLnBhdGg9YTt0aGlzLk9lPWJ9ZGgucHJvdG90eXBlLk1jPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGF0aC5lKCk/dGhpczpuZXcgZGgoVCh0aGlzLnBhdGgpLHRoaXMuT2UpfTtkaC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk9wZXJhdGlvbihcIit0aGlzLnBhdGgrXCI6IFwiK3RoaXMuc291cmNlLnRvU3RyaW5nKCkrXCIgYWNrIHdyaXRlIHJldmVydD1cIit0aGlzLk9lK1wiKVwifTtmdW5jdGlvbiBmaChhLGIpe3RoaXMudHlwZT16Zzt0aGlzLnNvdXJjZT1hO3RoaXMucGF0aD1ifWZoLnByb3RvdHlwZS5NYz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhdGguZSgpP25ldyBmaCh0aGlzLnNvdXJjZSxVKTpuZXcgZmgodGhpcy5zb3VyY2UsVCh0aGlzLnBhdGgpKX07ZmgucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIGxpc3Rlbl9jb21wbGV0ZSlcIn07ZnVuY3Rpb24gZ2goYSxiLGMpe3RoaXMudHlwZT1zZzt0aGlzLnNvdXJjZT1hO3RoaXMucGF0aD1iO3RoaXMuY2hpbGRyZW49Y31naC5wcm90b3R5cGUuTWM9ZnVuY3Rpb24oYSl7aWYodGhpcy5wYXRoLmUoKSlyZXR1cm4gYT10aGlzLmNoaWxkcmVuLnN1YnRyZWUobmV3IFMoYSkpLGEuZSgpP251bGw6YS52YWx1ZT9uZXcgY2godGhpcy5zb3VyY2UsVSxhLnZhbHVlKTpuZXcgZ2godGhpcy5zb3VyY2UsVSxhKTt5KEkodGhpcy5wYXRoKT09PWEsXCJDYW4ndCBnZXQgYSBtZXJnZSBmb3IgYSBjaGlsZCBub3Qgb24gdGhlIHBhdGggb2YgdGhlIG9wZXJhdGlvblwiKTtyZXR1cm4gbmV3IGdoKHRoaXMuc291cmNlLFQodGhpcy5wYXRoKSx0aGlzLmNoaWxkcmVuKX07Z2gucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIG1lcmdlOiBcIit0aGlzLmNoaWxkcmVuLnRvU3RyaW5nKCkrXCIpXCJ9O3ZhciBwZz0wLHNnPTEsdmc9Mix6Zz0zO2Z1bmN0aW9uIGhoKGEsYixjLGQpe3RoaXMucWU9YTt0aGlzLmVmPWI7dGhpcy56Yj1jO3RoaXMuVGU9ZDt5KCFkfHxiLFwiVGFnZ2VkIHF1ZXJpZXMgbXVzdCBiZSBmcm9tIHNlcnZlci5cIil9dmFyIGVoPW5ldyBoaCghMCwhMSxudWxsLCExKSxpaD1uZXcgaGgoITEsITAsbnVsbCwhMSk7aGgucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucWU/XCJ1c2VyXCI6dGhpcy5UZT9cInNlcnZlcihxdWVyeUlEPVwiK3RoaXMuemIrXCIpXCI6XCJzZXJ2ZXJcIn07ZnVuY3Rpb24gamgoYSl7dGhpcy5uYT0kZjt0aGlzLnliPW5ldyBZZzt0aGlzLldjPXt9O3RoaXMuY2M9e307dGhpcy5GYz1hfWZ1bmN0aW9uIGtoKGEsYixjLGQsZSl7dmFyIGY9YS55YixnPWU7eShkPmYuRWMsXCJTdGFja2luZyBhbiBvbGRlciB3cml0ZSBvbiB0b3Agb2YgbmV3ZXIgb25lc1wiKTttKGcpfHwoZz0hMCk7Zi54YS5wdXNoKHtwYXRoOmIsR2E6YyxkZTpkLHZpc2libGU6Z30pO2cmJihmLlQ9U2coZi5ULGIsYykpO2YuRWM9ZDtyZXR1cm4gZT9saChhLG5ldyBjaChlaCxiLGMpKTpbXX1mdW5jdGlvbiBtaChhLGIsYyxkKXt2YXIgZT1hLnliO3koZD5lLkVjLFwiU3RhY2tpbmcgYW4gb2xkZXIgbWVyZ2Ugb24gdG9wIG9mIG5ld2VyIG9uZXNcIik7ZS54YS5wdXNoKHtwYXRoOmIsY2hpbGRyZW46YyxkZTpkLHZpc2libGU6ITB9KTtlLlQ9VGcoZS5ULGIsYyk7ZS5FYz1kO2M9YWcoYyk7cmV0dXJuIGxoKGEsbmV3IGdoKGVoLGIsYykpfVxuZnVuY3Rpb24gbmgoYSxiLGMpe2M9Y3x8ITE7Yj1hLnliLkxkKGIpO3JldHVybiBudWxsPT1iP1tdOmxoKGEsbmV3IGRoKGIsYykpfWZ1bmN0aW9uIG9oKGEsYixjKXtjPWFnKGMpO3JldHVybiBsaChhLG5ldyBnaChpaCxiLGMpKX1mdW5jdGlvbiBwaChhLGIsYyxkKXtkPVFkKGEuV2MsXCJfXCIrZCk7aWYobnVsbCE9ZCl7dmFyIGU9cWgoZCk7ZD1lLnBhdGg7ZT1lLnpiO2I9VihkLGIpO2M9bmV3IGNoKG5ldyBoaCghMSwhMCxlLCEwKSxiLGMpO3JldHVybiByaChhLGQsYyl9cmV0dXJuW119ZnVuY3Rpb24gc2goYSxiLGMsZCl7aWYoZD1RZChhLldjLFwiX1wiK2QpKXt2YXIgZT1xaChkKTtkPWUucGF0aDtlPWUuemI7Yj1WKGQsYik7Yz1hZyhjKTtjPW5ldyBnaChuZXcgaGgoITEsITAsZSwhMCksYixjKTtyZXR1cm4gcmgoYSxkLGMpfXJldHVybltdfVxuamgucHJvdG90eXBlLkdiPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5wYXRoLGQ9bnVsbCxlPSExO2lnKHRoaXMubmEsYyxmdW5jdGlvbihhLGIpe3ZhciBmPVYoYSxjKTtkPWIuYmIoZik7ZT1lfHxudWxsIT1OZyhiKTtyZXR1cm4hZH0pO3ZhciBmPXRoaXMubmEuZ2V0KGMpO2Y/KGU9ZXx8bnVsbCE9TmcoZiksZD1kfHxmLmJiKFUpKTooZj1uZXcgTWcsdGhpcy5uYT10aGlzLm5hLnNldChjLGYpKTt2YXIgZztudWxsIT1kP2c9ITA6KGc9ITEsZD1NLG1nKHRoaXMubmEuc3VidHJlZShjKSxmdW5jdGlvbihhLGIpe3ZhciBjPWIuYmIoVSk7YyYmKGQ9ZC5QKGEsYykpfSkpO3ZhciBrPW51bGwhPVBnKGYsYSk7aWYoIWsmJiFNYyhhLm4pKXt2YXIgbD10aChhKTt5KCEobCBpbiB0aGlzLmNjKSxcIlZpZXcgZG9lcyBub3QgZXhpc3QsIGJ1dCB3ZSBoYXZlIGEgdGFnXCIpO3ZhciBuPXVoKys7dGhpcy5jY1tsXT1uO3RoaXMuV2NbXCJfXCIrbl09bH1nPWYuR2IoYSxiLG5ldyBiaChjLHRoaXMueWIpLFxuZCxnKTtrfHxlfHwoZj1QZyhmLGEpLGc9Zy5jb25jYXQodmgodGhpcyxhLGYpKSk7cmV0dXJuIGd9O1xuamgucHJvdG90eXBlLmdiPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLnBhdGgsZT10aGlzLm5hLmdldChkKSxmPVtdO2lmKGUmJihcImRlZmF1bHRcIj09PWEuRmEoKXx8bnVsbCE9UGcoZSxhKSkpe2Y9ZS5nYihhLGIsYyk7ZS5lKCkmJih0aGlzLm5hPXRoaXMubmEucmVtb3ZlKGQpKTtlPWYuc2c7Zj1mLlZmO2I9LTEhPT1OYShlLGZ1bmN0aW9uKGEpe3JldHVybiBNYyhhLm4pfSk7dmFyIGc9Z2codGhpcy5uYSxkLGZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGwhPU5nKGIpfSk7aWYoYiYmIWcmJihkPXRoaXMubmEuc3VidHJlZShkKSwhZC5lKCkpKWZvcih2YXIgZD13aChkKSxrPTA7azxkLmxlbmd0aDsrK2spe3ZhciBsPWRba10sbj1sLlcsbD14aCh0aGlzLGwpO3RoaXMuRmMuUWUobix5aCh0aGlzLG4pLGwubmQsbC5IKX1pZighZyYmMDxlLmxlbmd0aCYmIWMpaWYoYil0aGlzLkZjLlZkKGEsbnVsbCk7ZWxzZXt2YXIgdT10aGlzO0hhKGUsZnVuY3Rpb24oYSl7YS5GYSgpO3ZhciBiPXUuY2NbdGgoYSldO1xudS5GYy5WZChhLGIpfSl9emgodGhpcyxlKX1yZXR1cm4gZn07amgucHJvdG90eXBlLnBhPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy55YixkPWdnKHRoaXMubmEsYSxmdW5jdGlvbihiLGMpe3ZhciBkPVYoYixhKTtpZihkPWMuYmIoZCkpcmV0dXJuIGR9KTtyZXR1cm4gYy5wYShhLGQsYiwhMCl9O2Z1bmN0aW9uIHdoKGEpe3JldHVybiBlZyhhLGZ1bmN0aW9uKGEsYyxkKXtpZihjJiZudWxsIT1OZyhjKSlyZXR1cm5bTmcoYyldO3ZhciBlPVtdO2MmJihlPU9nKGMpKTtBKGQsZnVuY3Rpb24oYSl7ZT1lLmNvbmNhdChhKX0pO3JldHVybiBlfSl9ZnVuY3Rpb24gemgoYSxiKXtmb3IodmFyIGM9MDtjPGIubGVuZ3RoOysrYyl7dmFyIGQ9YltjXTtpZighTWMoZC5uKSl7dmFyIGQ9dGgoZCksZT1hLmNjW2RdO2RlbGV0ZSBhLmNjW2RdO2RlbGV0ZSBhLldjW1wiX1wiK2VdfX19XG5mdW5jdGlvbiB2aChhLGIsYyl7dmFyIGQ9Yi5wYXRoLGU9eWgoYSxiKTtjPXhoKGEsYyk7Yj1hLkZjLlFlKGIsZSxjLm5kLGMuSCk7ZD1hLm5hLnN1YnRyZWUoZCk7aWYoZSl5KG51bGw9PU5nKGQudmFsdWUpLFwiSWYgd2UncmUgYWRkaW5nIGEgcXVlcnksIGl0IHNob3VsZG4ndCBiZSBzaGFkb3dlZFwiKTtlbHNlIGZvcihlPWVnKGQsZnVuY3Rpb24oYSxiLGMpe2lmKCFhLmUoKSYmYiYmbnVsbCE9TmcoYikpcmV0dXJuW0pnKE5nKGIpKV07dmFyIGQ9W107YiYmKGQ9ZC5jb25jYXQoSmEoT2coYiksZnVuY3Rpb24oYSl7cmV0dXJuIGEuV30pKSk7QShjLGZ1bmN0aW9uKGEpe2Q9ZC5jb25jYXQoYSl9KTtyZXR1cm4gZH0pLGQ9MDtkPGUubGVuZ3RoOysrZCljPWVbZF0sYS5GYy5WZChjLHloKGEsYykpO3JldHVybiBifVxuZnVuY3Rpb24geGgoYSxiKXt2YXIgYz1iLlcsZD15aChhLGMpO3JldHVybntuZDpmdW5jdGlvbigpe3JldHVybihiLm8oKXx8TSkuaGFzaCgpfSxIOmZ1bmN0aW9uKGIsZil7aWYoXCJva1wiPT09Yil7aWYoZiYmXCJvYmplY3RcIj09PXR5cGVvZiBmJiZzKGYsXCJ3XCIpKXt2YXIgZz10KGYsXCJ3XCIpO2VhKGcpJiYwPD1HYShnLFwibm9faW5kZXhcIikmJnooXCJVc2luZyBhbiB1bnNwZWNpZmllZCBpbmRleC4gQ29uc2lkZXIgYWRkaW5nIFwiKygnXCIuaW5kZXhPblwiOiBcIicrYy5uLmcudG9TdHJpbmcoKSsnXCInKStcIiBhdCBcIitjLnBhdGgudG9TdHJpbmcoKStcIiB0byB5b3VyIHNlY3VyaXR5IHJ1bGVzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcIil9aWYoZCl7dmFyIGs9Yy5wYXRoO2lmKGc9UWQoYS5XYyxcIl9cIitkKSl2YXIgbD1xaChnKSxnPWwucGF0aCxsPWwuemIsaz1WKGcsayksaz1uZXcgZmgobmV3IGhoKCExLCEwLGwsITApLGspLGc9cmgoYSxnLGspO2Vsc2UgZz1bXX1lbHNlIGc9bGgoYSxuZXcgZmgoaWgsXG5jLnBhdGgpKTtyZXR1cm4gZ31nPVwiVW5rbm93biBFcnJvclwiO1widG9vX2JpZ1wiPT09Yj9nPVwiVGhlIGRhdGEgcmVxdWVzdGVkIGV4Y2VlZHMgdGhlIG1heGltdW0gc2l6ZSB0aGF0IGNhbiBiZSBhY2Nlc3NlZCB3aXRoIGEgc2luZ2xlIHJlcXVlc3QuXCI6XCJwZXJtaXNzaW9uX2RlbmllZFwiPT1iP2c9XCJDbGllbnQgZG9lc24ndCBoYXZlIHBlcm1pc3Npb24gdG8gYWNjZXNzIHRoZSBkZXNpcmVkIGRhdGEuXCI6XCJ1bmF2YWlsYWJsZVwiPT1iJiYoZz1cIlRoZSBzZXJ2aWNlIGlzIHVuYXZhaWxhYmxlXCIpO2c9RXJyb3IoYitcIjogXCIrZyk7Zy5jb2RlPWIudG9VcHBlckNhc2UoKTtyZXR1cm4gYS5nYihjLG51bGwsZyl9fX1mdW5jdGlvbiB0aChhKXtyZXR1cm4gYS5wYXRoLnRvU3RyaW5nKCkrXCIkXCIrYS5GYSgpfVxuZnVuY3Rpb24gcWgoYSl7dmFyIGI9YS5pbmRleE9mKFwiJFwiKTt5KC0xIT09YiYmYjxhLmxlbmd0aC0xLFwiQmFkIHF1ZXJ5S2V5LlwiKTtyZXR1cm57emI6YS5zdWJzdHIoYisxKSxwYXRoOm5ldyBTKGEuc3Vic3RyKDAsYikpfX1mdW5jdGlvbiB5aChhLGIpe3ZhciBjPXRoKGIpO3JldHVybiB0KGEuY2MsYyl9dmFyIHVoPTE7ZnVuY3Rpb24gcmgoYSxiLGMpe3ZhciBkPWEubmEuZ2V0KGIpO3koZCxcIk1pc3Npbmcgc3luYyBwb2ludCBmb3IgcXVlcnkgdGFnIHRoYXQgd2UncmUgdHJhY2tpbmdcIik7cmV0dXJuIGQuWWEoYyxuZXcgYmgoYixhLnliKSxudWxsKX1mdW5jdGlvbiBsaChhLGIpe3JldHVybiBBaChhLGIsYS5uYSxudWxsLG5ldyBiaChVLGEueWIpKX1cbmZ1bmN0aW9uIEFoKGEsYixjLGQsZSl7aWYoYi5wYXRoLmUoKSlyZXR1cm4gQmgoYSxiLGMsZCxlKTt2YXIgZj1jLmdldChVKTtudWxsPT1kJiZudWxsIT1mJiYoZD1mLmJiKFUpKTt2YXIgZz1bXSxrPUkoYi5wYXRoKSxsPWIuTWMoayk7aWYoKGM9Yy5jaGlsZHJlbi5nZXQoaykpJiZsKXZhciBuPWQ/ZC5LKGspOm51bGwsaz1lLnUoayksZz1nLmNvbmNhdChBaChhLGwsYyxuLGspKTtmJiYoZz1nLmNvbmNhdChmLllhKGIsZSxkKSkpO3JldHVybiBnfWZ1bmN0aW9uIEJoKGEsYixjLGQsZSl7dmFyIGY9Yy5nZXQoVSk7bnVsbD09ZCYmbnVsbCE9ZiYmKGQ9Zi5iYihVKSk7dmFyIGc9W107Yy5jaGlsZHJlbi5mYShmdW5jdGlvbihjLGYpe3ZhciBuPWQ/ZC5LKGMpOm51bGwsdT1lLnUoYykseD1iLk1jKGMpO3gmJihnPWcuY29uY2F0KEJoKGEseCxmLG4sdSkpKX0pO2YmJihnPWcuY29uY2F0KGYuWWEoYixlLGQpKSk7cmV0dXJuIGd9O2Z1bmN0aW9uIENoKGEpe3RoaXMuTz1hO3RoaXMuUmE9WmQoYSk7dGhpcy5iYT1uZXcgZ2Y7dGhpcy5BZD0xO3RoaXMuUz1uZXcgTWUodGhpcy5PLHEodGhpcy5EZCx0aGlzKSxxKHRoaXMuQmQsdGhpcykscSh0aGlzLkllLHRoaXMpKTt0aGlzLkFnPSRkKGEscShmdW5jdGlvbigpe3JldHVybiBuZXcgV2QodGhpcy5SYSx0aGlzLlMpfSx0aGlzKSk7dGhpcy5tYz1uZXcgV2M7dGhpcy54ZT1uZXcgZmY7dmFyIGI9dGhpczt0aGlzLnJkPW5ldyBqaCh7UWU6ZnVuY3Rpb24oYSxkLGUsZil7ZD1bXTtlPWIueGUuaihhLnBhdGgpO2UuZSgpfHwoZD1saChiLnJkLG5ldyBjaChpaCxhLnBhdGgsZSkpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtmKFwib2tcIil9LDApKTtyZXR1cm4gZH0sVmQ6YmF9KTtEaCh0aGlzLFwiY29ubmVjdGVkXCIsITEpO3RoaXMuZ2E9bmV3IGNmO3RoaXMuUT1uZXcgSWYoYSxxKHRoaXMuUy5RLHRoaXMuUykscSh0aGlzLlMuVmUsdGhpcy5TKSxxKHRoaXMuRmUsdGhpcykpO3RoaXMuaGQ9XG4wO3RoaXMueWU9bnVsbDt0aGlzLk49bmV3IGpoKHtRZTpmdW5jdGlvbihhLGQsZSxmKXtRZShiLlMsYSxlLGQsZnVuY3Rpb24oZCxlKXt2YXIgbD1mKGQsZSk7bGYoYi5iYSxhLnBhdGgsbCl9KTtyZXR1cm5bXX0sVmQ6ZnVuY3Rpb24oYSxkKXt2YXIgZT1iLlMsZj1hLnBhdGgudG9TdHJpbmcoKSxnPWEuRmEoKTtlLmYoXCJVbmxpc3RlbiBjYWxsZWQgZm9yIFwiK2YrXCIgXCIrZyk7aWYoU2UoZSxmLGcpJiZlLmphKXt2YXIgaz1MYyhhLm4pO2UuZihcIlVubGlzdGVuIG9uIFwiK2YrXCIgZm9yIFwiK2cpO2Y9e3A6Zn07ZCYmKGYucT1rLGYudD1kKTtlLkJhKFwiblwiLGYpfX19KX1oPUNoLnByb3RvdHlwZTtoLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuTy5CYj9cImh0dHBzOi8vXCI6XCJodHRwOi8vXCIpK3RoaXMuTy5ob3N0fTtoLm5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5PLnVifTtcbmZ1bmN0aW9uIEVoKGEpe2E9YS54ZS5qKG5ldyBTKFwiLmluZm8vc2VydmVyVGltZU9mZnNldFwiKSkuSSgpfHwwO3JldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpK2F9ZnVuY3Rpb24gRmgoYSl7YT1hPXt0aW1lc3RhbXA6RWgoYSl9O2EudGltZXN0YW1wPWEudGltZXN0YW1wfHwobmV3IERhdGUpLmdldFRpbWUoKTtyZXR1cm4gYX1oLkRkPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuaGQrKzt2YXIgZT1uZXcgUyhhKTtiPXRoaXMueWU/dGhpcy55ZShhLGIpOmI7YT1bXTtkP2M/KGI9d2QoYixmdW5jdGlvbihhKXtyZXR1cm4gTyhhKX0pLGE9c2godGhpcy5OLGUsYixkKSk6KGI9TyhiKSxhPXBoKHRoaXMuTixlLGIsZCkpOmM/KGQ9d2QoYixmdW5jdGlvbihhKXtyZXR1cm4gTyhhKX0pLGE9b2godGhpcy5OLGUsZCkpOihkPU8oYiksYT1saCh0aGlzLk4sbmV3IGNoKGloLGUsZCkpKTtkPWU7MDxhLmxlbmd0aCYmKGQ9R2godGhpcyxlKSk7bGYodGhpcy5iYSxkLGEpfTtcbmguQmQ9ZnVuY3Rpb24oYSl7RGgodGhpcyxcImNvbm5lY3RlZFwiLGEpOyExPT09YSYmSGgodGhpcyl9O2guSWU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczt6YihhLGZ1bmN0aW9uKGEsZCl7RGgoYixkLGEpfSl9O2guRmU9ZnVuY3Rpb24oYSl7RGgodGhpcyxcImF1dGhlbnRpY2F0ZWRcIixhKX07ZnVuY3Rpb24gRGgoYSxiLGMpe2I9bmV3IFMoXCIvLmluZm8vXCIrYik7Yz1PKGMpO3ZhciBkPWEueGU7ZC5PZD1kLk9kLkQoYixjKTtjPWxoKGEucmQsbmV3IGNoKGloLGIsYykpO2xmKGEuYmEsYixjKX1cbmguQ2I9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5mKFwic2V0XCIse3BhdGg6YS50b1N0cmluZygpLHZhbHVlOmIsSWc6Y30pO3ZhciBlPUZoKHRoaXMpO2I9TyhiLGMpO3ZhciBlPVhmKGIsZSksZj10aGlzLkFkKyssZT1raCh0aGlzLk4sYSxlLGYsITApO2hmKHRoaXMuYmEsZSk7dmFyIGc9dGhpczt0aGlzLlMucHV0KGEudG9TdHJpbmcoKSxiLkkoITApLGZ1bmN0aW9uKGIsYyl7dmFyIGU9XCJva1wiPT09YjtlfHx6KFwic2V0IGF0IFwiK2ErXCIgZmFpbGVkOiBcIitiKTtlPW5oKGcuTixmLCFlKTtsZihnLmJhLGEsZSk7SWgoZCxiLGMpfSk7ZT1KaCh0aGlzLGEpO0doKHRoaXMsZSk7bGYodGhpcy5iYSxlLFtdKX07XG5oLnVwZGF0ZT1mdW5jdGlvbihhLGIsYyl7dGhpcy5mKFwidXBkYXRlXCIse3BhdGg6YS50b1N0cmluZygpLHZhbHVlOmJ9KTt2YXIgZD0hMCxlPUZoKHRoaXMpLGY9e307QShiLGZ1bmN0aW9uKGEsYil7ZD0hMTt2YXIgYz1PKGEpO2ZbYl09WGYoYyxlKX0pO2lmKGQpaGIoXCJ1cGRhdGUoKSBjYWxsZWQgd2l0aCBlbXB0eSBkYXRhLiAgRG9uJ3QgZG8gYW55dGhpbmcuXCIpLEloKGMsXCJva1wiKTtlbHNle3ZhciBnPXRoaXMuQWQrKyxrPW1oKHRoaXMuTixhLGYsZyk7aGYodGhpcy5iYSxrKTt2YXIgbD10aGlzO1llKHRoaXMuUyxhLnRvU3RyaW5nKCksYixmdW5jdGlvbihiLGQpe3koXCJva1wiPT09Ynx8XCJwZXJtaXNzaW9uX2RlbmllZFwiPT09YixcIm1lcmdlIGF0IFwiK2ErXCIgZmFpbGVkLlwiKTt2YXIgZT1cIm9rXCI9PT1iO2V8fHooXCJ1cGRhdGUgYXQgXCIrYStcIiBmYWlsZWQ6IFwiK2IpO3ZhciBlPW5oKGwuTixnLCFlKSxmPWE7MDxlLmxlbmd0aCYmKGY9R2gobCxhKSk7bGYobC5iYSxmLGUpO0loKGMsYixcbmQpfSk7Yj1KaCh0aGlzLGEpO0doKHRoaXMsYik7bGYodGhpcy5iYSxhLFtdKX19O2Z1bmN0aW9uIEhoKGEpe2EuZihcIm9uRGlzY29ubmVjdEV2ZW50c1wiKTt2YXIgYj1GaChhKSxjPVtdO2VmKFdmKGEuZ2EsYiksVSxmdW5jdGlvbihiLGUpe2M9Yy5jb25jYXQobGgoYS5OLG5ldyBjaChpaCxiLGUpKSk7dmFyIGY9SmgoYSxiKTtHaChhLGYpfSk7YS5nYT1uZXcgY2Y7bGYoYS5iYSxVLGMpfWguR2U9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO3RoaXMuUy5HZShhLnRvU3RyaW5nKCksZnVuY3Rpb24oZCxlKXtcIm9rXCI9PT1kJiZkZihjLmdhLGEpO0loKGIsZCxlKX0pfTtmdW5jdGlvbiBLaChhLGIsYyxkKXt2YXIgZT1PKGMpO1VlKGEuUyxiLnRvU3RyaW5nKCksZS5JKCEwKSxmdW5jdGlvbihjLGcpe1wib2tcIj09PWMmJmEuZ2EuZWMoYixlKTtJaChkLGMsZyl9KX1cbmZ1bmN0aW9uIExoKGEsYixjLGQsZSl7dmFyIGY9TyhjLGQpO1VlKGEuUyxiLnRvU3RyaW5nKCksZi5JKCEwKSxmdW5jdGlvbihjLGQpe1wib2tcIj09PWMmJmEuZ2EuZWMoYixmKTtJaChlLGMsZCl9KX1mdW5jdGlvbiBNaChhLGIsYyxkKXt2YXIgZT0hMCxmO2ZvcihmIGluIGMpZT0hMTtlPyhoYihcIm9uRGlzY29ubmVjdCgpLnVwZGF0ZSgpIGNhbGxlZCB3aXRoIGVtcHR5IGRhdGEuICBEb24ndCBkbyBhbnl0aGluZy5cIiksSWgoZCxcIm9rXCIpKTpXZShhLlMsYi50b1N0cmluZygpLGMsZnVuY3Rpb24oZSxmKXtpZihcIm9rXCI9PT1lKWZvcih2YXIgbCBpbiBjKXt2YXIgbj1PKGNbbF0pO2EuZ2EuZWMoYi51KGwpLG4pfUloKGQsZSxmKX0pfWZ1bmN0aW9uIFJjKGEsYixjKXtjPVwiLmluZm9cIj09PUkoYi5wYXRoKT9hLnJkLkdiKGIsYyk6YS5OLkdiKGIsYyk7U2MoYS5iYSxiLnBhdGgsYyl9aC5xYj1mdW5jdGlvbigpe3RoaXMuUy5xYigpfTtoLmljPWZ1bmN0aW9uKCl7dGhpcy5TLmljKCl9O1xuaC5SZT1mdW5jdGlvbihhKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUpe2E/KHRoaXMuVWR8fCh0aGlzLlVkPW5ldyBWZCh0aGlzLlJhKSksYT10aGlzLlVkLmdldCgpKTphPXRoaXMuUmEuZ2V0KCk7dmFyIGI9S2EoTWQoYSksZnVuY3Rpb24oYSxiKXtyZXR1cm4gTWF0aC5tYXgoYi5sZW5ndGgsYSl9LDApLGM7Zm9yKGMgaW4gYSl7Zm9yKHZhciBkPWFbY10sZT1jLmxlbmd0aDtlPGIrMjtlKyspYys9XCIgXCI7Y29uc29sZS5sb2coYytkKX19fTtoLlNlPWZ1bmN0aW9uKGEpe1VkKHRoaXMuUmEsYSk7dGhpcy5BZy56ZlthXT0hMH07aC5mPWZ1bmN0aW9uKGEpe2hiKFwicjpcIit0aGlzLlMuaWQrXCI6XCIsYXJndW1lbnRzKX07ZnVuY3Rpb24gSWgoYSxiLGMpe2EmJkNiKGZ1bmN0aW9uKCl7aWYoXCJva1wiPT1iKWEobnVsbCk7ZWxzZXt2YXIgZD0oYnx8XCJlcnJvclwiKS50b1VwcGVyQ2FzZSgpLGU9ZDtjJiYoZSs9XCI6IFwiK2MpO2U9RXJyb3IoZSk7ZS5jb2RlPWQ7YShlKX19KX07ZnVuY3Rpb24gTmgoYSxiLGMsZCxlKXtmdW5jdGlvbiBmKCl7fWEuZihcInRyYW5zYWN0aW9uIG9uIFwiK2IpO3ZhciBnPW5ldyBSKGEsYik7Zy53YihcInZhbHVlXCIsZik7Yz17cGF0aDpiLHVwZGF0ZTpjLEg6ZCxzdGF0dXM6bnVsbCxxZjplYigpLFdlOmUseGY6MCxiZTpmdW5jdGlvbigpe2cuJGIoXCJ2YWx1ZVwiLGYpfSxlZTpudWxsLHlhOm51bGwsZWQ6bnVsbCxmZDpudWxsLGdkOm51bGx9O2Q9YS5OLnBhKGIsdm9pZCAwKXx8TTtjLmVkPWQ7ZD1jLnVwZGF0ZShkLkkoKSk7aWYobShkKSl7U2IoXCJ0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgXCIsZCk7Yy5zdGF0dXM9MTtlPVhjKGEubWMsYik7dmFyIGs9ZS56YSgpfHxbXTtrLnB1c2goYyk7WWMoZSxrKTtcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kJiZzKGQsXCIucHJpb3JpdHlcIik/KGs9dChkLFwiLnByaW9yaXR5XCIpLHkoUWIoayksXCJJbnZhbGlkIHByaW9yaXR5IHJldHVybmVkIGJ5IHRyYW5zYWN0aW9uLiBQcmlvcml0eSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwuXCIpKTpcbms9KGEuTi5wYShiKXx8TSkuTCgpLkkoKTtlPUZoKGEpO2Q9TyhkLGspO2U9WGYoZCxlKTtjLmZkPWQ7Yy5nZD1lO2MueWE9YS5BZCsrO2M9a2goYS5OLGIsZSxjLnlhLGMuV2UpO2xmKGEuYmEsYixjKTtPaChhKX1lbHNlIGMuYmUoKSxjLmZkPW51bGwsYy5nZD1udWxsLGMuSCYmKGE9bmV3IEQoYy5lZCxuZXcgUihhLGMucGF0aCksTCksYy5IKG51bGwsITEsYSkpfWZ1bmN0aW9uIE9oKGEsYil7dmFyIGM9Ynx8YS5tYztifHxQaChhLGMpO2lmKG51bGwhPT1jLnphKCkpe3ZhciBkPVFoKGEsYyk7eSgwPGQubGVuZ3RoLFwiU2VuZGluZyB6ZXJvIGxlbmd0aCB0cmFuc2FjdGlvbiBxdWV1ZVwiKTtMYShkLGZ1bmN0aW9uKGEpe3JldHVybiAxPT09YS5zdGF0dXN9KSYmUmgoYSxjLnBhdGgoKSxkKX1lbHNlIGMubWQoKSYmYy5VKGZ1bmN0aW9uKGIpe09oKGEsYil9KX1cbmZ1bmN0aW9uIFJoKGEsYixjKXtmb3IodmFyIGQ9SmEoYyxmdW5jdGlvbihhKXtyZXR1cm4gYS55YX0pLGU9YS5OLnBhKGIsZCl8fE0sZD1lLGU9ZS5oYXNoKCksZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgZz1jW2ZdO3koMT09PWcuc3RhdHVzLFwidHJ5VG9TZW5kVHJhbnNhY3Rpb25RdWV1ZV86IGl0ZW1zIGluIHF1ZXVlIHNob3VsZCBhbGwgYmUgcnVuLlwiKTtnLnN0YXR1cz0yO2cueGYrKzt2YXIgaz1WKGIsZy5wYXRoKSxkPWQuRChrLGcuZmQpfWQ9ZC5JKCEwKTthLlMucHV0KGIudG9TdHJpbmcoKSxkLGZ1bmN0aW9uKGQpe2EuZihcInRyYW5zYWN0aW9uIHB1dCByZXNwb25zZVwiLHtwYXRoOmIudG9TdHJpbmcoKSxzdGF0dXM6ZH0pO3ZhciBlPVtdO2lmKFwib2tcIj09PWQpe2Q9W107Zm9yKGY9MDtmPGMubGVuZ3RoO2YrKyl7Y1tmXS5zdGF0dXM9MztlPWUuY29uY2F0KG5oKGEuTixjW2ZdLnlhKSk7aWYoY1tmXS5IKXt2YXIgZz1jW2ZdLmdkLGs9bmV3IFIoYSxjW2ZdLnBhdGgpO2QucHVzaChxKGNbZl0uSCxcbm51bGwsbnVsbCwhMCxuZXcgRChnLGssTCkpKX1jW2ZdLmJlKCl9UGgoYSxYYyhhLm1jLGIpKTtPaChhKTtsZihhLmJhLGIsZSk7Zm9yKGY9MDtmPGQubGVuZ3RoO2YrKylDYihkW2ZdKX1lbHNle2lmKFwiZGF0YXN0YWxlXCI9PT1kKWZvcihmPTA7ZjxjLmxlbmd0aDtmKyspY1tmXS5zdGF0dXM9ND09PWNbZl0uc3RhdHVzPzU6MTtlbHNlIGZvcih6KFwidHJhbnNhY3Rpb24gYXQgXCIrYi50b1N0cmluZygpK1wiIGZhaWxlZDogXCIrZCksZj0wO2Y8Yy5sZW5ndGg7ZisrKWNbZl0uc3RhdHVzPTUsY1tmXS5lZT1kO0doKGEsYil9fSxlKX1mdW5jdGlvbiBHaChhLGIpe3ZhciBjPVNoKGEsYiksZD1jLnBhdGgoKSxjPVFoKGEsYyk7VGgoYSxjLGQpO3JldHVybiBkfVxuZnVuY3Rpb24gVGgoYSxiLGMpe2lmKDAhPT1iLmxlbmd0aCl7Zm9yKHZhciBkPVtdLGU9W10sZj1KYShiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnlhfSksZz0wO2c8Yi5sZW5ndGg7ZysrKXt2YXIgaz1iW2ddLGw9VihjLGsucGF0aCksbj0hMSx1O3kobnVsbCE9PWwsXCJyZXJ1blRyYW5zYWN0aW9uc1VuZGVyTm9kZV86IHJlbGF0aXZlUGF0aCBzaG91bGQgbm90IGJlIG51bGwuXCIpO2lmKDU9PT1rLnN0YXR1cyluPSEwLHU9ay5lZSxlPWUuY29uY2F0KG5oKGEuTixrLnlhLCEwKSk7ZWxzZSBpZigxPT09ay5zdGF0dXMpaWYoMjU8PWsueGYpbj0hMCx1PVwibWF4cmV0cnlcIixlPWUuY29uY2F0KG5oKGEuTixrLnlhLCEwKSk7ZWxzZXt2YXIgeD1hLk4ucGEoay5wYXRoLGYpfHxNO2suZWQ9eDt2YXIgRj1iW2ddLnVwZGF0ZSh4LkkoKSk7bShGKT8oU2IoXCJ0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgXCIsRiksbD1PKEYpLFwib2JqZWN0XCI9PT10eXBlb2YgRiYmbnVsbCE9RiYmcyhGLFxuXCIucHJpb3JpdHlcIil8fChsPWwuJCh4LkwoKSkpLHg9ay55YSxGPUZoKGEpLEY9WGYobCxGKSxrLmZkPWwsay5nZD1GLGsueWE9YS5BZCsrLE9hKGYseCksZT1lLmNvbmNhdChraChhLk4say5wYXRoLEYsay55YSxrLldlKSksZT1lLmNvbmNhdChuaChhLk4seCwhMCkpKToobj0hMCx1PVwibm9kYXRhXCIsZT1lLmNvbmNhdChuaChhLk4say55YSwhMCkpKX1sZihhLmJhLGMsZSk7ZT1bXTtuJiYoYltnXS5zdGF0dXM9MyxzZXRUaW1lb3V0KGJbZ10uYmUsTWF0aC5mbG9vcigwKSksYltnXS5IJiYoXCJub2RhdGFcIj09PXU/KGs9bmV3IFIoYSxiW2ddLnBhdGgpLGQucHVzaChxKGJbZ10uSCxudWxsLG51bGwsITEsbmV3IEQoYltnXS5lZCxrLEwpKSkpOmQucHVzaChxKGJbZ10uSCxudWxsLEVycm9yKHUpLCExLG51bGwpKSkpfVBoKGEsYS5tYyk7Zm9yKGc9MDtnPGQubGVuZ3RoO2crKylDYihkW2ddKTtPaChhKX19XG5mdW5jdGlvbiBTaChhLGIpe2Zvcih2YXIgYyxkPWEubWM7bnVsbCE9PShjPUkoYikpJiZudWxsPT09ZC56YSgpOylkPVhjKGQsYyksYj1UKGIpO3JldHVybiBkfWZ1bmN0aW9uIFFoKGEsYil7dmFyIGM9W107VWgoYSxiLGMpO2Muc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLnFmLWIucWZ9KTtyZXR1cm4gY31mdW5jdGlvbiBVaChhLGIsYyl7dmFyIGQ9Yi56YSgpO2lmKG51bGwhPT1kKWZvcih2YXIgZT0wO2U8ZC5sZW5ndGg7ZSsrKWMucHVzaChkW2VdKTtiLlUoZnVuY3Rpb24oYil7VWgoYSxiLGMpfSl9ZnVuY3Rpb24gUGgoYSxiKXt2YXIgYz1iLnphKCk7aWYoYyl7Zm9yKHZhciBkPTAsZT0wO2U8Yy5sZW5ndGg7ZSsrKTMhPT1jW2VdLnN0YXR1cyYmKGNbZF09Y1tlXSxkKyspO2MubGVuZ3RoPWQ7WWMoYiwwPGMubGVuZ3RoP2M6bnVsbCl9Yi5VKGZ1bmN0aW9uKGIpe1BoKGEsYil9KX1cbmZ1bmN0aW9uIEpoKGEsYil7dmFyIGM9U2goYSxiKS5wYXRoKCksZD1YYyhhLm1jLGIpO2FkKGQsZnVuY3Rpb24oYil7VmgoYSxiKX0pO1ZoKGEsZCk7JGMoZCxmdW5jdGlvbihiKXtWaChhLGIpfSk7cmV0dXJuIGN9XG5mdW5jdGlvbiBWaChhLGIpe3ZhciBjPWIuemEoKTtpZihudWxsIT09Yyl7Zm9yKHZhciBkPVtdLGU9W10sZj0tMSxnPTA7ZzxjLmxlbmd0aDtnKyspNCE9PWNbZ10uc3RhdHVzJiYoMj09PWNbZ10uc3RhdHVzPyh5KGY9PT1nLTEsXCJBbGwgU0VOVCBpdGVtcyBzaG91bGQgYmUgYXQgYmVnaW5uaW5nIG9mIHF1ZXVlLlwiKSxmPWcsY1tnXS5zdGF0dXM9NCxjW2ddLmVlPVwic2V0XCIpOih5KDE9PT1jW2ddLnN0YXR1cyxcIlVuZXhwZWN0ZWQgdHJhbnNhY3Rpb24gc3RhdHVzIGluIGFib3J0XCIpLGNbZ10uYmUoKSxlPWUuY29uY2F0KG5oKGEuTixjW2ddLnlhLCEwKSksY1tnXS5IJiZkLnB1c2gocShjW2ddLkgsbnVsbCxFcnJvcihcInNldFwiKSwhMSxudWxsKSkpKTstMT09PWY/WWMoYixudWxsKTpjLmxlbmd0aD1mKzE7bGYoYS5iYSxiLnBhdGgoKSxlKTtmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKUNiKGRbZ10pfX07ZnVuY3Rpb24gV2goKXt0aGlzLmZjPXt9fWNhKFdoKTtXaC5wcm90b3R5cGUucWI9ZnVuY3Rpb24oKXtmb3IodmFyIGEgaW4gdGhpcy5mYyl0aGlzLmZjW2FdLnFiKCl9O1doLnByb3RvdHlwZS5pbnRlcnJ1cHQ9V2gucHJvdG90eXBlLnFiO1doLnByb3RvdHlwZS5pYz1mdW5jdGlvbigpe2Zvcih2YXIgYSBpbiB0aGlzLmZjKXRoaXMuZmNbYV0uaWMoKX07V2gucHJvdG90eXBlLnJlc3VtZT1XaC5wcm90b3R5cGUuaWM7ZnVuY3Rpb24gWGgoYSl7dmFyIGI9dGhpczt0aGlzLnNjPWE7dGhpcy5YZD1cIipcIjtBZigpP3RoaXMuSGM9dGhpcy5wZD1yZigpOih0aGlzLkhjPXdpbmRvdy5vcGVuZXIsdGhpcy5wZD13aW5kb3cpO2lmKCFiLkhjKXRocm93XCJVbmFibGUgdG8gZmluZCByZWxheSBmcmFtZVwiO3NmKHRoaXMucGQsXCJtZXNzYWdlXCIscSh0aGlzLmFjLHRoaXMpKTtzZih0aGlzLnBkLFwibWVzc2FnZVwiLHEodGhpcy5uZix0aGlzKSk7dHJ5e1loKHRoaXMse2E6XCJyZWFkeVwifSl9Y2F0Y2goYyl7c2YodGhpcy5IYyxcImxvYWRcIixmdW5jdGlvbigpe1loKGIse2E6XCJyZWFkeVwifSl9KX1zZih3aW5kb3csXCJ1bmxvYWRcIixxKHRoaXMuamcsdGhpcykpfWZ1bmN0aW9uIFloKGEsYil7Yj1yKGIpO0FmKCk/YS5IYy5kb1Bvc3QoYixhLlhkKTphLkhjLnBvc3RNZXNzYWdlKGIsYS5YZCl9XG5YaC5wcm90b3R5cGUuYWM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjO3RyeXtjPXRhKGEuZGF0YSl9Y2F0Y2goZCl7fWMmJlwicmVxdWVzdFwiPT09Yy5hJiYodGYod2luZG93LFwibWVzc2FnZVwiLHRoaXMuYWMpLHRoaXMuWGQ9YS5vcmlnaW4sdGhpcy5zYyYmc2V0VGltZW91dChmdW5jdGlvbigpe2Iuc2MoYi5YZCxjLmQsZnVuY3Rpb24oYSxjKXtiLk1mPSFjO2Iuc2M9dm9pZCAwO1loKGIse2E6XCJyZXNwb25zZVwiLGQ6YSxmb3JjZUtlZXBXaW5kb3dPcGVuOmN9KX0pfSwwKSl9O1hoLnByb3RvdHlwZS5qZz1mdW5jdGlvbigpe3RyeXt0Zih0aGlzLnBkLFwibWVzc2FnZVwiLHRoaXMubmYpfWNhdGNoKGEpe310aGlzLnNjJiYoWWgodGhpcyx7YTpcImVycm9yXCIsZDpcInVua25vd24gY2xvc2VkIHdpbmRvd1wifSksdGhpcy5zYz12b2lkIDApO3RyeXt3aW5kb3cuY2xvc2UoKX1jYXRjaChiKXt9fTtYaC5wcm90b3R5cGUubmY9ZnVuY3Rpb24oYSl7aWYodGhpcy5NZiYmXCJkaWVcIj09PWEuZGF0YSl0cnl7d2luZG93LmNsb3NlKCl9Y2F0Y2goYil7fX07dmFyIFk9e1hmOmZ1bmN0aW9uKCl7bGU9Y2U9ITB9fTtZLmZvcmNlTG9uZ1BvbGxpbmc9WS5YZjtZLllmPWZ1bmN0aW9uKCl7bWU9ITB9O1kuZm9yY2VXZWJTb2NrZXRzPVkuWWY7WS54Zz1mdW5jdGlvbihhLGIpe2Euay5TLlBlPWJ9O1kuc2V0U2VjdXJpdHlEZWJ1Z0NhbGxiYWNrPVkueGc7WS5SZT1mdW5jdGlvbihhLGIpe2Euay5SZShiKX07WS5zdGF0cz1ZLlJlO1kuU2U9ZnVuY3Rpb24oYSxiKXthLmsuU2UoYil9O1kuc3RhdHNJbmNyZW1lbnRDb3VudGVyPVkuU2U7WS5oZD1mdW5jdGlvbihhKXtyZXR1cm4gYS5rLmhkfTtZLmRhdGFVcGRhdGVDb3VudD1ZLmhkO1kuYWc9ZnVuY3Rpb24oYSxiKXthLmsueWU9Yn07WS5pbnRlcmNlcHRTZXJ2ZXJEYXRhPVkuYWc7WS5nZz1mdW5jdGlvbihhKXtuZXcgWGgoYSl9O1kub25Qb3B1cE9wZW49WS5nZztZLnZnPWZ1bmN0aW9uKGEpe21mPWF9O1kuc2V0QXV0aGVudGljYXRpb25TZXJ2ZXI9WS52ZztmdW5jdGlvbiBaKGEsYil7dGhpcy5SYz1hO3RoaXMuRWE9Yn1aLnByb3RvdHlwZS5jYW5jZWw9ZnVuY3Rpb24oYSl7RShcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLmNhbmNlbFwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtIKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuY2FuY2VsXCIsMSxhLCEwKTt0aGlzLlJjLkdlKHRoaXMuRWEsYXx8bnVsbCl9O1oucHJvdG90eXBlLmNhbmNlbD1aLnByb3RvdHlwZS5jYW5jZWw7Wi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEpe0UoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5yZW1vdmVcIiwwLDEsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5yZW1vdmVcIix0aGlzLkVhKTtIKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkucmVtb3ZlXCIsMSxhLCEwKTtLaCh0aGlzLlJjLHRoaXMuRWEsbnVsbCxhKX07Wi5wcm90b3R5cGUucmVtb3ZlPVoucHJvdG90eXBlLnJlbW92ZTtcbloucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe0UoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIix0aGlzLkVhKTtSYihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFwiLGEsITEpO0goXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRcIiwyLGIsITApO0toKHRoaXMuUmMsdGhpcy5FYSxhLGIpfTtaLnByb3RvdHlwZS5zZXQ9Wi5wcm90b3R5cGUuc2V0O1xuWi5wcm90b3R5cGUuQ2I9ZnVuY3Rpb24oYSxiLGMpe0UoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS5zZXRXaXRoUHJpb3JpdHlcIix0aGlzLkVhKTtSYihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFdpdGhQcmlvcml0eVwiLGEsITEpO1ZiKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuc2V0V2l0aFByaW9yaXR5XCIsMixiKTtIKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuc2V0V2l0aFByaW9yaXR5XCIsMyxjLCEwKTtMaCh0aGlzLlJjLHRoaXMuRWEsYSxiLGMpfTtaLnByb3RvdHlwZS5zZXRXaXRoUHJpb3JpdHk9Wi5wcm90b3R5cGUuQ2I7XG5aLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSxiKXtFKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO1piKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsdGhpcy5FYSk7aWYoZWEoYSkpe2Zvcih2YXIgYz17fSxkPTA7ZDxhLmxlbmd0aDsrK2QpY1tcIlwiK2RdPWFbZF07YT1jO3ooXCJQYXNzaW5nIGFuIEFycmF5IHRvIEZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXQoKSBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGRhdGEsIG9yIGFuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uXCIpfVViKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlXCIsYSk7SChcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZVwiLDIsYiwhMCk7TWgodGhpcy5SYyxcbnRoaXMuRWEsYSxiKX07Wi5wcm90b3R5cGUudXBkYXRlPVoucHJvdG90eXBlLnVwZGF0ZTt2YXIgJD17fTskLm9jPU1lOyQuRGF0YUNvbm5lY3Rpb249JC5vYztNZS5wcm90b3R5cGUuemc9ZnVuY3Rpb24oYSxiKXt0aGlzLkJhKFwicVwiLHtwOmF9LGIpfTskLm9jLnByb3RvdHlwZS5zaW1wbGVMaXN0ZW49JC5vYy5wcm90b3R5cGUuemc7TWUucHJvdG90eXBlLlNmPWZ1bmN0aW9uKGEsYil7dGhpcy5CYShcImVjaG9cIix7ZDphfSxiKX07JC5vYy5wcm90b3R5cGUuZWNobz0kLm9jLnByb3RvdHlwZS5TZjtNZS5wcm90b3R5cGUuaW50ZXJydXB0PU1lLnByb3RvdHlwZS5xYjskLkRmPXdlOyQuUmVhbFRpbWVDb25uZWN0aW9uPSQuRGY7d2UucHJvdG90eXBlLnNlbmRSZXF1ZXN0PXdlLnByb3RvdHlwZS5CYTt3ZS5wcm90b3R5cGUuY2xvc2U9d2UucHJvdG90eXBlLmNsb3NlO1xuJC4kZj1mdW5jdGlvbihhKXt2YXIgYj1NZS5wcm90b3R5cGUucHV0O01lLnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24oYyxkLGUsZil7bShmKSYmKGY9YSgpKTtiLmNhbGwodGhpcyxjLGQsZSxmKX07cmV0dXJuIGZ1bmN0aW9uKCl7TWUucHJvdG90eXBlLnB1dD1ifX07JC5oaWphY2tIYXNoPSQuJGY7JC5DZj1BYTskLkNvbm5lY3Rpb25UYXJnZXQ9JC5DZjskLkZhPWZ1bmN0aW9uKGEpe3JldHVybiBhLkZhKCl9OyQucXVlcnlJZGVudGlmaWVyPSQuRmE7JC5iZz1mdW5jdGlvbihhKXtyZXR1cm4gYS5rLlMudGF9OyQubGlzdGVucz0kLmJnO3ZhciBaaD1mdW5jdGlvbigpe3ZhciBhPTAsYj1bXTtyZXR1cm4gZnVuY3Rpb24oYyl7dmFyIGQ9Yz09PWE7YT1jO2Zvcih2YXIgZT1BcnJheSg4KSxmPTc7MDw9ZjtmLS0pZVtmXT1cIi0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5jaGFyQXQoYyU2NCksYz1NYXRoLmZsb29yKGMvNjQpO3koMD09PWMsXCJDYW5ub3QgcHVzaCBhdCB0aW1lID09IDBcIik7Yz1lLmpvaW4oXCJcIik7aWYoZCl7Zm9yKGY9MTE7MDw9ZiYmNjM9PT1iW2ZdO2YtLSliW2ZdPTA7YltmXSsrfWVsc2UgZm9yKGY9MDsxMj5mO2YrKyliW2ZdPU1hdGguZmxvb3IoNjQqTWF0aC5yYW5kb20oKSk7Zm9yKGY9MDsxMj5mO2YrKyljKz1cIi0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5jaGFyQXQoYltmXSk7eSgyMD09PWMubGVuZ3RoLFwiTmV4dFB1c2hJZDogTGVuZ3RoIHNob3VsZCBiZSAyMC5cIik7XG5yZXR1cm4gY319KCk7ZnVuY3Rpb24gUihhLGIpe3ZhciBjLGQsZTtpZihhIGluc3RhbmNlb2YgQ2gpYz1hLGQ9YjtlbHNle0UoXCJuZXcgRmlyZWJhc2VcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7ZD1yYihhcmd1bWVudHNbMF0pO2M9ZC5CZztcImZpcmViYXNlXCI9PT1kLmRvbWFpbiYmcWIoZC5ob3N0K1wiIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tIGluc3RlYWRcIik7Y3x8cWIoXCJDYW5ub3QgcGFyc2UgRmlyZWJhc2UgdXJsLiBQbGVhc2UgdXNlIGh0dHBzOi8vPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tXCIpO2QuQmJ8fFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cubG9jYXRpb24mJndpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCYmLTEhPT13aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZihcImh0dHBzOlwiKSYmeihcIkluc2VjdXJlIEZpcmViYXNlIGFjY2VzcyBmcm9tIGEgc2VjdXJlIHBhZ2UuIFBsZWFzZSB1c2UgaHR0cHMgaW4gY2FsbHMgdG8gbmV3IEZpcmViYXNlKCkuXCIpO1xuYz1uZXcgQWEoZC5ob3N0LGQuQmIsYyxcIndzXCI9PT1kLnNjaGVtZXx8XCJ3c3NcIj09PWQuc2NoZW1lKTtkPW5ldyBTKGQuUGMpO2U9ZC50b1N0cmluZygpO3ZhciBmOyEoZj0hcChjLmhvc3QpfHwwPT09Yy5ob3N0Lmxlbmd0aHx8IVBiKGMudWIpKSYmKGY9MCE9PWUubGVuZ3RoKSYmKGUmJihlPWUucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sXCIvXCIpKSxmPSEocChlKSYmMCE9PWUubGVuZ3RoJiYhT2IudGVzdChlKSkpO2lmKGYpdGhyb3cgRXJyb3IoRyhcIm5ldyBGaXJlYmFzZVwiLDEsITEpKydtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgVVJMIGFuZCB0aGUgcGF0aCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiLicpO2lmKGIpaWYoYiBpbnN0YW5jZW9mIFdoKWU9YjtlbHNlIGlmKHAoYikpZT1XaC5PYigpLGMuSWQ9YjtlbHNlIHRocm93IEVycm9yKFwiRXhwZWN0ZWQgYSB2YWxpZCBGaXJlYmFzZS5Db250ZXh0IGZvciBzZWNvbmQgYXJndW1lbnQgdG8gbmV3IEZpcmViYXNlKClcIik7XG5lbHNlIGU9V2guT2IoKTtmPWMudG9TdHJpbmcoKTt2YXIgZz10KGUuZmMsZik7Z3x8KGc9bmV3IENoKGMpLGUuZmNbZl09Zyk7Yz1nfVEuY2FsbCh0aGlzLGMsZCxJYywhMSl9bWEoUixRKTt2YXIgJGg9UixhaT1bXCJGaXJlYmFzZVwiXSxiaT1hYTthaVswXWluIGJpfHwhYmkuZXhlY1NjcmlwdHx8YmkuZXhlY1NjcmlwdChcInZhciBcIithaVswXSk7Zm9yKHZhciBjaTthaS5sZW5ndGgmJihjaT1haS5zaGlmdCgpKTspIWFpLmxlbmd0aCYmbSgkaCk/YmlbY2ldPSRoOmJpPWJpW2NpXT9iaVtjaV06YmlbY2ldPXt9O1IucHJvdG90eXBlLm5hbWU9ZnVuY3Rpb24oKXt6KFwiRmlyZWJhc2UubmFtZSgpIGJlaW5nIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRmlyZWJhc2Uua2V5KCkgaW5zdGVhZC5cIik7RShcIkZpcmViYXNlLm5hbWVcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMua2V5KCl9O1IucHJvdG90eXBlLm5hbWU9Ui5wcm90b3R5cGUubmFtZTtcblIucHJvdG90eXBlLmtleT1mdW5jdGlvbigpe0UoXCJGaXJlYmFzZS5rZXlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMucGF0aC5lKCk/bnVsbDpVYyh0aGlzLnBhdGgpfTtSLnByb3RvdHlwZS5rZXk9Ui5wcm90b3R5cGUua2V5O1IucHJvdG90eXBlLnU9ZnVuY3Rpb24oYSl7RShcIkZpcmViYXNlLmNoaWxkXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKGdhKGEpKWE9U3RyaW5nKGEpO2Vsc2UgaWYoIShhIGluc3RhbmNlb2YgUykpaWYobnVsbD09PUkodGhpcy5wYXRoKSl7dmFyIGI9YTtiJiYoYj1iLnJlcGxhY2UoL15cXC8qXFwuaW5mbyhcXC98JCkvLFwiL1wiKSk7WWIoXCJGaXJlYmFzZS5jaGlsZFwiLGIpfWVsc2UgWWIoXCJGaXJlYmFzZS5jaGlsZFwiLGEpO3JldHVybiBuZXcgUih0aGlzLmssdGhpcy5wYXRoLnUoYSkpfTtSLnByb3RvdHlwZS5jaGlsZD1SLnByb3RvdHlwZS51O1xuUi5wcm90b3R5cGUucGFyZW50PWZ1bmN0aW9uKCl7RShcIkZpcmViYXNlLnBhcmVudFwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTt2YXIgYT10aGlzLnBhdGgucGFyZW50KCk7cmV0dXJuIG51bGw9PT1hP251bGw6bmV3IFIodGhpcy5rLGEpfTtSLnByb3RvdHlwZS5wYXJlbnQ9Ui5wcm90b3R5cGUucGFyZW50O1IucHJvdG90eXBlLnJvb3Q9ZnVuY3Rpb24oKXtFKFwiRmlyZWJhc2UucmVmXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO2Zvcih2YXIgYT10aGlzO251bGwhPT1hLnBhcmVudCgpOylhPWEucGFyZW50KCk7cmV0dXJuIGF9O1IucHJvdG90eXBlLnJvb3Q9Ui5wcm90b3R5cGUucm9vdDtcblIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7RShcIkZpcmViYXNlLnRvU3RyaW5nXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3ZhciBhO2lmKG51bGw9PT10aGlzLnBhcmVudCgpKWE9dGhpcy5rLnRvU3RyaW5nKCk7ZWxzZXthPXRoaXMucGFyZW50KCkudG9TdHJpbmcoKStcIi9cIjt2YXIgYj10aGlzLmtleSgpO2ErPWVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYikpfXJldHVybiBhfTtSLnByb3RvdHlwZS50b1N0cmluZz1SLnByb3RvdHlwZS50b1N0cmluZztSLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiKXtFKFwiRmlyZWJhc2Uuc2V0XCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO1piKFwiRmlyZWJhc2Uuc2V0XCIsdGhpcy5wYXRoKTtSYihcIkZpcmViYXNlLnNldFwiLGEsITEpO0goXCJGaXJlYmFzZS5zZXRcIiwyLGIsITApO3RoaXMuay5DYih0aGlzLnBhdGgsYSxudWxsLGJ8fG51bGwpfTtSLnByb3RvdHlwZS5zZXQ9Ui5wcm90b3R5cGUuc2V0O1xuUi5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEsYil7RShcIkZpcmViYXNlLnVwZGF0ZVwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtaYihcIkZpcmViYXNlLnVwZGF0ZVwiLHRoaXMucGF0aCk7aWYoZWEoYSkpe2Zvcih2YXIgYz17fSxkPTA7ZDxhLmxlbmd0aDsrK2QpY1tcIlwiK2RdPWFbZF07YT1jO3ooXCJQYXNzaW5nIGFuIEFycmF5IHRvIEZpcmViYXNlLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXQoKSBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGRhdGEsIG9yIGFuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uXCIpfVViKFwiRmlyZWJhc2UudXBkYXRlXCIsYSk7SChcIkZpcmViYXNlLnVwZGF0ZVwiLDIsYiwhMCk7dGhpcy5rLnVwZGF0ZSh0aGlzLnBhdGgsYSxifHxudWxsKX07Ui5wcm90b3R5cGUudXBkYXRlPVIucHJvdG90eXBlLnVwZGF0ZTtcblIucHJvdG90eXBlLkNiPWZ1bmN0aW9uKGEsYixjKXtFKFwiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5XCIsMiwzLGFyZ3VtZW50cy5sZW5ndGgpO1piKFwiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5XCIsdGhpcy5wYXRoKTtSYihcIkZpcmViYXNlLnNldFdpdGhQcmlvcml0eVwiLGEsITEpO1ZiKFwiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5XCIsMixiKTtIKFwiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5XCIsMyxjLCEwKTtpZihcIi5sZW5ndGhcIj09PXRoaXMua2V5KCl8fFwiLmtleXNcIj09PXRoaXMua2V5KCkpdGhyb3dcIkZpcmViYXNlLnNldFdpdGhQcmlvcml0eSBmYWlsZWQ6IFwiK3RoaXMua2V5KCkrXCIgaXMgYSByZWFkLW9ubHkgb2JqZWN0LlwiO3RoaXMuay5DYih0aGlzLnBhdGgsYSxiLGN8fG51bGwpfTtSLnByb3RvdHlwZS5zZXRXaXRoUHJpb3JpdHk9Ui5wcm90b3R5cGUuQ2I7XG5SLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oYSl7RShcIkZpcmViYXNlLnJlbW92ZVwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtaYihcIkZpcmViYXNlLnJlbW92ZVwiLHRoaXMucGF0aCk7SChcIkZpcmViYXNlLnJlbW92ZVwiLDEsYSwhMCk7dGhpcy5zZXQobnVsbCxhKX07Ui5wcm90b3R5cGUucmVtb3ZlPVIucHJvdG90eXBlLnJlbW92ZTtcblIucHJvdG90eXBlLnRyYW5zYWN0aW9uPWZ1bmN0aW9uKGEsYixjKXtFKFwiRmlyZWJhc2UudHJhbnNhY3Rpb25cIiwxLDMsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLHRoaXMucGF0aCk7SChcIkZpcmViYXNlLnRyYW5zYWN0aW9uXCIsMSxhLCExKTtIKFwiRmlyZWJhc2UudHJhbnNhY3Rpb25cIiwyLGIsITApO2lmKG0oYykmJlwiYm9vbGVhblwiIT10eXBlb2YgYyl0aHJvdyBFcnJvcihHKFwiRmlyZWJhc2UudHJhbnNhY3Rpb25cIiwzLCEwKStcIm11c3QgYmUgYSBib29sZWFuLlwiKTtpZihcIi5sZW5ndGhcIj09PXRoaXMua2V5KCl8fFwiLmtleXNcIj09PXRoaXMua2V5KCkpdGhyb3dcIkZpcmViYXNlLnRyYW5zYWN0aW9uIGZhaWxlZDogXCIrdGhpcy5rZXkoKStcIiBpcyBhIHJlYWQtb25seSBvYmplY3QuXCI7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjJiYoYz0hMCk7TmgodGhpcy5rLHRoaXMucGF0aCxhLGJ8fG51bGwsYyl9O1IucHJvdG90eXBlLnRyYW5zYWN0aW9uPVIucHJvdG90eXBlLnRyYW5zYWN0aW9uO1xuUi5wcm90b3R5cGUud2c9ZnVuY3Rpb24oYSxiKXtFKFwiRmlyZWJhc2Uuc2V0UHJpb3JpdHlcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5zZXRQcmlvcml0eVwiLHRoaXMucGF0aCk7VmIoXCJGaXJlYmFzZS5zZXRQcmlvcml0eVwiLDEsYSk7SChcIkZpcmViYXNlLnNldFByaW9yaXR5XCIsMixiLCEwKTt0aGlzLmsuQ2IodGhpcy5wYXRoLnUoXCIucHJpb3JpdHlcIiksYSxudWxsLGIpfTtSLnByb3RvdHlwZS5zZXRQcmlvcml0eT1SLnByb3RvdHlwZS53ZztSLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGEsYil7RShcIkZpcmViYXNlLnB1c2hcIiwwLDIsYXJndW1lbnRzLmxlbmd0aCk7WmIoXCJGaXJlYmFzZS5wdXNoXCIsdGhpcy5wYXRoKTtSYihcIkZpcmViYXNlLnB1c2hcIixhLCEwKTtIKFwiRmlyZWJhc2UucHVzaFwiLDIsYiwhMCk7dmFyIGM9RWgodGhpcy5rKSxjPVpoKGMpLGM9dGhpcy51KGMpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgYSYmbnVsbCE9PWEmJmMuc2V0KGEsYik7cmV0dXJuIGN9O1xuUi5wcm90b3R5cGUucHVzaD1SLnByb3RvdHlwZS5wdXNoO1IucHJvdG90eXBlLmZiPWZ1bmN0aW9uKCl7WmIoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3RcIix0aGlzLnBhdGgpO3JldHVybiBuZXcgWih0aGlzLmssdGhpcy5wYXRoKX07Ui5wcm90b3R5cGUub25EaXNjb25uZWN0PVIucHJvdG90eXBlLmZiO1IucHJvdG90eXBlLlE9ZnVuY3Rpb24oYSxiLGMpe3ooXCJGaXJlYmFzZVJlZi5hdXRoKCkgYmVpbmcgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBGaXJlYmFzZVJlZi5hdXRoV2l0aEN1c3RvbVRva2VuKCkgaW5zdGVhZC5cIik7RShcIkZpcmViYXNlLmF1dGhcIiwxLDMsYXJndW1lbnRzLmxlbmd0aCk7JGIoXCJGaXJlYmFzZS5hdXRoXCIsYSk7SChcIkZpcmViYXNlLmF1dGhcIiwyLGIsITApO0goXCJGaXJlYmFzZS5hdXRoXCIsMyxiLCEwKTtPZih0aGlzLmsuUSxhLHt9LHtyZW1lbWJlcjpcIm5vbmVcIn0sYixjKX07Ui5wcm90b3R5cGUuYXV0aD1SLnByb3RvdHlwZS5RO1xuUi5wcm90b3R5cGUuVmU9ZnVuY3Rpb24oYSl7RShcIkZpcmViYXNlLnVuYXV0aFwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtIKFwiRmlyZWJhc2UudW5hdXRoXCIsMSxhLCEwKTtQZih0aGlzLmsuUSxhKX07Ui5wcm90b3R5cGUudW5hdXRoPVIucHJvdG90eXBlLlZlO1IucHJvdG90eXBlLnJlPWZ1bmN0aW9uKCl7RShcIkZpcmViYXNlLmdldEF1dGhcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuay5RLnJlKCl9O1IucHJvdG90eXBlLmdldEF1dGg9Ui5wcm90b3R5cGUucmU7Ui5wcm90b3R5cGUuZmc9ZnVuY3Rpb24oYSxiKXtFKFwiRmlyZWJhc2Uub25BdXRoXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO0goXCJGaXJlYmFzZS5vbkF1dGhcIiwxLGEsITEpO01iKFwiRmlyZWJhc2Uub25BdXRoXCIsMixiKTt0aGlzLmsuUS53YihcImF1dGhfc3RhdHVzXCIsYSxiKX07Ui5wcm90b3R5cGUub25BdXRoPVIucHJvdG90eXBlLmZnO1xuUi5wcm90b3R5cGUuZWc9ZnVuY3Rpb24oYSxiKXtFKFwiRmlyZWJhc2Uub2ZmQXV0aFwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtIKFwiRmlyZWJhc2Uub2ZmQXV0aFwiLDEsYSwhMSk7TWIoXCJGaXJlYmFzZS5vZmZBdXRoXCIsMixiKTt0aGlzLmsuUS4kYihcImF1dGhfc3RhdHVzXCIsYSxiKX07Ui5wcm90b3R5cGUub2ZmQXV0aD1SLnByb3RvdHlwZS5lZztSLnByb3RvdHlwZS5IZj1mdW5jdGlvbihhLGIsYyl7RShcIkZpcmViYXNlLmF1dGhXaXRoQ3VzdG9tVG9rZW5cIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7JGIoXCJGaXJlYmFzZS5hdXRoV2l0aEN1c3RvbVRva2VuXCIsYSk7SChcIkZpcmViYXNlLmF1dGhXaXRoQ3VzdG9tVG9rZW5cIiwyLGIsITEpO0ooXCJGaXJlYmFzZS5hdXRoV2l0aEN1c3RvbVRva2VuXCIsMyxjLCEwKTtPZih0aGlzLmsuUSxhLHt9LGN8fHt9LGIpfTtSLnByb3RvdHlwZS5hdXRoV2l0aEN1c3RvbVRva2VuPVIucHJvdG90eXBlLkhmO1xuUi5wcm90b3R5cGUuSWY9ZnVuY3Rpb24oYSxiLGMpe0UoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUG9wdXBcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7YWMoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUG9wdXBcIiwxLGEpO0goXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUG9wdXBcIiwyLGIsITEpO0ooXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUG9wdXBcIiwzLGMsITApO1RmKHRoaXMuay5RLGEsYyxiKX07Ui5wcm90b3R5cGUuYXV0aFdpdGhPQXV0aFBvcHVwPVIucHJvdG90eXBlLklmO1xuUi5wcm90b3R5cGUuSmY9ZnVuY3Rpb24oYSxiLGMpe0UoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3RcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7YWMoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3RcIiwxLGEpO0goXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3RcIiwyLGIsITEpO0ooXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3RcIiwzLGMsITApO3ZhciBkPXRoaXMuay5RO1JmKGQpO3ZhciBlPVtIZl0sZj1wZihjKTtcImFub255bW91c1wiPT09YXx8XCJmaXJlYmFzZVwiPT09YT9CKGIsWChcIlRSQU5TUE9SVF9VTkFWQUlMQUJMRVwiKSk6KHYuc2V0KFwicmVkaXJlY3RfY2xpZW50X29wdGlvbnNcIixmLmNkKSxTZihkLGUsXCIvYXV0aC9cIithLGYsYikpfTtSLnByb3RvdHlwZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3Q9Ui5wcm90b3R5cGUuSmY7XG5SLnByb3RvdHlwZS5LZj1mdW5jdGlvbihhLGIsYyxkKXtFKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsMyw0LGFyZ3VtZW50cy5sZW5ndGgpO2FjKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsMSxhKTtIKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsMyxjLCExKTtKKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsNCxkLCEwKTtwKGIpPyhhYyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhUb2tlblwiLDIsYiksUWYodGhpcy5rLlEsYStcIi90b2tlblwiLHthY2Nlc3NfdG9rZW46Yn0sZCxjKSk6KEooXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiwyLGIsITEpLFFmKHRoaXMuay5RLGErXCIvdG9rZW5cIixiLGQsYykpfTtSLnByb3RvdHlwZS5hdXRoV2l0aE9BdXRoVG9rZW49Ui5wcm90b3R5cGUuS2Y7XG5SLnByb3RvdHlwZS5HZj1mdW5jdGlvbihhLGIpe0UoXCJGaXJlYmFzZS5hdXRoQW5vbnltb3VzbHlcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7SChcIkZpcmViYXNlLmF1dGhBbm9ueW1vdXNseVwiLDEsYSwhMSk7SihcIkZpcmViYXNlLmF1dGhBbm9ueW1vdXNseVwiLDIsYiwhMCk7UWYodGhpcy5rLlEsXCJhbm9ueW1vdXNcIix7fSxiLGEpfTtSLnByb3RvdHlwZS5hdXRoQW5vbnltb3VzbHk9Ui5wcm90b3R5cGUuR2Y7XG5SLnByb3RvdHlwZS5MZj1mdW5jdGlvbihhLGIsYyl7RShcIkZpcmViYXNlLmF1dGhXaXRoUGFzc3dvcmRcIiwyLDMsYXJndW1lbnRzLmxlbmd0aCk7SihcIkZpcmViYXNlLmF1dGhXaXRoUGFzc3dvcmRcIiwxLGEsITEpO0soXCJGaXJlYmFzZS5hdXRoV2l0aFBhc3N3b3JkXCIsYSxcImVtYWlsXCIpO0soXCJGaXJlYmFzZS5hdXRoV2l0aFBhc3N3b3JkXCIsYSxcInBhc3N3b3JkXCIpO0goXCJGaXJlYmFzZS5hdXRoQW5vbnltb3VzbHlcIiwyLGIsITEpO0ooXCJGaXJlYmFzZS5hdXRoQW5vbnltb3VzbHlcIiwzLGMsITApO1FmKHRoaXMuay5RLFwicGFzc3dvcmRcIixhLGMsYil9O1IucHJvdG90eXBlLmF1dGhXaXRoUGFzc3dvcmQ9Ui5wcm90b3R5cGUuTGY7XG5SLnByb3RvdHlwZS5uZT1mdW5jdGlvbihhLGIpe0UoXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsMiwyLGFyZ3VtZW50cy5sZW5ndGgpO0ooXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsMSxhLCExKTtLKFwiRmlyZWJhc2UuY3JlYXRlVXNlclwiLGEsXCJlbWFpbFwiKTtLKFwiRmlyZWJhc2UuY3JlYXRlVXNlclwiLGEsXCJwYXNzd29yZFwiKTtIKFwiRmlyZWJhc2UuY3JlYXRlVXNlclwiLDIsYiwhMSk7dGhpcy5rLlEubmUoYSxiKX07Ui5wcm90b3R5cGUuY3JlYXRlVXNlcj1SLnByb3RvdHlwZS5uZTtSLnByb3RvdHlwZS5NZT1mdW5jdGlvbihhLGIpe0UoXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsMiwyLGFyZ3VtZW50cy5sZW5ndGgpO0ooXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsMSxhLCExKTtLKFwiRmlyZWJhc2UucmVtb3ZlVXNlclwiLGEsXCJlbWFpbFwiKTtLKFwiRmlyZWJhc2UucmVtb3ZlVXNlclwiLGEsXCJwYXNzd29yZFwiKTtIKFwiRmlyZWJhc2UucmVtb3ZlVXNlclwiLDIsYiwhMSk7dGhpcy5rLlEuTWUoYSxiKX07XG5SLnByb3RvdHlwZS5yZW1vdmVVc2VyPVIucHJvdG90eXBlLk1lO1IucHJvdG90eXBlLmplPWZ1bmN0aW9uKGEsYil7RShcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsMiwyLGFyZ3VtZW50cy5sZW5ndGgpO0ooXCJGaXJlYmFzZS5jaGFuZ2VQYXNzd29yZFwiLDEsYSwhMSk7SyhcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsYSxcImVtYWlsXCIpO0soXCJGaXJlYmFzZS5jaGFuZ2VQYXNzd29yZFwiLGEsXCJvbGRQYXNzd29yZFwiKTtLKFwiRmlyZWJhc2UuY2hhbmdlUGFzc3dvcmRcIixhLFwibmV3UGFzc3dvcmRcIik7SChcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsMixiLCExKTt0aGlzLmsuUS5qZShhLGIpfTtSLnByb3RvdHlwZS5jaGFuZ2VQYXNzd29yZD1SLnByb3RvdHlwZS5qZTtcblIucHJvdG90eXBlLmllPWZ1bmN0aW9uKGEsYil7RShcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsMiwyLGFyZ3VtZW50cy5sZW5ndGgpO0ooXCJGaXJlYmFzZS5jaGFuZ2VFbWFpbFwiLDEsYSwhMSk7SyhcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsYSxcIm9sZEVtYWlsXCIpO0soXCJGaXJlYmFzZS5jaGFuZ2VFbWFpbFwiLGEsXCJuZXdFbWFpbFwiKTtLKFwiRmlyZWJhc2UuY2hhbmdlRW1haWxcIixhLFwicGFzc3dvcmRcIik7SChcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsMixiLCExKTt0aGlzLmsuUS5pZShhLGIpfTtSLnByb3RvdHlwZS5jaGFuZ2VFbWFpbD1SLnByb3RvdHlwZS5pZTtcblIucHJvdG90eXBlLk5lPWZ1bmN0aW9uKGEsYil7RShcIkZpcmViYXNlLnJlc2V0UGFzc3dvcmRcIiwyLDIsYXJndW1lbnRzLmxlbmd0aCk7SihcIkZpcmViYXNlLnJlc2V0UGFzc3dvcmRcIiwxLGEsITEpO0soXCJGaXJlYmFzZS5yZXNldFBhc3N3b3JkXCIsYSxcImVtYWlsXCIpO0goXCJGaXJlYmFzZS5yZXNldFBhc3N3b3JkXCIsMixiLCExKTt0aGlzLmsuUS5OZShhLGIpfTtSLnByb3RvdHlwZS5yZXNldFBhc3N3b3JkPVIucHJvdG90eXBlLk5lO1IuZ29PZmZsaW5lPWZ1bmN0aW9uKCl7RShcIkZpcmViYXNlLmdvT2ZmbGluZVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtXaC5PYigpLnFiKCl9O1IuZ29PbmxpbmU9ZnVuY3Rpb24oKXtFKFwiRmlyZWJhc2UuZ29PbmxpbmVcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7V2guT2IoKS5pYygpfTtcbmZ1bmN0aW9uIG5iKGEsYil7eSghYnx8ITA9PT1hfHwhMT09PWEsXCJDYW4ndCB0dXJuIG9uIGN1c3RvbSBsb2dnZXJzIHBlcnNpc3RlbnRseS5cIik7ITA9PT1hPyhcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUmJihcImZ1bmN0aW9uXCI9PT10eXBlb2YgY29uc29sZS5sb2c/bGI9cShjb25zb2xlLmxvZyxjb25zb2xlKTpcIm9iamVjdFwiPT09dHlwZW9mIGNvbnNvbGUubG9nJiYobGI9ZnVuY3Rpb24oYSl7Y29uc29sZS5sb2coYSl9KSksYiYmdi5zZXQoXCJsb2dnaW5nX2VuYWJsZWRcIiwhMCkpOmE/bGI9YToobGI9bnVsbCx2LnJlbW92ZShcImxvZ2dpbmdfZW5hYmxlZFwiKSl9Ui5lbmFibGVMb2dnaW5nPW5iO1IuU2VydmVyVmFsdWU9e1RJTUVTVEFNUDp7XCIuc3ZcIjpcInRpbWVzdGFtcFwifX07Ui5TREtfVkVSU0lPTj1cIjIuMi4wXCI7Ui5JTlRFUk5BTD1ZO1IuQ29udGV4dD1XaDtSLlRFU1RfQUNDRVNTPSQ7fSkoKTtcbm1vZHVsZS5leHBvcnRzID0gRmlyZWJhc2U7XG4iLCJcblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2FwcGVuZCcgOiByZXF1aXJlKCcuL2FycmF5L2FwcGVuZCcpLFxuICAgICdjb2xsZWN0JyA6IHJlcXVpcmUoJy4vYXJyYXkvY29sbGVjdCcpLFxuICAgICdjb21iaW5lJyA6IHJlcXVpcmUoJy4vYXJyYXkvY29tYmluZScpLFxuICAgICdjb21wYWN0JyA6IHJlcXVpcmUoJy4vYXJyYXkvY29tcGFjdCcpLFxuICAgICdjb250YWlucycgOiByZXF1aXJlKCcuL2FycmF5L2NvbnRhaW5zJyksXG4gICAgJ2RpZmZlcmVuY2UnIDogcmVxdWlyZSgnLi9hcnJheS9kaWZmZXJlbmNlJyksXG4gICAgJ2VxdWFscycgOiByZXF1aXJlKCcuL2FycmF5L2VxdWFscycpLFxuICAgICdldmVyeScgOiByZXF1aXJlKCcuL2FycmF5L2V2ZXJ5JyksXG4gICAgJ2ZpbHRlcicgOiByZXF1aXJlKCcuL2FycmF5L2ZpbHRlcicpLFxuICAgICdmaW5kJyA6IHJlcXVpcmUoJy4vYXJyYXkvZmluZCcpLFxuICAgICdmaW5kSW5kZXgnIDogcmVxdWlyZSgnLi9hcnJheS9maW5kSW5kZXgnKSxcbiAgICAnZmluZExhc3QnIDogcmVxdWlyZSgnLi9hcnJheS9maW5kTGFzdCcpLFxuICAgICdmaW5kTGFzdEluZGV4JyA6IHJlcXVpcmUoJy4vYXJyYXkvZmluZExhc3RJbmRleCcpLFxuICAgICdmbGF0dGVuJyA6IHJlcXVpcmUoJy4vYXJyYXkvZmxhdHRlbicpLFxuICAgICdmb3JFYWNoJyA6IHJlcXVpcmUoJy4vYXJyYXkvZm9yRWFjaCcpLFxuICAgICdncm91cEJ5JyA6IHJlcXVpcmUoJy4vYXJyYXkvZ3JvdXBCeScpLFxuICAgICdpbmRleE9mJyA6IHJlcXVpcmUoJy4vYXJyYXkvaW5kZXhPZicpLFxuICAgICdpbnNlcnQnIDogcmVxdWlyZSgnLi9hcnJheS9pbnNlcnQnKSxcbiAgICAnaW50ZXJzZWN0aW9uJyA6IHJlcXVpcmUoJy4vYXJyYXkvaW50ZXJzZWN0aW9uJyksXG4gICAgJ2ludm9rZScgOiByZXF1aXJlKCcuL2FycmF5L2ludm9rZScpLFxuICAgICdqb2luJyA6IHJlcXVpcmUoJy4vYXJyYXkvam9pbicpLFxuICAgICdsYXN0JyA6IHJlcXVpcmUoJy4vYXJyYXkvbGFzdCcpLFxuICAgICdsYXN0SW5kZXhPZicgOiByZXF1aXJlKCcuL2FycmF5L2xhc3RJbmRleE9mJyksXG4gICAgJ21hcCcgOiByZXF1aXJlKCcuL2FycmF5L21hcCcpLFxuICAgICdtYXgnIDogcmVxdWlyZSgnLi9hcnJheS9tYXgnKSxcbiAgICAnbWluJyA6IHJlcXVpcmUoJy4vYXJyYXkvbWluJyksXG4gICAgJ3BpY2snIDogcmVxdWlyZSgnLi9hcnJheS9waWNrJyksXG4gICAgJ3BsdWNrJyA6IHJlcXVpcmUoJy4vYXJyYXkvcGx1Y2snKSxcbiAgICAncmFuZ2UnIDogcmVxdWlyZSgnLi9hcnJheS9yYW5nZScpLFxuICAgICdyZWR1Y2UnIDogcmVxdWlyZSgnLi9hcnJheS9yZWR1Y2UnKSxcbiAgICAncmVkdWNlUmlnaHQnIDogcmVxdWlyZSgnLi9hcnJheS9yZWR1Y2VSaWdodCcpLFxuICAgICdyZWplY3QnIDogcmVxdWlyZSgnLi9hcnJheS9yZWplY3QnKSxcbiAgICAncmVtb3ZlJyA6IHJlcXVpcmUoJy4vYXJyYXkvcmVtb3ZlJyksXG4gICAgJ3JlbW92ZUFsbCcgOiByZXF1aXJlKCcuL2FycmF5L3JlbW92ZUFsbCcpLFxuICAgICdzaHVmZmxlJyA6IHJlcXVpcmUoJy4vYXJyYXkvc2h1ZmZsZScpLFxuICAgICdzbGljZScgOiByZXF1aXJlKCcuL2FycmF5L3NsaWNlJyksXG4gICAgJ3NvbWUnIDogcmVxdWlyZSgnLi9hcnJheS9zb21lJyksXG4gICAgJ3NvcnQnIDogcmVxdWlyZSgnLi9hcnJheS9zb3J0JyksXG4gICAgJ3NvcnRCeScgOiByZXF1aXJlKCcuL2FycmF5L3NvcnRCeScpLFxuICAgICdzcGxpdCcgOiByZXF1aXJlKCcuL2FycmF5L3NwbGl0JyksXG4gICAgJ3Rha2UnIDogcmVxdWlyZSgnLi9hcnJheS90YWtlJyksXG4gICAgJ3RvTG9va3VwJyA6IHJlcXVpcmUoJy4vYXJyYXkvdG9Mb29rdXAnKSxcbiAgICAndW5pb24nIDogcmVxdWlyZSgnLi9hcnJheS91bmlvbicpLFxuICAgICd1bmlxdWUnIDogcmVxdWlyZSgnLi9hcnJheS91bmlxdWUnKSxcbiAgICAneG9yJyA6IHJlcXVpcmUoJy4vYXJyYXkveG9yJyksXG4gICAgJ3ppcCcgOiByZXF1aXJlKCcuL2FycmF5L3ppcCcpXG59O1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBhbiBhcnJheSB0byB0aGUgZW5kIG9mIGFub3RoZXIuXG4gICAgICogVGhlIGZpcnN0IGFycmF5IHdpbGwgYmUgbW9kaWZpZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwZW5kKGFycjEsIGFycjIpIHtcbiAgICAgICAgaWYgKGFycjIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFycjE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFkID0gYXJyMS5sZW5ndGgsXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBsZW4gPSBhcnIyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgYXJyMVtwYWQgKyBpXSA9IGFycjJbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjE7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gYXBwZW5kO1xuXG4iLCJ2YXIgYXBwZW5kID0gcmVxdWlyZSgnLi9hcHBlbmQnKTtcbnZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIHRoZSBpdGVtcyBpbiB0aGUgYXJyYXkgYW5kIGNvbmNhdGVuYXRlcyB0aGUgcmVzdWx0IGFycmF5cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb2xsZWN0KGFyciwgY2FsbGJhY2ssIHRoaXNPYmope1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgdGhpc09iaik7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjYWxsYmFjayhhcnJbaV0sIGksIGFycik7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFwcGVuZChyZXN1bHRzLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbGxlY3Q7XG5cblxuIiwidmFyIGluZGV4T2YgPSByZXF1aXJlKCcuL2luZGV4T2YnKTtcblxuICAgIC8qKlxuICAgICAqIENvbWJpbmVzIGFuIGFycmF5IHdpdGggYWxsIHRoZSBpdGVtcyBvZiBhbm90aGVyLlxuICAgICAqIERvZXMgbm90IGFsbG93IGR1cGxpY2F0ZXMgYW5kIGlzIGNhc2UgYW5kIHR5cGUgc2Vuc2l0aXZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbWJpbmUoYXJyMSwgYXJyMikge1xuICAgICAgICBpZiAoYXJyMiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFycjIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXhPZihhcnIxLCBhcnIyW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhcnIxLnB1c2goYXJyMltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyMTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb21iaW5lO1xuXG4iLCJ2YXIgZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgbnVsbC91bmRlZmluZWQgaXRlbXMgZnJvbSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycikge1xuICAgICAgICByZXR1cm4gZmlsdGVyKGFyciwgZnVuY3Rpb24odmFsKXtcbiAgICAgICAgICAgIHJldHVybiAodmFsICE9IG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbXBhY3Q7XG5cbiIsInZhciBpbmRleE9mID0gcmVxdWlyZSgnLi9pbmRleE9mJyk7XG5cbiAgICAvKipcbiAgICAgKiBJZiBhcnJheSBjb250YWlucyB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMoYXJyLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4T2YoYXJyLCB2YWwpICE9PSAtMTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb250YWlucztcblxuIiwidmFyIHVuaXF1ZSA9IHJlcXVpcmUoJy4vdW5pcXVlJyk7XG52YXIgZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcbnZhciBzb21lID0gcmVxdWlyZSgnLi9zb21lJyk7XG52YXIgY29udGFpbnMgPSByZXF1aXJlKCcuL2NvbnRhaW5zJyk7XG52YXIgc2xpY2UgPSByZXF1aXJlKCcuL3NsaWNlJyk7XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBBcnJheSB3aXRoIGVsZW1lbnRzIHRoYXQgYXJlbid0IHByZXNlbnQgaW4gdGhlIG90aGVyIEFycmF5cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaWZmZXJlbmNlKGFycikge1xuICAgICAgICB2YXIgYXJycyA9IHNsaWNlKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXIodW5pcXVlKGFyciksIGZ1bmN0aW9uKG5lZWRsZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFzb21lKGFycnMsIGZ1bmN0aW9uKGhheXN0YWNrKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGhheXN0YWNrLCBuZWVkbGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkaWZmZXJlbmNlO1xuXG5cbiIsInZhciBpcyA9IHJlcXVpcmUoJy4uL2xhbmcvaXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5Jyk7XG52YXIgZXZlcnkgPSByZXF1aXJlKCcuL2V2ZXJ5Jyk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyBpZiBib3RoIGFycmF5cyBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIsIGNhbGxiYWNrKXtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBpcztcblxuICAgICAgICBpZiAoIWlzQXJyYXkoYSkgfHwgIWlzQXJyYXkoYikpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhhLCBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmVyeShhLCBtYWtlQ29tcGFyZShjYWxsYmFjayksIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VDb21wYXJlKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGkgaW4gdGhpcyAmJiBjYWxsYmFjayh2YWx1ZSwgdGhpc1tpXSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlcXVhbHM7XG5cblxuIiwidmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IGV2ZXJ5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoYXJyLCBjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgdGhpc09iaik7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICAvLyB3ZSBpdGVyYXRlIG92ZXIgc3BhcnNlIGl0ZW1zIHNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byBtYWtlIGl0XG4gICAgICAgICAgICAvLyB3b3JrIHByb3Blcmx5IG9uIElFIDctOC4gc2VlICM2NFxuICAgICAgICAgICAgaWYgKCFjYWxsYmFjayhhcnJbaV0sIGksIGFycikgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZXZlcnk7XG5cbiIsInZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBmaWx0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoYXJyLCBjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgdGhpc09iaik7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoLCB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgdmFsdWUgPSBhcnJbaV07XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGksIGFycikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG5cblxuIiwidmFyIGZpbmRJbmRleCA9IHJlcXVpcmUoJy4vZmluZEluZGV4Jyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpcnN0IGl0ZW0gdGhhdCBtYXRjaGVzIGNyaXRlcmlhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZChhcnIsIGl0ZXJhdG9yLCB0aGlzT2JqKXtcbiAgICAgICAgdmFyIGlkeCA9IGZpbmRJbmRleChhcnIsIGl0ZXJhdG9yLCB0aGlzT2JqKTtcbiAgICAgICAgcmV0dXJuIGlkeCA+PSAwPyBhcnJbaWR4XSA6IHZvaWQoMCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaW5kO1xuXG5cbiIsInZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbSB0aGF0IG1hdGNoZXMgY3JpdGVyaWFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBpdGVyYXRvciwgdGhpc09iail7XG4gICAgICAgIGl0ZXJhdG9yID0gbWFrZUl0ZXJhdG9yKGl0ZXJhdG9yLCB0aGlzT2JqKTtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IoYXJyW2ldLCBpLCBhcnIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaW5kSW5kZXg7XG5cbiIsInZhciBmaW5kTGFzdEluZGV4ID0gcmVxdWlyZSgnLi9maW5kTGFzdEluZGV4Jyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxhc3QgaXRlbSB0aGF0IG1hdGNoZXMgY3JpdGVyaWFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdChhcnIsIGl0ZXJhdG9yLCB0aGlzT2JqKXtcbiAgICAgICAgdmFyIGlkeCA9IGZpbmRMYXN0SW5kZXgoYXJyLCBpdGVyYXRvciwgdGhpc09iaik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMD8gYXJyW2lkeF0gOiB2b2lkKDApO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZmluZExhc3Q7XG5cblxuIiwidmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGl0ZW0gdGhhdCBtYXRjaGVzIGNyaXRlcmlhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnIsIGl0ZXJhdG9yLCB0aGlzT2JqKXtcbiAgICAgICAgaXRlcmF0b3IgPSBtYWtlSXRlcmF0b3IoaXRlcmF0b3IsIHRoaXNPYmopO1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IoYXJyW25dLCBuLCBhcnIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaW5kTGFzdEluZGV4O1xuXG5cbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5Jyk7XG52YXIgYXBwZW5kID0gcmVxdWlyZSgnLi9hcHBlbmQnKTtcblxuICAgIC8qXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGZsYXR0ZW4gdG8gYSBkZXN0aW5hdGlvbiBhcnJheS5cbiAgICAgKiBVc2VkIHRvIHJlbW92ZSB0aGUgbmVlZCB0byBjcmVhdGUgaW50ZXJtZWRpYXRlIGFycmF5cyB3aGlsZSBmbGF0dGVuaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5UbyhhcnIsIHJlc3VsdCwgbGV2ZWwpIHtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgICAgICBhcHBlbmQocmVzdWx0LCBhcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSxcbiAgICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICAgIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIHZhbHVlID0gYXJyW2ldO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZmxhdHRlblRvKHZhbHVlLCByZXN1bHQsIGxldmVsIC0gMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGFuIGFycmF5LlxuICAgICAqIEEgbmV3IGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBlbGVtZW50cyBpcyByZXR1cm5lZC5cbiAgICAgKiBJZiBgc2hhbGxvd2AgaXMgdHJ1ZSwgaXQgd2lsbCBvbmx5IGZsYXR0ZW4gb25lIGxldmVsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyLCBsZXZlbCkge1xuICAgICAgICBsZXZlbCA9IGxldmVsID09IG51bGw/IC0xIDogbGV2ZWw7XG4gICAgICAgIHJldHVybiBmbGF0dGVuVG8oYXJyLCBbXSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcblxuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgZm9yRWFjaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goYXJyLCBjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgLy8gd2UgaXRlcmF0ZSBvdmVyIHNwYXJzZSBpdGVtcyBzaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gbWFrZSBpdFxuICAgICAgICAgICAgLy8gd29yayBwcm9wZXJseSBvbiBJRSA3LTguIHNlZSAjNjRcbiAgICAgICAgICAgIGlmICggY2FsbGJhY2suY2FsbCh0aGlzT2JqLCBhcnJbaV0sIGksIGFycikgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG5cbiIsInZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vYXJyYXkvZm9yRWFjaCcpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vaWRlbnRpdHknKTtcbnZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBCdWNrZXQgdGhlIGFycmF5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBncm91cEJ5KGFyciwgY2F0ZWdvcml6ZSwgdGhpc09iaikge1xuICAgICAgICBpZiAoY2F0ZWdvcml6ZSkge1xuICAgICAgICAgICAgY2F0ZWdvcml6ZSA9IG1ha2VJdGVyYXRvcihjYXRlZ29yaXplLCB0aGlzT2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gaWRlbnRpdHkgZnVuY3Rpb24uXG4gICAgICAgICAgICBjYXRlZ29yaXplID0gaWRlbnRpdHk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnVja2V0cyA9IHt9O1xuICAgICAgICBmb3JFYWNoKGFyciwgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGJ1Y2tldCA9IGNhdGVnb3JpemUoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoIShidWNrZXQgaW4gYnVja2V0cykpIHtcbiAgICAgICAgICAgICAgICBidWNrZXRzW2J1Y2tldF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVja2V0c1tidWNrZXRdLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBidWNrZXRzO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZ3JvdXBCeTtcblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBBcnJheS5pbmRleE9mXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnIsIGl0ZW0sIGZyb21JbmRleCkge1xuICAgICAgICBmcm9tSW5kZXggPSBmcm9tSW5kZXggfHwgMDtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aCxcbiAgICAgICAgICAgIGkgPSBmcm9tSW5kZXggPCAwID8gbGVuICsgZnJvbUluZGV4IDogZnJvbUluZGV4O1xuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgLy8gd2UgaXRlcmF0ZSBvdmVyIHNwYXJzZSBpdGVtcyBzaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gbWFrZSBpdFxuICAgICAgICAgICAgLy8gd29yayBwcm9wZXJseSBvbiBJRSA3LTguIHNlZSAjNjRcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaW5kZXhPZjtcblxuIiwidmFyIGRpZmZlcmVuY2UgPSByZXF1aXJlKCcuL2RpZmZlcmVuY2UnKTtcbnZhciBzbGljZSA9IHJlcXVpcmUoJy4vc2xpY2UnKTtcblxuICAgIC8qKlxuICAgICAqIEluc2VydCBpdGVtIGludG8gYXJyYXkgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnQoYXJyLCByZXN0X2l0ZW1zKSB7XG4gICAgICAgIHZhciBkaWZmID0gZGlmZmVyZW5jZShzbGljZShhcmd1bWVudHMsIDEpLCBhcnIpO1xuICAgICAgICBpZiAoZGlmZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFyciwgZGlmZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyci5sZW5ndGg7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaW5zZXJ0O1xuXG4iLCJ2YXIgdW5pcXVlID0gcmVxdWlyZSgnLi91bmlxdWUnKTtcbnZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xudmFyIGV2ZXJ5ID0gcmVxdWlyZSgnLi9ldmVyeScpO1xudmFyIGNvbnRhaW5zID0gcmVxdWlyZSgnLi9jb250YWlucycpO1xudmFyIHNsaWNlID0gcmVxdWlyZSgnLi9zbGljZScpO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgQXJyYXkgd2l0aCBlbGVtZW50cyBjb21tb24gdG8gYWxsIEFycmF5cy5cbiAgICAgKiAtIGJhc2VkIG9uIHVuZGVyc2NvcmUuanMgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oYXJyKSB7XG4gICAgICAgIHZhciBhcnJzID0gc2xpY2UoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlcih1bmlxdWUoYXJyKSwgZnVuY3Rpb24obmVlZGxlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlcnkoYXJycywgZnVuY3Rpb24oaGF5c3RhY2spe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbnMoaGF5c3RhY2ssIG5lZWRsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdGlvbjtcblxuXG4iLCJ2YXIgc2xpY2UgPSByZXF1aXJlKCcuL3NsaWNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGBtZXRob2ROYW1lYCBvbiBlYWNoIGl0ZW0gb2YgdGhlIGFycmF5IHBhc3NpbmcgY3VzdG9tIGFyZ3VtZW50cyBpZlxuICAgICAqIG5lZWRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZva2UoYXJyLCBtZXRob2ROYW1lLCB2YXJfYXJncyl7XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgdmFyIGkgPSAtMSwgbGVuID0gYXJyLmxlbmd0aCwgdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIHZhbHVlID0gYXJyW2ldO1xuICAgICAgICAgICAgdmFsdWVbbWV0aG9kTmFtZV0uYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGludm9rZTtcblxuIiwidmFyIGZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkU3RyaW5nKHZhbCkge1xuICAgICAgICByZXR1cm4gKHZhbCAhPSBudWxsICYmIHZhbCAhPT0gJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEpvaW5zIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWVkIHNlcGFyYXRvciBpbnNlcnRlZCBiZXR3ZWVuIGVhY2ggdmFsdWUuXG4gICAgICogTnVsbCB2YWx1ZXMgYW5kIGVtcHR5IHN0cmluZ3Mgd2lsbCBiZSBleGNsdWRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBqb2luKGl0ZW1zLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8ICcnO1xuICAgICAgICByZXR1cm4gZmlsdGVyKGl0ZW1zLCBpc1ZhbGlkU3RyaW5nKS5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqb2luO1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGFzdCBlbGVtZW50IG9mIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyKXtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsIHx8IGFyci5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBsYXN0O1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgbGFzdEluZGV4T2ZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnIsIGl0ZW0sIGZyb21JbmRleCkge1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ID09IG51bGwgfHwgZnJvbUluZGV4ID49IGxlbik/IGxlbiAtIDEgOiBmcm9tSW5kZXg7XG4gICAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPCAwKT8gbGVuICsgZnJvbUluZGV4IDogZnJvbUluZGV4O1xuXG4gICAgICAgIHdoaWxlIChmcm9tSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgLy8gd2UgaXRlcmF0ZSBvdmVyIHNwYXJzZSBpdGVtcyBzaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gbWFrZSBpdFxuICAgICAgICAgICAgLy8gd29yayBwcm9wZXJseSBvbiBJRSA3LTguIHNlZSAjNjRcbiAgICAgICAgICAgIGlmIChhcnJbZnJvbUluZGV4XSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tSW5kZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGxhc3RJbmRleE9mO1xuXG4iLCJ2YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgbWFwXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgICAgICAgY2FsbGJhY2sgPSBtYWtlSXRlcmF0b3IoY2FsbGJhY2ssIHRoaXNPYmopO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoYXJyID09IG51bGwpe1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0gY2FsbGJhY2soYXJyW2ldLCBpLCBhcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgIG1vZHVsZS5leHBvcnRzID0gbWFwO1xuXG4iLCJ2YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIG1heGltdW0gdmFsdWUgaW5zaWRlIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGFyciwgaXRlcmF0b3IsIHRoaXNPYmope1xuICAgICAgICBpZiAoYXJyID09IG51bGwgfHwgIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfSBlbHNlIGlmIChhcnIubGVuZ3RoICYmICFpdGVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIGFycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRvciA9IG1ha2VJdGVyYXRvcihpdGVyYXRvciwgdGhpc09iaik7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgICAgIGNvbXBhcmUgPSAtSW5maW5pdHksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgdGVtcDtcblxuICAgICAgICAgICAgdmFyIGkgPSAtMSwgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgICAgICAgICB0ZW1wID0gaXRlcmF0b3IodmFsdWUsIGksIGFycik7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXAgPiBjb21wYXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmUgPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1heDtcblxuXG4iLCJ2YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIG1pbmltdW0gdmFsdWUgaW5zaWRlIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGFyciwgaXRlcmF0b3IsIHRoaXNPYmope1xuICAgICAgICBpZiAoYXJyID09IG51bGwgfHwgIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCAmJiAhaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBhcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IgPSBtYWtlSXRlcmF0b3IoaXRlcmF0b3IsIHRoaXNPYmopO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgICAgICBjb21wYXJlID0gSW5maW5pdHksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgdGVtcDtcblxuICAgICAgICAgICAgdmFyIGkgPSAtMSwgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgICAgICAgICB0ZW1wID0gaXRlcmF0b3IodmFsdWUsIGksIGFycik7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXAgPCBjb21wYXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmUgPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1pbjtcblxuXG4iLCJ2YXIgcmFuZEludCA9IHJlcXVpcmUoJy4uL3JhbmRvbS9yYW5kSW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgcmFuZG9tIGl0ZW0ocykgZnJvbSB0aGUgQXJyYXkgYW5kIHJldHVybiBpdC5cbiAgICAgKiBSZXR1cm5zIGFuIEFycmF5IG9mIGl0ZW1zIGlmIFtuSXRlbXNdIGlzIHByb3ZpZGVkIG9yIGEgc2luZ2xlIGl0ZW0gaWZcbiAgICAgKiBpdCBpc24ndCBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGljayhhcnIsIG5JdGVtcyl7XG4gICAgICAgIGlmIChuSXRlbXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgaWYgKG5JdGVtcyA+IDAgJiYgYXJyICYmIGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuSXRlbXMgPSBuSXRlbXMgPiBhcnIubGVuZ3RoPyBhcnIubGVuZ3RoIDogbkl0ZW1zO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuSXRlbXMtLSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCggcGlja09uZShhcnIpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGFyciAmJiBhcnIubGVuZ3RoKT8gcGlja09uZShhcnIpIDogdm9pZCgwKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHBpY2tPbmUoYXJyKXtcbiAgICAgICAgdmFyIGlkeCA9IHJhbmRJbnQoMCwgYXJyLmxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gYXJyLnNwbGljZShpZHgsIDEpWzBdO1xuICAgIH1cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuXG5cbiIsInZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBhIGxpc3Qgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBsdWNrKGFyciwgcHJvcE5hbWUpe1xuICAgICAgICByZXR1cm4gbWFwKGFyciwgcHJvcE5hbWUpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcGx1Y2s7XG5cblxuIiwidmFyIGNvdW50U3RlcHMgPSByZXF1aXJlKCcuLi9tYXRoL2NvdW50U3RlcHMnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gQXJyYXkgb2YgbnVtYmVycyBpbnNpZGUgcmFuZ2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcCA9IHN0YXJ0O1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgblN0ZXBzID0gY291bnRTdGVwcyhzdG9wIC0gc3RhcnQsIHN0ZXApLFxuICAgICAgICAgICAgaSA9IHN0YXJ0O1xuXG4gICAgICAgIHdoaWxlIChpIDw9IHN0b3ApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICAgICAgaSArPSBzdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJhbmdlO1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgcmVkdWNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGFyciwgZm4sIGluaXRWYWwpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGFyZ3MubGVuZ3RoIHNpbmNlIGluaXRWYWwgbWlnaHQgYmUgXCJ1bmRlZmluZWRcIiBzZWUgI2doLTU3XG4gICAgICAgIHZhciBoYXNJbml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIsXG4gICAgICAgICAgICByZXN1bHQgPSBpbml0VmFsO1xuXG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCB8fCAhYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFoYXNJbml0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0VmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAtMSwgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgaWYgKCFoYXNJbml0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXJyW2ldO1xuICAgICAgICAgICAgICAgIGhhc0luaXQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihyZXN1bHQsIGFycltpXSwgaSwgYXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZWR1Y2U7XG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgcmVkdWNlUmlnaHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChhcnIsIGZuLCBpbml0VmFsKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBhcmdzLmxlbmd0aCBzaW5jZSBpbml0VmFsIG1pZ2h0IGJlIFwidW5kZWZpbmVkXCIgc2VlICNnaC01N1xuICAgICAgICB2YXIgaGFzSW5pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuXG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCB8fCAhYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc0luaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5pdFZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IGFyci5sZW5ndGgsIHJlc3VsdCA9IGluaXRWYWwsIHZhbHVlO1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIC8vIHdlIGl0ZXJhdGUgb3ZlciBzcGFyc2UgaXRlbXMgc2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIG1ha2UgaXRcbiAgICAgICAgICAgIC8vIHdvcmsgcHJvcGVybHkgb24gSUUgNy04LiBzZWUgIzY0XG4gICAgICAgICAgICB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgICAgIGlmICghaGFzSW5pdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGhhc0luaXQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihyZXN1bHQsIHZhbHVlLCBpLCBhcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZWR1Y2VSaWdodDtcblxuIiwidmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IHJlamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChhcnIsIGNhbGxiYWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbWFrZUl0ZXJhdG9yKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFyci5sZW5ndGgsIHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2sodmFsdWUsIGksIGFycikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZWplY3Q7XG5cbiIsInZhciBpbmRleE9mID0gcmVxdWlyZSgnLi9pbmRleE9mJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzaW5nbGUgaXRlbSBmcm9tIHRoZSBhcnJheS5cbiAgICAgKiAoaXQgd29uJ3QgcmVtb3ZlIGR1cGxpY2F0ZXMsIGp1c3QgYSBzaW5nbGUgaXRlbSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyLCBpdGVtKXtcbiAgICAgICAgdmFyIGlkeCA9IGluZGV4T2YoYXJyLCBpdGVtKTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIGFyci5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlbW92ZTtcblxuIiwidmFyIGluZGV4T2YgPSByZXF1aXJlKCcuL2luZGV4T2YnKTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgaW5zdGFuY2VzIG9mIGFuIGl0ZW0gZnJvbSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVBbGwoYXJyLCBpdGVtKXtcbiAgICAgICAgdmFyIGlkeCA9IGluZGV4T2YoYXJyLCBpdGVtKTtcbiAgICAgICAgd2hpbGUgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFyci5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIGlkeCA9IGluZGV4T2YoYXJyLCBpdGVtLCBpZHgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZW1vdmVBbGw7XG5cbiIsInZhciByYW5kSW50ID0gcmVxdWlyZSgnLi4vcmFuZG9tL3JhbmRJbnQnKTtcblxuICAgIC8qKlxuICAgICAqIFNodWZmbGUgYXJyYXkgaXRlbXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShhcnIpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgIHJuZDtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFyci5sZW5ndGgsIHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoIWkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzWzBdID0gYXJyWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBybmQgPSByYW5kSW50KDAsIGkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSByZXN1bHRzW3JuZF07XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tybmRdID0gYXJyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzaHVmZmxlO1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBzbGljZSBvZiBzb3VyY2UgYXJyYXkgb3IgYXJyYXktbGlrZSBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGljZShhcnIsIHN0YXJ0LCBlbmQpe1xuICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcblxuICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heChsZW4gKyBzdGFydCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWluKHN0YXJ0LCBsZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSBsZW47XG4gICAgICAgIH0gZWxzZSBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgZW5kID0gTWF0aC5tYXgobGVuICsgZW5kLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgbGVuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnJbc3RhcnQrK10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNsaWNlO1xuXG5cbiIsInZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzb21lXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShhcnIsIGNhbGxiYWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbWFrZUl0ZXJhdG9yKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IC0xLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICAvLyB3ZSBpdGVyYXRlIG92ZXIgc3BhcnNlIGl0ZW1zIHNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byBtYWtlIGl0XG4gICAgICAgICAgICAvLyB3b3JrIHByb3Blcmx5IG9uIElFIDctOC4gc2VlICM2NFxuICAgICAgICAgICAgaWYgKCBjYWxsYmFjayhhcnJbaV0sIGksIGFycikgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzb21lO1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIE1lcmdlIHNvcnQgKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVyZ2Vfc29ydClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZVNvcnQoYXJyLCBjb21wYXJlRm4pIHtcbiAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyZUZuID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBhcmVGbiA9IGRlZmF1bHRDb21wYXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pZCwgbGVmdCwgcmlnaHQ7XG5cbiAgICAgICAgbWlkICAgPSB+fihhcnIubGVuZ3RoIC8gMik7XG4gICAgICAgIGxlZnQgID0gbWVyZ2VTb3J0KCBhcnIuc2xpY2UoMCwgbWlkKSwgY29tcGFyZUZuICk7XG4gICAgICAgIHJpZ2h0ID0gbWVyZ2VTb3J0KCBhcnIuc2xpY2UobWlkLCBhcnIubGVuZ3RoKSwgY29tcGFyZUZuICk7XG5cbiAgICAgICAgcmV0dXJuIG1lcmdlKGxlZnQsIHJpZ2h0LCBjb21wYXJlRm4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAoYSA+IGI/IDEgOiAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZShsZWZ0LCByaWdodCwgY29tcGFyZUZuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICB3aGlsZSAobGVmdC5sZW5ndGggJiYgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoY29tcGFyZUZuKGxlZnRbMF0sIHJpZ2h0WzBdKSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgMCBpdCBzaG91bGQgcHJlc2VydmUgc2FtZSBvcmRlciAoc3RhYmxlKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxlZnQuc2hpZnQoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJpZ2h0LnNoaWZ0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlZnQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGxlZnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWVyZ2VTb3J0O1xuXG5cbiIsInZhciBzb3J0ID0gcmVxdWlyZSgnLi9zb3J0Jyk7XG52YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLypcbiAgICAgKiBTb3J0IGFycmF5IGJ5IHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydEJ5KGFyciwgY2FsbGJhY2ssIGNvbnRleHQpe1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgY29udGV4dCk7XG5cbiAgICAgICAgcmV0dXJuIHNvcnQoYXJyLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICBhID0gY2FsbGJhY2soYSk7XG4gICAgICAgICAgICBiID0gY2FsbGJhY2soYik7XG4gICAgICAgICAgICByZXR1cm4gKGEgPCBiKSA/IC0xIDogKChhID4gYikgPyAxIDogMCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gc29ydEJ5O1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgYXJyYXkgaW50byBhIGZpeGVkIG51bWJlciBvZiBzZWdtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdChhcnJheSwgc2VnbWVudHMpIHtcbiAgICAgICAgc2VnbWVudHMgPSBzZWdtZW50cyB8fCAyO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoYXJyYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluTGVuZ3RoID0gTWF0aC5mbG9vcihhcnJheS5sZW5ndGggLyBzZWdtZW50cyksXG4gICAgICAgICAgICByZW1haW5kZXIgPSBhcnJheS5sZW5ndGggJSBzZWdtZW50cyxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgc2VnbWVudEluZGV4ID0gMCxcbiAgICAgICAgICAgIHNlZ21lbnRMZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIHNlZ21lbnRMZW5ndGggPSBtaW5MZW5ndGg7XG4gICAgICAgICAgICBpZiAoc2VnbWVudEluZGV4IDwgcmVtYWluZGVyKSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudExlbmd0aCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goYXJyYXkuc2xpY2UoaSwgaSArIHNlZ21lbnRMZW5ndGgpKTtcblxuICAgICAgICAgICAgc2VnbWVudEluZGV4Kys7XG4gICAgICAgICAgICBpICs9IHNlZ21lbnRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzcGxpdDtcblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGEgY2FsbGJhY2sgYSBzZXQgYW1vdW50IG9mIHRpbWVzXG4gICAgICogcmV0dXJuaW5nIHRoZSByZXN1bHRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZShuLCBjYWxsYmFjaywgdGhpc09iail7XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgaWYoICF0aGlzT2JqICl7XG4gICAgICAgICAgICB3aGlsZSgrK2kgPCBuKXtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSBjYWxsYmFjayhpLCBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlKCsraSA8IG4pe1xuICAgICAgICAgICAgICAgIGFycltpXSA9IGNhbGxiYWNrLmNhbGwodGhpc09iaiwgaSwgbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRha2U7XG5cblxuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9sYW5nL2lzRnVuY3Rpb24nKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaG9sZHMgYSBsb29rdXAgZm9yIHRoZSBvYmplY3RzIGluIHRoZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvb2t1cChhcnIsIGtleSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChhcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFyci5sZW5ndGgsIHZhbHVlO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihrZXkpKSB7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhcnJbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleSh2YWx1ZSldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhcnJbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0W3ZhbHVlW2tleV1dID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvTG9va3VwO1xuXG4iLCJ2YXIgdW5pcXVlID0gcmVxdWlyZSgnLi91bmlxdWUnKTtcbnZhciBhcHBlbmQgPSByZXF1aXJlKCcuL2FwcGVuZCcpO1xuXG4gICAgLyoqXG4gICAgICogQ29uY2F0IG11bHRpcGxlIGFycmF5cyBhbmQgcmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlvbihhcnJzKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIHZhciBpID0gLTEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGFwcGVuZChyZXN1bHRzLCBhcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuaXF1ZShyZXN1bHRzKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHVuaW9uO1xuXG5cbiIsInZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIHVuaXF1ZSBpdGVtc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZShhcnIsIGNvbXBhcmUpe1xuICAgICAgICBjb21wYXJlID0gY29tcGFyZSB8fCBpc0VxdWFsO1xuICAgICAgICByZXR1cm4gZmlsdGVyKGFyciwgZnVuY3Rpb24oaXRlbSwgaSwgYXJyKXtcbiAgICAgICAgICAgIHZhciBuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBjb21wYXJlKGl0ZW0sIGFycltpXSkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFcXVhbChhLCBiKXtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1bmlxdWU7XG5cblxuIiwidmFyIHVuaXF1ZSA9IHJlcXVpcmUoJy4vdW5pcXVlJyk7XG52YXIgZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcbnZhciBjb250YWlucyA9IHJlcXVpcmUoJy4vY29udGFpbnMnKTtcblxuXG4gICAgLyoqXG4gICAgICogRXhjbHVzaXZlIE9SLiBSZXR1cm5zIGl0ZW1zIHRoYXQgYXJlIHByZXNlbnQgaW4gYSBzaW5nbGUgYXJyYXkuXG4gICAgICogLSBsaWtlIHB0eWhvbidzIGBzeW1tZXRyaWNfZGlmZmVyZW5jZWBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB4b3IoYXJyMSwgYXJyMikge1xuICAgICAgICBhcnIxID0gdW5pcXVlKGFycjEpO1xuICAgICAgICBhcnIyID0gdW5pcXVlKGFycjIpO1xuXG4gICAgICAgIHZhciBhMSA9IGZpbHRlcihhcnIxLCBmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWNvbnRhaW5zKGFycjIsIGl0ZW0pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhMiA9IGZpbHRlcihhcnIyLCBmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWNvbnRhaW5zKGFycjEsIGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGExLmNvbmNhdChhMik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB4b3I7XG5cblxuIiwidmFyIG1heCA9IHJlcXVpcmUoJy4vbWF4Jyk7XG52YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAnKTtcblxuICAgIGZ1bmN0aW9uIGdldExlbmd0aChhcnIpIHtcbiAgICAgICAgcmV0dXJuIGFyciA9PSBudWxsID8gMCA6IGFyci5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRvZ2V0aGVyIHRoZSB2YWx1ZXMgb2YgZWFjaCBvZiB0aGUgYXJyYXlzIHdpdGggdGhlIHZhbHVlcyBhdCB0aGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcChhcnIpe1xuICAgICAgICB2YXIgbGVuID0gYXJyID8gbWF4KG1hcChhcmd1bWVudHMsIGdldExlbmd0aCkpIDogMCxcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgLy8ganNoaW50IGxvb3BmdW5jOiB0cnVlXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobWFwKGFyZ3VtZW50cywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtID09IG51bGwgPyB1bmRlZmluZWQgOiBpdGVtW2ldO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB6aXA7XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdjb250YWlucycgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vY29udGFpbnMnKSxcbiAgICAnZXZlcnknIDogcmVxdWlyZSgnLi9jb2xsZWN0aW9uL2V2ZXJ5JyksXG4gICAgJ2ZpbHRlcicgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vZmlsdGVyJyksXG4gICAgJ2ZpbmQnIDogcmVxdWlyZSgnLi9jb2xsZWN0aW9uL2ZpbmQnKSxcbiAgICAnZm9yRWFjaCcgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vZm9yRWFjaCcpLFxuICAgICdtYWtlXycgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vbWFrZV8nKSxcbiAgICAnbWFwJyA6IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9tYXAnKSxcbiAgICAnbWF4JyA6IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9tYXgnKSxcbiAgICAnbWluJyA6IHJlcXVpcmUoJy4vY29sbGVjdGlvbi9taW4nKSxcbiAgICAncGx1Y2snIDogcmVxdWlyZSgnLi9jb2xsZWN0aW9uL3BsdWNrJyksXG4gICAgJ3JlZHVjZScgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vcmVkdWNlJyksXG4gICAgJ3JlamVjdCcgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vcmVqZWN0JyksXG4gICAgJ3NpemUnIDogcmVxdWlyZSgnLi9jb2xsZWN0aW9uL3NpemUnKSxcbiAgICAnc29tZScgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24vc29tZScpXG59O1xuXG5cbiIsInZhciBtYWtlID0gcmVxdWlyZSgnLi9tYWtlXycpO1xudmFyIGFyckNvbnRhaW5zID0gcmVxdWlyZSgnLi4vYXJyYXkvY29udGFpbnMnKTtcbnZhciBvYmpDb250YWlucyA9IHJlcXVpcmUoJy4uL29iamVjdC9jb250YWlucycpO1xuXG4gICAgLyoqXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlKGFyckNvbnRhaW5zLCBvYmpDb250YWlucyk7XG5cblxuIiwidmFyIG1ha2UgPSByZXF1aXJlKCcuL21ha2VfJyk7XG52YXIgYXJyRXZlcnkgPSByZXF1aXJlKCcuLi9hcnJheS9ldmVyeScpO1xudmFyIG9iakV2ZXJ5ID0gcmVxdWlyZSgnLi4vb2JqZWN0L2V2ZXJ5Jyk7XG5cbiAgICAvKipcbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2UoYXJyRXZlcnksIG9iakV2ZXJ5KTtcblxuXG4iLCJ2YXIgZm9yRWFjaCA9IHJlcXVpcmUoJy4vZm9yRWFjaCcpO1xudmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIGZpbHRlciBjb2xsZWN0aW9uIHZhbHVlcywgcmV0dXJucyBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIobGlzdCwgaXRlcmF0b3IsIHRoaXNPYmopIHtcbiAgICAgICAgaXRlcmF0b3IgPSBtYWtlSXRlcmF0b3IoaXRlcmF0b3IsIHRoaXNPYmopO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGZvckVhY2gobGlzdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IodmFsdWUsIGluZGV4LCBsaXN0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZpbHRlcjtcblxuXG4iLCJ2YXIgbWFrZSA9IHJlcXVpcmUoJy4vbWFrZV8nKTtcbnZhciBhcnJGaW5kID0gcmVxdWlyZSgnLi4vYXJyYXkvZmluZCcpO1xudmFyIG9iakZpbmQgPSByZXF1aXJlKCcuLi9vYmplY3QvZmluZCcpO1xuXG4gICAgLyoqXG4gICAgICogRmluZCB2YWx1ZSB0aGF0IHJldHVybnMgdHJ1ZSBvbiBpdGVyYXRvciBjaGVjay5cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2UoYXJyRmluZCwgb2JqRmluZCk7XG5cblxuIiwidmFyIG1ha2UgPSByZXF1aXJlKCcuL21ha2VfJyk7XG52YXIgYXJyRm9yRWFjaCA9IHJlcXVpcmUoJy4uL2FycmF5L2ZvckVhY2gnKTtcbnZhciBvYmpGb3JFYWNoID0gcmVxdWlyZSgnLi4vb2JqZWN0L2Zvck93bicpO1xuXG4gICAgLyoqXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlKGFyckZvckVhY2gsIG9iakZvckVhY2gpO1xuXG5cbiIsInZhciBzbGljZSA9IHJlcXVpcmUoJy4uL2FycmF5L3NsaWNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBpbnRlcm5hbCBtZXRob2QgdXNlZCB0byBjcmVhdGUgb3RoZXIgY29sbGVjdGlvbiBtb2R1bGVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VDb2xsZWN0aW9uTWV0aG9kKGFyck1ldGhvZCwgb2JqTWV0aG9kLCBkZWZhdWx0UmV0dXJuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKGFyZ3NbMF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0UmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXJyYXktbGlrZSBpcyB0cmVhdGVkIGFzIGFycmF5XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBhcmdzWzBdLmxlbmd0aCA9PT0gJ251bWJlcicpPyBhcnJNZXRob2QuYXBwbHkobnVsbCwgYXJncykgOiBvYmpNZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlQ29sbGVjdGlvbk1ldGhvZDtcblxuXG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzT2JqZWN0Jyk7XG52YXIgdmFsdWVzID0gcmVxdWlyZSgnLi4vb2JqZWN0L3ZhbHVlcycpO1xudmFyIGFyck1hcCA9IHJlcXVpcmUoJy4uL2FycmF5L21hcCcpO1xudmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIE1hcCBjb2xsZWN0aW9uIHZhbHVlcywgcmV0dXJucyBBcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAobGlzdCwgY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgICAgICAgY2FsbGJhY2sgPSBtYWtlSXRlcmF0b3IoY2FsbGJhY2ssIHRoaXNPYmopO1xuICAgICAgICAvLyBsaXN0Lmxlbmd0aCB0byBjaGVjayBhcnJheS1saWtlIG9iamVjdCwgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgLy8gd2Ugc2ltcGx5IG1hcCBhbGwgdGhlIG9iamVjdCB2YWx1ZXNcbiAgICAgICAgaWYoIGlzT2JqZWN0KGxpc3QpICYmIGxpc3QubGVuZ3RoID09IG51bGwgKXtcbiAgICAgICAgICAgIGxpc3QgPSB2YWx1ZXMobGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyck1hcChsaXN0LCBmdW5jdGlvbiAodmFsLCBrZXksIGxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh2YWwsIGtleSwgbGlzdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWFwO1xuXG5cbiIsInZhciBtYWtlID0gcmVxdWlyZSgnLi9tYWtlXycpO1xudmFyIGFyck1heCA9IHJlcXVpcmUoJy4uL2FycmF5L21heCcpO1xudmFyIG9iak1heCA9IHJlcXVpcmUoJy4uL29iamVjdC9tYXgnKTtcblxuICAgIC8qKlxuICAgICAqIEdldCBtYXhpbXVtIHZhbHVlIGluc2lkZSBjb2xsZWN0aW9uXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlKGFyck1heCwgb2JqTWF4KTtcblxuXG4iLCJ2YXIgbWFrZSA9IHJlcXVpcmUoJy4vbWFrZV8nKTtcbnZhciBhcnJNaW4gPSByZXF1aXJlKCcuLi9hcnJheS9taW4nKTtcbnZhciBvYmpNaW4gPSByZXF1aXJlKCcuLi9vYmplY3QvbWluJyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbWluaW11bSB2YWx1ZSBpbnNpZGUgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2UoYXJyTWluLCBvYmpNaW4pO1xuXG5cbiIsInZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBhIGxpc3Qgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBsdWNrKGxpc3QsIGtleSkge1xuICAgICAgICByZXR1cm4gbWFwKGxpc3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwbHVjaztcblxuXG4iLCJ2YXIgbWFrZSA9IHJlcXVpcmUoJy4vbWFrZV8nKTtcbnZhciBhcnJSZWR1Y2UgPSByZXF1aXJlKCcuLi9hcnJheS9yZWR1Y2UnKTtcbnZhciBvYmpSZWR1Y2UgPSByZXF1aXJlKCcuLi9vYmplY3QvcmVkdWNlJyk7XG5cbiAgICAvKipcbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2UoYXJyUmVkdWNlLCBvYmpSZWR1Y2UpO1xuXG5cbiIsInZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xudmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIEludmVyc2Ugb3IgY29sbGVjdGlvbi9maWx0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QobGlzdCwgaXRlcmF0b3IsIHRoaXNPYmopIHtcbiAgICAgICAgaXRlcmF0b3IgPSBtYWtlSXRlcmF0b3IoaXRlcmF0b3IsIHRoaXNPYmopO1xuICAgICAgICByZXR1cm4gZmlsdGVyKGxpc3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuICFpdGVyYXRvcih2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICB9LCB0aGlzT2JqKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlamVjdDtcblxuXG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpO1xudmFyIG9ialNpemUgPSByZXF1aXJlKCcuLi9vYmplY3Qvc2l6ZScpO1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbGxlY3Rpb24gc2l6ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUobGlzdCkge1xuICAgICAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KGxpc3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9ialNpemUobGlzdCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzaXplO1xuXG5cbiIsInZhciBtYWtlID0gcmVxdWlyZSgnLi9tYWtlXycpO1xudmFyIGFyclNvbWUgPSByZXF1aXJlKCcuLi9hcnJheS9zb21lJyk7XG52YXIgb2JqU29tZSA9IHJlcXVpcmUoJy4uL29iamVjdC9zb21lJyk7XG5cbiAgICAvKipcbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2UoYXJyU29tZSwgb2JqU29tZSk7XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdkYXlPZlRoZVllYXInIDogcmVxdWlyZSgnLi9kYXRlL2RheU9mVGhlWWVhcicpLFxuICAgICdkaWZmJyA6IHJlcXVpcmUoJy4vZGF0ZS9kaWZmJyksXG4gICAgJ2kxOG5fJyA6IHJlcXVpcmUoJy4vZGF0ZS9pMThuXycpLFxuICAgICdpc0xlYXBZZWFyJyA6IHJlcXVpcmUoJy4vZGF0ZS9pc0xlYXBZZWFyJyksXG4gICAgJ2lzU2FtZScgOiByZXF1aXJlKCcuL2RhdGUvaXNTYW1lJyksXG4gICAgJ3BhcnNlSXNvJyA6IHJlcXVpcmUoJy4vZGF0ZS9wYXJzZUlzbycpLFxuICAgICdxdWFydGVyJyA6IHJlcXVpcmUoJy4vZGF0ZS9xdWFydGVyJyksXG4gICAgJ3N0YXJ0T2YnIDogcmVxdWlyZSgnLi9kYXRlL3N0YXJ0T2YnKSxcbiAgICAnc3RyZnRpbWUnIDogcmVxdWlyZSgnLi9kYXRlL3N0cmZ0aW1lJyksXG4gICAgJ3RpbWV6b25lQWJicicgOiByZXF1aXJlKCcuL2RhdGUvdGltZXpvbmVBYmJyJyksXG4gICAgJ3RpbWV6b25lT2Zmc2V0JyA6IHJlcXVpcmUoJy4vZGF0ZS90aW1lem9uZU9mZnNldCcpLFxuICAgICd0b3RhbERheXNJbk1vbnRoJyA6IHJlcXVpcmUoJy4vZGF0ZS90b3RhbERheXNJbk1vbnRoJyksXG4gICAgJ3RvdGFsRGF5c0luWWVhcicgOiByZXF1aXJlKCcuL2RhdGUvdG90YWxEYXlzSW5ZZWFyJyksXG4gICAgJ3dlZWtPZlRoZVllYXInIDogcmVxdWlyZSgnLi9kYXRlL3dlZWtPZlRoZVllYXInKVxufTtcblxuXG4iLCJ2YXIgaXNEYXRlID0gcmVxdWlyZSgnLi4vbGFuZy9pc0RhdGUnKTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgZGF5IG9mIHRoZSB5ZWFyICgxLi4zNjYpXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGF5T2ZUaGVZZWFyKGRhdGUpe1xuICAgICAgICByZXR1cm4gKERhdGUuVVRDKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSkgLVxuICAgICAgICAgICAgICAgIERhdGUuVVRDKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSkpIC8gODY0MDAwMDAgKyAxO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZGF5T2ZUaGVZZWFyO1xuXG5cbiIsInZhciB0b3RhbERheXNJbk1vbnRoID0gcmVxdWlyZSgnLi90b3RhbERheXNJbk1vbnRoJyk7XG52YXIgdG90YWxEYXlzSW5ZZWFyID0gcmVxdWlyZSgnLi90b3RhbERheXNJblllYXInKTtcbnZhciBjb252ZXJ0ID0gcmVxdWlyZSgnLi4vdGltZS9jb252ZXJ0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBkYXRlcyAocmFuZ2UpXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlmZihzdGFydCwgZW5kLCB1bml0TmFtZSl7XG4gICAgICAgIC8vIHNvcnQgdGhlIGRhdGVzIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHByb2Nlc3MgKHNwZWNpYWxseSB5ZWFyL21vbnRoKVxuICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgIHZhciBzd2FwID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgIGVuZCA9IHN3YXA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0O1xuXG4gICAgICAgIGlmICh1bml0TmFtZSA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgb3V0cHV0ID0gZ2V0TW9udGhzRGlmZihzdGFydCwgZW5kKTtcbiAgICAgICAgfSBlbHNlIGlmICh1bml0TmFtZSA9PT0gJ3llYXInKXtcbiAgICAgICAgICAgIG91dHB1dCA9IGdldFllYXJzRGlmZihzdGFydCwgZW5kKTtcbiAgICAgICAgfSBlbHNlIGlmICh1bml0TmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodW5pdE5hbWUgPT09ICdkYXknKSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHRpbWV6b25lIGRpZmZlcmVuY2UgYmVjYXVzZSBvZiBkYXlsaWdodCBzYXZpbmdzIHRpbWVcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRvVXRjKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBlbmQgPSB0b1V0YyhlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0ID0gY29udmVydChlbmQgLSBzdGFydCwgJ21zJywgdW5pdE5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gdG9VdGMoZCl7XG4gICAgICAgIC8vIHdlIGlnbm9yZSB0aW1lem9uZSBkaWZmZXJlbmNlcyBvbiBwdXJwb3NlIGJlY2F1c2Ugb2YgZGF5bGlnaHRcbiAgICAgICAgLy8gc2F2aW5ncyB0aW1lLCBvdGhlcndpc2UgaXQgd291bGQgcmV0dXJuIGZyYWN0aW9uYWwgZGF5cy93ZWVrcyBldmVuXG4gICAgICAgIC8vIGlmIGEgZnVsbCBkYXkgZWxhcHNlZC4gZWc6XG4gICAgICAgIC8vIFdlZCBGZWIgMTIgMjAxNCAwMDowMDowMCBHTVQtMDIwMCAoQlJTVClcbiAgICAgICAgLy8gU3VuIEZlYiAxNiAyMDE0IDAwOjAwOjAwIEdNVC0wMzAwIChCUlQpXG4gICAgICAgIC8vIGRpZmYgc2hvdWxkIGJlIDQgZGF5cyBhbmQgbm90IDQuMDQxNjY2NjY2NjY2NjY3XG4gICAgICAgIHJldHVybiBEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIGQuZ2V0VVRDTW9udGgoKSwgZC5nZXRVVENEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkLmdldEhvdXJzKCksIGQuZ2V0TWludXRlcygpLCBkLmdldFNlY29uZHMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuZ2V0TWlsbGlzZWNvbmRzKCkpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZ2V0TW9udGhzRGlmZihzdGFydCwgZW5kKXtcbiAgICAgICAgcmV0dXJuIGdldEVsYXBzZWRNb250aHMoc3RhcnQsIGVuZCkgK1xuICAgICAgICAgICAgICAgZ2V0RWxhcHNlZFllYXJzKHN0YXJ0LCBlbmQpICogMTIgK1xuICAgICAgICAgICAgICAgZ2V0RnJhY3Rpb25hbE1vbnRoKHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZ2V0WWVhcnNEaWZmKHN0YXJ0LCBlbmQpe1xuICAgICAgICB2YXIgZWxhcHNlZFllYXJzID0gZ2V0RWxhcHNlZFllYXJzKHN0YXJ0LCBlbmQpO1xuICAgICAgICByZXR1cm4gZWxhcHNlZFllYXJzICsgZ2V0RnJhY3Rpb25hbFllYXIoc3RhcnQsIGVuZCwgZWxhcHNlZFllYXJzKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldEVsYXBzZWRNb250aHMoc3RhcnQsIGVuZCl7XG4gICAgICAgIHZhciBtb250aERpZmYgPSBlbmQuZ2V0TW9udGgoKSAtIHN0YXJ0LmdldE1vbnRoKCk7XG4gICAgICAgIGlmIChtb250aERpZmYgPCAwKSB7XG4gICAgICAgICAgICBtb250aERpZmYgKz0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGVzcyB0aGFuIGEgZnVsbCBtb250aFxuICAgICAgICBpZiAoc3RhcnQuZ2V0RGF0ZSgpID4gZW5kLmdldERhdGUoKSkge1xuICAgICAgICAgICAgbW9udGhEaWZmIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vbnRoRGlmZjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldEVsYXBzZWRZZWFycyhzdGFydCwgZW5kKXtcbiAgICAgICAgdmFyIHllYXJEaWZmID0gZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpO1xuICAgICAgICAvLyBsZXNzIHRoYW4gYSBmdWxsIHllYXJcbiAgICAgICAgaWYgKHN0YXJ0LmdldE1vbnRoKCkgPiBlbmQuZ2V0TW9udGgoKSkge1xuICAgICAgICAgICAgeWVhckRpZmYgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhckRpZmY7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBnZXRGcmFjdGlvbmFsTW9udGgoc3RhcnQsIGVuZCl7XG4gICAgICAgIHZhciBmcmFjdGlvbmFsRGlmZiA9IDA7XG4gICAgICAgIHZhciBzdGFydERheSA9IHN0YXJ0LmdldERhdGUoKTtcbiAgICAgICAgdmFyIGVuZERheSA9IGVuZC5nZXREYXRlKCk7XG5cbiAgICAgICAgaWYgKHN0YXJ0RGF5ICE9PSBlbmREYXkpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFRvdGFsRGF5cyA9IHRvdGFsRGF5c0luTW9udGgoc3RhcnQpO1xuICAgICAgICAgICAgdmFyIGVuZFRvdGFsRGF5cyA9IHRvdGFsRGF5c0luTW9udGgoZW5kKTtcbiAgICAgICAgICAgIHZhciB0b3RhbERheXM7XG4gICAgICAgICAgICB2YXIgZGF5c0VsYXBzZWQ7XG5cbiAgICAgICAgICAgIGlmIChzdGFydERheSA+IGVuZERheSkge1xuICAgICAgICAgICAgICAgIC8vIGVnOiBKYW4gMjkgLSBGZWIgMjcgKDI5IGRheXMgZWxhcHNlZCBidXQgbm90IGEgZnVsbCBtb250aClcbiAgICAgICAgICAgICAgICB2YXIgYmFzZURheSA9IHN0YXJ0VG90YWxEYXlzIC0gc3RhcnREYXk7XG4gICAgICAgICAgICAgICAgZGF5c0VsYXBzZWQgPSBlbmREYXkgKyBiYXNlRGF5O1xuICAgICAgICAgICAgICAgIC8vIHRvdGFsIGRheXMgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIDFzdCBkYXkgb2YgbmV4dCBtb250aCBpZlxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0RGF5ID4gZW5kVG90YWxEYXlzXG4gICAgICAgICAgICAgICAgdG90YWxEYXlzID0gKHN0YXJ0RGF5ID4gZW5kVG90YWxEYXlzKT9cbiAgICAgICAgICAgICAgICAgICAgZW5kVG90YWxEYXlzICsgYmFzZURheSArIDEgOiBzdGFydERheSArIGJhc2VEYXk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZyYWN0aW9uYWwgaXMgb25seSBiYXNlZCBvbiBlbmRNb250aCBlZzogSmFuIDEyIC0gRmViIDE4XG4gICAgICAgICAgICAgICAgLy8gKDYgZnJhY3Rpb25hbCBkYXlzLCAyOCBkYXlzIHVudGlsIG5leHQgZnVsbCBtb250aClcbiAgICAgICAgICAgICAgICBkYXlzRWxhcHNlZCA9IGVuZERheSAtIHN0YXJ0RGF5O1xuICAgICAgICAgICAgICAgIHRvdGFsRGF5cyA9IGVuZFRvdGFsRGF5cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJhY3Rpb25hbERpZmYgPSBkYXlzRWxhcHNlZCAvIHRvdGFsRGF5cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmcmFjdGlvbmFsRGlmZjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldEZyYWN0aW9uYWxZZWFyKHN0YXJ0LCBlbmQsIGVsYXBzZWRZZWFycyl7XG4gICAgICAgIHZhciBiYXNlID0gZWxhcHNlZFllYXJzP1xuICAgICAgICAgICAgbmV3IERhdGUoZW5kLmdldEZ1bGxZZWFyKCksIHN0YXJ0LmdldE1vbnRoKCksIHN0YXJ0LmdldERhdGUoKSkgOlxuICAgICAgICAgICAgc3RhcnQ7XG4gICAgICAgIHZhciBlbGFwc2VkRGF5cyA9IGRpZmYoYmFzZSwgZW5kLCAnZGF5Jyk7XG4gICAgICAgIHJldHVybiBlbGFwc2VkRGF5cyAvIHRvdGFsRGF5c0luWWVhcihlbmQpO1xuICAgIH1cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkaWZmO1xuXG5cbiIsIlxuICAgIC8vIGVuLVVTIChFbmdsaXNoLCBVbml0ZWQgU3RhdGVzKVxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBcImFtXCIgOiBcIkFNXCIsXG4gICAgICAgIFwicG1cIiA6IFwiUE1cIixcblxuICAgICAgICBcInhcIjogXCIlbS8lZC8leVwiLFxuICAgICAgICBcIlhcIjogXCIlSDolTTolU1wiLFxuICAgICAgICBcImNcIjogXCIlYSAlZCAlYiAlWSAlSTolTTolUyAlcCAlWlwiLFxuXG4gICAgICAgIFwibW9udGhzXCIgOiBbXG4gICAgICAgICAgICBcIkphbnVhcnlcIixcbiAgICAgICAgICAgIFwiRmVicnVhcnlcIixcbiAgICAgICAgICAgIFwiTWFyY2hcIixcbiAgICAgICAgICAgIFwiQXByaWxcIixcbiAgICAgICAgICAgIFwiTWF5XCIsXG4gICAgICAgICAgICBcIkp1bmVcIixcbiAgICAgICAgICAgIFwiSnVseVwiLFxuICAgICAgICAgICAgXCJBdWd1c3RcIixcbiAgICAgICAgICAgIFwiU2VwdGVtYmVyXCIsXG4gICAgICAgICAgICBcIk9jdG9iZXJcIixcbiAgICAgICAgICAgIFwiTm92ZW1iZXJcIixcbiAgICAgICAgICAgIFwiRGVjZW1iZXJcIlxuICAgICAgICBdLFxuXG4gICAgICAgIFwibW9udGhzX2FiYnJcIiA6IFtcbiAgICAgICAgICAgIFwiSmFuXCIsXG4gICAgICAgICAgICBcIkZlYlwiLFxuICAgICAgICAgICAgXCJNYXJcIixcbiAgICAgICAgICAgIFwiQXByXCIsXG4gICAgICAgICAgICBcIk1heVwiLFxuICAgICAgICAgICAgXCJKdW5cIixcbiAgICAgICAgICAgIFwiSnVsXCIsXG4gICAgICAgICAgICBcIkF1Z1wiLFxuICAgICAgICAgICAgXCJTZXBcIixcbiAgICAgICAgICAgIFwiT2N0XCIsXG4gICAgICAgICAgICBcIk5vdlwiLFxuICAgICAgICAgICAgXCJEZWNcIlxuICAgICAgICBdLFxuXG4gICAgICAgIFwiZGF5c1wiIDogW1xuICAgICAgICAgICAgXCJTdW5kYXlcIixcbiAgICAgICAgICAgIFwiTW9uZGF5XCIsXG4gICAgICAgICAgICBcIlR1ZXNkYXlcIixcbiAgICAgICAgICAgIFwiV2VkbmVzZGF5XCIsXG4gICAgICAgICAgICBcIlRodXJzZGF5XCIsXG4gICAgICAgICAgICBcIkZyaWRheVwiLFxuICAgICAgICAgICAgXCJTYXR1cmRheVwiXG4gICAgICAgIF0sXG5cbiAgICAgICAgXCJkYXlzX2FiYnJcIiA6IFtcbiAgICAgICAgICAgIFwiU3VuXCIsXG4gICAgICAgICAgICBcIk1vblwiLFxuICAgICAgICAgICAgXCJUdWVcIixcbiAgICAgICAgICAgIFwiV2VkXCIsXG4gICAgICAgICAgICBcIlRodVwiLFxuICAgICAgICAgICAgXCJGcmlcIixcbiAgICAgICAgICAgIFwiU2F0XCJcbiAgICAgICAgXVxuICAgIH07XG5cbiIsInZhciBtaXhJbiA9IHJlcXVpcmUoJy4uL29iamVjdC9taXhJbicpO1xudmFyIGVuVVMgPSByZXF1aXJlKCcuL2kxOG4vZW4tVVMnKTtcblxuICAgIC8vIHdlIGFsc28gdXNlIG1peEluIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBhZmZlY3QgdGhlIG9yaWdpbmFsIGxvY2FsZVxuICAgIHZhciBhY3RpdmVMb2NhbGUgPSBtaXhJbih7fSwgZW5VUywge1xuICAgICAgICAvLyB3ZSBleHBvc2UgYSBcInNldFwiIG1ldGhvZCB0byBhbGxvdyBvdmVycmlkaW5nIHRoZSBnbG9iYWwgbG9jYWxlXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKGxvY2FsZURhdGEpe1xuICAgICAgICAgICAgbWl4SW4oYWN0aXZlTG9jYWxlLCBsb2NhbGVEYXRhKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBhY3RpdmVMb2NhbGU7XG5cblxuIiwidmFyIGlzRGF0ZSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNEYXRlJyk7XG5cbiAgICAvKipcbiAgICAgKiBjaGVja3MgaWYgaXQncyBhIGxlYXAgeWVhclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoZnVsbFllYXIpe1xuICAgICAgICBpZiAoaXNEYXRlKGZ1bGxZZWFyKSkge1xuICAgICAgICAgICAgZnVsbFllYXIgPSBmdWxsWWVhci5nZXRGdWxsWWVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdWxsWWVhciAlIDQwMCA9PT0gMCB8fCAoZnVsbFllYXIgJSAxMDAgIT09IDAgJiYgZnVsbFllYXIgJSA0ID09PSAwKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzTGVhcFllYXI7XG5cblxuIiwidmFyIHN0YXJ0T2YgPSByZXF1aXJlKCcuL3N0YXJ0T2YnKTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGRhdGUgaXMgXCJzYW1lXCIgd2l0aCBvcHRpb25hbCBwZXJpb2RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1NhbWUoZGF0ZTEsIGRhdGUyLCBwZXJpb2Qpe1xuICAgICAgICBpZiAocGVyaW9kKSB7XG4gICAgICAgICAgICBkYXRlMSA9IHN0YXJ0T2YoZGF0ZTEsIHBlcmlvZCk7XG4gICAgICAgICAgICBkYXRlMiA9IHN0YXJ0T2YoZGF0ZTIsIHBlcmlvZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlcihkYXRlMSkgPT09IE51bWJlcihkYXRlMik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc1NhbWU7XG5cblxuIiwidmFyIHNvbWUgPSByZXF1aXJlKCcuLi9hcnJheS9zb21lJyk7XG5cbiAgICB2YXIgZGF0ZVBhdHRlcm5zID0gW1xuICAgICAgICAvXihbMC05XXs0fSkkLywgICAgICAgICAgICAgICAgICAgICAgICAvLyBZWVlZXG4gICAgICAgIC9eKFswLTldezR9KS0oWzAtOV17Mn0pJC8sICAgICAgICAgICAgIC8vIFlZWVktTU0gKFlZWVlNTSBub3QgYWxsb3dlZClcbiAgICAgICAgL14oWzAtOV17NH0pLT8oWzAtOV17Mn0pLT8oWzAtOV17Mn0pJC8gLy8gWVlZWS1NTS1ERCBvciBZWVlZTU1ERFxuICAgIF07XG4gICAgdmFyIE9SRF9EQVRFID0gL14oWzAtOV17NH0pLT8oWzAtOV17M30pJC87IC8vIFlZWVktREREXG5cbiAgICB2YXIgdGltZVBhdHRlcm5zID0gW1xuICAgICAgICAvXihbMC05XXsyfSg/OlxcLlswLTldKik/KSQvLCAgICAgICAgICAgICAgICAgICAgICAvLyBISC5oaFxuICAgICAgICAvXihbMC05XXsyfSk6PyhbMC05XXsyfSg/OlxcLlswLTldKik/KSQvLCAgICAgICAgICAvLyBISDpNTS5tbVxuICAgICAgICAvXihbMC05XXsyfSk6PyhbMC05XXsyfSk6PyhbMC05XXsyfShcXC5bMC05XSopPykkLyAvLyBISDpNTTpTUy5zc1xuICAgIF07XG5cbiAgICB2YXIgREFURV9USU1FID0gL14oLispVCguKykkLztcbiAgICB2YXIgVElNRV9aT05FID0gL14oLispKFsrXFwtXSkoWzAtOV17Mn0pOj8oWzAtOV17Mn0pJC87XG5cbiAgICBmdW5jdGlvbiBtYXRjaEFsbChzdHIsIHBhdHRlcm5zKSB7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgdmFyIGZvdW5kID0gc29tZShwYXR0ZXJucywgZnVuY3Rpb24ocGF0dGVybikge1xuICAgICAgICAgICAgcmV0dXJuICEhKG1hdGNoID0gcGF0dGVybi5leGVjKHN0cikpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZm91bmQgPyBtYXRjaCA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZSh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuXG4gICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHllYXIgdG8gYXZvaWQgRGF0ZS5VVEMgbWFraW5nIGRhdGVzIDwgMTAwIHJlbGF0aXZlIHRvXG4gICAgICAgIC8vIDE5MDBcbiAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyKTtcblxuICAgICAgICB2YXIgdmFsaWQgPVxuICAgICAgICAgICAgZGF0ZS5nZXRVVENGdWxsWWVhcigpID09PSB5ZWFyICYmXG4gICAgICAgICAgICBkYXRlLmdldFVUQ01vbnRoKCkgPT09IG1vbnRoICYmXG4gICAgICAgICAgICBkYXRlLmdldFVUQ0RhdGUoKSA9PT0gZGF5O1xuICAgICAgICByZXR1cm4gdmFsaWQgPyArZGF0ZSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9yZGluYWxEYXRlKHN0cikge1xuICAgICAgICB2YXIgbWF0Y2ggPSBPUkRfREFURS5leGVjKHN0cik7XG4gICAgICAgIGlmIChtYXRjaCApIHtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gK21hdGNoWzFdLFxuICAgICAgICAgICAgICAgIGRheSA9ICttYXRjaFsyXSxcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgMCwgZGF5KSk7XG5cbiAgICAgICAgICAgIGlmIChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPT09IHllYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gK2RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRGF0ZShzdHIpIHtcbiAgICAgICAgdmFyIG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5O1xuXG4gICAgICAgIG1hdGNoID0gbWF0Y2hBbGwoc3RyLCBkYXRlUGF0dGVybnMpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE9yZGluYWwgZGF0ZXMgYXJlIHZlcmlmaWVkIGRpZmZlcmVudGx5LlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlT3JkaW5hbERhdGUoc3RyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHllYXIgPSAobWF0Y2hbMV0gPT09IHZvaWQgMCkgPyAwIDogK21hdGNoWzFdO1xuICAgICAgICBtb250aCA9IChtYXRjaFsyXSA9PT0gdm9pZCAwKSA/IDAgOiArbWF0Y2hbMl0gLSAxO1xuICAgICAgICBkYXkgPSAobWF0Y2hbM10gPT09IHZvaWQgMCkgPyAxIDogK21hdGNoWzNdO1xuXG4gICAgICAgIHJldHVybiBnZXREYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRpbWUoaHIsIG1pbiwgc2VjKSB7XG4gICAgICAgIHZhciB2YWxpZCA9XG4gICAgICAgICAgICAoaHIgPCAyNCAmJiBociA+PSAwICYmXG4gICAgICAgICAgICAgbWluIDwgNjAgJiYgbWluID49IDAgJiZcbiAgICAgICAgICAgICBzZWMgPCA2MCAmJiBtaW4gPj0gMCkgfHxcbiAgICAgICAgICAgIChociA9PT0gMjQgJiYgbWluID09PSAwICYmIHNlYyA9PT0gMCk7XG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKChociAqIDYwICsgbWluKSAqIDYwICsgc2VjKSAqIDEwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPZmZzZXQoc3RyKSB7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnWicpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2ggPSBUSU1FX1pPTkUuZXhlYyhzdHIpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhvdXJzID0gK21hdGNoWzNdLFxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gKG1hdGNoWzRdID09PSB2b2lkIDApID8gMCA6ICttYXRjaFs0XSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gZ2V0VGltZShob3VycywgbWludXRlcywgMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMl0gPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKj0gLTE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb2Zmc2V0OiBvZmZzZXQsIHRpbWU6IG1hdGNoWzFdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyB0aW1lIHpvbmUgc3BlY2lmaWVkLCBhc3N1bWUgVVRDXG4gICAgICAgIHJldHVybiB7IG9mZnNldDogMCwgdGltZTogc3RyIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VUaW1lKHN0cikge1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZU9mZnNldChzdHIpO1xuXG4gICAgICAgIHN0ciA9IG9mZnNldC50aW1lO1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQub2Zmc2V0O1xuICAgICAgICBpZiAoaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGNoID0gbWF0Y2hBbGwoc3RyLCB0aW1lUGF0dGVybnMpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaG91cnMgPSAobWF0Y2hbMV0gPT09IHZvaWQgMCkgPyAwIDogK21hdGNoWzFdLFxuICAgICAgICAgICAgbWludXRlcyA9IChtYXRjaFsyXSA9PT0gdm9pZCAwKSA/IDAgOiArbWF0Y2hbMl0sXG4gICAgICAgICAgICBzZWNvbmRzID0gKG1hdGNoWzNdID09PSB2b2lkIDApID8gMCA6ICttYXRjaFszXTtcblxuICAgICAgICByZXR1cm4gZ2V0VGltZShob3VycywgbWludXRlcywgc2Vjb25kcykgLSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgYW4gSVNPODYwMSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcsIGFuZCByZXR1cm4gYSBEYXRlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUlTTzg2MDEoc3RyKXtcbiAgICAgICAgdmFyIG1hdGNoID0gREFURV9USU1FLmV4ZWMoc3RyKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgLy8gTm8gdGltZSBzcGVjaWZpZWRcbiAgICAgICAgICAgIHJldHVybiBwYXJzZURhdGUoc3RyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZURhdGUobWF0Y2hbMV0pICsgcGFyc2VUaW1lKG1hdGNoWzJdKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcnNlSVNPODYwMTtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIGdldHMgZGF0ZSBxdWFydGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhcnRlcihkYXRlKXtcbiAgICAgICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICAgICAgICBpZiAobW9udGggPCAzKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKG1vbnRoIDwgNikgcmV0dXJuIDI7XG4gICAgICAgIGlmIChtb250aCA8IDkpIHJldHVybiAzO1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHF1YXJ0ZXI7XG5cblxuIiwidmFyIGNsb25lID0gcmVxdWlyZSgnLi4vbGFuZy9jbG9uZScpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0IGEgbmV3IERhdGUgb2JqZWN0IHJlcHJlc2VudGluZyBzdGFydCBvZiBwZXJpb2RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydE9mKGRhdGUsIHBlcmlvZCl7XG4gICAgICAgIGRhdGUgPSBjbG9uZShkYXRlKTtcblxuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IHJlbW92ZWQgXCJicmVha1wiIGZyb20gc3dpdGNoIHNpbmNlIHN0YXJ0IG9mXG4gICAgICAgIC8vIG1vbnRoL3llYXIvZXRjIHNob3VsZCBhbHNvIHJlc2V0IHRoZSBmb2xsb3dpbmcgcGVyaW9kc1xuICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRNb250aCgwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoMSk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRIb3VycygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIGRhdGUuc2V0TWludXRlcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRTZWNvbmRzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICBkYXRlLnNldE1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicrIHBlcmlvZCArJ1wiIGlzIG5vdCBhIHZhbGlkIHBlcmlvZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2VlayBpcyB0aGUgb25seSBjYXNlIHRoYXQgc2hvdWxkIHJlc2V0IHRoZSB3ZWVrRGF5IGFuZCBtYXliZSBldmVuXG4gICAgICAgIC8vIG92ZXJmbG93IHRvIHByZXZpb3VzIG1vbnRoXG4gICAgICAgIGlmIChwZXJpb2QgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgdmFyIHdlZWtEYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgdmFyIGJhc2VEYXRlID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICAgICAgICBpZiAod2Vla0RheSkge1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrRGF5ID49IGJhc2VEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vc3RhcnQgb2YgdGhlIHdlZWsgaXMgb24gcHJldmlvdXMgbW9udGhcbiAgICAgICAgICAgICAgICAgICAgZGF0ZS5zZXREYXRlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBkYXRlLmdldERheSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gc3RhcnRPZjtcblxuXG4iLCJ2YXIgcGFkID0gcmVxdWlyZSgnLi4vbnVtYmVyL3BhZCcpO1xudmFyIGxwYWQgPSByZXF1aXJlKCcuLi9zdHJpbmcvbHBhZCcpO1xudmFyIGkxOG4gPSByZXF1aXJlKCcuL2kxOG5fJyk7XG52YXIgZGF5T2ZUaGVZZWFyID0gcmVxdWlyZSgnLi9kYXlPZlRoZVllYXInKTtcbnZhciB0aW1lem9uZU9mZnNldCA9IHJlcXVpcmUoJy4vdGltZXpvbmVPZmZzZXQnKTtcbnZhciB0aW1lem9uZUFiYnIgPSByZXF1aXJlKCcuL3RpbWV6b25lQWJicicpO1xudmFyIHdlZWtPZlRoZVllYXIgPSByZXF1aXJlKCcuL3dlZWtPZlRoZVllYXInKTtcblxuICAgIHZhciBfY29tYmluYXRpb25zID0ge1xuICAgICAgICAnRCc6ICclbS8lZC8leScsXG4gICAgICAgICdGJzogJyVZLSVtLSVkJyxcbiAgICAgICAgJ3InOiAnJUk6JU06JVMgJXAnLFxuICAgICAgICAnUic6ICclSDolTScsXG4gICAgICAgICdUJzogJyVIOiVNOiVTJyxcbiAgICAgICAgJ3gnOiAnbG9jYWxlJyxcbiAgICAgICAgJ1gnOiAnbG9jYWxlJyxcbiAgICAgICAgJ2MnOiAnbG9jYWxlJ1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIGZvcm1hdCBkYXRlIGJhc2VkIG9uIHN0cmZ0aW1lIGZvcm1hdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmZ0aW1lKGRhdGUsIGZvcm1hdCwgbG9jYWxlRGF0YSl7XG4gICAgICAgIGxvY2FsZURhdGEgPSBsb2NhbGVEYXRhICB8fCBpMThuO1xuICAgICAgICB2YXIgcmVUb2tlbiA9IC8lKFthLXolXSkvZ2k7XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZUl0ZXJhdG9yKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obWF0Y2gsIHRva2VuKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oZGF0ZSwgdG9rZW4sIGxvY2FsZURhdGEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXRcbiAgICAgICAgICAgIC5yZXBsYWNlKHJlVG9rZW4sIG1ha2VJdGVyYXRvcihleHBhbmRDb21iaW5hdGlvbnMpKVxuICAgICAgICAgICAgLnJlcGxhY2UocmVUb2tlbiwgbWFrZUl0ZXJhdG9yKGNvbnZlcnRUb2tlbikpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZXhwYW5kQ29tYmluYXRpb25zKGRhdGUsIHRva2VuLCBsMTBuKXtcbiAgICAgICAgaWYgKHRva2VuIGluIF9jb21iaW5hdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBleHBhbmRlZCA9IF9jb21iaW5hdGlvbnNbdG9rZW5dO1xuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVkID09PSAnbG9jYWxlJz8gbDEwblt0b2tlbl0gOiBleHBhbmRlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJScrIHRva2VuO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0VG9rZW4oZGF0ZSwgdG9rZW4sIGwxMG4pe1xuICAgICAgICBzd2l0Y2ggKHRva2VuKXtcbiAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgIHJldHVybiBsMTBuLmRheXNfYWJicltkYXRlLmdldERheSgpXTtcbiAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgIHJldHVybiBsMTBuLmRheXNbZGF0ZS5nZXREYXkoKV07XG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgIHJldHVybiBsMTBuLm1vbnRoc19hYmJyW2RhdGUuZ2V0TW9udGgoKV07XG4gICAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbDEwbi5tb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoTWF0aC5mbG9vcihkYXRlLmdldEZ1bGxZZWFyKCkgLyAxMDApLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoZGF0ZS5nZXREYXRlKCksIDIpO1xuICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldERhdGUoKSwgMiwgJyAnKTtcbiAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoZGF0ZS5nZXRIb3VycygpLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoZGF0ZS5nZXRIb3VycygpICUgMTIsIDIpO1xuICAgICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkYXlPZlRoZVllYXIoZGF0ZSksIDMpO1xuICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxwYWQoZGF0ZS5nZXRIb3VycygpICUgMTIsIDIpO1xuICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldE1pbGxpc2Vjb25kcygpLCAzKTtcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoZGF0ZS5nZXRNb250aCgpICsgMSwgMik7XG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFkKGRhdGUuZ2V0TWludXRlcygpLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFxuJztcbiAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlLmdldEhvdXJzKCkgPj0gMTI/IGwxMG4ucG0gOiBsMTBuLmFtO1xuICAgICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb2tlbihkYXRlLCAncCcsIGwxMG4pLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgLyAxMDAwO1xuICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkYXRlLmdldFNlY29uZHMoKSwgMik7XG4gICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcdCc7XG4gICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICB2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF5ID09PSAwPyA3IDogZGF5O1xuICAgICAgICAgICAgY2FzZSAnVSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZCh3ZWVrT2ZUaGVZZWFyKGRhdGUpLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZCh3ZWVrT2ZUaGVZZWFyKGRhdGUsIDEpLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoZGF0ZS5nZXRGdWxsWWVhcigpICUgMTAwLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ1knOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYWQoZGF0ZS5nZXRGdWxsWWVhcigpLCA0KTtcbiAgICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aW1lem9uZU9mZnNldChkYXRlKTtcbiAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aW1lem9uZUFiYnIoZGF0ZSk7XG4gICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJyUnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBrZWVwIHVucmVjb2duaXplZCB0b2tlbnNcbiAgICAgICAgICAgICAgICByZXR1cm4gJyUnKyB0b2tlbjtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzdHJmdGltZTtcblxuXG4iLCJ2YXIgdGltZXpvbmVPZmZzZXQgPSByZXF1aXJlKCcuL3RpbWV6b25lT2Zmc2V0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBBYmJyZXZpYXRlZCB0aW1lIHpvbmUgbmFtZSBvciBzaW1pbGFyIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWV6b25lQWJicihkYXRlKXtcbiAgICAgICAgLy8gRGF0ZS50b1N0cmluZyBnaXZlcyBkaWZmZXJlbnQgcmVzdWx0cyBkZXBlbmRpbmcgb24gdGhlXG4gICAgICAgIC8vIGJyb3dzZXIvc3lzdGVtIHNvIHdlIGZhbGxiYWNrIHRvIHRpbWV6b25lIG9mZnNldFxuICAgICAgICAvLyBjaHJvbWU6ICdNb24gQXByIDA4IDIwMTMgMDk6MDI6MDQgR01ULTAzMDAgKEJSVCknXG4gICAgICAgIC8vIElFOiAnTW9uIEFwciA4IDA5OjAyOjA0IFVUQy0wMzAwIDIwMTMnXG4gICAgICAgIHZhciB0eiA9IC9cXCgoW0EtWl17Myw0fSlcXCkvLmV4ZWMoZGF0ZS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHR6PyB0elsxXSA6IHRpbWV6b25lT2Zmc2V0KGRhdGUpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdGltZXpvbmVBYmJyO1xuXG5cbiIsInZhciBwYWQgPSByZXF1aXJlKCcuLi9udW1iZXIvcGFkJyk7XG5cbiAgICAvKipcbiAgICAgKiB0aW1lIHpvbmUgYXMgaG91ciBhbmQgbWludXRlIG9mZnNldCBmcm9tIFVUQyAoZS5nLiArMDkwMClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lem9uZU9mZnNldChkYXRlKXtcbiAgICAgICAgdmFyIG9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzKG9mZnNldCk7XG4gICAgICAgIHZhciBoID0gcGFkKE1hdGguZmxvb3IoYWJzIC8gNjApLCAyKTtcbiAgICAgICAgdmFyIG0gPSBwYWQoYWJzICUgNjAsIDIpO1xuICAgICAgICByZXR1cm4gKG9mZnNldCA+IDA/ICctJyA6ICcrJykgKyBoICsgbTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRpbWV6b25lT2Zmc2V0O1xuXG5cbiIsInZhciBpc0RhdGUgPSByZXF1aXJlKCcuLi9sYW5nL2lzRGF0ZScpO1xudmFyIGlzTGVhcFllYXIgPSByZXF1aXJlKCcuL2lzTGVhcFllYXInKTtcblxuICAgIHZhciBEQVlTX0lOX01PTlRIID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgdG90YWwgYW1vdW50IG9mIGRheXMgaW4gdGhlIG1vbnRoIChjb25zaWRlcmluZyBsZWFwIHllYXJzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvdGFsRGF5c0luTW9udGgoZnVsbFllYXIsIG1vbnRoSW5kZXgpe1xuICAgICAgICBpZiAoaXNEYXRlKGZ1bGxZZWFyKSkge1xuICAgICAgICAgICAgbW9udGhJbmRleCA9IGZ1bGxZZWFyLmdldE1vbnRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9udGhJbmRleCA9PT0gMSAmJiBpc0xlYXBZZWFyKGZ1bGxZZWFyKSkge1xuICAgICAgICAgICAgcmV0dXJuIDI5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIERBWVNfSU5fTU9OVEhbbW9udGhJbmRleF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvdGFsRGF5c0luTW9udGg7XG5cblxuIiwidmFyIGlzTGVhcFllYXIgPSByZXF1aXJlKCcuL2lzTGVhcFllYXInKTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgYW1vdW50IG9mIGRheXMgaW4gdGhlIHllYXIgZm9sbG93aW5nIHRoZSBncmVnb3JpYW4gY2FsZW5kYXJcbiAgICAgKiBhbmQgbGVhcCB5ZWFyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvdGFsRGF5c0luWWVhcihmdWxsWWVhcil7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKGZ1bGxZZWFyKT8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdG90YWxEYXlzSW5ZZWFyO1xuXG5cbiIsInZhciBkYXlPZlRoZVllYXIgPSByZXF1aXJlKCcuL2RheU9mVGhlWWVhcicpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyIGJhc2VkIG9uIGdpdmVuIGZpcnN0RGF5T2ZXZWVrXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2Vla09mVGhlWWVhcihkYXRlLCBmaXJzdERheU9mV2Vlayl7XG4gICAgICAgIGZpcnN0RGF5T2ZXZWVrID0gZmlyc3REYXlPZldlZWsgPT0gbnVsbD8gMCA6IGZpcnN0RGF5T2ZXZWVrO1xuICAgICAgICB2YXIgZG95ID0gZGF5T2ZUaGVZZWFyKGRhdGUpO1xuICAgICAgICB2YXIgZG93ID0gKDcgKyBkYXRlLmdldERheSgpIC0gZmlyc3REYXlPZldlZWspICUgNztcbiAgICAgICAgdmFyIHJlbGF0aXZlV2Vla0RheSA9IDYgLSBmaXJzdERheU9mV2VlayAtIGRvdztcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGRveSArIHJlbGF0aXZlV2Vla0RheSkgLyA3KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdlZWtPZlRoZVllYXI7XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdhd2FpdERlbGF5JyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXdhaXREZWxheScpLFxuICAgICdiaW5kJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vYmluZCcpLFxuICAgICdjb21wb3NlJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vY29tcG9zZScpLFxuICAgICdjb25zdGFudCcgOiByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbnN0YW50JyksXG4gICAgJ2RlYm91bmNlJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vZGVib3VuY2UnKSxcbiAgICAnZnVuYycgOiByZXF1aXJlKCcuL2Z1bmN0aW9uL2Z1bmMnKSxcbiAgICAnaWRlbnRpdHknIDogcmVxdWlyZSgnLi9mdW5jdGlvbi9pZGVudGl0eScpLFxuICAgICdtYWtlSXRlcmF0b3JfJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpLFxuICAgICdwYXJ0aWFsJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vcGFydGlhbCcpLFxuICAgICdwcm9wJyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvcCcpLFxuICAgICdzZXJpZXMnIDogcmVxdWlyZSgnLi9mdW5jdGlvbi9zZXJpZXMnKSxcbiAgICAndGhyb3R0bGUnIDogcmVxdWlyZSgnLi9mdW5jdGlvbi90aHJvdHRsZScpLFxuICAgICd0aW1lb3V0JyA6IHJlcXVpcmUoJy4vZnVuY3Rpb24vdGltZW91dCcpLFxuICAgICd0aW1lcycgOiByZXF1aXJlKCcuL2Z1bmN0aW9uL3RpbWVzJyksXG4gICAgJ3dyYXAnIDogcmVxdWlyZSgnLi9mdW5jdGlvbi93cmFwJylcbn07XG5cblxuIiwidmFyIG5vdyA9IHJlcXVpcmUoJy4uL3RpbWUvbm93Jyk7XG52YXIgdGltZW91dCA9IHJlcXVpcmUoJy4vdGltZW91dCcpO1xudmFyIGFwcGVuZCA9IHJlcXVpcmUoJy4uL2FycmF5L2FwcGVuZCcpO1xuXG4gICAgLyoqXG4gICAgICogRW5zdXJlIGEgbWluaW11bSBkZWxheSBmb3IgY2FsbGJhY2tzXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXdhaXREZWxheSggY2FsbGJhY2ssIGRlbGF5ICl7XG4gICAgICAgIHZhciBiYXNlVGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBhbGwgYnJvd3NlcnMgd2lsbCBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5IChhdm9pZCBoYXJkXG4gICAgICAgICAgICAvLyB0byBjYXRjaCBlcnJvcnMpIG5vdCB1c2luZyBcIjBcIiBiZWNhdXNlIG9mIG9sZCBicm93c2VycyBhbmQgYWxzb1xuICAgICAgICAgICAgLy8gc2luY2UgbmV3IGJyb3dzZXJzIGluY3JlYXNlIHRoZSB2YWx1ZSB0byBiZSBhdCBsZWFzdCBcIjRcIlxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGltZXJzLmh0bWwjZG9tLXdpbmRvd3RpbWVycy1zZXR0aW1lb3V0XG4gICAgICAgICAgICB2YXIgbXMgPSBNYXRoLm1heChiYXNlVGltZSAtIG5vdygpLCA0KTtcbiAgICAgICAgICAgIHJldHVybiB0aW1lb3V0LmFwcGx5KHRoaXMsIGFwcGVuZChbY2FsbGJhY2ssIG1zLCB0aGlzXSwgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBhd2FpdERlbGF5O1xuXG5cbiIsInZhciBzbGljZSA9IHJlcXVpcmUoJy4uL2FycmF5L3NsaWNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSBpbiB0aGUgZ2l2ZW4gY29udGV4dCwgb3B0aW9uYWxseSBhZGRpbmcgYW55IGFkZGl0aW9uYWwgc3VwcGxpZWQgcGFyYW1ldGVycyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmd1bWVudHMgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgRnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgICBFeGVjdXRpb24gY29udGV4dC5cbiAgICAgKiBAcGFyYW0ge3Jlc3R9IGFyZ3MgICAgQXJndW1lbnRzICgwLi4ubiBhcmd1bWVudHMpLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBXcmFwcGVkIEZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmQoZm4sIGNvbnRleHQsIGFyZ3Mpe1xuICAgICAgICB2YXIgYXJnc0FyciA9IHNsaWNlKGFyZ3VtZW50cywgMik7IC8vY3VycmllZCBhcmdzXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3NBcnIuY29uY2F0KHNsaWNlKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJpbmQ7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjb21wb3NlcyBtdWx0aXBsZSBmdW5jdGlvbnMsIHBhc3NpbmcgcmVzdWx0cyB0b1xuICAgICAqIGVhY2ggb3RoZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICAgICAgdmFyIGZucyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFyZyl7XG4gICAgICAgICAgICAvLyBvbmx5IGNhcmVzIGFib3V0IHRoZSBmaXJzdCBhcmd1bWVudCBzaW5jZSB0aGUgY2hhaW4gY2FuIG9ubHlcbiAgICAgICAgICAgIC8vIGRlYWwgd2l0aCBhIHNpbmdsZSByZXR1cm4gdmFsdWUgYW55d2F5LiBJdCBzaG91bGQgc3RhcnQgZnJvbVxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgZm4uXG4gICAgICAgICAgICB2YXIgbiA9IGZucy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gZm5zW25dLmNhbGwodGhpcywgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgICB9O1xuICAgICB9XG5cbiAgICAgbW9kdWxlLmV4cG9ydHMgPSBjb21wb3NlO1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIHRoZSB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKXtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBEZWJvdW5jZSBjYWxsYmFjayBleGVjdXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmbiwgdGhyZXNob2xkLCBpc0FzYXApe1xuICAgICAgICB2YXIgdGltZW91dCwgcmVzdWx0O1xuICAgICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKXtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLCBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGF5ZWQoKXtcbiAgICAgICAgICAgICAgICBpZiAoISBpc0FzYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXNhcCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZGVsYXllZCwgdGhyZXNob2xkKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVib3VuY2VkLmNhbmNlbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbGwgYSBtZXRob2Qgb24gdGhlIHBhc3NlZCBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jKG5hbWUpe1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKXtcbiAgICAgICAgICAgIHJldHVybiBvYmpbbmFtZV0oKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmM7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWwpe1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cblxuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xudmFyIHByb3AgPSByZXF1aXJlKCcuL3Byb3AnKTtcbnZhciBkZWVwTWF0Y2hlcyA9IHJlcXVpcmUoJy4uL29iamVjdC9kZWVwTWF0Y2hlcycpO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYXJndW1lbnQgaW50byBhIHZhbGlkIGl0ZXJhdG9yLlxuICAgICAqIFVzZWQgaW50ZXJuYWxseSBvbiBtb3N0IGFycmF5L29iamVjdC9jb2xsZWN0aW9uIG1ldGhvZHMgdGhhdCByZWNlaXZlcyBhXG4gICAgICogY2FsbGJhY2svaXRlcmF0b3IgcHJvdmlkaW5nIGEgc2hvcnRjdXQgc3ludGF4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VJdGVyYXRvcihzcmMsIHRoaXNPYmope1xuICAgICAgICBpZiAoc3JjID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2godHlwZW9mIHNyYykge1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uIGlzIHRoZSBmaXJzdCB0byBpbXByb3ZlIHBlcmYgKG1vc3QgY29tbW9uIGNhc2UpXG4gICAgICAgICAgICAgICAgLy8gYWxzbyBhdm9pZCB1c2luZyBgRnVuY3Rpb24jY2FsbGAgaWYgbm90IG5lZWRlZCwgd2hpY2ggYm9vc3RzXG4gICAgICAgICAgICAgICAgLy8gcGVyZiBhIGxvdCBpbiBzb21lIGNhc2VzXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdGhpc09iaiAhPT0gJ3VuZGVmaW5lZCcpPyBmdW5jdGlvbih2YWwsIGksIGFycil7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcmMuY2FsbCh0aGlzT2JqLCB2YWwsIGksIGFycik7XG4gICAgICAgICAgICAgICAgfSA6IHNyYztcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWVwTWF0Y2hlcyh2YWwsIHNyYyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wKHNyYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2VJdGVyYXRvcjtcblxuXG4iLCJ2YXIgc2xpY2UgPSByZXF1aXJlKCcuLi9hcnJheS9zbGljZScpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWwoZikge1xuICAgICAgICB2YXIgYXMgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFzLmNvbmNhdChzbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcmdzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzW2ldID09PSBwYXJ0aWFsLl8pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3Muc3BsaWNlKC0xKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJ0aWFsLl8gPSB7fTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcGFydGlhbDtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGdldHMgYSBwcm9wZXJ0eSBvZiB0aGUgcGFzc2VkIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3AobmFtZSl7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmope1xuICAgICAgICAgICAgcmV0dXJuIG9ialtuYW1lXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHByb3A7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgYSBsaXN0IG9mIGZ1bmN0aW9ucyBpbiBzZXF1ZW5jZVxuICAgICAqIHBhc3NpbmcgdGhlIHNhbWUgYXJndW1lbnRzIHRvIGVhY2ggb25lLiAodXNlZnVsIGZvciBiYXRjaCBwcm9jZXNzaW5nXG4gICAgICogaXRlbXMgZHVyaW5nIGEgZm9yRWFjaCBsb29wKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlcmllcygpe1xuICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICBuID0gZm5zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICAgICAgICAgIGZuc1tpXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNlcmllcztcblxuXG4iLCJ2YXIgbm93ID0gcmVxdWlyZSgnLi4vdGltZS9ub3cnKTtcblxuICAgIC8qKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZuLCBkZWxheSl7XG4gICAgICAgIHZhciBjb250ZXh0LCB0aW1lb3V0LCByZXN1bHQsIGFyZ3MsXG4gICAgICAgICAgICBkaWZmLCBwcmV2Q2FsbCA9IDA7XG4gICAgICAgIGZ1bmN0aW9uIGRlbGF5ZWQoKXtcbiAgICAgICAgICAgIHByZXZDYWxsID0gbm93KCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRocm90dGxlZCgpe1xuICAgICAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgZGlmZiA9IGRlbGF5IC0gKG5vdygpIC0gcHJldkNhbGwpO1xuICAgICAgICAgICAgaWYgKGRpZmYgPD0gMCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBkZWxheWVkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEgdGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIGRpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdHRsZWQuY2FuY2VsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRocm90dGxlZDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuXG5cbiIsInZhciBzbGljZSA9IHJlcXVpcmUoJy4uL2FycmF5L3NsaWNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBEZWxheXMgdGhlIGNhbGwgb2YgYSBmdW5jdGlvbiB3aXRoaW4gYSBnaXZlbiBjb250ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVvdXQoZm4sIG1pbGxpcywgY29udGV4dCl7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDMpO1xuXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH0sIG1pbGxpcyk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0aW1lb3V0O1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhIGNhbGxiYWNrIGEgc2V0IGFtb3VudCBvZiB0aW1lc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGNhbGxiYWNrLCB0aGlzT2JqKXtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgIGlmICggY2FsbGJhY2suY2FsbCh0aGlzT2JqLCBpKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRpbWVzO1xuXG5cbiIsInZhciBwYXJ0aWFsID0gcmVxdWlyZSgnLi9wYXJ0aWFsJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgICAgKiBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gICAgICogY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKGZuLCB3cmFwcGVyKXtcbiAgICAgICAgcmV0dXJuIHBhcnRpYWwod3JhcHBlciwgZm4pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gd3JhcDtcblxuXG4iLCIvKipAbGljZW5zZVxuICogbW91dCB2MC4xMS4wIHwgaHR0cDovL21vdXRqcy5jb20gfCBNSVQgbGljZW5zZVxuICovXG5cblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ1ZFUlNJT04nIDogJzAuMTEuMCcsXG4gICAgJ2FycmF5JyA6IHJlcXVpcmUoJy4vYXJyYXknKSxcbiAgICAnY29sbGVjdGlvbicgOiByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKSxcbiAgICAnZGF0ZScgOiByZXF1aXJlKCcuL2RhdGUnKSxcbiAgICAnZnVuY3Rpb24nIDogcmVxdWlyZSgnLi9mdW5jdGlvbicpLFxuICAgICdsYW5nJyA6IHJlcXVpcmUoJy4vbGFuZycpLFxuICAgICdtYXRoJyA6IHJlcXVpcmUoJy4vbWF0aCcpLFxuICAgICdudW1iZXInIDogcmVxdWlyZSgnLi9udW1iZXInKSxcbiAgICAnb2JqZWN0JyA6IHJlcXVpcmUoJy4vb2JqZWN0JyksXG4gICAgJ3F1ZXJ5U3RyaW5nJyA6IHJlcXVpcmUoJy4vcXVlcnlTdHJpbmcnKSxcbiAgICAncmFuZG9tJyA6IHJlcXVpcmUoJy4vcmFuZG9tJyksXG4gICAgJ3N0cmluZycgOiByZXF1aXJlKCcuL3N0cmluZycpLFxuICAgICd0aW1lJyA6IHJlcXVpcmUoJy4vdGltZScpLFxuICAgICdmbicgOiByZXF1aXJlKCcuL2Z1bmN0aW9uJylcbn07XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdHTE9CQUwnIDogcmVxdWlyZSgnLi9sYW5nL0dMT0JBTCcpLFxuICAgICdjbG9uZScgOiByZXF1aXJlKCcuL2xhbmcvY2xvbmUnKSxcbiAgICAnY3JlYXRlT2JqZWN0JyA6IHJlcXVpcmUoJy4vbGFuZy9jcmVhdGVPYmplY3QnKSxcbiAgICAnY3RvckFwcGx5JyA6IHJlcXVpcmUoJy4vbGFuZy9jdG9yQXBwbHknKSxcbiAgICAnZGVlcENsb25lJyA6IHJlcXVpcmUoJy4vbGFuZy9kZWVwQ2xvbmUnKSxcbiAgICAnZGVlcEVxdWFscycgOiByZXF1aXJlKCcuL2xhbmcvZGVlcEVxdWFscycpLFxuICAgICdkZWZhdWx0cycgOiByZXF1aXJlKCcuL2xhbmcvZGVmYXVsdHMnKSxcbiAgICAnaW5oZXJpdFByb3RvdHlwZScgOiByZXF1aXJlKCcuL2xhbmcvaW5oZXJpdFByb3RvdHlwZScpLFxuICAgICdpcycgOiByZXF1aXJlKCcuL2xhbmcvaXMnKSxcbiAgICAnaXNBcmd1bWVudHMnIDogcmVxdWlyZSgnLi9sYW5nL2lzQXJndW1lbnRzJyksXG4gICAgJ2lzQXJyYXknIDogcmVxdWlyZSgnLi9sYW5nL2lzQXJyYXknKSxcbiAgICAnaXNCb29sZWFuJyA6IHJlcXVpcmUoJy4vbGFuZy9pc0Jvb2xlYW4nKSxcbiAgICAnaXNEYXRlJyA6IHJlcXVpcmUoJy4vbGFuZy9pc0RhdGUnKSxcbiAgICAnaXNFbXB0eScgOiByZXF1aXJlKCcuL2xhbmcvaXNFbXB0eScpLFxuICAgICdpc0Zpbml0ZScgOiByZXF1aXJlKCcuL2xhbmcvaXNGaW5pdGUnKSxcbiAgICAnaXNGdW5jdGlvbicgOiByZXF1aXJlKCcuL2xhbmcvaXNGdW5jdGlvbicpLFxuICAgICdpc0ludGVnZXInIDogcmVxdWlyZSgnLi9sYW5nL2lzSW50ZWdlcicpLFxuICAgICdpc0tpbmQnIDogcmVxdWlyZSgnLi9sYW5nL2lzS2luZCcpLFxuICAgICdpc05hTicgOiByZXF1aXJlKCcuL2xhbmcvaXNOYU4nKSxcbiAgICAnaXNOdWxsJyA6IHJlcXVpcmUoJy4vbGFuZy9pc051bGwnKSxcbiAgICAnaXNOdW1iZXInIDogcmVxdWlyZSgnLi9sYW5nL2lzTnVtYmVyJyksXG4gICAgJ2lzT2JqZWN0JyA6IHJlcXVpcmUoJy4vbGFuZy9pc09iamVjdCcpLFxuICAgICdpc1BsYWluT2JqZWN0JyA6IHJlcXVpcmUoJy4vbGFuZy9pc1BsYWluT2JqZWN0JyksXG4gICAgJ2lzUHJpbWl0aXZlJyA6IHJlcXVpcmUoJy4vbGFuZy9pc1ByaW1pdGl2ZScpLFxuICAgICdpc1JlZ0V4cCcgOiByZXF1aXJlKCcuL2xhbmcvaXNSZWdFeHAnKSxcbiAgICAnaXNTdHJpbmcnIDogcmVxdWlyZSgnLi9sYW5nL2lzU3RyaW5nJyksXG4gICAgJ2lzVW5kZWZpbmVkJyA6IHJlcXVpcmUoJy4vbGFuZy9pc1VuZGVmaW5lZCcpLFxuICAgICdpc250JyA6IHJlcXVpcmUoJy4vbGFuZy9pc250JyksXG4gICAgJ2tpbmRPZicgOiByZXF1aXJlKCcuL2xhbmcva2luZE9mJyksXG4gICAgJ3RvQXJyYXknIDogcmVxdWlyZSgnLi9sYW5nL3RvQXJyYXknKSxcbiAgICAndG9OdW1iZXInIDogcmVxdWlyZSgnLi9sYW5nL3RvTnVtYmVyJyksXG4gICAgJ3RvU3RyaW5nJyA6IHJlcXVpcmUoJy4vbGFuZy90b1N0cmluZycpXG59O1xuXG5cbiIsIlxuXG4gICAgLy8gUmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgY29udGV4dCAod29ya3Mgb24gRVMzIGFuZCBFUzUtc3RyaWN0IG1vZGUpXG4gICAgLy9qc2hpbnQgLVcwNjEsIC1XMDY0XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5cbiIsInZhciBraW5kT2YgPSByZXF1aXJlKCcuL2tpbmRPZicpO1xudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKTtcbnZhciBtaXhJbiA9IHJlcXVpcmUoJy4uL29iamVjdC9taXhJbicpO1xuXG4gICAgLyoqXG4gICAgICogQ2xvbmUgbmF0aXZlIHR5cGVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbCl7XG4gICAgICAgIHN3aXRjaCAoa2luZE9mKHZhbCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lT2JqZWN0KHZhbCk7XG4gICAgICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXkodmFsKTtcbiAgICAgICAgICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKHZhbCk7XG4gICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVEYXRlKHZhbCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZU9iamVjdChzb3VyY2UpIHtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1peEluKHt9LCBzb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lUmVnRXhwKHIpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gJyc7XG4gICAgICAgIGZsYWdzICs9IHIubXVsdGlsaW5lID8gJ20nIDogJyc7XG4gICAgICAgIGZsYWdzICs9IHIuZ2xvYmFsID8gJ2cnIDogJyc7XG4gICAgICAgIGZsYWdzICs9IHIuaWdub3JlQ2FzZSA/ICdpJyA6ICcnO1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyLnNvdXJjZSwgZmxhZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lRGF0ZShkYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgrZGF0ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheShhcnIpIHtcbiAgICAgICAgcmV0dXJuIGFyci5zbGljZSgpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG5cblxuIiwidmFyIG1peEluID0gcmVxdWlyZSgnLi4vb2JqZWN0L21peEluJyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgT2JqZWN0IHVzaW5nIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIHNldHRpbmcgY3VzdG9tIHByb3BlcnRpZXMuXG4gICAgICogLSBNaXggYmV0d2VlbiBEb3VnbGFzIENyb2NrZm9yZCBQcm90b3R5cGFsIEluaGVyaXRhbmNlIDxodHRwOi8vamF2YXNjcmlwdC5jcm9ja2ZvcmQuY29tL3Byb3RvdHlwYWwuaHRtbD4gYW5kIHRoZSBFY21hU2NyaXB0IDUgYE9iamVjdC5jcmVhdGUoKWAgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnQgICAgUGFyZW50IE9iamVjdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3Byb3BzXSBPYmplY3QgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENyZWF0ZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdChwYXJlbnQsIHByb3BzKXtcbiAgICAgICAgZnVuY3Rpb24gRigpe31cbiAgICAgICAgRi5wcm90b3R5cGUgPSBwYXJlbnQ7XG4gICAgICAgIHJldHVybiBtaXhJbihuZXcgRigpLCBwcm9wcyk7XG5cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVPYmplY3Q7XG5cblxuIiwiXG5cbiAgICBmdW5jdGlvbiBGKCl7fVxuXG4gICAgLyoqXG4gICAgICogRG8gZm4uYXBwbHkgb24gYSBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdG9yQXBwbHkoY3RvciwgYXJncykge1xuICAgICAgICBGLnByb3RvdHlwZSA9IGN0b3IucHJvdG90eXBlO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgRigpO1xuICAgICAgICBjdG9yLmFwcGx5KGluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY3RvckFwcGx5O1xuXG5cbiIsInZhciBjbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUnKTtcbnZhciBmb3JPd24gPSByZXF1aXJlKCcuLi9vYmplY3QvZm9yT3duJyk7XG52YXIga2luZE9mID0gcmVxdWlyZSgnLi9raW5kT2YnKTtcbnZhciBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc1BsYWluT2JqZWN0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBjbG9uZSBuYXRpdmUgdHlwZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVlcENsb25lKHZhbCwgaW5zdGFuY2VDbG9uZSkge1xuICAgICAgICBzd2l0Y2ggKCBraW5kT2YodmFsKSApIHtcbiAgICAgICAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lT2JqZWN0KHZhbCwgaW5zdGFuY2VDbG9uZSk7XG4gICAgICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXkodmFsLCBpbnN0YW5jZUNsb25lKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lKHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZU9iamVjdChzb3VyY2UsIGluc3RhbmNlQ2xvbmUpIHtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICAgICAgZm9yT3duKHNvdXJjZSwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBkZWVwQ2xvbmUodmFsLCBpbnN0YW5jZUNsb25lKTtcbiAgICAgICAgICAgIH0sIG91dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2UgaWYgKGluc3RhbmNlQ2xvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZUNsb25lKHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheShhcnIsIGluc3RhbmNlQ2xvbmUpIHtcbiAgICAgICAgdmFyIG91dCA9IFtdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbiA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgICB2YWw7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBkZWVwQ2xvbmUoYXJyW2ldLCBpbnN0YW5jZUNsb25lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZGVlcENsb25lO1xuXG5cblxuIiwidmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcbnZhciBvYmpFcXVhbHMgPSByZXF1aXJlKCcuLi9vYmplY3QvZXF1YWxzJyk7XG52YXIgYXJyRXF1YWxzID0gcmVxdWlyZSgnLi4vYXJyYXkvZXF1YWxzJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBjaGVja3MgZm9yIHNhbWUgcHJvcGVydGllcyBhbmQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZXBFcXVhbHMoYSwgYiwgY2FsbGJhY2spe1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGlzO1xuXG4gICAgICAgIHZhciBib3RoT2JqZWN0cyA9IGlzT2JqZWN0KGEpICYmIGlzT2JqZWN0KGIpO1xuICAgICAgICB2YXIgYm90aEFycmF5cyA9ICFib3RoT2JqZWN0cyAmJiBpc0FycmF5KGEpICYmIGlzQXJyYXkoYik7XG5cbiAgICAgICAgaWYgKCFib3RoT2JqZWN0cyAmJiAhYm90aEFycmF5cykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGEsIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKXtcbiAgICAgICAgICAgIHJldHVybiBkZWVwRXF1YWxzKGEsIGIsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXRob2QgPSBib3RoT2JqZWN0cyA/IG9iakVxdWFscyA6IGFyckVxdWFscztcbiAgICAgICAgcmV0dXJuIG1ldGhvZChhLCBiLCBjb21wYXJlKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZXBFcXVhbHM7XG5cblxuIiwidmFyIHRvQXJyYXkgPSByZXF1aXJlKCcuL3RvQXJyYXknKTtcbnZhciBmaW5kID0gcmVxdWlyZSgnLi4vYXJyYXkvZmluZCcpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGZpcnN0IG5vbiB2b2lkIGFyZ3VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdHModmFyX2FyZ3Mpe1xuICAgICAgICByZXR1cm4gZmluZCh0b0FycmF5KGFyZ3VtZW50cyksIG5vblZvaWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vblZvaWQodmFsKXtcbiAgICAgICAgcmV0dXJuIHZhbCAhPSBudWxsO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG5cblxuIiwidmFyIGNyZWF0ZU9iamVjdCA9IHJlcXVpcmUoJy4vY3JlYXRlT2JqZWN0Jyk7XG5cbiAgICAvKipcbiAgICAqIEluaGVyaXQgcHJvdG90eXBlIGZyb20gYW5vdGhlciBPYmplY3QuXG4gICAgKiAtIGluc3BpcmVkIGJ5IE5pY2hvbGFzIFphY2thcyA8aHR0cDovL25jem9ubGluZS5uZXQ+IFNvbHV0aW9uXG4gICAgKiBAcGFyYW0ge29iamVjdH0gY2hpbGQgQ2hpbGQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50ICAgIFBhcmVudCBPYmplY3RcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGluaGVyaXRQcm90b3R5cGUoY2hpbGQsIHBhcmVudCl7XG4gICAgICAgIHZhciBwID0gY3JlYXRlT2JqZWN0KHBhcmVudC5wcm90b3R5cGUpO1xuICAgICAgICBwLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgICAgIGNoaWxkLnByb3RvdHlwZSA9IHA7XG4gICAgICAgIGNoaWxkLnN1cGVyXyA9IHBhcmVudDtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpbmhlcml0UHJvdG90eXBlO1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGJvdGggYXJndW1lbnRzIGFyZSBlZ2FsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHgsIHkpe1xuICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiBib3Jyb3dlZCBmcm9tIGhhcm1vbnk6ZWdhbCBzcGVjXG4gICAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgLy8gMCA9PT0gLTAsIGJ1dCB0aGV5IGFyZSBub3QgaWRlbnRpY2FsXG4gICAgICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmFOICE9PSBOYU4sIGJ1dCB0aGV5IGFyZSBpZGVudGljYWwuXG4gICAgICAgIC8vIE5hTnMgYXJlIHRoZSBvbmx5IG5vbi1yZWZsZXhpdmUgdmFsdWUsIGkuZS4sIGlmIHggIT09IHgsXG4gICAgICAgIC8vIHRoZW4geCBpcyBhIE5hTi5cbiAgICAgICAgLy8gaXNOYU4gaXMgYnJva2VuOiBpdCBjb252ZXJ0cyBpdHMgYXJndW1lbnQgdG8gbnVtYmVyLCBzb1xuICAgICAgICAvLyBpc05hTihcImZvb1wiKSA9PiB0cnVlXG4gICAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpcztcblxuXG4iLCJ2YXIgaXNLaW5kID0gcmVxdWlyZSgnLi9pc0tpbmQnKTtcblxuICAgIC8qKlxuICAgICAqL1xuICAgIHZhciBpc0FyZ3MgPSBpc0tpbmQoYXJndW1lbnRzLCAnQXJndW1lbnRzJyk/XG4gICAgICAgICAgICBmdW5jdGlvbih2YWwpe1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0tpbmQodmFsLCAnQXJndW1lbnRzJyk7XG4gICAgICAgICAgICB9IDpcbiAgICAgICAgICAgIGZ1bmN0aW9uKHZhbCl7XG4gICAgICAgICAgICAgICAgLy8gQXJndW1lbnRzIGlzIGFuIE9iamVjdCBvbiBJRTdcbiAgICAgICAgICAgICAgICByZXR1cm4gISEodmFsICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsICdjYWxsZWUnKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3M7XG5cbiIsInZhciBpc0tpbmQgPSByZXF1aXJlKCcuL2lzS2luZCcpO1xuICAgIC8qKlxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiBpc0tpbmQodmFsLCAnQXJyYXknKTtcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuIiwidmFyIGlzS2luZCA9IHJlcXVpcmUoJy4vaXNLaW5kJyk7XG4gICAgLyoqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbCkge1xuICAgICAgICByZXR1cm4gaXNLaW5kKHZhbCwgJ0Jvb2xlYW4nKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0Jvb2xlYW47XG5cbiIsInZhciBpc0tpbmQgPSByZXF1aXJlKCcuL2lzS2luZCcpO1xuICAgIC8qKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGlzS2luZCh2YWwsICdEYXRlJyk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNEYXRlO1xuXG4iLCJ2YXIgZm9yT3duID0gcmVxdWlyZSgnLi4vb2JqZWN0L2Zvck93bicpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsKXtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCA9PSAnb2JqZWN0JyBzbyB3ZSBjaGVjayBpdCBmaXJzdFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IGlzQXJyYXkodmFsKSApIHtcbiAgICAgICAgICAgIHJldHVybiAhdmFsLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvck93bih2YWwsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBicmVhayBsb29wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNFbXB0eTtcblxuXG4iLCJ2YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuL2lzTnVtYmVyJyk7XG52YXIgR0xPQkFMID0gcmVxdWlyZSgnLi9HTE9CQUwnKTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHZhbHVlIGlzIGZpbml0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbCl7XG4gICAgICAgIHZhciBpcyA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsICE9PSAnJykge1xuICAgICAgICAgICAgaXMgPSBHTE9CQUwuaXNGaW5pdGUoIHBhcnNlRmxvYXQodmFsKSApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbCkpe1xuICAgICAgICAgICAgLy8gbmVlZCB0byB1c2UgaXNOdW1iZXIgYmVjYXVzZSBvZiBOdW1iZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIGlzID0gR0xPQkFMLmlzRmluaXRlKCB2YWwgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0Zpbml0ZTtcblxuXG4iLCJ2YXIgaXNLaW5kID0gcmVxdWlyZSgnLi9pc0tpbmQnKTtcbiAgICAvKipcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gaXNLaW5kKHZhbCwgJ0Z1bmN0aW9uJyk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcblxuIiwidmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnLi9pc051bWJlcicpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdmFsdWUgaXMgYW4gaW50ZWdlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWwpe1xuICAgICAgICByZXR1cm4gaXNOdW1iZXIodmFsKSAmJiAodmFsICUgMSA9PT0gMCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0ludGVnZXI7XG5cblxuIiwidmFyIGtpbmRPZiA9IHJlcXVpcmUoJy4va2luZE9mJyk7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdmFsdWUgaXMgZnJvbSBhIHNwZWNpZmljIFwia2luZFwiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2luZCh2YWwsIGtpbmQpe1xuICAgICAgICByZXR1cm4ga2luZE9mKHZhbCkgPT09IGtpbmQ7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNLaW5kO1xuXG4iLCJ2YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuL2lzTnVtYmVyJyk7XG52YXIgJGlzTmFOID0gcmVxdWlyZSgnLi4vbnVtYmVyL2lzTmFOJyk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB2YWx1ZSBpcyBOYU4gZm9yIHJlYWx6XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsKXtcbiAgICAgICAgLy8gYmFzZWQgb24gdGhlIGZhY3QgdGhhdCBOYU4gIT09IE5hTlxuICAgICAgICAvLyBuZWVkIHRvIGNoZWNrIGlmIGl0J3MgYSBudW1iZXIgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggaG9zdCBvYmplY3RzXG4gICAgICAgIC8vIGFsc28gbmVlZCB0byBjb2VyY2UgVG9OdW1iZXIgdG8gYXZvaWQgZWRnZSBjYXNlIGBuZXcgTnVtYmVyKE5hTilgXG4gICAgICAgIHJldHVybiAhaXNOdW1iZXIodmFsKSB8fCAkaXNOYU4oTnVtYmVyKHZhbCkpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNOYU47XG5cblxuIiwiXG4gICAgLyoqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbCl7XG4gICAgICAgIHJldHVybiB2YWwgPT09IG51bGw7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNOdWxsO1xuXG5cbiIsInZhciBpc0tpbmQgPSByZXF1aXJlKCcuL2lzS2luZCcpO1xuICAgIC8qKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICAgICAgICByZXR1cm4gaXNLaW5kKHZhbCwgJ051bWJlcicpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzTnVtYmVyO1xuXG4iLCJ2YXIgaXNLaW5kID0gcmVxdWlyZSgnLi9pc0tpbmQnKTtcbiAgICAvKipcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGlzS2luZCh2YWwsICdPYmplY3QnKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICghIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGlzIGEgcHJpbWl0aXZlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgICAgICAgLy8gVXNpbmcgc3dpdGNoIGZhbGx0aHJvdWdoIGJlY2F1c2UgaXQncyBzaW1wbGUgdG8gcmVhZCBhbmQgaXNcbiAgICAgICAgLy8gZ2VuZXJhbGx5IGZhc3Q6IGh0dHA6Ly9qc3BlcmYuY29tL3Rlc3RpbmctdmFsdWUtaXMtcHJpbWl0aXZlLzVcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzUHJpbWl0aXZlO1xuXG5cbiIsInZhciBpc0tpbmQgPSByZXF1aXJlKCcuL2lzS2luZCcpO1xuICAgIC8qKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVnRXhwKHZhbCkge1xuICAgICAgICByZXR1cm4gaXNLaW5kKHZhbCwgJ1JlZ0V4cCcpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzUmVnRXhwO1xuXG4iLCJ2YXIgaXNLaW5kID0gcmVxdWlyZSgnLi9pc0tpbmQnKTtcbiAgICAvKipcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGlzS2luZCh2YWwsICdTdHJpbmcnKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcblxuIiwiXG4gICAgdmFyIFVOREVGO1xuXG4gICAgLyoqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZih2YWwpe1xuICAgICAgICByZXR1cm4gdmFsID09PSBVTkRFRjtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc1VuZGVmO1xuXG4iLCJ2YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBib3RoIHZhbHVlcyBhcmUgbm90IGlkZW50aWNhbC9lZ2FsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNudCh4LCB5KXtcbiAgICAgICAgcmV0dXJuICFpcyh4LCB5KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzbnQ7XG5cblxuIiwiXG5cbiAgICB2YXIgX3JLaW5kID0gL15cXFtvYmplY3QgKC4qKVxcXSQvLFxuICAgICAgICBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICBVTkRFRjtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFwia2luZFwiIG9mIHZhbHVlLiAoZS5nLiBcIlN0cmluZ1wiLCBcIk51bWJlclwiLCBldGMpXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2luZE9mKHZhbCkge1xuICAgICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ051bGwnO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gVU5ERUYpIHtcbiAgICAgICAgICAgIHJldHVybiAnVW5kZWZpbmVkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfcktpbmQuZXhlYyggX3RvU3RyaW5nLmNhbGwodmFsKSApWzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0ga2luZE9mO1xuXG4iLCJ2YXIga2luZE9mID0gcmVxdWlyZSgnLi9raW5kT2YnKTtcbnZhciBHTE9CQUwgPSByZXF1aXJlKCcuL0dMT0JBTCcpO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhcnJheS1saWtlIG9iamVjdCBpbnRvIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheSh2YWwpe1xuICAgICAgICB2YXIgcmV0ID0gW10sXG4gICAgICAgICAgICBraW5kID0ga2luZE9mKHZhbCksXG4gICAgICAgICAgICBuO1xuXG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCB2YWwubGVuZ3RoID09IG51bGwgfHwga2luZCA9PT0gJ1N0cmluZycgfHwga2luZCA9PT0gJ0Z1bmN0aW9uJyB8fCBraW5kID09PSAnUmVnRXhwJyB8fCB2YWwgPT09IEdMT0JBTCApIHtcbiAgICAgICAgICAgICAgICAvL3N0cmluZywgcmVnZXhwLCBmdW5jdGlvbiBoYXZlIC5sZW5ndGggYnV0IHVzZXIgcHJvYmFibHkganVzdCB3YW50XG4gICAgICAgICAgICAgICAgLy90byB3cmFwIHZhbHVlIGludG8gYW4gYXJyYXkuLlxuICAgICAgICAgICAgICAgIHJldFtyZXQubGVuZ3RoXSA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy93aW5kb3cgcmV0dXJucyB0cnVlIG9uIGlzT2JqZWN0IGluIElFNyBhbmQgbWF5IGhhdmUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgLy9wcm9wZXJ0eS4gYHR5cGVvZiBOb2RlTGlzdGAgcmV0dXJucyBgZnVuY3Rpb25gIG9uIFNhZmFyaSBzb1xuICAgICAgICAgICAgICAgIC8vd2UgY2FuJ3QgdXNlIGl0ICgjNTgpXG4gICAgICAgICAgICAgICAgbiA9IHZhbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgICAgICAgICAgICByZXRbbl0gPSB2YWxbbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gdG9BcnJheTtcblxuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuICAgIC8qKlxuICAgICAqIGNvdmVydCB2YWx1ZSBpbnRvIG51bWJlciBpZiBudW1lcmljXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsKXtcbiAgICAgICAgLy8gbnVtYmVyaWMgdmFsdWVzIHNob3VsZCBjb21lIGZpcnN0IGJlY2F1c2Ugb2YgLTBcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSByZXR1cm4gdmFsO1xuICAgICAgICAvLyB3ZSB3YW50IGFsbCBmYWxzeSB2YWx1ZXMgKGJlc2lkZXMgLTApIHRvIHJldHVybiB6ZXJvIHRvIGF2b2lkXG4gICAgICAgIC8vIGhlYWRhY2hlc1xuICAgICAgICBpZiAoIXZhbCkgcmV0dXJuIDA7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykgcmV0dXJuIHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgLy8gYXJyYXlzIGFyZSBlZGdlIGNhc2VzLiBgTnVtYmVyKFs0XSkgPT09IDRgXG4gICAgICAgIGlmIChpc0FycmF5KHZhbCkpIHJldHVybiBOYU47XG4gICAgICAgIHJldHVybiBOdW1iZXIodmFsKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogVHlwZWNhc3QgYSB2YWx1ZSB0byBhIFN0cmluZywgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHZhbHVlIGZvciBudWxsIG9yXG4gICAgICogdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbCl7XG4gICAgICAgIHJldHVybiB2YWwgPT0gbnVsbCA/ICcnIDogdmFsLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuXG4iLCJcblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2NlaWwnIDogcmVxdWlyZSgnLi9tYXRoL2NlaWwnKSxcbiAgICAnY2xhbXAnIDogcmVxdWlyZSgnLi9tYXRoL2NsYW1wJyksXG4gICAgJ2NvdW50U3RlcHMnIDogcmVxdWlyZSgnLi9tYXRoL2NvdW50U3RlcHMnKSxcbiAgICAnZmxvb3InIDogcmVxdWlyZSgnLi9tYXRoL2Zsb29yJyksXG4gICAgJ2luUmFuZ2UnIDogcmVxdWlyZSgnLi9tYXRoL2luUmFuZ2UnKSxcbiAgICAnaXNOZWFyJyA6IHJlcXVpcmUoJy4vbWF0aC9pc05lYXInKSxcbiAgICAnbGVycCcgOiByZXF1aXJlKCcuL21hdGgvbGVycCcpLFxuICAgICdsb29wJyA6IHJlcXVpcmUoJy4vbWF0aC9sb29wJyksXG4gICAgJ21hcCcgOiByZXF1aXJlKCcuL21hdGgvbWFwJyksXG4gICAgJ25vcm0nIDogcmVxdWlyZSgnLi9tYXRoL25vcm0nKSxcbiAgICAncm91bmQnIDogcmVxdWlyZSgnLi9tYXRoL3JvdW5kJylcbn07XG5cblxuIiwiXG4gICAgLyoqXG4gICAgICogUm91bmQgdmFsdWUgdXAgd2l0aCBhIGN1c3RvbSByYWRpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjZWlsKHZhbCwgc3RlcCl7XG4gICAgICAgIHN0ZXAgPSBNYXRoLmFicyhzdGVwIHx8IDEpO1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHZhbCAvIHN0ZXApICogc3RlcDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNlaWw7XG5cbiIsIlxuICAgIC8qKlxuICAgICAqIENsYW1wcyB2YWx1ZSBpbnNpZGUgcmFuZ2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXAodmFsLCBtaW4sIG1heCl7XG4gICAgICAgIHJldHVybiB2YWwgPCBtaW4/IG1pbiA6ICh2YWwgPiBtYXg/IG1heCA6IHZhbCk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gY2xhbXA7XG5cbiIsIlxuICAgIC8qKlxuICAgICogQ291bnQgbnVtYmVyIG9mIGZ1bGwgc3RlcHMuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBjb3VudFN0ZXBzKHZhbCwgc3RlcCwgb3ZlcmZsb3cpe1xuICAgICAgICB2YWwgPSBNYXRoLmZsb29yKHZhbCAvIHN0ZXApO1xuXG4gICAgICAgIGlmIChvdmVyZmxvdykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCAlIG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvdW50U3RlcHM7XG5cbiIsIlxuICAgIC8qKlxuICAgICogRmxvb3IgdmFsdWUgdG8gZnVsbCBzdGVwcy5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGZsb29yKHZhbCwgc3RlcCl7XG4gICAgICAgIHN0ZXAgPSBNYXRoLmFicyhzdGVwIHx8IDEpO1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih2YWwgLyBzdGVwKSAqIHN0ZXA7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gZmxvb3I7XG5cbiIsIlxuICAgIC8qKlxuICAgICogQ2hlY2tzIGlmIHZhbHVlIGlzIGluc2lkZSB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBpblJhbmdlKHZhbCwgbWluLCBtYXgsIHRocmVzaG9sZCl7XG4gICAgICAgIHRocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAwO1xuICAgICAgICByZXR1cm4gKHZhbCArIHRocmVzaG9sZCA+PSBtaW4gJiYgdmFsIC0gdGhyZXNob2xkIDw9IG1heCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpblJhbmdlO1xuXG4iLCJcbiAgICAvKipcbiAgICAqIENoZWNrIGlmIHZhbHVlIGlzIGNsb3NlIHRvIHRhcmdldC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmVhcih2YWwsIHRhcmdldCwgdGhyZXNob2xkKXtcbiAgICAgICAgcmV0dXJuIChNYXRoLmFicyh2YWwgLSB0YXJnZXQpIDw9IHRocmVzaG9sZCk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNOZWFyO1xuXG4iLCJcbiAgICAvKipcbiAgICAqIExpbmVhciBpbnRlcnBvbGF0aW9uLlxuICAgICogSU1QT1JUQU5UOndpbGwgcmV0dXJuIGBJbmZpbml0eWAgaWYgbnVtYmVycyBvdmVyZmxvdyBOdW1iZXIuTUFYX1ZBTFVFXG4gICAgKi9cbiAgICBmdW5jdGlvbiBsZXJwKHJhdGlvLCBzdGFydCwgZW5kKXtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHJhdGlvO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbGVycDtcblxuIiwiXG4gICAgLyoqXG4gICAgKiBMb29wcyB2YWx1ZSBpbnNpZGUgcmFuZ2UuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBsb29wKHZhbCwgbWluLCBtYXgpe1xuICAgICAgICByZXR1cm4gdmFsIDwgbWluPyBtYXggOiAodmFsID4gbWF4PyBtaW4gOiB2YWwpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbG9vcDtcblxuIiwidmFyIGxlcnAgPSByZXF1aXJlKCcuL2xlcnAnKTtcbnZhciBub3JtID0gcmVxdWlyZSgnLi9ub3JtJyk7XG4gICAgLyoqXG4gICAgKiBNYXBzIGEgbnVtYmVyIGZyb20gb25lIHNjYWxlIHRvIGFub3RoZXIuXG4gICAgKiBAZXhhbXBsZSBtYXAoMywgMCwgNCwgLTEsIDEpIC0+IDAuNVxuICAgICovXG4gICAgZnVuY3Rpb24gbWFwKHZhbCwgbWluMSwgbWF4MSwgbWluMiwgbWF4Mil7XG4gICAgICAgIHJldHVybiBsZXJwKCBub3JtKHZhbCwgbWluMSwgbWF4MSksIG1pbjIsIG1heDIgKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYXA7XG5cbiIsIlxuICAgIC8qKlxuICAgICogR2V0cyBub3JtYWxpemVkIHJhdGlvIG9mIHZhbHVlIGluc2lkZSByYW5nZS5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm0odmFsLCBtaW4sIG1heCl7XG4gICAgICAgIGlmICh2YWwgPCBtaW4gfHwgdmFsID4gbWF4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgKCcgKyB2YWwgKyAnKSBtdXN0IGJlIGJldHdlZW4gJyArIG1pbiArICcgYW5kICcgKyBtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gbWF4ID8gMSA6ICh2YWwgLSBtaW4pIC8gKG1heCAtIG1pbik7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gbm9ybTtcblxuIiwiXG4gICAgLyoqXG4gICAgICogUm91bmQgbnVtYmVyIHRvIGEgc3BlY2lmaWMgcmFkaXhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3VuZCh2YWx1ZSwgcmFkaXgpe1xuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDE7IC8vIGRlZmF1bHQgcm91bmQgMVxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIHJhZGl4KSAqIHJhZGl4O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcm91bmQ7XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdNQVhfSU5UJyA6IHJlcXVpcmUoJy4vbnVtYmVyL01BWF9JTlQnKSxcbiAgICAnTUFYX1NBRkVfSU5URUdFUicgOiByZXF1aXJlKCcuL251bWJlci9NQVhfU0FGRV9JTlRFR0VSJyksXG4gICAgJ01BWF9VSU5UJyA6IHJlcXVpcmUoJy4vbnVtYmVyL01BWF9VSU5UJyksXG4gICAgJ01JTl9JTlQnIDogcmVxdWlyZSgnLi9udW1iZXIvTUlOX0lOVCcpLFxuICAgICdhYmJyZXZpYXRlJyA6IHJlcXVpcmUoJy4vbnVtYmVyL2FiYnJldmlhdGUnKSxcbiAgICAnY3VycmVuY3lGb3JtYXQnIDogcmVxdWlyZSgnLi9udW1iZXIvY3VycmVuY3lGb3JtYXQnKSxcbiAgICAnZW5mb3JjZVByZWNpc2lvbicgOiByZXF1aXJlKCcuL251bWJlci9lbmZvcmNlUHJlY2lzaW9uJyksXG4gICAgJ2lzTmFOJyA6IHJlcXVpcmUoJy4vbnVtYmVyL2lzTmFOJyksXG4gICAgJ250aCcgOiByZXF1aXJlKCcuL251bWJlci9udGgnKSxcbiAgICAnb3JkaW5hbCcgOiByZXF1aXJlKCcuL251bWJlci9vcmRpbmFsJyksXG4gICAgJ3BhZCcgOiByZXF1aXJlKCcuL251bWJlci9wYWQnKSxcbiAgICAncm9sJyA6IHJlcXVpcmUoJy4vbnVtYmVyL3JvbCcpLFxuICAgICdyb3InIDogcmVxdWlyZSgnLi9udW1iZXIvcm9yJyksXG4gICAgJ3NpZ24nIDogcmVxdWlyZSgnLi9udW1iZXIvc2lnbicpLFxuICAgICd0b0ludCcgOiByZXF1aXJlKCcuL251bWJlci90b0ludCcpLFxuICAgICd0b1VJbnQnIDogcmVxdWlyZSgnLi9udW1iZXIvdG9VSW50JyksXG4gICAgJ3RvVUludDMxJyA6IHJlcXVpcmUoJy4vbnVtYmVyL3RvVUludDMxJylcbn07XG5cblxuIiwiLyoqXG4gKiBAY29uc3RhbnQgTWF4aW11bSAzMi1iaXQgc2lnbmVkIGludGVnZXIgdmFsdWUuICgyXjMxIC0gMSlcbiAqL1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSAyMTQ3NDgzNjQ3O1xuXG4iLCJcblxuICAgIC8vIG1heGltdW0gc2FmZSBpbnRlZ2VyIChNYXRoLnBvdygyLCA1MykgLSAxKVxuICAgIC8vIHNlZTogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cblxuIiwiLyoqXG4gKiBAY29uc3RhbnQgTWF4aW11bSAzMi1iaXQgdW5zaWduZWQgaW50ZWdldCB2YWx1ZSAoMl4zMiAtIDEpXG4gKi9cblxuICAgIG1vZHVsZS5leHBvcnRzID0gNDI5NDk2NzI5NTtcblxuIiwiLyoqXG4gKiBAY29uc3RhbnQgTWluaW11bSAzMi1iaXQgc2lnbmVkIGludGVnZXIgdmFsdWUgKC0yXjMxKS5cbiAqL1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSAtMjE0NzQ4MzY0ODtcblxuIiwidmFyIGVuZm9yY2VQcmVjaXNpb24gPSByZXF1aXJlKCcuL2VuZm9yY2VQcmVjaXNpb24nKTtcblxuICAgIHZhciBfZGVmYXVsdERpY3QgPSB7XG4gICAgICAgIHRob3VzYW5kIDogJ0snLFxuICAgICAgICBtaWxsaW9uIDogJ00nLFxuICAgICAgICBiaWxsaW9uIDogJ0InXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFiYnJldmlhdGUgbnVtYmVyIGlmIGJpZ2dlciB0aGFuIDEwMDAuIChlZzogMi41SywgMTcuNU0sIDMuNEIsIC4uLilcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhYmJyZXZpYXRlTnVtYmVyKHZhbCwgbkRlY2ltYWxzLCBkaWN0KXtcbiAgICAgICAgbkRlY2ltYWxzID0gbkRlY2ltYWxzICE9IG51bGw/IG5EZWNpbWFscyA6IDE7XG4gICAgICAgIGRpY3QgPSBkaWN0IHx8IF9kZWZhdWx0RGljdDtcbiAgICAgICAgdmFsID0gZW5mb3JjZVByZWNpc2lvbih2YWwsIG5EZWNpbWFscyk7XG5cbiAgICAgICAgdmFyIHN0ciwgbW9kO1xuXG4gICAgICAgIGlmICh2YWwgPCAxMDAwMDAwKSB7XG4gICAgICAgICAgICBtb2QgPSBlbmZvcmNlUHJlY2lzaW9uKHZhbCAvIDEwMDAsIG5EZWNpbWFscyk7XG4gICAgICAgICAgICAvLyBtaWdodCBvdmVyZmxvdyB0byBuZXh0IHNjYWxlIGR1cmluZyByb3VuZGluZ1xuICAgICAgICAgICAgc3RyID0gbW9kIDwgMTAwMD8gbW9kICsgZGljdC50aG91c2FuZCA6IDEgKyBkaWN0Lm1pbGxpb247XG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDwgMTAwMDAwMDAwMCkge1xuICAgICAgICAgICAgbW9kID0gZW5mb3JjZVByZWNpc2lvbih2YWwgLyAxMDAwMDAwLCBuRGVjaW1hbHMpO1xuICAgICAgICAgICAgc3RyID0gbW9kIDwgMTAwMD8gbW9kICsgZGljdC5taWxsaW9uIDogMSArIGRpY3QuYmlsbGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IGVuZm9yY2VQcmVjaXNpb24odmFsIC8gMTAwMDAwMDAwMCwgbkRlY2ltYWxzKSArIGRpY3QuYmlsbGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBhYmJyZXZpYXRlTnVtYmVyO1xuXG5cbiIsInZhciB0b051bWJlciA9IHJlcXVpcmUoJy4uL2xhbmcvdG9OdW1iZXInKTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIG51bWJlciBpbnRvIGN1cnJlbmN5IGZvcm1hdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJlbmN5Rm9ybWF0KHZhbCwgbkRlY2ltYWxEaWdpdHMsIGRlY2ltYWxTZXBhcmF0b3IsIHRob3VzYW5kc1NlcGFyYXRvcikge1xuICAgICAgICB2YWwgPSB0b051bWJlcih2YWwpO1xuICAgICAgICBuRGVjaW1hbERpZ2l0cyA9IG5EZWNpbWFsRGlnaXRzID09IG51bGw/IDIgOiBuRGVjaW1hbERpZ2l0cztcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvciA9IGRlY2ltYWxTZXBhcmF0b3IgPT0gbnVsbD8gJy4nIDogZGVjaW1hbFNlcGFyYXRvcjtcbiAgICAgICAgdGhvdXNhbmRzU2VwYXJhdG9yID0gdGhvdXNhbmRzU2VwYXJhdG9yID09IG51bGw/ICcsJyA6IHRob3VzYW5kc1NlcGFyYXRvcjtcblxuICAgICAgICAvL2Nhbid0IHVzZSBlbmZvcmNlIHByZWNpc2lvbiBzaW5jZSBpdCByZXR1cm5zIGEgbnVtYmVyIGFuZCB3ZSBhcmVcbiAgICAgICAgLy9kb2luZyBhIFJlZ0V4cCBvdmVyIHRoZSBzdHJpbmdcbiAgICAgICAgdmFyIGZpeGVkID0gdmFsLnRvRml4ZWQobkRlY2ltYWxEaWdpdHMpLFxuICAgICAgICAgICAgLy9zZXBhcmF0ZSBiZWdpbiBbJDFdLCBtaWRkbGUgWyQyXSBhbmQgZGVjaW1hbCBkaWdpdHMgWyQ0XVxuICAgICAgICAgICAgcGFydHMgPSBuZXcgUmVnRXhwKCdeKC0/XFxcXGR7MSwzfSkoKD86XFxcXGR7M30pKykoXFxcXC4oXFxcXGR7JysgbkRlY2ltYWxEaWdpdHMgKyd9KSk/JCcpLmV4ZWMoIGZpeGVkICk7XG5cbiAgICAgICAgaWYocGFydHMpeyAvL3ZhbCA+PSAxMDAwIHx8IHZhbCA8PSAtMTAwMFxuICAgICAgICAgICAgcmV0dXJuIHBhcnRzWzFdICsgcGFydHNbMl0ucmVwbGFjZSgvXFxkezN9L2csIHRob3VzYW5kc1NlcGFyYXRvciArICckJicpICsgKHBhcnRzWzRdID8gZGVjaW1hbFNlcGFyYXRvciArIHBhcnRzWzRdIDogJycpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJldHVybiBmaXhlZC5yZXBsYWNlKCcuJywgZGVjaW1hbFNlcGFyYXRvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGN1cnJlbmN5Rm9ybWF0O1xuXG5cbiIsInZhciB0b051bWJlciA9IHJlcXVpcmUoJy4uL2xhbmcvdG9OdW1iZXInKTtcbiAgICAvKipcbiAgICAgKiBFbmZvcmNlIGEgc3BlY2lmaWMgYW1vdW50IG9mIGRlY2ltYWwgZGlnaXRzIGFuZCBhbHNvIGZpeCBmbG9hdGluZ1xuICAgICAqIHBvaW50IHJvdW5kaW5nIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmZvcmNlUHJlY2lzaW9uKHZhbCwgbkRlY2ltYWxEaWdpdHMpe1xuICAgICAgICB2YWwgPSB0b051bWJlcih2YWwpO1xuICAgICAgICB2YXIgcG93ID0gTWF0aC5wb3coMTAsIG5EZWNpbWFsRGlnaXRzKTtcbiAgICAgICAgcmV0dXJuICsoTWF0aC5yb3VuZCh2YWwgKiBwb3cpIC8gcG93KS50b0ZpeGVkKG5EZWNpbWFsRGlnaXRzKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlbmZvcmNlUHJlY2lzaW9uO1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIEVTNiBOdW1iZXIuaXNOYU5cbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNOYU5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWwpe1xuICAgICAgICAvLyBqc2hpbnQgZXFlcWVxOmZhbHNlXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiB2YWwgIT0gdmFsO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNOYU47XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFwibnRoXCIgb2YgbnVtYmVyICgxID0gXCJzdFwiLCAyID0gXCJuZFwiLCAzID0gXCJyZFwiLCA0Li4xMCA9IFwidGhcIiwgLi4uKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aChpKSB7XG4gICAgICAgIHZhciB0ID0gKGkgJSAxMDApO1xuICAgICAgICBpZiAodCA+PSAxMCAmJiB0IDw9IDIwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RoJztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2goaSAlIDEwKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdzdCc7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICduZCc7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZCc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAndGgnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBudGg7XG5cblxuIiwidmFyIHRvSW50ID0gcmVxdWlyZSgnLi90b0ludCcpO1xudmFyIG50aCA9IHJlcXVpcmUoJy4vbnRoJyk7XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBudW1iZXIgaW50byBvcmRpbmFsIGZvcm0gKDFzdCwgMm5kLCAzcmQsIDR0aCwgLi4uKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9yZGluYWwobil7XG4gICAgICAgbiA9IHRvSW50KG4pO1xuICAgICAgIHJldHVybiBuICsgbnRoKG4pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gb3JkaW5hbDtcblxuXG4iLCJ2YXIgbHBhZCA9IHJlcXVpcmUoJy4uL3N0cmluZy9scGFkJyk7XG52YXIgdG9OdW1iZXIgPSByZXF1aXJlKCcuLi9sYW5nL3RvTnVtYmVyJyk7XG5cbiAgICAvKipcbiAgICAgKiBBZGQgcGFkZGluZyB6ZXJvcyBpZiBuLmxlbmd0aCA8IG1pbkxlbmd0aC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQobiwgbWluTGVuZ3RoLCBjaGFyKXtcbiAgICAgICAgbiA9IHRvTnVtYmVyKG4pO1xuICAgICAgICByZXR1cm4gbHBhZCgnJysgbiwgbWluTGVuZ3RoLCBjaGFyIHx8ICcwJyk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYWQ7XG5cblxuIiwiXG4gICAgLyoqXG4gICAgICogQml0d2lzZSBjaXJjdWxhciBzaGlmdCBsZWZ0XG4gICAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DaXJjdWxhcl9zaGlmdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvbCh2YWwsIHNoaWZ0KXtcbiAgICAgICAgcmV0dXJuICh2YWwgPDwgc2hpZnQpIHwgKHZhbCA+PiAoMzIgLSBzaGlmdCkpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJvbDtcblxuIiwiXG4gICAgLyoqXG4gICAgICogQml0d2lzZSBjaXJjdWxhciBzaGlmdCByaWdodFxuICAgICAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2lyY3VsYXJfc2hpZnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3IodmFsLCBzaGlmdCl7XG4gICAgICAgIHJldHVybiAodmFsID4+IHNoaWZ0KSB8ICh2YWwgPDwgKDMyIC0gc2hpZnQpKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByb3I7XG5cbiIsInZhciB0b051bWJlciA9IHJlcXVpcmUoJy4uL2xhbmcvdG9OdW1iZXInKTtcblxuICAgIC8qKlxuICAgICAqIEdldCBzaWduIG9mIHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKHZhbCkge1xuICAgICAgICB2YXIgbnVtID0gdG9OdW1iZXIodmFsKTtcbiAgICAgICAgaWYgKG51bSA9PT0gMCkgcmV0dXJuIG51bTsgLy8gKzAgYW5kICswID09PSAwXG4gICAgICAgIGlmIChpc05hTihudW0pKSByZXR1cm4gbnVtOyAvLyBOYU5cbiAgICAgICAgcmV0dXJuIG51bSA8IDA/IC0xIDogMTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNpZ247XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBcIkNvbnZlcnRcIiB2YWx1ZSBpbnRvIGFuIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqIFdvcmtzIGxpa2UgYE1hdGguZmxvb3JgIGlmIHZhbCA+IDAgYW5kIGBNYXRoLmNlaWxgIGlmIHZhbCA8IDAuXG4gICAgICogSU1QT1JUQU5UOiB2YWwgd2lsbCB3cmFwIGF0IDJeMzEgYW5kIC0yXjMxLlxuICAgICAqIFBlcmYgdGVzdHM6IGh0dHA6Ly9qc3BlcmYuY29tL3ZzLXZzLXBhcnNlaW50LWJpdHdpc2Utb3BlcmF0b3JzLzdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0ludCh2YWwpe1xuICAgICAgICAvLyB3ZSBkbyBub3QgdXNlIGxhbmcvdG9OdW1iZXIgYmVjYXVzZSBvZiBwZXJmIGFuZCBhbHNvIGJlY2F1c2UgaXRcbiAgICAgICAgLy8gZG9lc24ndCBicmVhayB0aGUgZnVuY3Rpb25hbGl0eVxuICAgICAgICByZXR1cm4gfn52YWw7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b0ludDtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFwiQ29udmVydFwiIHZhbHVlIGludG8gYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlci5cbiAgICAgKiBJTVBPUlRBTlQ6IFZhbHVlIHdpbGwgd3JhcCBhdCAyXjMyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvVUludCh2YWwpe1xuICAgICAgICAvLyB3ZSBkbyBub3QgdXNlIGxhbmcvdG9OdW1iZXIgYmVjYXVzZSBvZiBwZXJmIGFuZCBhbHNvIGJlY2F1c2UgaXRcbiAgICAgICAgLy8gZG9lc24ndCBicmVhayB0aGUgZnVuY3Rpb25hbGl0eVxuICAgICAgICByZXR1cm4gdmFsID4+PiAwO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdG9VSW50O1xuXG5cbiIsInZhciBNQVhfSU5UID0gcmVxdWlyZSgnLi9NQVhfSU5UJyk7XG5cbiAgICAvKipcbiAgICAgKiBcIkNvbnZlcnRcIiB2YWx1ZSBpbnRvIGFuIDMxLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIChzaW5jZSAxIGJpdCBpcyB1c2VkIGZvciBzaWduKS5cbiAgICAgKiBJTVBPUlRBTlQ6IHZhbHVlIHdpbCB3cmFwIGF0IDJeMzEsIGlmIG5lZ2F0aXZlIHdpbGwgcmV0dXJuIDAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9VSW50MzEodmFsKXtcbiAgICAgICAgLy8gd2UgZG8gbm90IHVzZSBsYW5nL3RvTnVtYmVyIGJlY2F1c2Ugb2YgcGVyZiBhbmQgYWxzbyBiZWNhdXNlIGl0XG4gICAgICAgIC8vIGRvZXNuJ3QgYnJlYWsgdGhlIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgcmV0dXJuICh2YWwgPD0gMCk/IDAgOiAodmFsID4gTUFYX0lOVD8gfn4odmFsICUgKE1BWF9JTlQgKyAxKSkgOiB+fnZhbCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b1VJbnQzMTtcblxuXG4iLCJcblxuLy9hdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCwgZG8gbm90IGVkaXQhXG4vL3J1biBgbm9kZSBidWlsZGAgaW5zdGVhZFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2JpbmRBbGwnIDogcmVxdWlyZSgnLi9vYmplY3QvYmluZEFsbCcpLFxuICAgICdjb250YWlucycgOiByZXF1aXJlKCcuL29iamVjdC9jb250YWlucycpLFxuICAgICdkZWVwRmlsbEluJyA6IHJlcXVpcmUoJy4vb2JqZWN0L2RlZXBGaWxsSW4nKSxcbiAgICAnZGVlcE1hdGNoZXMnIDogcmVxdWlyZSgnLi9vYmplY3QvZGVlcE1hdGNoZXMnKSxcbiAgICAnZGVlcE1peEluJyA6IHJlcXVpcmUoJy4vb2JqZWN0L2RlZXBNaXhJbicpLFxuICAgICdlcXVhbHMnIDogcmVxdWlyZSgnLi9vYmplY3QvZXF1YWxzJyksXG4gICAgJ2V2ZXJ5JyA6IHJlcXVpcmUoJy4vb2JqZWN0L2V2ZXJ5JyksXG4gICAgJ2ZpbGxJbicgOiByZXF1aXJlKCcuL29iamVjdC9maWxsSW4nKSxcbiAgICAnZmlsdGVyJyA6IHJlcXVpcmUoJy4vb2JqZWN0L2ZpbHRlcicpLFxuICAgICdmaW5kJyA6IHJlcXVpcmUoJy4vb2JqZWN0L2ZpbmQnKSxcbiAgICAnZm9ySW4nIDogcmVxdWlyZSgnLi9vYmplY3QvZm9ySW4nKSxcbiAgICAnZm9yT3duJyA6IHJlcXVpcmUoJy4vb2JqZWN0L2Zvck93bicpLFxuICAgICdmdW5jdGlvbnMnIDogcmVxdWlyZSgnLi9vYmplY3QvZnVuY3Rpb25zJyksXG4gICAgJ2dldCcgOiByZXF1aXJlKCcuL29iamVjdC9nZXQnKSxcbiAgICAnaGFzJyA6IHJlcXVpcmUoJy4vb2JqZWN0L2hhcycpLFxuICAgICdoYXNPd24nIDogcmVxdWlyZSgnLi9vYmplY3QvaGFzT3duJyksXG4gICAgJ2tleXMnIDogcmVxdWlyZSgnLi9vYmplY3Qva2V5cycpLFxuICAgICdtYXAnIDogcmVxdWlyZSgnLi9vYmplY3QvbWFwJyksXG4gICAgJ21hdGNoZXMnIDogcmVxdWlyZSgnLi9vYmplY3QvbWF0Y2hlcycpLFxuICAgICdtYXgnIDogcmVxdWlyZSgnLi9vYmplY3QvbWF4JyksXG4gICAgJ21lcmdlJyA6IHJlcXVpcmUoJy4vb2JqZWN0L21lcmdlJyksXG4gICAgJ21pbicgOiByZXF1aXJlKCcuL29iamVjdC9taW4nKSxcbiAgICAnbWl4SW4nIDogcmVxdWlyZSgnLi9vYmplY3QvbWl4SW4nKSxcbiAgICAnbmFtZXNwYWNlJyA6IHJlcXVpcmUoJy4vb2JqZWN0L25hbWVzcGFjZScpLFxuICAgICdvbWl0JyA6IHJlcXVpcmUoJy4vb2JqZWN0L29taXQnKSxcbiAgICAncGljaycgOiByZXF1aXJlKCcuL29iamVjdC9waWNrJyksXG4gICAgJ3BsdWNrJyA6IHJlcXVpcmUoJy4vb2JqZWN0L3BsdWNrJyksXG4gICAgJ3JlZHVjZScgOiByZXF1aXJlKCcuL29iamVjdC9yZWR1Y2UnKSxcbiAgICAncmVqZWN0JyA6IHJlcXVpcmUoJy4vb2JqZWN0L3JlamVjdCcpLFxuICAgICdyZXN1bHQnIDogcmVxdWlyZSgnLi9vYmplY3QvcmVzdWx0JyksXG4gICAgJ3NldCcgOiByZXF1aXJlKCcuL29iamVjdC9zZXQnKSxcbiAgICAnc2l6ZScgOiByZXF1aXJlKCcuL29iamVjdC9zaXplJyksXG4gICAgJ3NvbWUnIDogcmVxdWlyZSgnLi9vYmplY3Qvc29tZScpLFxuICAgICd1bnNldCcgOiByZXF1aXJlKCcuL29iamVjdC91bnNldCcpLFxuICAgICd2YWx1ZXMnIDogcmVxdWlyZSgnLi9vYmplY3QvdmFsdWVzJylcbn07XG5cblxuIiwidmFyIGZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL2JpbmQnKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vYXJyYXkvZm9yRWFjaCcpO1xudmFyIHNsaWNlID0gcmVxdWlyZSgnLi4vYXJyYXkvc2xpY2UnKTtcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgdGhlIG9iamVjdCB0byBiZSBydW4gaW4gaXQncyBvd24gY29udGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kQWxsKG9iaiwgcmVzdF9tZXRob2ROYW1lcyl7XG4gICAgICAgIHZhciBrZXlzID0gYXJndW1lbnRzLmxlbmd0aCA+IDE/XG4gICAgICAgICAgICAgICAgICAgIHNsaWNlKGFyZ3VtZW50cywgMSkgOiBmdW5jdGlvbnMob2JqKTtcbiAgICAgICAgZm9yRWFjaChrZXlzLCBmdW5jdGlvbihrZXkpe1xuICAgICAgICAgICAgb2JqW2tleV0gPSBiaW5kKG9ialtrZXldLCBvYmopO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJpbmRBbGw7XG5cblxuIiwidmFyIHNvbWUgPSByZXF1aXJlKCcuL3NvbWUnKTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIG9iamVjdCBjb250YWlucyB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKG9iaiwgbmVlZGxlKSB7XG4gICAgICAgIHJldHVybiBzb21lKG9iaiwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbCA9PT0gbmVlZGxlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gY29udGFpbnM7XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNQbGFpbk9iamVjdCcpO1xuXG4gICAgLyoqXG4gICAgICogRGVlcGx5IGNvcHkgbWlzc2luZyBwcm9wZXJ0aWVzIGluIHRoZSB0YXJnZXQgZnJvbSB0aGUgZGVmYXVsdHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVlcEZpbGxJbih0YXJnZXQsIGRlZmF1bHRzKXtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBvYmo7XG5cbiAgICAgICAgd2hpbGUoKytpIDwgbikge1xuICAgICAgICAgICAgb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgICAgIC8vIGpzaGludCBsb29wZnVuYzogdHJ1ZVxuICAgICAgICAgICAgICAgIGZvck93bihvYmosIGZ1bmN0aW9uKG5ld1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1clZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoY3VyVmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQbGFpbk9iamVjdChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBGaWxsSW4oY3VyVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZXBGaWxsSW47XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpO1xuXG4gICAgZnVuY3Rpb24gY29udGFpbnNNYXRjaChhcnJheSwgcGF0dGVybikge1xuICAgICAgICB2YXIgaSA9IC0xLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChkZWVwTWF0Y2hlcyhhcnJheVtpXSwgcGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEFycmF5KHRhcmdldCwgcGF0dGVybikge1xuICAgICAgICB2YXIgaSA9IC0xLCBwYXR0ZXJuTGVuZ3RoID0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBwYXR0ZXJuTGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5zTWF0Y2godGFyZ2V0LCBwYXR0ZXJuW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoT2JqZWN0KHRhcmdldCwgcGF0dGVybikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgZm9yT3duKHBhdHRlcm4sIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgICAgICBpZiAoIWRlZXBNYXRjaGVzKHRhcmdldFtrZXldLCB2YWwpKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIHRvIGJyZWFrIG91dCBvZiBmb3JPd24gZWFybHlcbiAgICAgICAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBjaGVjayBpZiB0aGUgb2JqZWN0cyBtYXRjaC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWVwTWF0Y2hlcyh0YXJnZXQsIHBhdHRlcm4pe1xuICAgICAgICBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzQXJyYXkocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hBcnJheSh0YXJnZXQsIHBhdHRlcm4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hPYmplY3QodGFyZ2V0LCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQgPT09IHBhdHRlcm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZXBNYXRjaGVzO1xuXG5cbiIsInZhciBmb3JPd24gPSByZXF1aXJlKCcuL2Zvck93bicpO1xudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzUGxhaW5PYmplY3QnKTtcblxuICAgIC8qKlxuICAgICAqIE1peGVzIG9iamVjdHMgaW50byB0aGUgdGFyZ2V0IG9iamVjdCwgcmVjdXJzaXZlbHkgbWl4aW5nIGV4aXN0aW5nIGNoaWxkXG4gICAgICogb2JqZWN0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWVwTWl4SW4odGFyZ2V0LCBvYmplY3RzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIG4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgb2JqO1xuXG4gICAgICAgIHdoaWxlKCsraSA8IG4pe1xuICAgICAgICAgICAgb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgICAgIGZvck93bihvYmosIGNvcHlQcm9wLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3B5UHJvcCh2YWwsIGtleSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzW2tleV07XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHZhbCkgJiYgaXNQbGFpbk9iamVjdChleGlzdGluZykpIHtcbiAgICAgICAgICAgIGRlZXBNaXhJbihleGlzdGluZywgdmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZGVlcE1peEluO1xuXG5cbiIsInZhciBoYXNPd24gPSByZXF1aXJlKCcuL2hhc093bicpO1xudmFyIGV2ZXJ5ID0gcmVxdWlyZSgnLi9ldmVyeScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc09iamVjdCcpO1xudmFyIGlzID0gcmVxdWlyZSgnLi4vbGFuZy9pcycpO1xuXG4gICAgLy8gTWFrZXMgYSBmdW5jdGlvbiB0byBjb21wYXJlIHRoZSBvYmplY3QgdmFsdWVzIGZyb20gdGhlIHNwZWNpZmllZCBjb21wYXJlXG4gICAgLy8gb3BlcmF0aW9uIGNhbGxiYWNrLlxuICAgIGZ1bmN0aW9uIG1ha2VDb21wYXJlKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzT3duKHRoaXMsIGtleSkgJiYgY2FsbGJhY2sodmFsdWUsIHRoaXNba2V5XSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tQcm9wZXJ0aWVzKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGhhc093bih0aGlzLCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0d28gb2JqZWN0cyBoYXZlIHRoZSBzYW1lIGtleXMgYW5kIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYiwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBpcztcblxuICAgICAgICBpZiAoIWlzT2JqZWN0KGEpIHx8ICFpc09iamVjdChiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGEsIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChldmVyeShhLCBtYWtlQ29tcGFyZShjYWxsYmFjayksIGIpICYmXG4gICAgICAgICAgICAgICAgZXZlcnkoYiwgY2hlY2tQcm9wZXJ0aWVzLCBhKSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlcXVhbHM7XG5cbiIsInZhciBmb3JPd24gPSByZXF1aXJlKCcuL2Zvck93bicpO1xudmFyIG1ha2VJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL21ha2VJdGVyYXRvcl8nKTtcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBldmVyeVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KG9iaiwgY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgICAgICAgY2FsbGJhY2sgPSBtYWtlSXRlcmF0b3IoY2FsbGJhY2ssIHRoaXNPYmopO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgZm9yT3duKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgICAgIC8vIHdlIGNvbnNpZGVyIGFueSBmYWxzeSB2YWx1ZXMgYXMgXCJmYWxzZVwiIG9uIHB1cnBvc2Ugc28gc2hvcnRoYW5kXG4gICAgICAgICAgICAvLyBzeW50YXggY2FuIGJlIHVzZWQgdG8gY2hlY2sgcHJvcGVydHkgZXhpc3RlbmNlXG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrKHZhbCwga2V5LCBvYmopKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGV2ZXJ5O1xuXG5cbiIsInZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vYXJyYXkvZm9yRWFjaCcpO1xudmFyIHNsaWNlID0gcmVxdWlyZSgnLi4vYXJyYXkvc2xpY2UnKTtcbnZhciBmb3JPd24gPSByZXF1aXJlKCcuL2Zvck93bicpO1xuXG4gICAgLyoqXG4gICAgICogQ29weSBtaXNzaW5nIHByb3BlcnRpZXMgaW4gdGhlIG9iaiBmcm9tIHRoZSBkZWZhdWx0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWxsSW4ob2JqLCB2YXJfZGVmYXVsdHMpe1xuICAgICAgICBmb3JFYWNoKHNsaWNlKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKGJhc2Upe1xuICAgICAgICAgICAgZm9yT3duKGJhc2UsIGZ1bmN0aW9uKHZhbCwga2V5KXtcbiAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaWxsSW47XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG52YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgd2hlcmUgdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgICAgKiB0cnVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlclZhbHVlcyhvYmosIGNhbGxiYWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbWFrZUl0ZXJhdG9yKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHt9O1xuICAgICAgICBmb3JPd24ob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmopKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXJWYWx1ZXM7XG5cbiIsInZhciBzb21lID0gcmVxdWlyZSgnLi9zb21lJyk7XG52YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaXJzdCBpdGVtIHRoYXQgbWF0Y2hlcyBjcml0ZXJpYVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmQob2JqLCBjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgdGhpc09iaik7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHNvbWUob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmopKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaW5kO1xuXG5cbiIsInZhciBoYXNPd24gPSByZXF1aXJlKCcuL2hhc093bicpO1xuXG4gICAgdmFyIF9oYXNEb250RW51bUJ1ZyxcbiAgICAgICAgX2RvbnRFbnVtcztcblxuICAgIGZ1bmN0aW9uIGNoZWNrRG9udEVudW0oKXtcbiAgICAgICAgX2RvbnRFbnVtcyA9IFtcbiAgICAgICAgICAgICAgICAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICd0b0xvY2FsZVN0cmluZycsXG4gICAgICAgICAgICAgICAgJ3ZhbHVlT2YnLFxuICAgICAgICAgICAgICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgICAgICAgICAgICAgJ2NvbnN0cnVjdG9yJ1xuICAgICAgICAgICAgXTtcblxuICAgICAgICBfaGFzRG9udEVudW1CdWcgPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB7J3RvU3RyaW5nJzogbnVsbH0pIHtcbiAgICAgICAgICAgIF9oYXNEb250RW51bUJ1ZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBBcnJheS9mb3JFYWNoIGJ1dCB3b3JrcyBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzIGFuZCBmaXhlcyBEb24ndFxuICAgICAqIEVudW0gYnVnIG9uIElFLlxuICAgICAqIGJhc2VkIG9uOiBodHRwOi8vd2hhdHRoZWhlYWRzYWlkLmNvbS8yMDEwLzEwL2Etc2FmZXItb2JqZWN0LWtleXMtY29tcGF0aWJpbGl0eS1pbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluKG9iaiwgZm4sIHRoaXNPYmope1xuICAgICAgICB2YXIga2V5LCBpID0gMDtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBjaGVjayBpZiBhcmd1bWVudCBpcyBhIHJlYWwgb2JqZWN0IHRoYXQgd2F5IHdlIGNhbiB1c2VcbiAgICAgICAgLy8gaXQgZm9yIGFycmF5cywgZnVuY3Rpb25zLCBkYXRlLCBldGMuXG5cbiAgICAgICAgLy9wb3N0LXBvbmUgY2hlY2sgdGlsbCBuZWVkZWRcbiAgICAgICAgaWYgKF9oYXNEb250RW51bUJ1ZyA9PSBudWxsKSBjaGVja0RvbnRFbnVtKCk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoZXhlYyhmbiwgb2JqLCBrZXksIHRoaXNPYmopID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoX2hhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgICAgICB2YXIgY3RvciA9IG9iai5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgICBpc1Byb3RvID0gISFjdG9yICYmIG9iaiA9PT0gY3Rvci5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgIHdoaWxlIChrZXkgPSBfZG9udEVudW1zW2krK10pIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgY29uc3RydWN0b3IsIGlmIGl0IGlzIGEgcHJvdG90eXBlIG9iamVjdCB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAvLyBpcyBhbHdheXMgbm9uLWVudW1lcmFibGUgdW5sZXNzIGRlZmluZWQgb3RoZXJ3aXNlIChhbmRcbiAgICAgICAgICAgICAgICAvLyBlbnVtZXJhdGVkIGFib3ZlKS4gIEZvciBub24tcHJvdG90eXBlIG9iamVjdHMsIGl0IHdpbGwgaGF2ZVxuICAgICAgICAgICAgICAgIC8vIHRvIGJlIGRlZmluZWQgb24gdGhpcyBvYmplY3QsIHNpbmNlIGl0IGNhbm5vdCBiZSBkZWZpbmVkIG9uXG4gICAgICAgICAgICAgICAgLy8gYW55IHByb3RvdHlwZSBvYmplY3RzLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gRm9yIG90aGVyIFtbRG9udEVudW1dXSBwcm9wZXJ0aWVzLCBjaGVjayBpZiB0aGUgdmFsdWUgaXNcbiAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbnQgdGhhbiBPYmplY3QgcHJvdG90eXBlIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKGtleSAhPT0gJ2NvbnN0cnVjdG9yJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCFpc1Byb3RvICYmIGhhc093bihvYmosIGtleSkpKSAmJlxuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSAhPT0gT2JqZWN0LnByb3RvdHlwZVtrZXldXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGVjKGZuLCBvYmosIGtleSwgdGhpc09iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4ZWMoZm4sIG9iaiwga2V5LCB0aGlzT2JqKXtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpc09iaiwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZvckluO1xuXG5cbiIsInZhciBoYXNPd24gPSByZXF1aXJlKCcuL2hhc093bicpO1xudmFyIGZvckluID0gcmVxdWlyZSgnLi9mb3JJbicpO1xuXG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBBcnJheS9mb3JFYWNoIGJ1dCB3b3JrcyBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzIGFuZCBmaXhlcyBEb24ndFxuICAgICAqIEVudW0gYnVnIG9uIElFLlxuICAgICAqIGJhc2VkIG9uOiBodHRwOi8vd2hhdHRoZWhlYWRzYWlkLmNvbS8yMDEwLzEwL2Etc2FmZXItb2JqZWN0LWtleXMtY29tcGF0aWJpbGl0eS1pbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93bihvYmosIGZuLCB0aGlzT2JqKXtcbiAgICAgICAgZm9ySW4ob2JqLCBmdW5jdGlvbih2YWwsIGtleSl7XG4gICAgICAgICAgICBpZiAoaGFzT3duKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXNPYmosIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZm9yT3duO1xuXG5cbiIsInZhciBmb3JJbiA9IHJlcXVpcmUoJy4vZm9ySW4nKTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIGxpc3Qgb2YgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iail7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvckluKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpe1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGtleXMuc29ydCgpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb25zO1xuXG5cbiIsInZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNQcmltaXRpdmUnKTtcblxuICAgIC8qKlxuICAgICAqIGdldCBcIm5lc3RlZFwiIG9iamVjdCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChvYmosIHByb3Ape1xuICAgICAgICB2YXIgcGFydHMgPSBwcm9wLnNwbGl0KCcuJyksXG4gICAgICAgICAgICBsYXN0ID0gcGFydHMucG9wKCk7XG5cbiAgICAgICAgd2hpbGUgKHByb3AgPSBwYXJ0cy5zaGlmdCgpKSB7XG4gICAgICAgICAgICBvYmogPSBvYmpbcHJvcF07XG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmpbbGFzdF07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG5cblxuIiwidmFyIGdldCA9IHJlcXVpcmUoJy4vZ2V0Jyk7XG5cbiAgICB2YXIgVU5ERUY7XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBvYmplY3QgaGFzIG5lc3RlZCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqLCBwcm9wKXtcbiAgICAgICAgcmV0dXJuIGdldChvYmosIHByb3ApICE9PSBVTkRFRjtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGhhcztcblxuXG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogU2FmZXIgT2JqZWN0Lmhhc093blByb3BlcnR5XG4gICAgICovXG4gICAgIGZ1bmN0aW9uIGhhc093bihvYmosIHByb3Ape1xuICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuICAgICB9XG5cbiAgICAgbW9kdWxlLmV4cG9ydHMgPSBoYXNPd247XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgb2JqZWN0IGtleXNcbiAgICAgKi9cbiAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yT3duKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpe1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ga2V5cztcblxuXG4iLCJ2YXIgZm9yT3duID0gcmVxdWlyZSgnLi9mb3JPd24nKTtcbnZhciBtYWtlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi9tYWtlSXRlcmF0b3JfJyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aGVyZSBhbGwgdGhlIHZhbHVlcyBhcmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nXG4gICAgICogYGNhbGxiYWNrYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqLCBjYWxsYmFjaywgdGhpc09iaikge1xuICAgICAgICBjYWxsYmFjayA9IG1ha2VJdGVyYXRvcihjYWxsYmFjaywgdGhpc09iaik7XG4gICAgICAgIHZhciBvdXRwdXQgPSB7fTtcbiAgICAgICAgZm9yT3duKG9iaiwgZnVuY3Rpb24odmFsLCBrZXksIG9iaikge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBjYWxsYmFjayh2YWwsIGtleSwgb2JqKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYXBWYWx1ZXM7XG5cbiIsInZhciBmb3JPd24gPSByZXF1aXJlKCcuL2Zvck93bicpO1xuXG4gICAgLyoqXG4gICAgICogY2hlY2tzIGlmIGEgb2JqZWN0IGNvbnRhaW5zIGFsbCBnaXZlbiBwcm9wZXJ0aWVzL3ZhbHVlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXModGFyZ2V0LCBwcm9wcyl7XG4gICAgICAgIC8vIGNhbid0IHVzZSBcIm9iamVjdC9ldmVyeVwiIGJlY2F1c2Ugb2YgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgZm9yT3duKHByb3BzLCBmdW5jdGlvbih2YWwsIGtleSl7XG4gICAgICAgICAgICBpZiAodGFyZ2V0W2tleV0gIT09IHZhbCkge1xuICAgICAgICAgICAgICAgIC8vIGJyZWFrIGxvb3AgYXQgZmlyc3QgZGlmZmVyZW5jZVxuICAgICAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1hdGNoZXM7XG5cblxuIiwidmFyIGFyck1heCA9IHJlcXVpcmUoJy4uL2FycmF5L21heCcpO1xudmFyIHZhbHVlcyA9IHJlcXVpcmUoJy4vdmFsdWVzJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG1heGltdW0gdmFsdWUgaW5zaWRlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgob2JqLCBjb21wYXJlRm4pIHtcbiAgICAgICAgcmV0dXJuIGFyck1heCh2YWx1ZXMob2JqKSwgY29tcGFyZUZuKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1heDtcblxuIiwidmFyIGhhc093biA9IHJlcXVpcmUoJy4vaGFzT3duJyk7XG52YXIgZGVlcENsb25lID0gcmVxdWlyZSgnLi4vbGFuZy9kZWVwQ2xvbmUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKTtcblxuICAgIC8qKlxuICAgICAqIERlZXAgbWVyZ2Ugb2JqZWN0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZSgpIHtcbiAgICAgICAgdmFyIGkgPSAxLFxuICAgICAgICAgICAga2V5LCB2YWwsIG9iaiwgdGFyZ2V0O1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBtb2RpZnkgc291cmNlIGVsZW1lbnQgYW5kIGl0J3MgcHJvcGVydGllc1xuICAgICAgICAvLyBvYmplY3RzIGFyZSBwYXNzZWQgYnkgcmVmZXJlbmNlXG4gICAgICAgIHRhcmdldCA9IGRlZXBDbG9uZSggYXJndW1lbnRzWzBdICk7XG5cbiAgICAgICAgd2hpbGUgKG9iaiA9IGFyZ3VtZW50c1tpKytdKSB7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoICEgaGFzT3duKG9iaiwga2V5KSApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsID0gb2JqW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIGlzT2JqZWN0KHZhbCkgJiYgaXNPYmplY3QodGFyZ2V0W2tleV0pICl7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluY2VwdGlvbiwgZGVlcCBtZXJnZSBvYmplY3RzXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2UodGFyZ2V0W2tleV0sIHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGFycmF5cywgcmVnZXhwLCBkYXRlLCBvYmplY3RzIGFyZSBjbG9uZWRcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBkZWVwQ2xvbmUodmFsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcblxuXG4iLCJ2YXIgYXJyTWluID0gcmVxdWlyZSgnLi4vYXJyYXkvbWluJyk7XG52YXIgdmFsdWVzID0gcmVxdWlyZSgnLi92YWx1ZXMnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbWluaW11bSB2YWx1ZSBpbnNpZGUgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihvYmosIGl0ZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBhcnJNaW4odmFsdWVzKG9iaiksIGl0ZXJhdG9yKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1pbjtcblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG5cbiAgICAvKipcbiAgICAqIENvbWJpbmUgcHJvcGVydGllcyBmcm9tIGFsbCB0aGUgb2JqZWN0cyBpbnRvIGZpcnN0IG9uZS5cbiAgICAqIC0gVGhpcyBtZXRob2QgYWZmZWN0cyB0YXJnZXQgb2JqZWN0IGluIHBsYWNlLCBpZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBuZXcgT2JqZWN0IHBhc3MgYW4gZW1wdHkgb2JqZWN0IGFzIGZpcnN0IHBhcmFtLlxuICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAgICBUYXJnZXQgT2JqZWN0XG4gICAgKiBAcGFyYW0gey4uLm9iamVjdH0gb2JqZWN0cyAgICBPYmplY3RzIHRvIGJlIGNvbWJpbmVkICgwLi4ubiBvYmplY3RzKS5cbiAgICAqIEByZXR1cm4ge29iamVjdH0gVGFyZ2V0IE9iamVjdC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIG1peEluKHRhcmdldCwgb2JqZWN0cyl7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIG4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgb2JqO1xuICAgICAgICB3aGlsZSgrK2kgPCBuKXtcbiAgICAgICAgICAgIG9iaiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvck93bihvYmosIGNvcHlQcm9wLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29weVByb3AodmFsLCBrZXkpe1xuICAgICAgICB0aGlzW2tleV0gPSB2YWw7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtaXhJbjtcblxuIiwidmFyIGZvckVhY2ggPSByZXF1aXJlKCcuLi9hcnJheS9mb3JFYWNoJyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgbmVzdGVkIG9iamVjdCBpZiBub24tZXhpc3RlbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuYW1lc3BhY2Uob2JqLCBwYXRoKXtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gb2JqO1xuICAgICAgICBmb3JFYWNoKHBhdGguc3BsaXQoJy4nKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgICAgIGlmICghb2JqW2tleV0pIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbmFtZXNwYWNlO1xuXG5cbiIsInZhciBzbGljZSA9IHJlcXVpcmUoJy4uL2FycmF5L3NsaWNlJyk7XG52YXIgY29udGFpbnMgPSByZXF1aXJlKCcuLi9hcnJheS9jb250YWlucycpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0LCBmaWx0ZXJlZCB0byBvbmx5IGNvbnRhaW4gcHJvcGVydGllcyBleGNlcHQgdGhlIGJsYWNrbGlzdGVkIGtleXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdChvYmosIHZhcl9rZXlzKXtcbiAgICAgICAgdmFyIGtleXMgPSB0eXBlb2YgYXJndW1lbnRzWzFdICE9PSAnc3RyaW5nJz8gYXJndW1lbnRzWzFdIDogc2xpY2UoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIG91dCA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgJiYgIWNvbnRhaW5zKGtleXMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIG91dFtwcm9wZXJ0eV0gPSBvYmpbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBvbWl0O1xuXG5cbiIsInZhciBzbGljZSA9IHJlcXVpcmUoJy4uL2FycmF5L3NsaWNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3QsIGZpbHRlcmVkIHRvIG9ubHkgaGF2ZSB2YWx1ZXMgZm9yIHRoZSB3aGl0ZWxpc3RlZCBrZXlzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2sob2JqLCB2YXJfa2V5cyl7XG4gICAgICAgIHZhciBrZXlzID0gdHlwZW9mIGFyZ3VtZW50c1sxXSAhPT0gJ3N0cmluZyc/IGFyZ3VtZW50c1sxXSA6IHNsaWNlKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICBvdXQgPSB7fSxcbiAgICAgICAgICAgIGkgPSAwLCBrZXk7XG4gICAgICAgIHdoaWxlIChrZXkgPSBrZXlzW2krK10pIHtcbiAgICAgICAgICAgIG91dFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBpY2s7XG5cblxuIiwidmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG52YXIgcHJvcCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL3Byb3AnKTtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgYSBsaXN0IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwbHVjayhvYmosIHByb3BOYW1lKXtcbiAgICAgICAgcmV0dXJuIG1hcChvYmosIHByb3AocHJvcE5hbWUpKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBsdWNrO1xuXG5cbiIsInZhciBmb3JPd24gPSByZXF1aXJlKCcuL2Zvck93bicpO1xudmFyIHNpemUgPSByZXF1aXJlKCcuL3NpemUnKTtcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCByZWR1Y2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2Uob2JqLCBjYWxsYmFjaywgbWVtbywgdGhpc09iaikge1xuICAgICAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuXG4gICAgICAgIGlmICghc2l6ZShvYmopICYmICFpbml0aWFsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlZHVjZSBvZiBlbXB0eSBvYmplY3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JPd24ob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBsaXN0KSB7XG4gICAgICAgICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gY2FsbGJhY2suY2FsbCh0aGlzT2JqLCBtZW1vLCB2YWx1ZSwga2V5LCBsaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZWR1Y2U7XG5cblxuIiwidmFyIGZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG52YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHJlamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChvYmosIGNhbGxiYWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbWFrZUl0ZXJhdG9yKGNhbGxiYWNrLCB0aGlzT2JqKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcihvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gIWNhbGxiYWNrKHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgfSwgdGhpc09iaik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZWplY3Q7XG5cblxuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9sYW5nL2lzRnVuY3Rpb24nKTtcblxuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmosIHByb3ApIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gb2JqW3Byb3BdO1xuXG4gICAgICAgIGlmKHByb3BlcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHByb3BlcnR5KSA/IHByb3BlcnR5LmNhbGwob2JqKSA6IHByb3BlcnR5O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0O1xuXG4iLCJ2YXIgbmFtZXNwYWNlID0gcmVxdWlyZSgnLi9uYW1lc3BhY2UnKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBcIm5lc3RlZFwiIG9iamVjdCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChvYmosIHByb3AsIHZhbCl7XG4gICAgICAgIHZhciBwYXJ0cyA9ICgvXiguKylcXC4oLispJC8pLmV4ZWMocHJvcCk7XG4gICAgICAgIGlmIChwYXJ0cyl7XG4gICAgICAgICAgICBuYW1lc3BhY2Uob2JqLCBwYXJ0c1sxXSlbcGFydHNbMl1dID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZXQ7XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgb2JqZWN0IHNpemVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKG9iaikge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICBmb3JPd24ob2JqLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNpemU7XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG52YXIgbWFrZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24vbWFrZUl0ZXJhdG9yXycpO1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHNvbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKG9iaiwgY2FsbGJhY2ssIHRoaXNPYmopIHtcbiAgICAgICAgY2FsbGJhY2sgPSBtYWtlSXRlcmF0b3IoY2FsbGJhY2ssIHRoaXNPYmopO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGZvck93bihvYmosIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsLCBrZXksIG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzb21lO1xuXG5cbiIsInZhciBoYXMgPSByZXF1aXJlKCcuL2hhcycpO1xuXG4gICAgLyoqXG4gICAgICogVW5zZXQgb2JqZWN0IHByb3BlcnR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuc2V0KG9iaiwgcHJvcCl7XG4gICAgICAgIGlmIChoYXMob2JqLCBwcm9wKSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gcHJvcC5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIGxhc3QgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgIHdoaWxlIChwcm9wID0gcGFydHMuc2hpZnQoKSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoZGVsZXRlIG9ialtsYXN0XSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QgdHJlYXQgYXMgZGVsZXRlZFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHVuc2V0O1xuXG5cbiIsInZhciBmb3JPd24gPSByZXF1aXJlKCcuL2Zvck93bicpO1xuXG4gICAgLyoqXG4gICAgICogR2V0IG9iamVjdCB2YWx1ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gICAgICAgIHZhciB2YWxzID0gW107XG4gICAgICAgIGZvck93bihvYmosIGZ1bmN0aW9uKHZhbCwga2V5KXtcbiAgICAgICAgICAgIHZhbHMucHVzaCh2YWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB2YWx1ZXM7XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdjb250YWlucycgOiByZXF1aXJlKCcuL3F1ZXJ5U3RyaW5nL2NvbnRhaW5zJyksXG4gICAgJ2RlY29kZScgOiByZXF1aXJlKCcuL3F1ZXJ5U3RyaW5nL2RlY29kZScpLFxuICAgICdlbmNvZGUnIDogcmVxdWlyZSgnLi9xdWVyeVN0cmluZy9lbmNvZGUnKSxcbiAgICAnZ2V0UGFyYW0nIDogcmVxdWlyZSgnLi9xdWVyeVN0cmluZy9nZXRQYXJhbScpLFxuICAgICdnZXRRdWVyeScgOiByZXF1aXJlKCcuL3F1ZXJ5U3RyaW5nL2dldFF1ZXJ5JyksXG4gICAgJ3BhcnNlJyA6IHJlcXVpcmUoJy4vcXVlcnlTdHJpbmcvcGFyc2UnKSxcbiAgICAnc2V0UGFyYW0nIDogcmVxdWlyZSgnLi9xdWVyeVN0cmluZy9zZXRQYXJhbScpXG59O1xuXG5cbiIsInZhciBnZXRRdWVyeSA9IHJlcXVpcmUoJy4vZ2V0UXVlcnknKTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBxdWVyeSBzdHJpbmcgY29udGFpbnMgcGFyYW1ldGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHVybCwgcGFyYW1OYW1lKSB7XG4gICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJyhcXFxcP3wmKScrIHBhcmFtTmFtZSArJz0nLCAnZycpOyAvL21hdGNoZXMgYD9wYXJhbT1gIG9yIGAmcGFyYW09YFxuICAgICAgICByZXR1cm4gcmVnZXgudGVzdChnZXRRdWVyeSh1cmwpKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zO1xuXG4iLCJ2YXIgdHlwZWNhc3QgPSByZXF1aXJlKCcuLi9zdHJpbmcvdHlwZWNhc3QnKTtcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvaXNTdHJpbmcnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5Jyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vb2JqZWN0L2hhc093bicpO1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIHF1ZXJ5IHN0cmluZyBpbnRvIGFuIG9iamVjdCBvZiBrZXlzID0+IHZhbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjb2RlKHF1ZXJ5U3RyLCBzaG91bGRUeXBlY2FzdCkge1xuICAgICAgICB2YXIgcXVlcnlBcnIgPSAocXVlcnlTdHIgfHwgJycpLnJlcGxhY2UoJz8nLCAnJykuc3BsaXQoJyYnKSxcbiAgICAgICAgICAgIGNvdW50ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBxdWVyeUFyci5sZW5ndGgsXG4gICAgICAgICAgICBvYmogPSB7fSxcbiAgICAgICAgICAgIGl0ZW0sIHBWYWx1ZSwgcE5hbWUsIHRvU2V0O1xuXG4gICAgICAgIHdoaWxlICgrK2NvdW50IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtID0gcXVlcnlBcnJbY291bnRdLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBwTmFtZSA9IGl0ZW1bMF07XG4gICAgICAgICAgICBpZiAoIXBOYW1lIHx8ICFwTmFtZS5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcFZhbHVlID0gc2hvdWxkVHlwZWNhc3QgPT09IGZhbHNlID8gaXRlbVsxXSA6IHR5cGVjYXN0KGl0ZW1bMV0pO1xuICAgICAgICAgICAgdG9TZXQgPSBpc1N0cmluZyhwVmFsdWUpID8gZGVjb2RlVVJJQ29tcG9uZW50KHBWYWx1ZSkgOiBwVmFsdWU7XG4gICAgICAgICAgICBpZiAoaGFzT3duKG9iaixwTmFtZSkpe1xuICAgICAgICAgICAgICAgIGlmKGlzQXJyYXkob2JqW3BOYW1lXSkpe1xuICAgICAgICAgICAgICAgICAgICBvYmpbcE5hbWVdLnB1c2godG9TZXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtwTmFtZV0gPSBbb2JqW3BOYW1lXSx0b1NldF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpbcE5hbWVdID0gdG9TZXQ7XG4gICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZGVjb2RlO1xuXG4iLCJ2YXIgZm9yT3duID0gcmVxdWlyZSgnLi4vb2JqZWN0L2Zvck93bicpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vYXJyYXkvZm9yRWFjaCcpO1xuXG4gICAgLyoqXG4gICAgICogRW5jb2RlIG9iamVjdCBpbnRvIGEgcXVlcnkgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuY29kZShvYmope1xuICAgICAgICB2YXIgcXVlcnkgPSBbXSxcbiAgICAgICAgICAgIGFyclZhbHVlcywgcmVnO1xuICAgICAgICBmb3JPd24ob2JqLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgICAgICBhcnJWYWx1ZXMgPSBrZXkgKyAnPSc7XG4gICAgICAgICAgICAgICAgcmVnID0gbmV3IFJlZ0V4cCgnJicra2V5KycrPSQnKTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKHZhbCwgZnVuY3Rpb24gKGFWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJWYWx1ZXMgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGFWYWx1ZSkgKyAnJicgKyBrZXkgKyAnPSc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcXVlcnkucHVzaChhcnJWYWx1ZXMucmVwbGFjZShyZWcsICcnKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgcXVlcnkucHVzaChrZXkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKHF1ZXJ5Lmxlbmd0aCkgPyAnPycgKyBxdWVyeS5qb2luKCcmJykgOiAnJztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVuY29kZTtcblxuIiwidmFyIHR5cGVjYXN0ID0gcmVxdWlyZSgnLi4vc3RyaW5nL3R5cGVjYXN0Jyk7XG52YXIgZ2V0UXVlcnkgPSByZXF1aXJlKCcuL2dldFF1ZXJ5Jyk7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcXVlcnkgcGFyYW1ldGVyIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBhcmFtKHVybCwgcGFyYW0sIHNob3VsZFR5cGVjYXN0KXtcbiAgICAgICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyhcXFxcP3wmKScrIHBhcmFtICsgJz0oW14mXSopJyksIC8vbWF0Y2hlcyBgP3BhcmFtPXZhbHVlYCBvciBgJnBhcmFtPXZhbHVlYCwgdmFsdWUgPSAkMlxuICAgICAgICAgICAgcmVzdWx0ID0gcmVnZXhwLmV4ZWMoIGdldFF1ZXJ5KHVybCkgKSxcbiAgICAgICAgICAgIHZhbCA9IChyZXN1bHQgJiYgcmVzdWx0WzJdKT8gcmVzdWx0WzJdIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHNob3VsZFR5cGVjYXN0ID09PSBmYWxzZT8gdmFsIDogdHlwZWNhc3QodmFsKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdldFBhcmFtO1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIEdldHMgZnVsbCBxdWVyeSBhcyBzdHJpbmcgd2l0aCBhbGwgc3BlY2lhbCBjaGFycyBkZWNvZGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFF1ZXJ5KHVybCkge1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvIy4qLywgJycpOyAvL3JlbW92ZXMgaGFzaCAodG8gYXZvaWQgZ2V0dGluZyBoYXNoIHF1ZXJ5KVxuICAgICAgICB2YXIgcXVlcnlTdHJpbmcgPSAvXFw/W2EtekEtWjAtOVxcPVxcJlxcJVxcJFxcLVxcX1xcLlxcK1xcIVxcKlxcJ1xcKFxcKVxcLF0rLy5leGVjKHVybCk7IC8vdmFsaWQgY2hhcnMgYWNjb3JkaW5nIHRvOiBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMxNzM4LnR4dFxuICAgICAgICByZXR1cm4gKHF1ZXJ5U3RyaW5nKT8gZGVjb2RlVVJJQ29tcG9uZW50KHF1ZXJ5U3RyaW5nWzBdKSA6ICcnO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZ2V0UXVlcnk7XG5cbiIsInZhciBkZWNvZGUgPSByZXF1aXJlKCcuL2RlY29kZScpO1xudmFyIGdldFF1ZXJ5ID0gcmVxdWlyZSgnLi9nZXRRdWVyeScpO1xuXG4gICAgLyoqXG4gICAgICogR2V0IHF1ZXJ5IHN0cmluZywgcGFyc2VzIGFuZCBkZWNvZGVzIGl0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlKHVybCwgc2hvdWxkVHlwZWNhc3QpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZShnZXRRdWVyeSh1cmwpLCBzaG91bGRUeXBlY2FzdCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFNldCBxdWVyeSBzdHJpbmcgcGFyYW1ldGVyIHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0UGFyYW0odXJsLCBwYXJhbU5hbWUsIHZhbHVlKXtcbiAgICAgICAgdXJsID0gdXJsIHx8ICcnO1xuXG4gICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJyhcXFxcP3wmKScrIHBhcmFtTmFtZSArJz1bXiZdKicgKTtcbiAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1OYW1lICsnPScrIGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgKTtcblxuICAgICAgICBpZiAoIHJlLnRlc3QodXJsKSApIHtcbiAgICAgICAgICAgIHJldHVybiB1cmwucmVwbGFjZShyZSwgJyQxJysgcGFyYW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCc/JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignPScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHVybCArPSAnJic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXJsICsgcGFyYW07XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gc2V0UGFyYW07XG5cblxuIiwiXG5cbi8vYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGRvIG5vdCBlZGl0IVxuLy9ydW4gYG5vZGUgYnVpbGRgIGluc3RlYWRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdjaG9pY2UnIDogcmVxdWlyZSgnLi9yYW5kb20vY2hvaWNlJyksXG4gICAgJ2d1aWQnIDogcmVxdWlyZSgnLi9yYW5kb20vZ3VpZCcpLFxuICAgICdyYW5kJyA6IHJlcXVpcmUoJy4vcmFuZG9tL3JhbmQnKSxcbiAgICAncmFuZEJpdCcgOiByZXF1aXJlKCcuL3JhbmRvbS9yYW5kQml0JyksXG4gICAgJ3JhbmRCb29sJyA6IHJlcXVpcmUoJy4vcmFuZG9tL3JhbmRCb29sJyksXG4gICAgJ3JhbmRIZXgnIDogcmVxdWlyZSgnLi9yYW5kb20vcmFuZEhleCcpLFxuICAgICdyYW5kSW50JyA6IHJlcXVpcmUoJy4vcmFuZG9tL3JhbmRJbnQnKSxcbiAgICAncmFuZFNpZ24nIDogcmVxdWlyZSgnLi9yYW5kb20vcmFuZFNpZ24nKSxcbiAgICAncmFuZFN0cmluZycgOiByZXF1aXJlKCcuL3JhbmRvbS9yYW5kU3RyaW5nJyksXG4gICAgJ3JhbmRvbScgOiByZXF1aXJlKCcuL3JhbmRvbS9yYW5kb20nKVxufTtcblxuXG4iLCJ2YXIgcmFuZEludCA9IHJlcXVpcmUoJy4vcmFuZEludCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByYW5kb20gZWxlbWVudCBmcm9tIHRoZSBzdXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiBvciBmcm9tIHRoZSBhcnJheSAoaWYgc2luZ2xlIGFyZ3VtZW50IGlzIGFuIGFycmF5KS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaG9pY2UoaXRlbXMpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkoaXRlbXMpKT8gaXRlbXMgOiBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiB0YXJnZXRbIHJhbmRJbnQoMCwgdGFyZ2V0Lmxlbmd0aCAtIDEpIF07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjaG9pY2U7XG5cblxuIiwidmFyIHJhbmRIZXggPSByZXF1aXJlKCcuL3JhbmRIZXgnKTtcbnZhciBjaG9pY2UgPSByZXF1aXJlKCcuL2Nob2ljZScpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBzZXVkby1yYW5kb20gZ3VpZCAoVVVJRCB2NClcbiAgICogSU1QT1JUQU5UOiBpdCdzIG5vdCB0b3RhbGx5IFwic2FmZVwiIHNpbmNlIHJhbmRIZXgvY2hvaWNlIHVzZXMgTWF0aC5yYW5kb21cbiAgICogYnkgZGVmYXVsdCBhbmQgc2VxdWVuY2VzIGNhbiBiZSBwcmVkaWN0ZWQgaW4gc29tZSBjYXNlcy4gU2VlIHRoZVxuICAgKiBcInJhbmRvbS9yYW5kb21cIiBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGluZm8gYWJvdXQgaXQgYW5kIGhvdyB0byByZXBsYWNlXG4gICAqIHRoZSBkZWZhdWx0IFBSTkcuXG4gICAqL1xuICBmdW5jdGlvbiBndWlkKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHJhbmRIZXgoOCkrJy0nK1xuICAgICAgICByYW5kSGV4KDQpKyctJytcbiAgICAgICAgLy8gdjQgVVVJRCBhbHdheXMgY29udGFpbiBcIjRcIiBhdCB0aGlzIHBvc2l0aW9uIHRvIHNwZWNpZnkgaXQgd2FzXG4gICAgICAgIC8vIHJhbmRvbWx5IGdlbmVyYXRlZFxuICAgICAgICAnNCcgKyByYW5kSGV4KDMpICsnLScrXG4gICAgICAgIC8vIHY0IFVVSUQgYWx3YXlzIGNvbnRhaW4gY2hhcnMgW2EsYiw4LDldIGF0IHRoaXMgcG9zaXRpb25cbiAgICAgICAgY2hvaWNlKDgsIDksICdhJywgJ2InKSArIHJhbmRIZXgoMykrJy0nK1xuICAgICAgICByYW5kSGV4KDEyKVxuICAgICk7XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMgPSBndWlkO1xuXG4iLCJ2YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcbnZhciBNSU5fSU5UID0gcmVxdWlyZSgnLi4vbnVtYmVyL01JTl9JTlQnKTtcbnZhciBNQVhfSU5UID0gcmVxdWlyZSgnLi4vbnVtYmVyL01BWF9JTlQnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmFuZG9tIG51bWJlciBpbnNpZGUgcmFuZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kKG1pbiwgbWF4KXtcbiAgICAgICAgbWluID0gbWluID09IG51bGw/IE1JTl9JTlQgOiBtaW47XG4gICAgICAgIG1heCA9IG1heCA9PSBudWxsPyBNQVhfSU5UIDogbWF4O1xuICAgICAgICByZXR1cm4gbWluICsgKG1heCAtIG1pbikgKiByYW5kb20oKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJhbmQ7XG5cbiIsInZhciByYW5kQm9vbCA9IHJlcXVpcmUoJy4vcmFuZEJvb2wnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmFuZG9tIGJpdCAoMCBvciAxKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbUJpdCgpIHtcbiAgICAgICAgcmV0dXJuIHJhbmRCb29sKCk/IDEgOiAwO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tQml0O1xuXG4iLCJ2YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgYSByYW5kb20gYm9vbGVhbiB2YWx1ZSAodHJ1ZSBvciBmYWxzZSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kQm9vbCgpe1xuICAgICAgICByZXR1cm4gcmFuZG9tKCkgPj0gMC41O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmFuZEJvb2w7XG5cblxuIiwidmFyIGNob2ljZSA9IHJlcXVpcmUoJy4vY2hvaWNlJyk7XG5cbiAgICB2YXIgX2NoYXJzID0gJzAxMjM0NTY3ODlhYmNkZWYnLnNwbGl0KCcnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByYW5kb20gaGV4YWRlY2ltYWwgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZEhleChzaXplKXtcbiAgICAgICAgc2l6ZSA9IHNpemUgJiYgc2l6ZSA+IDA/IHNpemUgOiA2O1xuICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICAgIHN0ciArPSBjaG9pY2UoX2NoYXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmFuZEhleDtcblxuXG4iLCJ2YXIgTUlOX0lOVCA9IHJlcXVpcmUoJy4uL251bWJlci9NSU5fSU5UJyk7XG52YXIgTUFYX0lOVCA9IHJlcXVpcmUoJy4uL251bWJlci9NQVhfSU5UJyk7XG52YXIgcmFuZCA9IHJlcXVpcmUoJy4vcmFuZCcpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyByYW5kb20gaW50ZWdlciBpbnNpZGUgcmFuZ2Ugb3Igc25hcCB0byBtaW4vbWF4IHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kSW50KG1pbiwgbWF4KXtcbiAgICAgICAgbWluID0gbWluID09IG51bGw/IE1JTl9JTlQgOiB+fm1pbjtcbiAgICAgICAgbWF4ID0gbWF4ID09IG51bGw/IE1BWF9JTlQgOiB+fm1heDtcbiAgICAgICAgLy8gY2FuJ3QgYmUgbWF4ICsgMC41IG90aGVyd2lzZSBpdCB3aWxsIHJvdW5kIHVwIGlmIGByYW5kYFxuICAgICAgICAvLyByZXR1cm5zIGBtYXhgIGNhdXNpbmcgaXQgdG8gb3ZlcmZsb3cgcmFuZ2UuXG4gICAgICAgIC8vIC0wLjUgYW5kICsgMC40OSBhcmUgcmVxdWlyZWQgdG8gYXZvaWQgYmlhcyBjYXVzZWQgYnkgcm91bmRpbmdcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoIHJhbmQobWluIC0gMC41LCBtYXggKyAwLjQ5OTk5OTk5OTk5OSkgKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJhbmRJbnQ7XG5cbiIsInZhciByYW5kQm9vbCA9IHJlcXVpcmUoJy4vcmFuZEJvb2wnKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmFuZG9tIHNpZ24gKC0xIG9yIDEpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tU2lnbigpIHtcbiAgICAgICAgcmV0dXJuIHJhbmRCb29sKCk/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbVNpZ247XG5cbiIsInZhciBpc051bWJlciA9IHJlcXVpcmUoJy4uL2xhbmcvaXNOdW1iZXInKTtcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvaXNTdHJpbmcnKTtcbnZhciByYW5kSW50ID0gcmVxdWlyZSgnLi9yYW5kSW50Jyk7XG5cbiAgICB2YXIgZGVmYXVsdERpY3Rpb25hcnkgPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XG5cbiAgICBmdW5jdGlvbiByYW5kb21TdHJpbmcobGVuZ3RoLCBkaWN0aW9uYXJ5KSB7XG4gICAgICAgIGlmKCFpc051bWJlcihsZW5ndGgpIHx8IGxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgbGVuZ3RoID0gODtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFpc1N0cmluZyhkaWN0aW9uYXJ5KSB8fCBkaWN0aW9uYXJ5Lmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICBkaWN0aW9uYXJ5ID0gZGVmYXVsdERpY3Rpb25hcnk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBkb21haW4gPSBkaWN0aW9uYXJ5Lmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUobGVuZ3RoLS0pIHtcbiAgICAgICAgICByZXN1bHQgKz0gZGljdGlvbmFyeVtyYW5kSW50KDAsIGRvbWFpbildO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tU3RyaW5nO1xuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIEp1c3QgYSB3cmFwcGVyIHRvIE1hdGgucmFuZG9tLiBObyBtZXRob2RzIGluc2lkZSBtb3V0L3JhbmRvbSBzaG91bGQgY2FsbFxuICAgICAqIE1hdGgucmFuZG9tKCkgZGlyZWN0bHkgc28gd2UgY2FuIGluamVjdCB0aGUgcHNldWRvLXJhbmRvbSBudW1iZXJcbiAgICAgKiBnZW5lcmF0b3IgaWYgbmVlZGVkIChpZS4gaW4gY2FzZSB3ZSBuZWVkIGEgc2VlZGVkIHJhbmRvbSBvciBhIGJldHRlclxuICAgICAqIGFsZ29yaXRobSB0aGFuIHRoZSBuYXRpdmUgb25lKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbSgpe1xuICAgICAgICByZXR1cm4gcmFuZG9tLmdldCgpO1xuICAgIH1cblxuICAgIC8vIHdlIGV4cG9zZSB0aGUgbWV0aG9kIHNvIGl0IGNhbiBiZSBzd2FwcGVkIGlmIG5lZWRlZFxuICAgIHJhbmRvbS5nZXQgPSBNYXRoLnJhbmRvbTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tO1xuXG5cbiIsIlxuXG4vL2F1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLCBkbyBub3QgZWRpdCFcbi8vcnVuIGBub2RlIGJ1aWxkYCBpbnN0ZWFkXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnV0hJVEVfU1BBQ0VTJyA6IHJlcXVpcmUoJy4vc3RyaW5nL1dISVRFX1NQQUNFUycpLFxuICAgICdjYW1lbENhc2UnIDogcmVxdWlyZSgnLi9zdHJpbmcvY2FtZWxDYXNlJyksXG4gICAgJ2NvbnRhaW5zJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2NvbnRhaW5zJyksXG4gICAgJ2Nyb3AnIDogcmVxdWlyZSgnLi9zdHJpbmcvY3JvcCcpLFxuICAgICdlbmRzV2l0aCcgOiByZXF1aXJlKCcuL3N0cmluZy9lbmRzV2l0aCcpLFxuICAgICdlc2NhcGVIdG1sJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2VzY2FwZUh0bWwnKSxcbiAgICAnZXNjYXBlUmVnRXhwJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2VzY2FwZVJlZ0V4cCcpLFxuICAgICdlc2NhcGVVbmljb2RlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2VzY2FwZVVuaWNvZGUnKSxcbiAgICAnaHlwaGVuYXRlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2h5cGhlbmF0ZScpLFxuICAgICdpbnNlcnQnIDogcmVxdWlyZSgnLi9zdHJpbmcvaW5zZXJ0JyksXG4gICAgJ2ludGVycG9sYXRlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2ludGVycG9sYXRlJyksXG4gICAgJ2xvd2VyQ2FzZScgOiByZXF1aXJlKCcuL3N0cmluZy9sb3dlckNhc2UnKSxcbiAgICAnbHBhZCcgOiByZXF1aXJlKCcuL3N0cmluZy9scGFkJyksXG4gICAgJ2x0cmltJyA6IHJlcXVpcmUoJy4vc3RyaW5nL2x0cmltJyksXG4gICAgJ21ha2VQYXRoJyA6IHJlcXVpcmUoJy4vc3RyaW5nL21ha2VQYXRoJyksXG4gICAgJ25vcm1hbGl6ZUxpbmVCcmVha3MnIDogcmVxdWlyZSgnLi9zdHJpbmcvbm9ybWFsaXplTGluZUJyZWFrcycpLFxuICAgICdwYXNjYWxDYXNlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3Bhc2NhbENhc2UnKSxcbiAgICAncHJvcGVyQ2FzZScgOiByZXF1aXJlKCcuL3N0cmluZy9wcm9wZXJDYXNlJyksXG4gICAgJ3JlbW92ZU5vbkFTQ0lJJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3JlbW92ZU5vbkFTQ0lJJyksXG4gICAgJ3JlbW92ZU5vbldvcmQnIDogcmVxdWlyZSgnLi9zdHJpbmcvcmVtb3ZlTm9uV29yZCcpLFxuICAgICdyZXBlYXQnIDogcmVxdWlyZSgnLi9zdHJpbmcvcmVwZWF0JyksXG4gICAgJ3JlcGxhY2UnIDogcmVxdWlyZSgnLi9zdHJpbmcvcmVwbGFjZScpLFxuICAgICdyZXBsYWNlQWNjZW50cycgOiByZXF1aXJlKCcuL3N0cmluZy9yZXBsYWNlQWNjZW50cycpLFxuICAgICdycGFkJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3JwYWQnKSxcbiAgICAncnRyaW0nIDogcmVxdWlyZSgnLi9zdHJpbmcvcnRyaW0nKSxcbiAgICAnc2VudGVuY2VDYXNlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3NlbnRlbmNlQ2FzZScpLFxuICAgICdzbHVnaWZ5JyA6IHJlcXVpcmUoJy4vc3RyaW5nL3NsdWdpZnknKSxcbiAgICAnc3RhcnRzV2l0aCcgOiByZXF1aXJlKCcuL3N0cmluZy9zdGFydHNXaXRoJyksXG4gICAgJ3N0cmlwSHRtbFRhZ3MnIDogcmVxdWlyZSgnLi9zdHJpbmcvc3RyaXBIdG1sVGFncycpLFxuICAgICd0cmltJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3RyaW0nKSxcbiAgICAndHJ1bmNhdGUnIDogcmVxdWlyZSgnLi9zdHJpbmcvdHJ1bmNhdGUnKSxcbiAgICAndHlwZWNhc3QnIDogcmVxdWlyZSgnLi9zdHJpbmcvdHlwZWNhc3QnKSxcbiAgICAndW5DYW1lbENhc2UnIDogcmVxdWlyZSgnLi9zdHJpbmcvdW5DYW1lbENhc2UnKSxcbiAgICAndW5kZXJzY29yZScgOiByZXF1aXJlKCcuL3N0cmluZy91bmRlcnNjb3JlJyksXG4gICAgJ3VuZXNjYXBlSHRtbCcgOiByZXF1aXJlKCcuL3N0cmluZy91bmVzY2FwZUh0bWwnKSxcbiAgICAndW5lc2NhcGVVbmljb2RlJyA6IHJlcXVpcmUoJy4vc3RyaW5nL3VuZXNjYXBlVW5pY29kZScpLFxuICAgICd1bmh5cGhlbmF0ZScgOiByZXF1aXJlKCcuL3N0cmluZy91bmh5cGhlbmF0ZScpLFxuICAgICd1cHBlckNhc2UnIDogcmVxdWlyZSgnLi9zdHJpbmcvdXBwZXJDYXNlJylcbn07XG5cblxuIiwiXG4gICAgLyoqXG4gICAgICogQ29udGFpbnMgYWxsIFVuaWNvZGUgd2hpdGUtc3BhY2VzLiBUYWtlbiBmcm9tXG4gICAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XaGl0ZXNwYWNlX2NoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFtcbiAgICAgICAgJyAnLCAnXFxuJywgJ1xccicsICdcXHQnLCAnXFxmJywgJ1xcdicsICdcXHUwMEEwJywgJ1xcdTE2ODAnLCAnXFx1MTgwRScsXG4gICAgICAgICdcXHUyMDAwJywgJ1xcdTIwMDEnLCAnXFx1MjAwMicsICdcXHUyMDAzJywgJ1xcdTIwMDQnLCAnXFx1MjAwNScsICdcXHUyMDA2JyxcbiAgICAgICAgJ1xcdTIwMDcnLCAnXFx1MjAwOCcsICdcXHUyMDA5JywgJ1xcdTIwMEEnLCAnXFx1MjAyOCcsICdcXHUyMDI5JywgJ1xcdTIwMkYnLFxuICAgICAgICAnXFx1MjA1RicsICdcXHUzMDAwJ1xuICAgIF07XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciByZXBsYWNlQWNjZW50cyA9IHJlcXVpcmUoJy4vcmVwbGFjZUFjY2VudHMnKTtcbnZhciByZW1vdmVOb25Xb3JkID0gcmVxdWlyZSgnLi9yZW1vdmVOb25Xb3JkJyk7XG52YXIgdXBwZXJDYXNlID0gcmVxdWlyZSgnLi91cHBlckNhc2UnKTtcbnZhciBsb3dlckNhc2UgPSByZXF1aXJlKCcuL2xvd2VyQ2FzZScpO1xuICAgIC8qKlxuICAgICogQ29udmVydCBzdHJpbmcgdG8gY2FtZWxDYXNlIHRleHQuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBjYW1lbENhc2Uoc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgc3RyID0gcmVwbGFjZUFjY2VudHMoc3RyKTtcbiAgICAgICAgc3RyID0gcmVtb3ZlTm9uV29yZChzdHIpXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcLV9dL2csICcgJykgLy9jb252ZXJ0IGFsbCBoeXBoZW5zIGFuZCB1bmRlcnNjb3JlcyB0byBzcGFjZXNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHNbYS16XS9nLCB1cHBlckNhc2UpIC8vY29udmVydCBmaXJzdCBjaGFyIG9mIGVhY2ggd29yZCB0byBVUFBFUkNBU0VcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcnKSAvL3JlbW92ZSBzcGFjZXNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eW0EtWl0vZywgbG93ZXJDYXNlKTsgLy9jb252ZXJ0IGZpcnN0IGNoYXIgdG8gbG93ZXJjYXNlXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gY2FtZWxDYXNlO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBmb3IgYSBnaXZlbiBzdWJzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWlucyhzdHIsIHN1YnN0cmluZywgZnJvbUluZGV4KXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgc3Vic3RyaW5nID0gdG9TdHJpbmcoc3Vic3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKHN1YnN0cmluZywgZnJvbUluZGV4KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb250YWlucztcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgdHJ1bmNhdGUgPSByZXF1aXJlKCcuL3RydW5jYXRlJyk7XG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGUgc3RyaW5nIGF0IGZ1bGwgd29yZHMuXG4gICAgICovXG4gICAgIGZ1bmN0aW9uIGNyb3Aoc3RyLCBtYXhDaGFycywgYXBwZW5kKSB7XG4gICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICAgcmV0dXJuIHRydW5jYXRlKHN0ciwgbWF4Q2hhcnMsIGFwcGVuZCwgdHJ1ZSk7XG4gICAgIH1cblxuICAgICBtb2R1bGUuZXhwb3J0cyA9IGNyb3A7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgc3RyaW5nIGVuZHMgd2l0aCBzcGVjaWZpZWQgc3VmZml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc3VmZml4KSB7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIHN1ZmZpeCA9IHRvU3RyaW5nKHN1ZmZpeCk7XG5cbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKHN1ZmZpeCwgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVuZHNXaXRoO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIGEgc3RyaW5nIGZvciBpbnNlcnRpb24gaW50byBIVE1MLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZXNjYXBlSHRtbDtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGUgUmVnRXhwIHN0cmluZyBjaGFycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZyhzdHIpLnJlcGxhY2UoL1xcVy9nLCdcXFxcJCYnKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVzY2FwZVJlZ0V4cDtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGUgc3RyaW5nIGludG8gdW5pY29kZSBzZXF1ZW5jZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVVbmljb2RlKHN0ciwgc2hvdWxkRXNjYXBlUHJpbnRhYmxlKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxzXFxTXS9nLCBmdW5jdGlvbihjaCl7XG4gICAgICAgICAgICAvLyBza2lwIHByaW50YWJsZSBBU0NJSSBjaGFycyBpZiB3ZSBzaG91bGQgbm90IGVzY2FwZSB0aGVtXG4gICAgICAgICAgICBpZiAoIXNob3VsZEVzY2FwZVByaW50YWJsZSAmJiAoL1tcXHgyMC1cXHg3RV0vKS50ZXN0KGNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIHVzZSBcIjAwMFwiIGFuZCBzbGljZSgtNCkgZm9yIGJyZXZpdHksIG5lZWQgdG8gcGFkIHplcm9zLFxuICAgICAgICAgICAgLy8gdW5pY29kZSBlc2NhcGUgYWx3YXlzIGhhdmUgNCBjaGFycyBhZnRlciBcIlxcdVwiXG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx1JysgKCcwMDAnKyBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVzY2FwZVVuaWNvZGU7XG5cblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xudmFyIHNsdWdpZnkgPSByZXF1aXJlKCcuL3NsdWdpZnknKTtcbnZhciB1bkNhbWVsQ2FzZSA9IHJlcXVpcmUoJy4vdW5DYW1lbENhc2UnKTtcbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBzcGFjZXMgd2l0aCBoeXBoZW5zLCBzcGxpdCBjYW1lbENhc2UgdGV4dCwgcmVtb3ZlIG5vbi13b3JkIGNoYXJzLCByZW1vdmUgYWNjZW50cyBhbmQgY29udmVydCB0byBsb3dlciBjYXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGh5cGhlbmF0ZShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICBzdHIgPSB1bkNhbWVsQ2FzZShzdHIpO1xuICAgICAgICByZXR1cm4gc2x1Z2lmeShzdHIsIFwiLVwiKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTtcblxuIiwidmFyIGNsYW1wID0gcmVxdWlyZSgnLi4vbWF0aC9jbGFtcCcpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIHN0cmluZyBhdCBhIGdpdmVuIGluZGV4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydChzdHJpbmcsIGluZGV4LCBwYXJ0aWFsKXtcbiAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBpbmRleCA9IHN0cmluZy5sZW5ndGggKyBpbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gY2xhbXAoaW5kZXgsIDAsIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIGluZGV4KSArIHBhcnRpYWwgKyBzdHJpbmcuc3Vic3RyKGluZGV4KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGluc2VydDtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgZ2V0ID0gcmVxdWlyZSgnLi4vb2JqZWN0L2dldCcpO1xuXG4gICAgdmFyIHN0YWNoZSA9IC9cXHtcXHsoW15cXH1dKylcXH1cXH0vZzsgLy9tdXN0YWNoZS1saWtlXG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgaW50ZXJwb2xhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKHRlbXBsYXRlLCByZXBsYWNlbWVudHMsIHN5bnRheCl7XG4gICAgICAgIHRlbXBsYXRlID0gdG9TdHJpbmcodGVtcGxhdGUpO1xuICAgICAgICB2YXIgcmVwbGFjZUZuID0gZnVuY3Rpb24obWF0Y2gsIHByb3Ape1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKCBnZXQocmVwbGFjZW1lbnRzLCBwcm9wKSApO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZShzeW50YXggfHwgc3RhY2hlLCByZXBsYWNlRm4pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaW50ZXJwb2xhdGU7XG5cblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xuICAgIC8qKlxuICAgICAqIFwiU2FmZXJcIiBTdHJpbmcudG9Mb3dlckNhc2UoKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvd2VyQ2FzZShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBsb3dlckNhc2U7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCcuL3JlcGVhdCcpO1xuXG4gICAgLyoqXG4gICAgICogUGFkIHN0cmluZyB3aXRoIGBjaGFyYCBpZiBpdHMnIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gYG1pbkxlbmBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBscGFkKHN0ciwgbWluTGVuLCBjaCkge1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICBjaCA9IGNoIHx8ICcgJztcblxuICAgICAgICByZXR1cm4gKHN0ci5sZW5ndGggPCBtaW5MZW4pID9cbiAgICAgICAgICAgIHJlcGVhdChjaCwgbWluTGVuIC0gc3RyLmxlbmd0aCkgKyBzdHIgOiBzdHI7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBscGFkO1xuXG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciBXSElURV9TUEFDRVMgPSByZXF1aXJlKCcuL1dISVRFX1NQQUNFUycpO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBjaGFycyBmcm9tIGJlZ2lubmluZyBvZiBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbHRyaW0oc3RyLCBjaGFycykge1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICBjaGFycyA9IGNoYXJzIHx8IFdISVRFX1NQQUNFUztcblxuICAgICAgICB2YXIgc3RhcnQgPSAwLFxuICAgICAgICAgICAgbGVuID0gc3RyLmxlbmd0aCxcbiAgICAgICAgICAgIGNoYXJMZW4gPSBjaGFycy5sZW5ndGgsXG4gICAgICAgICAgICBmb3VuZCA9IHRydWUsXG4gICAgICAgICAgICBpLCBjO1xuXG4gICAgICAgIHdoaWxlIChmb3VuZCAmJiBzdGFydCA8IGxlbikge1xuICAgICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICAgIGMgPSBzdHIuY2hhckF0KHN0YXJ0KTtcblxuICAgICAgICAgICAgd2hpbGUgKCsraSA8IGNoYXJMZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gY2hhcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCsrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHN0YXJ0ID49IGxlbikgPyAnJyA6IHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBsdHJpbTtcblxuIiwidmFyIGpvaW4gPSByZXF1aXJlKCcuLi9hcnJheS9qb2luJyk7XG52YXIgc2xpY2UgPSByZXF1aXJlKCcuLi9hcnJheS9zbGljZScpO1xuXG4gICAgLyoqXG4gICAgICogR3JvdXAgYXJndW1lbnRzIGFzIHBhdGggc2VnbWVudHMsIGlmIGFueSBvZiB0aGUgYXJncyBpcyBgbnVsbGAgb3IgYW5cbiAgICAgKiBlbXB0eSBzdHJpbmcgaXQgd2lsbCBiZSBpZ25vcmVkIGZyb20gcmVzdWx0aW5nIHBhdGguXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZVBhdGgodmFyX2FyZ3Mpe1xuICAgICAgICB2YXIgcmVzdWx0ID0gam9pbihzbGljZShhcmd1bWVudHMpLCAnLycpO1xuICAgICAgICAvLyBuZWVkIHRvIGRpc2NvbnNpZGVyIGR1cGxpY2F0ZSAnLycgYWZ0ZXIgcHJvdG9jb2wgKGVnOiAnaHR0cDovLycpXG4gICAgICAgIHJldHVybiByZXN1bHQucmVwbGFjZSgvKFteOlxcL118XilcXC97Mix9L2csICckMS8nKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG1ha2VQYXRoO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGxpbmUtYnJlYWtzIGZyb20gRE9TL01BQyB0byBhIHNpbmdsZSBzdGFuZGFyZCAoVU5JWCBieSBkZWZhdWx0KVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmVCcmVha3Moc3RyLCBsaW5lRW5kKSB7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIGxpbmVFbmQgPSBsaW5lRW5kIHx8ICdcXG4nO1xuXG4gICAgICAgIHJldHVybiBzdHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHJcXG4vZywgbGluZUVuZCkgLy8gRE9TXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyL2csIGxpbmVFbmQpICAgLy8gTWFjXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csIGxpbmVFbmQpOyAgLy8gVW5peFxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplTGluZUJyZWFrcztcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgY2FtZWxDYXNlID0gcmVxdWlyZSgnLi9jYW1lbENhc2UnKTtcbnZhciB1cHBlckNhc2UgPSByZXF1aXJlKCcuL3VwcGVyQ2FzZScpO1xuICAgIC8qKlxuICAgICAqIGNhbWVsQ2FzZSArIFVQUEVSQ0FTRSBmaXJzdCBjaGFyXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFzY2FsQ2FzZShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICByZXR1cm4gY2FtZWxDYXNlKHN0cikucmVwbGFjZSgvXlthLXpdLywgdXBwZXJDYXNlKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBhc2NhbENhc2U7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciBsb3dlckNhc2UgPSByZXF1aXJlKCcuL2xvd2VyQ2FzZScpO1xudmFyIHVwcGVyQ2FzZSA9IHJlcXVpcmUoJy4vdXBwZXJDYXNlJyk7XG4gICAgLyoqXG4gICAgICogVVBQRVJDQVNFIGZpcnN0IGNoYXIgb2YgZWFjaCB3b3JkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlckNhc2Uoc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgcmV0dXJuIGxvd2VyQ2FzZShzdHIpLnJlcGxhY2UoL15cXHd8XFxzXFx3L2csIHVwcGVyQ2FzZSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJDYXNlO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIG5vbi1wcmludGFibGUgQVNDSUkgY2hhcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVOb25BU0NJSShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuXG4gICAgICAgIC8vIE1hdGNoZXMgbm9uLXByaW50YWJsZSBBU0NJSSBjaGFycyAtXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQVNDSUkjQVNDSUlfcHJpbnRhYmxlX2NoYXJhY3RlcnNcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXlxceDIwLVxceDdFXS9nLCAnJyk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZW1vdmVOb25BU0NJSTtcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xuICAgIC8vIFRoaXMgcGF0dGVybiBpcyBnZW5lcmF0ZWQgYnkgdGhlIF9idWlsZC9wYXR0ZXJuLXJlbW92ZU5vbldvcmQuanMgc2NyaXB0XG4gICAgdmFyIFBBVFRFUk4gPSAvW15cXHgyMFxceDJEMC05QS1aXFx4NUZhLXpcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx4RkZdL2c7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgbm9uLXdvcmQgY2hhcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlTm9uV29yZChzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoUEFUVEVSTiwgJycpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVtb3ZlTm9uV29yZDtcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xudmFyIHRvSW50ID0gcmVxdWlyZSgnLi4vbnVtYmVyL3RvSW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXQgc3RyaW5nIG4gdGltZXNcbiAgICAgKi9cbiAgICAgZnVuY3Rpb24gcmVwZWF0KHN0ciwgbil7XG4gICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICAgbiA9IHRvSW50KG4pO1xuICAgICAgICBpZiAobiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuID0gTWF0aC5mbG9vcihuIC8gMik7XG4gICAgICAgICAgICBzdHIgKz0gc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgIH1cblxuICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcGVhdDtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvdG9BcnJheScpO1xuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBzdHJpbmcocykgd2l0aCB0aGUgcmVwbGFjZW1lbnQocykgaW4gdGhlIHNvdXJjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKHN0ciwgc2VhcmNoLCByZXBsYWNlbWVudHMpIHtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgc2VhcmNoID0gdG9BcnJheShzZWFyY2gpO1xuICAgICAgICByZXBsYWNlbWVudHMgPSB0b0FycmF5KHJlcGxhY2VtZW50cyk7XG5cbiAgICAgICAgdmFyIHNlYXJjaExlbmd0aCA9IHNlYXJjaC5sZW5ndGgsXG4gICAgICAgICAgICByZXBsYWNlbWVudHNMZW5ndGggPSByZXBsYWNlbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChyZXBsYWNlbWVudHNMZW5ndGggIT09IDEgJiYgc2VhcmNoTGVuZ3RoICE9PSByZXBsYWNlbWVudHNMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5lcXVhbCBudW1iZXIgb2Ygc2VhcmNoZXMgYW5kIHJlcGxhY2VtZW50cycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IHNlYXJjaExlbmd0aCkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBmaXJzdCByZXBsYWNlbWVudCBmb3IgYWxsIHNlYXJjaGVzIGlmIG9ubHkgb25lXG4gICAgICAgICAgICAvLyByZXBsYWNlbWVudCBpcyBwcm92aWRlZFxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgc2VhcmNoW2ldLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50c1socmVwbGFjZW1lbnRzTGVuZ3RoID09PSAxKSA/IDAgOiBpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVwbGFjZTtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG4gICAgLyoqXG4gICAgKiBSZXBsYWNlcyBhbGwgYWNjZW50ZWQgY2hhcnMgd2l0aCByZWd1bGFyIG9uZXNcbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VBY2NlbnRzKHN0cil7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG5cbiAgICAgICAgLy8gdmVyaWZpZXMgaWYgdGhlIFN0cmluZyBoYXMgYWNjZW50cyBhbmQgcmVwbGFjZSB0aGVtXG4gICAgICAgIGlmIChzdHIuc2VhcmNoKC9bXFx4QzAtXFx4RkZdL2cpID4gLTEpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0clxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEMwLVxceEM1XS9nLCBcIkFcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhDNl0vZywgXCJBRVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEM3XS9nLCBcIkNcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhDOC1cXHhDQl0vZywgXCJFXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4Q0MtXFx4Q0ZdL2csIFwiSVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEQwXS9nLCBcIkRcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhEMV0vZywgXCJOXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RDItXFx4RDZcXHhEOF0vZywgXCJPXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RDktXFx4RENdL2csIFwiVVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEREXS9nLCBcIllcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhERV0vZywgXCJQXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RTAtXFx4RTVdL2csIFwiYVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEU2XS9nLCBcImFlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RTddL2csIFwiY1wiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEU4LVxceEVCXS9nLCBcImVcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhFQy1cXHhFRl0vZywgXCJpXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RjFdL2csIFwiblwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEYyLVxceEY2XFx4RjhdL2csIFwib1wiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceEY5LVxceEZDXS9nLCBcInVcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHhGRV0vZywgXCJwXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4RkRcXHhGRl0vZywgXCJ5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVwbGFjZUFjY2VudHM7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCcuL3JlcGVhdCcpO1xuXG4gICAgLyoqXG4gICAgICogUGFkIHN0cmluZyB3aXRoIGBjaGFyYCBpZiBpdHMnIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gYG1pbkxlbmBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBycGFkKHN0ciwgbWluTGVuLCBjaCkge1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuICAgICAgICBjaCA9IGNoIHx8ICcgJztcbiAgICAgICAgcmV0dXJuIChzdHIubGVuZ3RoIDwgbWluTGVuKT8gc3RyICsgcmVwZWF0KGNoLCBtaW5MZW4gLSBzdHIubGVuZ3RoKSA6IHN0cjtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJwYWQ7XG5cblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xudmFyIFdISVRFX1NQQUNFUyA9IHJlcXVpcmUoJy4vV0hJVEVfU1BBQ0VTJyk7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGNoYXJzIGZyb20gZW5kIG9mIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBydHJpbShzdHIsIGNoYXJzKSB7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIGNoYXJzID0gY2hhcnMgfHwgV0hJVEVfU1BBQ0VTO1xuXG4gICAgICAgIHZhciBlbmQgPSBzdHIubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIGNoYXJMZW4gPSBjaGFycy5sZW5ndGgsXG4gICAgICAgICAgICBmb3VuZCA9IHRydWUsXG4gICAgICAgICAgICBpLCBjO1xuXG4gICAgICAgIHdoaWxlIChmb3VuZCAmJiBlbmQgPj0gMCkge1xuICAgICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICAgIGMgPSBzdHIuY2hhckF0KGVuZCk7XG5cbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBjaGFyTGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IGNoYXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZW5kLS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoZW5kID49IDApID8gc3RyLnN1YnN0cmluZygwLCBlbmQgKyAxKSA6ICcnO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcnRyaW07XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciBsb3dlckNhc2UgPSByZXF1aXJlKCcuL2xvd2VyQ2FzZScpO1xudmFyIHVwcGVyQ2FzZSA9IHJlcXVpcmUoJy4vdXBwZXJDYXNlJyk7XG4gICAgLyoqXG4gICAgICogVVBQRVJDQVNFIGZpcnN0IGNoYXIgb2YgZWFjaCBzZW50ZW5jZSBhbmQgbG93ZXJjYXNlIG90aGVyIGNoYXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlbnRlbmNlQ2FzZShzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZmlyc3QgY2hhciBvZiBlYWNoIHNlbnRlbmNlIChuZXcgbGluZSBvciBhZnRlciAnLlxccysnKSB0b1xuICAgICAgICAvLyBVUFBFUkNBU0VcbiAgICAgICAgcmV0dXJuIGxvd2VyQ2FzZShzdHIpLnJlcGxhY2UoLyheXFx3KXxcXC5cXHMrKFxcdykvZ20sIHVwcGVyQ2FzZSk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gc2VudGVuY2VDYXNlO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgcmVwbGFjZUFjY2VudHMgPSByZXF1aXJlKCcuL3JlcGxhY2VBY2NlbnRzJyk7XG52YXIgcmVtb3ZlTm9uV29yZCA9IHJlcXVpcmUoJy4vcmVtb3ZlTm9uV29yZCcpO1xudmFyIHRyaW0gPSByZXF1aXJlKCcuL3RyaW0nKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRvIGxvd2VyIGNhc2UsIHJlbW92ZSBhY2NlbnRzLCByZW1vdmUgbm9uLXdvcmQgY2hhcnMgYW5kXG4gICAgICogcmVwbGFjZSBzcGFjZXMgd2l0aCB0aGUgc3BlY2lmaWVkIGRlbGltZXRlci5cbiAgICAgKiBEb2VzIG5vdCBzcGxpdCBjYW1lbENhc2UgdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbHVnaWZ5KHN0ciwgZGVsaW1ldGVyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcblxuICAgICAgICBpZiAoZGVsaW1ldGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGltZXRlciA9IFwiLVwiO1xuICAgICAgICB9XG4gICAgICAgIHN0ciA9IHJlcGxhY2VBY2NlbnRzKHN0cik7XG4gICAgICAgIHN0ciA9IHJlbW92ZU5vbldvcmQoc3RyKTtcbiAgICAgICAgc3RyID0gdHJpbShzdHIpIC8vc2hvdWxkIGNvbWUgYWZ0ZXIgcmVtb3ZlTm9uV29yZFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8gKy9nLCBkZWxpbWV0ZXIpIC8vcmVwbGFjZSBzcGFjZXMgd2l0aCBkZWxpbWV0ZXJcbiAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzbHVnaWZ5O1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHN0cmluZyBzdGFydHMgd2l0aCBzcGVjaWZpZWQgcHJlZml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBwcmVmaXgpIHtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgcHJlZml4ID0gdG9TdHJpbmcocHJlZml4KTtcblxuICAgICAgICByZXR1cm4gc3RyLmluZGV4T2YocHJlZml4KSA9PT0gMDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHN0YXJ0c1dpdGg7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgSFRNTCB0YWdzIGZyb20gc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmlwSHRtbFRhZ3Moc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcblxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLzxbXj5dKj4vZywgJycpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHN0cmlwSHRtbFRhZ3M7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciBXSElURV9TUEFDRVMgPSByZXF1aXJlKCcuL1dISVRFX1NQQUNFUycpO1xudmFyIGx0cmltID0gcmVxdWlyZSgnLi9sdHJpbScpO1xudmFyIHJ0cmltID0gcmVxdWlyZSgnLi9ydHJpbScpO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSB3aGl0ZS1zcGFjZXMgZnJvbSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbShzdHIsIGNoYXJzKSB7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIGNoYXJzID0gY2hhcnMgfHwgV0hJVEVfU1BBQ0VTO1xuICAgICAgICByZXR1cm4gbHRyaW0ocnRyaW0oc3RyLCBjaGFycyksIGNoYXJzKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcbnZhciB0cmltID0gcmVxdWlyZSgnLi90cmltJyk7XG4gICAgLyoqXG4gICAgICogTGltaXQgbnVtYmVyIG9mIGNoYXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0ciwgbWF4Q2hhcnMsIGFwcGVuZCwgb25seUZ1bGxXb3Jkcyl7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIGFwcGVuZCA9IGFwcGVuZCB8fCAnLi4uJztcbiAgICAgICAgbWF4Q2hhcnMgPSBvbmx5RnVsbFdvcmRzPyBtYXhDaGFycyArIDEgOiBtYXhDaGFycztcblxuICAgICAgICBzdHIgPSB0cmltKHN0cik7XG4gICAgICAgIGlmKHN0ci5sZW5ndGggPD0gbWF4Q2hhcnMpe1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIG1heENoYXJzIC0gYXBwZW5kLmxlbmd0aCk7XG4gICAgICAgIC8vY3JvcCBhdCBsYXN0IHNwYWNlIG9yIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICAgIHN0ciA9IG9ubHlGdWxsV29yZHM/IHN0ci5zdWJzdHIoMCwgc3RyLmxhc3RJbmRleE9mKCcgJykpIDogdHJpbShzdHIpO1xuICAgICAgICByZXR1cm4gc3RyICsgYXBwZW5kO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRydW5jYXRlO1xuXG4iLCJcblxuICAgIHZhciBVTkRFRjtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBzdHJpbmcgYW5kIGNvbnZlcnQgaXQgaW50byBhIG5hdGl2ZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0eXBlY2FzdCh2YWwpIHtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIGlmICggdmFsID09PSBudWxsIHx8IHZhbCA9PT0gJ251bGwnICkge1xuICAgICAgICAgICAgciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoIHZhbCA9PT0gJ3RydWUnICkge1xuICAgICAgICAgICAgciA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIHZhbCA9PT0gJ2ZhbHNlJyApIHtcbiAgICAgICAgICAgIHIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICggdmFsID09PSBVTkRFRiB8fCB2YWwgPT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgciA9IFVOREVGO1xuICAgICAgICB9IGVsc2UgaWYgKCB2YWwgPT09ICcnIHx8IGlzTmFOKHZhbCkgKSB7XG4gICAgICAgICAgICAvL2lzTmFOKCcnKSByZXR1cm5zIGZhbHNlXG4gICAgICAgICAgICByID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9wYXJzZUZsb2F0KG51bGwgfHwgJycpIHJldHVybnMgTmFOXG4gICAgICAgICAgICByID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdHlwZWNhc3Q7XG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcblxuICAgIHZhciBDQU1FTF9DQVNFX0JPUkRFUiA9IC8oW2EtelxceEUwLVxceEZGXSkoW0EtWlxceEMwXFx4REZdKS9nO1xuXG4gICAgLyoqXG4gICAgICogQWRkIHNwYWNlIGJldHdlZW4gY2FtZWxDYXNlIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5DYW1lbENhc2Uoc3RyLCBkZWxpbWl0ZXIpe1xuICAgICAgICBpZiAoZGVsaW1pdGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGltaXRlciA9ICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGpvaW4oc3RyLCBjMSwgYzIpIHtcbiAgICAgICAgICAgIHJldHVybiBjMSArIGRlbGltaXRlciArIGMyO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoQ0FNRUxfQ0FTRV9CT1JERVIsIGpvaW4pO1xuICAgICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTsgLy9hZGQgc3BhY2UgYmV0d2VlbiBjYW1lbENhc2UgdGV4dFxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHVuQ2FtZWxDYXNlO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG52YXIgc2x1Z2lmeSA9IHJlcXVpcmUoJy4vc2x1Z2lmeScpO1xudmFyIHVuQ2FtZWxDYXNlID0gcmVxdWlyZSgnLi91bkNhbWVsQ2FzZScpO1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHNwYWNlcyB3aXRoIHVuZGVyc2NvcmVzLCBzcGxpdCBjYW1lbENhc2UgdGV4dCwgcmVtb3ZlIG5vbi13b3JkIGNoYXJzLCByZW1vdmUgYWNjZW50cyBhbmQgY29udmVydCB0byBsb3dlciBjYXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZGVyc2NvcmUoc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgc3RyID0gdW5DYW1lbENhc2Uoc3RyKTtcbiAgICAgICAgcmV0dXJuIHNsdWdpZnkoc3RyLCBcIl9cIik7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gdW5kZXJzY29yZTtcblxuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vbGFuZy90b1N0cmluZycpO1xuXG4gICAgLyoqXG4gICAgICogVW5lc2NhcGVzIEhUTUwgc3BlY2lhbCBjaGFyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbChzdHIpe1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdHIpXG4gICAgICAgICAgICAucmVwbGFjZSgvJmFtcDsvZyAsICcmJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mbHQ7L2cgICwgJzwnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyZndDsvZyAgLCAnPicpXG4gICAgICAgICAgICAucmVwbGFjZSgvJiMwKjM5Oy9nICwgXCInXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdW5lc2NhcGVIdG1sO1xuXG5cbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2xhbmcvdG9TdHJpbmcnKTtcblxuICAgIC8qKlxuICAgICAqIFVuZXNjYXBlIHVuaWNvZGUgY2hhciBzZXF1ZW5jZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZVVuaWNvZGUoc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXFxcdVswLTlhLWZdezR9L2csIGZ1bmN0aW9uKGNoKXtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcGFyc2VJbnQoY2guc2xpY2UoMiksIDE2KTtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHVuZXNjYXBlVW5pY29kZTtcblxuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgaHlwaGVucyB3aXRoIHNwYWNlcy4gKG9ubHkgaHlwaGVucyBiZXR3ZWVuIHdvcmQgY2hhcnMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5oeXBoZW5hdGUoc3RyKXtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RyKTtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oXFx3KSgtKShcXHcpL2csICckMSAkMycpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHVuaHlwaGVuYXRlO1xuXG4iLCJ2YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL3RvU3RyaW5nJyk7XG4gICAgLyoqXG4gICAgICogXCJTYWZlclwiIFN0cmluZy50b1VwcGVyQ2FzZSgpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBwZXJDYXNlKHN0cil7XG4gICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0cik7XG4gICAgICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1cHBlckNhc2U7XG5cbiIsIlxuXG4vL2F1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLCBkbyBub3QgZWRpdCFcbi8vcnVuIGBub2RlIGJ1aWxkYCBpbnN0ZWFkXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnY29udmVydCcgOiByZXF1aXJlKCcuL3RpbWUvY29udmVydCcpLFxuICAgICdub3cnIDogcmVxdWlyZSgnLi90aW1lL25vdycpLFxuICAgICdwYXJzZU1zJyA6IHJlcXVpcmUoJy4vdGltZS9wYXJzZU1zJyksXG4gICAgJ3RvVGltZVN0cmluZycgOiByZXF1aXJlKCcuL3RpbWUvdG9UaW1lU3RyaW5nJylcbn07XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IHRpbWUgaW50byBhbm90aGVyIHVuaXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb252ZXJ0KHZhbCwgc291cmNlVW5pdE5hbWUsIGRlc3RpbmF0aW9uVW5pdE5hbWUpe1xuICAgICAgICBkZXN0aW5hdGlvblVuaXROYW1lID0gZGVzdGluYXRpb25Vbml0TmFtZSB8fCAnbXMnO1xuICAgICAgICByZXR1cm4gKHZhbCAqIGdldFVuaXQoc291cmNlVW5pdE5hbWUpKSAvIGdldFVuaXQoZGVzdGluYXRpb25Vbml0TmFtZSk7XG4gICAgfVxuXG5cbiAgICAvL1RPRE86IG1heWJlIGV4dHJhY3QgdG8gYSBzZXBhcmF0ZSBtb2R1bGVcbiAgICBmdW5jdGlvbiBnZXRVbml0KHVuaXROYW1lKXtcbiAgICAgICAgc3dpdGNoKHVuaXROYW1lKXtcbiAgICAgICAgICAgIGNhc2UgJ21zJzpcbiAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgcmV0dXJuIDEwMDA7XG4gICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgIHJldHVybiA2MDAwMDtcbiAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgIHJldHVybiAzNjAwMDAwO1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgICByZXR1cm4gODY0MDAwMDA7XG4gICAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgICByZXR1cm4gNjA0ODAwMDAwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJysgdW5pdE5hbWUgKyAnXCIgaXMgbm90IGEgdmFsaWQgdW5pdCcpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnQ7XG5cblxuIiwiXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCB0aW1lIGluIG1pbGlzZWNvbmRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm93KCl7XG4gICAgICAgIC8vIHllcywgd2UgZGVmZXIgdGhlIHdvcmsgdG8gYW5vdGhlciBmdW5jdGlvbiB0byBhbGxvdyBtb2NraW5nIGl0XG4gICAgICAgIC8vIGR1cmluZyB0aGUgdGVzdHNcbiAgICAgICAgcmV0dXJuIG5vdy5nZXQoKTtcbiAgICB9XG5cbiAgICBub3cuZ2V0ID0gKHR5cGVvZiBEYXRlLm5vdyA9PT0gJ2Z1bmN0aW9uJyk/IERhdGUubm93IDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuICsobmV3IERhdGUoKSk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gbm93O1xuXG5cbiIsInZhciBjb3VudFN0ZXBzID0gcmVxdWlyZSgnLi4vbWF0aC9jb3VudFN0ZXBzJyk7XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aW1lc3RhbXAgaW50byBhbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhtcyl7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgOiBjb3VudFN0ZXBzKG1zLCAxLCAxMDAwKSxcbiAgICAgICAgICAgIHNlY29uZHMgICAgICA6IGNvdW50U3RlcHMobXMsIDEwMDAsIDYwKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgICAgICA6IGNvdW50U3RlcHMobXMsIDYwMDAwLCA2MCksXG4gICAgICAgICAgICBob3VycyAgICAgICAgOiBjb3VudFN0ZXBzKG1zLCAzNjAwMDAwLCAyNCksXG4gICAgICAgICAgICBkYXlzICAgICAgICAgOiBjb3VudFN0ZXBzKG1zLCA4NjQwMDAwMClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcnNlTXM7XG5cbiIsInZhciBjb3VudFN0ZXBzID0gcmVxdWlyZSgnLi4vbWF0aC9jb3VudFN0ZXBzJyk7XG52YXIgcGFkID0gcmVxdWlyZSgnLi4vbnVtYmVyL3BhZCcpO1xuXG4gICAgdmFyIEhPVVIgPSAzNjAwMDAwLFxuICAgICAgICBNSU5VVEUgPSA2MDAwMCxcbiAgICAgICAgU0VDT05EID0gMTAwMDtcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCB0aW1lc3RhbXAgaW50byBhIHRpbWUgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvVGltZVN0cmluZyhtcyl7XG4gICAgICAgIHZhciBoID0gbXMgPCBIT1VSICAgPyAwIDogY291bnRTdGVwcyhtcywgSE9VUiksXG4gICAgICAgICAgICBtID0gbXMgPCBNSU5VVEUgPyAwIDogY291bnRTdGVwcyhtcywgTUlOVVRFLCA2MCksXG4gICAgICAgICAgICBzID0gbXMgPCBTRUNPTkQgPyAwIDogY291bnRTdGVwcyhtcywgU0VDT05ELCA2MCksXG4gICAgICAgICAgICBzdHIgPSAnJztcblxuICAgICAgICBzdHIgKz0gaD8gaCArICc6JyA6ICcnO1xuICAgICAgICBzdHIgKz0gcGFkKG0sIDIpICsgJzonO1xuICAgICAgICBzdHIgKz0gcGFkKHMsIDIpO1xuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gdG9UaW1lU3RyaW5nO1xuXG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcGF0aFRvUmVnZXhwO1xuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCJdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZF1cbiAgJyhbXFxcXC8uXSk/KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXildKSopXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W14pXSkqKVxcXFwpKShbKyo/XSk/JyxcbiAgLy8gTWF0Y2ggcmVnZXhwIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IGFyZSBhbHdheXMgZXNjYXBlZC5cbiAgJyhbLisqPz1eIToke30oKVtcXFxcXXxcXFxcL10pJ1xuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAge1JlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAga2V5c1xuICogQHJldHVybiB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5cztcbiAgcmV0dXJuIHJlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knO1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHtSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAga2V5c1xuICogQHJldHVybiB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiAgICAgIGksXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6ICBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiAgICBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cyk7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSk7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpO1xuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpO1xufVxuXG4vKipcbiAqIFJlcGxhY2UgdGhlIHNwZWNpZmljIHRhZ3Mgd2l0aCByZWdleHAgc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAga2V5c1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiByZXBsYWNlUGF0aCAocGF0aCwga2V5cykge1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIGZ1bmN0aW9uIHJlcGxhY2UgKF8sIGVzY2FwZWQsIHByZWZpeCwga2V5LCBjYXB0dXJlLCBncm91cCwgc3VmZml4LCBlc2NhcGUpIHtcbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcmV0dXJuIGVzY2FwZWQ7XG4gICAgfVxuXG4gICAgaWYgKGVzY2FwZSkge1xuICAgICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZTtcbiAgICB9XG5cbiAgICB2YXIgcmVwZWF0ICAgPSBzdWZmaXggPT09ICcrJyB8fCBzdWZmaXggPT09ICcqJztcbiAgICB2YXIgb3B0aW9uYWwgPSBzdWZmaXggPT09ICc/JyB8fCBzdWZmaXggPT09ICcqJztcblxuICAgIGtleXMucHVzaCh7XG4gICAgICBuYW1lOiAgICAgIGtleSB8fCBpbmRleCsrLFxuICAgICAgZGVsaW1pdGVyOiBwcmVmaXggfHwgJy8nLFxuICAgICAgb3B0aW9uYWw6ICBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogICAgcmVwZWF0XG4gICAgfSk7XG5cbiAgICBwcmVmaXggPSBwcmVmaXggPyAoJ1xcXFwnICsgcHJlZml4KSA6ICcnO1xuICAgIGNhcHR1cmUgPSBlc2NhcGVHcm91cChjYXB0dXJlIHx8IGdyb3VwIHx8ICdbXicgKyAocHJlZml4IHx8ICdcXFxcLycpICsgJ10rPycpO1xuXG4gICAgaWYgKHJlcGVhdCkge1xuICAgICAgY2FwdHVyZSA9IGNhcHR1cmUgKyAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgcmV0dXJuICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nO1xuICAgIH1cblxuICAgIC8vIEJhc2ljIHBhcmFtZXRlciBzdXBwb3J0LlxuICAgIHJldHVybiBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknO1xuICB9XG5cbiAgcmV0dXJuIHBhdGgucmVwbGFjZShQQVRIX1JFR0VYUCwgcmVwbGFjZSk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoU3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICAgICAgICAgW2tleXNdXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICAgICAgICAgIFtvcHRpb25zXVxuICogQHJldHVybiB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAga2V5cyA9IGtleXMgfHwgW107XG5cbiAgaWYgKCFpc0FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IGtleXM7XG4gICAga2V5cyA9IFtdO1xuICB9IGVsc2UgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoaXNBcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlO1xuICB2YXIgcm91dGUgPSByZXBsYWNlUGF0aChwYXRoLCBrZXlzKTtcbiAgdmFyIGVuZHNXaXRoU2xhc2ggPSBwYXRoLmNoYXJBdChwYXRoLmxlbmd0aCAtIDEpID09PSAnLyc7XG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoU2xhc2ggPyByb3V0ZS5zbGljZSgwLCAtMikgOiByb3V0ZSkgKyAnKD86XFxcXC8oPz0kKSk/JztcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCc7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aFNsYXNoID8gJycgOiAnKD89XFxcXC98JCknO1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsImRhdCA9IHJlcXVpcmUgXCJkYXQtZ3VpXCJcbnBhZ2UgPSByZXF1aXJlIFwicGFnZVwiXG5cblxuZ3VpID0gd2luZG93Ll9ndWkgPSBuZXcgZGF0LkdVSSgpXG5cbm9wdGlvbnMgPVxuXHRcImRlYnVnXCI6IGZhbHNlXG5cdFwiaW5kZXhcIjogLT4gcGFnZSBcIi9hYW5kbFwiXG5cdFwibW9ybmluZ1wiOiAtPiBwYWdlIFwiL2FhbmRsL21vcm5pbmdcIlxuXHRcImRheVwiOiAtPiBwYWdlIFwiL2FhbmRsL2RheVwiXG5cdFwibmlnaHRcIjogLT4gcGFnZSBcIi9hYW5kbC9uaWdodFwiXG5cbm1vZHVsZS5leHBvcnRzID0gLT5cblx0IyBkZWJ1Z1xuXHRkZWJ1ZyA9IGd1aS5hZGQob3B0aW9ucywgXCJkZWJ1Z1wiKVxuXG5cdCMgbmF2aWdhdGlvblxuXHRmb2xkZXIgPSBndWkuYWRkRm9sZGVyKFwibmF2aWdhdGlvblwiKVxuXHRmb2xkZXIuYWRkKG9wdGlvbnMsIFwiaW5kZXhcIikubmFtZShcIi9pbmRleFwiKVxuXHRmb2xkZXIuYWRkKG9wdGlvbnMsIFwibW9ybmluZ1wiKS5uYW1lKFwiL21vcm5pbmdcIilcblx0Zm9sZGVyLmFkZChvcHRpb25zLCBcImRheVwiKS5uYW1lKFwiL2RheVwiKVxuXHRmb2xkZXIuYWRkKG9wdGlvbnMsIFwibmlnaHRcIikubmFtZShcIi9uaWdodFwiKVxuXHRmb2xkZXIub3BlbigpXG4iLCJtb2R1bGUuZXhwb3J0cyA9XG5cbiAgICBmaXJlYmFzZTogXCJhbGljZWx1a2VcIlxuIiwiUmFjdGl2ZSA9IHJlcXVpcmUgXCJyYWN0aXZlXCJcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhY3RpdmUuZXh0ZW5kXG5cblx0aXNvbGF0ZWQ6IHRydWVcbiIsIiMjI1xuXHRAbW9kdWxlOiAgIGFic3RyYWN0LXNjZW5lXG5cdEBhdXRob3I6ICAgbHVrZWhlZGdlciA8bHVrZS5oZWRnZXJAZ21haWwuY29tPlxuXHRAY3NzOiAgICAgIC4vc291cmNlL2Nzcy9tb2R1bGUvYWJzdHJhY3Qtc2NlbmUuc3R5bFxuXHRAaHRtbDogICAgIC4vc291cmNlL3RlbXBsYXRlL21vZHVsZS9hYnN0cmFjdC1zY2VuZS5odG1sXG4jIyNcblxuXG5Nb2R1bGUgPSByZXF1aXJlIFwiLi9hYnN0cmFjdC1tb2R1bGVcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZS5leHRlbmRcblxuXHR0ZW1wbGF0ZTogcmVxdWlyZSBcIm1vZHVsZS9hYnN0cmFjdC1zY2VuZS5odG1sXCJcblxuXHRvbmluaXQ6IC0+XG5cdFx0XG4iLCIjIyNcblx0VEhJUyBGSUxFIElTIEdFTkVSQVRFRCBBVVRPTUFUSUNBTExZIEFORCBJVCBXSUxMXG5cdEJFIFJFUExBQ0VEIElGIEEgTkVXIE1PRFVMRSBJUyBBRERFRCBPUiBERUxFVEVELlxuIyMjXG5SYWN0aXZlID0gcmVxdWlyZSBcInJhY3RpdmVcIlxuXG5yZWdpc3RlciA9IC0+XG5cdFJhY3RpdmUuY29tcG9uZW50c1tcInVpLWFic3RyYWN0LXNjZW5lXCJdID0gcmVxdWlyZSBcIi4vYWJzdHJhY3Qtc2NlbmVcIlxuXHRSYWN0aXZlLmNvbXBvbmVudHNbXCJ1aS1zY2VuZS1kYXlcIl0gPSByZXF1aXJlIFwiLi9zY2VuZS1kYXlcIlxuXHRSYWN0aXZlLmNvbXBvbmVudHNbXCJ1aS1zY2VuZS1tb3JuaW5nXCJdID0gcmVxdWlyZSBcIi4vc2NlbmUtbW9ybmluZ1wiXG5cdFJhY3RpdmUuY29tcG9uZW50c1tcInVpLXNjZW5lLW5pZ2h0XCJdID0gcmVxdWlyZSBcIi4vc2NlbmUtbmlnaHRcIlxuXHRSYWN0aXZlLmNvbXBvbmVudHNbXCJ1aS1zdGFnZVwiXSA9IHJlcXVpcmUgXCIuL3N0YWdlXCJcblx0XG5cdHRydWVcblxubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlcigpIiwiIyMjXG5cdEBtb2R1bGU6ICAgc2NlbmUtZGF5XG5cdEBhdXRob3I6ICAgbHVrZWhlZGdlciA8bHVrZS5oZWRnZXJAZ21haWwuY29tPlxuXHRAY3NzOiAgICAgIC4vc291cmNlL2Nzcy9tb2R1bGUvc2NlbmUtZGF5LnN0eWxcblx0QGh0bWw6ICAgICAuL3NvdXJjZS90ZW1wbGF0ZS9tb2R1bGUvc2NlbmUtZGF5Lmh0bWxcbiMjI1xuXG5cbk1vZHVsZSA9IHJlcXVpcmUgXCIuL2Fic3RyYWN0LXNjZW5lXCJcbmtleXMgPSByZXF1aXJlKFwibW91dFwiKS5vYmplY3Qua2V5c1xubGFzdCA9IHJlcXVpcmUoXCJtb3V0XCIpLmFycmF5Lmxhc3RcblxubW9kdWxlLmV4cG9ydHMgPSBNb2R1bGUuZXh0ZW5kXG5cblx0dGVtcGxhdGU6IHJlcXVpcmUgXCJtb2R1bGUvc2NlbmUtZGF5Lmh0bWxcIlxuXG5cdHBhcnRpYWxzOlxuXHRcdHNsaWRlQ29udHJvbHM6IHJlcXVpcmUgXCJwYXJ0aWFscy9zbGlkZS1jb250cm9scy5odG1sXCJcblxuXHRkYXRhOlxuXHRcdGN1cnJlbnQ6IDBcblx0XHR4OiBbXCIxMDAlXCIsIFwiLTIwMCVcIl1cblxuXHRvbmluaXQ6IC0+IEBfc3VwZXIoKVxuXG5cdG9udGVhcmRvd246IC0+XG5cdFx0QHByZXZTbGlkZSgpXG5cdFx0IyBUT0RPIC0gdGhlcmUgaXMgYSBtaW5vciBpc3N1ZSB3aGVuIG1vdmluZyBmcm9tIGRpZ2VzdC0+ZGF5IHdoZXJlIGRpZ2VzdCBpcyBub3QgdmlzaWJsZSAoYmVoaW5kIGRheSkgc28gY2Fubm90IHNlZSBvdXRybyB0cmFuc2l0aW9uXG5cdFx0QHNldCBcInNsaWRlcy4qLmFjdGl2ZVwiLCBmYWxzZVxuXG5cdG9ucmVuZGVyOiAtPlxuXHRcdEBvbiBcImdvTmV4dFNsaWRlXCIsIC0+IEBuZXh0U2xpZGUoKVxuXHRcdEBvbiBcImdvUHJldlNsaWRlXCIsIC0+IEBwcmV2U2xpZGUoKVxuXG5cdFx0QG5leHRTbGlkZSgpXG5cblx0bmV4dFNsaWRlOiAtPlxuXHRcdGN1cnJlbnQgPSBAZ2V0KFwiY3VycmVudFwiKVxuXHRcdG5leHQgPSBpZiBjdXJyZW50IGlzIGtleXMoQGdldChcInNsaWRlc1wiKSkubGVuZ3RoIHRoZW4gMSBlbHNlIGN1cnJlbnQrPTFcblx0XHRAc2V0IFwic2xpZGVzLiN7QGdldChcImN1cnJlbnRcIil9LnhcIiwgQGdldChcInhbMV1cIikgaWYgQGdldChcImN1cnJlbnRcIikgaXNudCAwXG5cdFx0QHNldCBcInNsaWRlcy4je25leHR9LnhcIiwgQGdldChcInhbMF1cIilcblx0XHRAc2V0U2xpZGUgbmV4dFxuXG5cdHByZXZTbGlkZTogLT5cblx0XHRjdXJyZW50ID0gQGdldChcImN1cnJlbnRcIilcblx0XHRwcmV2ID0gaWYgY3VycmVudCBpcyAxIHRoZW4ga2V5cyhAZ2V0KFwic2xpZGVzXCIpKS5sZW5ndGggZWxzZSBjdXJyZW50LT0xXG5cdFx0QHNldCBcInNsaWRlcy4je0BnZXQoXCJjdXJyZW50XCIpfS54XCIsIEBnZXQoXCJ4WzBdXCIpIGlmIEBnZXQoXCJjdXJyZW50XCIpIGlzbnQgMFxuXHRcdEBzZXQgXCJzbGlkZXMuI3twcmV2fS54XCIsIEBnZXQoXCJ4WzFdXCIpXG5cdFx0QHNldFNsaWRlIHByZXZcblxuXHRzZXRTbGlkZTogKHNsaWRlKSAtPlxuXHRcdEBzZXQgXCJzbGlkZXMuI3tAZ2V0KFwiY3VycmVudFwiKX0uYWN0aXZlXCIsIGZhbHNlIGlmIEBnZXQoXCJjdXJyZW50XCIpIGlzbnQgMFxuXHRcdEBzZXQgXCJzbGlkZXMuI3tzbGlkZX0uYWN0aXZlXCIsIHRydWVcblx0XHRAc2V0IGN1cnJlbnQ6IHNsaWRlXG4iLCIjIyNcblx0QG1vZHVsZTogICBzY2VuZS1tb3JuaW5nXG5cdEBhdXRob3I6ICAgbHVrZWhlZGdlciA8bHVrZS5oZWRnZXJAZ21haWwuY29tPlxuXHRAY3NzOiAgICAgIC4vc291cmNlL2Nzcy9tb2R1bGUvc2NlbmUtbW9ybmluZy5zdHlsXG5cdEBodG1sOiAgICAgLi9zb3VyY2UvdGVtcGxhdGUvbW9kdWxlL3NjZW5lLW1vcm5pbmcuaHRtbFxuIyMjXG5cblxuTW9kdWxlID0gcmVxdWlyZSBcIi4vYWJzdHJhY3Qtc2NlbmVcIlxuXG5cbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlLmV4dGVuZFxuXG5cdHRlbXBsYXRlOiByZXF1aXJlIFwibW9kdWxlL3NjZW5lLW1vcm5pbmcuaHRtbFwiXG5cblx0b25pbml0OiAtPiBAX3N1cGVyKClcblxuXHRvbnJlbmRlcjogLT5cbiIsIiMjI1xuXHRAbW9kdWxlOiAgIHNjZW5lLW5pZ2h0XG5cdEBhdXRob3I6ICAgbHVrZWhlZGdlciA8bHVrZS5oZWRnZXJAZ21haWwuY29tPlxuXHRAY3NzOiAgICAgIC4vc291cmNlL2Nzcy9tb2R1bGUvc2NlbmUtbmlnaHQuc3R5bFxuXHRAaHRtbDogICAgIC4vc291cmNlL3RlbXBsYXRlL21vZHVsZS9zY2VuZS1uaWdodC5odG1sXG4jIyNcblxuXG5Nb2R1bGUgPSByZXF1aXJlIFwiLi9hYnN0cmFjdC1zY2VuZVwiXG5cbkFkZENsYXNzID0gcmVxdWlyZSBcIi4uL3V0aWwvYWRkQ2xhc3NcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZS5leHRlbmRcblxuXHR0ZW1wbGF0ZTogcmVxdWlyZSBcIm1vZHVsZS9zY2VuZS1uaWdodC5odG1sXCJcblxuXHRvbmluaXQ6IC0+IEBfc3VwZXIoKVxuXG5cdG9ucmVuZGVyOiAtPlxuXHRcdEBvbiBcInNlbmRNZXNzYWdlXCIsIChlKSAtPlxuXHRcdFx0QGZpcmUgXCJtc2dTZW50XCIsIEBnZXQoXCJtZXNzYWdlXCIpXG5cblx0XHRcdCMgZGlzYWJsZVxuXHRcdFx0QG9mZiBcInNlbmRNZXNzYWdlXCJcblx0XHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWVzc2FnZVwiKS5kaXNhYmxlZCA9IHRydWVcblx0XHRcdEFkZENsYXNzIGUubm9kZSwgXCJkaXNhYmxlZFwiXG5cblx0XHRcdCMgc2VudCFcblx0XHRcdGxpbmsgPSBAZmluZChcIi5wb3N0Y2FyZF9fc2VuZCBhXCIpXG5cdFx0XHRsaW5rLmlubmVySFRNTCA9IFwiU2VudFwiXG4iLCIjIyNcblx0QG1vZHVsZTogICBzdGFnZVxuXHRAYXV0aG9yOiAgIGx1a2VoZWRnZXIgPGx1a2UuaGVkZ2VyQGdtYWlsLmNvbT5cblx0QGNzczogICAgICAuL3NvdXJjZS9jc3MvbW9kdWxlL3N0YWdlLnN0eWxcblx0QGh0bWw6ICAgICAuL3NvdXJjZS90ZW1wbGF0ZS9tb2R1bGUvc3RhZ2UuaHRtbFxuIyMjXG5cblxuTW9kdWxlID0gcmVxdWlyZSBcIi4vYWJzdHJhY3QtbW9kdWxlXCJcbnBhZ2UgPSByZXF1aXJlIFwicGFnZVwiXG5cbmtleXMgPSByZXF1aXJlKFwibW91dFwiKS5vYmplY3Qua2V5c1xuZm9ySW4gPSByZXF1aXJlKFwibW91dFwiKS5vYmplY3QuZm9ySW5cbkFkZENsYXNzID0gcmVxdWlyZSBcIi4uL3V0aWwvYWRkQ2xhc3NcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZS5leHRlbmRcblxuXHR0ZW1wbGF0ZTogcmVxdWlyZSBcIm1vZHVsZS9zdGFnZS5odG1sXCJcblxuXHRwYXJ0aWFsczpcblx0XHRzdGFnZUNvbnRyb2xzOiByZXF1aXJlIFwicGFydGlhbHMvc3RhZ2UtY29udHJvbHMuaHRtbFwiXG5cdFx0ZmFybTogcmVxdWlyZSBcInBhcnRpYWxzL2Zhcm0uaHRtbFwiXG5cdFx0c3VuOiByZXF1aXJlIFwicGFydGlhbHMvc3VuLmh0bWxcIlxuXG5cdGRhdGE6XG5cdFx0Y3VycmVudDogMFxuXHRcdHNjZW5lczpcblx0XHRcdDE6IFwibW9ybmluZ1wiXG5cdFx0XHQyOiBcImRheVwiXG5cdFx0XHQzOiBcIm5pZ2h0XCJcblxuXHRvbmluaXQ6IC0+XG5cblx0XHR3aW5kb3cub25rZXlkb3duID0gKGUpID0+XG5cdFx0XHRAcHJldlNjZW5lKCkgaWYgZS5rZXlDb2RlIGlzIDM4XG5cdFx0XHRAbmV4dFNjZW5lKCkgaWYgZS5rZXlDb2RlIGlzIDQwXG5cblx0XHRAb24gXCJnb05leHRTY2VuZVwiLCAtPiBAbmV4dFNjZW5lKClcblx0XHRAb24gXCJnb1ByZXZTY2VuZVwiLCAtPiBAcHJldlNjZW5lKClcblxuXHRcdEBvYnNlcnZlIFwidmlld1wiLCAobmV3VmFsdWUpID0+XG5cdFx0XHRpZiBuZXdWYWx1ZVxuXHRcdFx0XHRmb3JJbihAZ2V0KFwic2NlbmVzXCIpLCAodiwgaykgPT4gcmV0dXJuIEBzZXQgY3VycmVudDogcGFyc2VJbnQoaywxMCkgaWYgdiBpcyBuZXdWYWx1ZSlcblxuXHRuZXh0U2NlbmU6IC0+XG5cdFx0Y3VycmVudCA9IEBnZXQoXCJjdXJyZW50XCIpXG5cdFx0bmV4dCA9IGlmIGN1cnJlbnQgaXMga2V5cyhAZ2V0KFwic2NlbmVzXCIpKS5sZW5ndGggdGhlbiAxIGVsc2UgY3VycmVudCs9MVxuXHRcdEBzZXRTY2VuZSBuZXh0XG5cblx0cHJldlNjZW5lOiAtPlxuXHRcdGN1cnJlbnQgPSBAZ2V0KFwiY3VycmVudFwiKVxuXHRcdHByZXYgPSBpZiBjdXJyZW50IGlzIDEgdGhlbiBrZXlzKEBnZXQoXCJzY2VuZXNcIikpLmxlbmd0aCBlbHNlIGN1cnJlbnQtPTFcblx0XHRAc2V0U2NlbmUgcHJldlxuXG5cdHNldFNjZW5lOiAoc2NlbmUpIC0+XG5cdFx0cGFnZSBcIi8je0BnZXQoXCJjb2RlXCIpfS8je0BnZXQoXCJzY2VuZXMuI3tzY2VuZX1cIil9XCJcbiIsIm1vZHVsZS5leHBvcnRzID0gKGVsLCBjbGFzc05hbWUpIC0+XG5cdGlmIGVsP1xuXHRcdGlmIGVsLmNsYXNzTGlzdD9cblx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKVxuXHRcdGVsc2Vcblx0XHRcdGVsLmNsYXNzTmFtZSArPSAnICcgKyBjbGFzc05hbWVcbiIsInBsYXRmb3JtID0gcmVxdWlyZSBcInBsYXRmb3JtXCJcblxubW9kdWxlLmV4cG9ydHMgPSAoKSAtPlxuXG4gICAgIyBJRTw5XG4gICAgcmV0dXJuIGlmIHBsYXRmb3JtLm5hbWUgaXMgXCJJRVwiIGFuZCBwYXJzZUZsb2F0KHBsYXRmb3JtLnZlcnNpb24pIDwgOSB0aGVuIGZhbHNlIGVsc2UgdHJ1ZVxuIiwiUmFjdGl2ZSA9IHJlcXVpcmUgXCJyYWN0aXZlXCJcbkZpcmViYXNlID0gcmVxdWlyZSBcImZpcmViYXNlXCJcbnBhZ2UgPSByZXF1aXJlIFwicGFnZVwiXG5cblN1cHBvcnRlZCA9IHJlcXVpcmUgXCIuLi91dGlsL3N1cHBvcnRlZFwiXG5sYXN0ID0gcmVxdWlyZShcIm1vdXRcIikuYXJyYXkubGFzdFxua2V5cyA9IHJlcXVpcmUoXCJtb3V0XCIpLm9iamVjdC5rZXlzXG5wYWQgPSByZXF1aXJlKFwibW91dFwiKS5udW1iZXIucGFkXG5cbmNvbmZpZyA9IHJlcXVpcmUgXCIuLi9jb25maWdcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhY3RpdmUuZXh0ZW5kXG5cblx0ZWw6IGRvY3VtZW50LmJvZHlcblxuXHRhcHBlbmQ6IHRydWVcblxuXHR0ZW1wbGF0ZTogcmVxdWlyZSBcIm1haW4tdmlldy5odG1sXCJcblxuXHRwYXJ0aWFsczpcblx0XHRsb2FkZXI6IHJlcXVpcmUgXCJwYXJ0aWFscy9sb2FkZXIuaHRtbFwiXG5cblx0ZGF0YTpcblx0XHRjb2RlOiBudWxsXG5cdFx0dmlldzogbnVsbFxuXHRcdGNvbnRlbnQ6IG51bGxcblx0XHRndWVzdDogbnVsbFxuXHRcdGF1dGhvcmlzZWQ6IHRydWVcblx0XHRsb2FkZWQ6IGZhbHNlXG5cdFx0c3VwcG9ydGVkOiB0cnVlXG5cblx0ZGI6IG51bGxcblxuXHRvbmluaXQ6IC0+XG5cdFx0QHNldF9yb3V0ZXIoKVxuXG5cdFx0IyBjYXRjaCB1bnN1cHBvcnRlZFxuXHRcdEBzZXQgc3VwcG9ydGVkOiBTdXBwb3J0ZWQoKVxuXHRcdHJldHVybiBpZiAhQGdldChcInN1cHBvcnRlZFwiKVxuXG5cdG9ucmVuZGVyOiAtPlxuXHRcdCMgY2hlY2sgY29kZVxuXHRcdGNvZGUgPSBAZ2V0KFwiY29kZVwiKVxuXHRcdGlmIGNvZGU/IHRoZW4gQGdldERhdGEoY29kZSkgZWxzZSBAc2V0KFwiYXV0aG9yaXNlZFwiLCBmYWxzZSlcblxuXHRnZXREYXRhOiAoY29kZSkgLT5cblx0XHQjIGNvbm5lY3QgZGJcblx0XHRAZGIgPSBuZXcgRmlyZWJhc2UgXCJodHRwczovLyN7Y29uZmlnLmZpcmViYXNlfS5maXJlYmFzZWlvLmNvbS9cIlxuXG5cdFx0QGRiLm9uY2UgXCJ2YWx1ZVwiLCAoc25hcHNob3QpID0+XG5cdFx0XHRkYXRhID0gc25hcHNob3QudmFsKClcblx0XHRcdEBzZXQgYXV0aG9yaXNlZDogaWYgY29kZSBpbiBrZXlzKGRhdGEuZ3Vlc3RzKSB0aGVuIHRydWUgZWxzZSBmYWxzZVxuXHRcdFx0cmV0dXJuIGlmICFAZ2V0KFwiYXV0aG9yaXNlZFwiKVxuXHRcdFx0QG9uRGF0YVN1Y2Nlc3MgZGF0YSwgY29kZVxuXHRcdCwgKGVycikgLT5cblx0XHQgICAgY29uc29sZS5sb2cgXCJlcnI6XCIsIGVyci5jb2RlXG5cblx0b25EYXRhU3VjY2VzczogKGRhdGEsIGNvZGUpIC0+XG5cdFx0IyBzZXQgZGF0YVxuXHRcdEBzZXRcblx0XHRcdGNvbnRlbnQ6IGRhdGEuY29udGVudFxuXHRcdFx0Z3Vlc3Q6IGRhdGEuZ3Vlc3RzW1wiI3tjb2RlfVwiXVxuXHRcdFx0bWVzc2FnZTogaWYgZGF0YS5tZXNzYWdlcyBhbmQgZGF0YS5tZXNzYWdlc1tcIiN7Y29kZX1cIl0/IHRoZW4gZGF0YS5tZXNzYWdlc1tcIiN7Y29kZX1cIl1bXCIje2xhc3Qoa2V5cyhkYXRhLm1lc3NhZ2VzW1wiI3tjb2RlfVwiXSkpfVwiXS5tZXNzYWdlIGVsc2UgXCJcIlxuXHRcdFx0bG9hZGVkOiB0cnVlXG5cblx0XHQjIGxpc3RlbiBmb3IgcnN2cHNcblx0XHRAb24gXCIqLm1zZ1NlbnRcIiwgKG1zZykgLT5cblx0XHRcdG5vdyA9IG5ldyBEYXRlKClcblx0XHRcdHRzID0gXCIje25vdy5nZXRGdWxsWWVhcigpfSN7cGFkKG5vdy5nZXRNb250aCgpKzEsIDIpfSN7cGFkKG5vdy5nZXREYXRlKCksIDIpfVwiXG5cdFx0XHRAZGIuY2hpbGQoXCJtZXNzYWdlcy8je0BnZXQoXCJjb2RlXCIpfVwiKS5wdXNoXG5cdFx0XHRcdG1lc3NhZ2U6IG1zZ1xuXHRcdFx0XHR0aW1lc3RhbXA6IHRzXG5cblx0c2V0X3JvdXRlcjogLT5cblx0XHRzZWxmID0gQFxuXG5cdFx0cGFnZSBcIi86Y29kZS86c2NlbmU/XCIsIChjdHgpIC0+XG5cdFx0XHRzZWxmLnNldFxuXHRcdFx0XHRjb2RlOiBjdHgucGFyYW1zLmNvZGVcblx0XHRcdFx0dmlldzogaWYgY3R4LnBhcmFtcy5zY2VuZT8gdGhlbiBjdHgucGFyYW1zLnNjZW5lIGVsc2UgXCJtb3JuaW5nXCJcblxuXHRcdHBhZ2UgY2xpY2s6IGZhbHNlLCBkaXNwYXRjaDogdHJ1ZSwgaGFzaGJhbmc6IGZhbHNlXG4iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MSxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwid3JhcHBlclwifSxcImZcIjpbe1widFwiOjQsXCJyXCI6XCJzdXBwb3J0ZWRcIixcImZcIjpbe1widFwiOjQsXCJyXCI6XCJhdXRob3Jpc2VkXCIsXCJmXCI6W3tcInRcIjo0LFwiclwiOlwibG9hZGVkXCIsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbXCJza3kgXCIse1widFwiOjIsXCJyXCI6XCJ2aWV3XCJ9XX19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwidWktc3RhZ2VcIixcImFcIjp7XCJ2aWV3XCI6W3tcInRcIjoyLFwiclwiOlwidmlld1wifV0sXCJjb2RlXCI6W3tcInRcIjoyLFwiclwiOlwiY29kZVwifV0sXCJjb250ZW50XCI6W3tcInRcIjoyLFwiclwiOlwiY29udGVudFwifV0sXCJndWVzdFwiOlt7XCJ0XCI6MixcInJcIjpcImd1ZXN0XCJ9XSxcIm1lc3NhZ2VcIjpbe1widFwiOjIsXCJyXCI6XCJtZXNzYWdlXCJ9XX19XX0sXCIgXCIse1widFwiOjQsXCJyXCI6XCJsb2FkZWRcIixcImZcIjpbe1widFwiOjgsXCJyXCI6XCJsb2FkZXJcIn1dLFwiblwiOjUxfV19LFwiIFwiLHtcInRcIjo0LFwiclwiOlwiYXV0aG9yaXNlZFwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJpbmZvXCJ9LFwiZlwiOltcIlNvcnJ5LCB5b3UgbmVlZCBhbiBpbnZpdGUgOylcIl19XSxcIm5cIjo1MX1dfSxcIiBcIix7XCJ0XCI6NCxcInJcIjpcInN1cHBvcnRlZFwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJpbmZvLS11bnN1cHBvcnRlZFwifSxcImZcIjpbXCJTb3JyeSwgeW91IG5lZWQgYSBcIix7XCJ0XCI6NyxcImVcIjpcImFcIixcImFcIjp7XCJocmVmXCI6XCJodHRwOi8vb3V0ZGF0ZWRicm93c2VyLmNvbS9lblwifSxcImZcIjpbXCJiZXR0ZXIgYnJvd3NlclwiXX0sXCIhXCJdfV0sXCJuXCI6NTF9XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjoxLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJhYnN0cmFjdC1zY2VuZVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJoMVwiLFwiZlwiOltcImFic3RyYWN0LXNjZW5lIDopXCJdfV19XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MSxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwic2NlbmUgc2NlbmUtZGF5XCJ9LFwidDFcIjp7XCJuXCI6XCJmbHlcIixcImFcIjpbe1wieFwiOlwiMCVcIixcInlcIjpcIjEwMCVcIixcIm9wYWNpdHlcIjoxfV19LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJzaG93dGltZVwifSxcInZcIjp7XCJzd2lwZXJpZ2h0XCI6XCJnb1ByZXZTbGlkZVwiLFwic3dpcGVsZWZ0XCI6XCJnb05leHRTbGlkZVwifSxcImZcIjpbe1widFwiOjgsXCJyXCI6XCJzbGlkZUNvbnRyb2xzXCJ9LFwiIFwiLHtcInRcIjo0LFwiclwiOlwic2xpZGVzXCIsXCJpXCI6XCJzbGlkZVwiLFwiZlwiOlt7XCJ0XCI6NCxcInJcIjpcImFjdGl2ZVwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6W1wic2xpZGUtLVwiLHtcInRcIjoyLFwiclwiOlwic2xpZGVcIn1dfSxcInQwXCI6e1wiblwiOlwiZmx5XCIsXCJkXCI6W1wieyB4OidcIix7XCJ0XCI6MixcInJcIjpcInhcIn0sXCInLCB5OicwJScsIG9wYWNpdHk6MSB9XCJdfSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwic2xpZGVfX3RpdGxlXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImgzXCIsXCJmXCI6W3tcInRcIjoyLFwiclwiOlwidGl0bGVcIn1dfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInNsaWRlX19ib2R5XCJ9LFwiZlwiOlt7XCJ0XCI6NCxcInhcIjp7XCJyXCI6W1wic2xpZGVcIl0sXCJzXCI6XCJfMD09MVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwic2xpZGVfX2ZlYXR1cmVcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImZlYXR1cmVfX2lubmVyXCJ9LFwiZlwiOltcIjExYW1cIl19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwic2xpZGVfX3NlY3Rpb25cIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInNlY3Rpb25fX2lubmVyXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInBcIixcImZcIjpbXCJXZSBzaGFsbCBiZSBnZXR0aW5nIG1hcnJpZWQgYXQgT3RoYW0gQ291cnQgQ2hhcGVsLlwiXX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJwXCIsXCJmXCI6W1wiSXQncyBwcmV0dHkgY29zeSBpbnNpZGUgd2l0aCBvbmx5IGEgZmV3IHBld3MuIFRoZSBjZXJlbW9ueSB3aWxsIGJlIHNob3J0IChhbmQgc3dlZXQpIGJ1dCBsZXQgdXMga25vdyBpZiB5b3UnbGwgbmVlZCBhIHNlYXQgYW5kIHdlJ2xsIHNhdmUgb25lIGVzcGVjaWFsbHkuXCJdfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBcIixcImZcIjpbXCJXZSd2ZSBhbHNvIGJlZW4gYXNrZWQgdG8gbGV0IHRob3NlIG9mIHlvdSB3aXRoIGxpdHRsZSBvbmVzIChvciB0aG9zZSBwcm9uZSB0byBmYWxsaW5nIGluIGxha2VzKSBrbm93IHRoYXQgdGhlcmUgYXJlIHR3byBvcGVuIHBvbmRzIHNvIHRha2UgY2FyZS5cIl19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicFwiLFwiZlwiOltcIlRoZXJlIGlzIHBsZW50eSBvZiBwYXJraW5nIGF2YWlsYWJsZSBvbi1zaXRlIVwiXX1dfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInNsaWRlX19zZWN0aW9uXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJzZWN0aW9uX19pbm5lci0tYWRkcmVzc1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJwXCIsXCJhXCI6e1wiY2xhc3NcIjpcInNsaWRlX19hZGRyZXNzXCJ9LFwiZlwiOltcIk90aGFtIENvdXJ0XCIse1widFwiOjcsXCJlXCI6XCJiclwifSxcIiBPdGhhbSBDb3VydCBMYW5lXCIse1widFwiOjcsXCJlXCI6XCJiclwifSxcIiBQb2xlZ2F0ZVwiLHtcInRcIjo3LFwiZVwiOlwiYnJcIn0sXCIgRWFzdCBTdXNzZXhcIix7XCJ0XCI6NyxcImVcIjpcImJyXCJ9LFwiIEJOMjYgNlFTXCIse1widFwiOjcsXCJlXCI6XCJiclwifV19XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJmbG93ZXItLTVcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsb3dlci0tOVwifX1dfSxcIiBcIix7XCJ0XCI6NCxcInhcIjp7XCJyXCI6W1wic2xpZGVcIl0sXCJzXCI6XCJfMD09MlwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwic2xpZGVfX2ZlYXR1cmVcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImZlYXR1cmVfX2lubmVyXCJ9LFwiZlwiOltcIjFwbVwiXX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJzbGlkZV9fc2VjdGlvblwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwic2VjdGlvbl9faW5uZXJcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwicFwiLFwiZlwiOltcIkZvbGxvd2luZyB0aGUgY2VyZW1vbnkgd2Ugc2hhbGwgYmUgY2VsZWJyYXRpbmcgYXQgSGF3dGhidXNoIEZhcm0sIHdpdGggcGxlbnR5IG9mIHBhZWxsYSwgaWNlIGNyZWFtIGFuZCBjaGVlc2UhIEluY2x1ZGluZyB3aW5lIGZyb20gb3VyIHBlcnNvbmFsIHZpbmV5YXJkIGluIEJvcmRlYXV4IGFuZCBiZWVycyBmcm9tIENhbWRlbiBUb3duIEJyZXdlcnkgYW5kIEd1biBCcmV3ZXJ5ICh3aGljaCBpcyBicmV3ZWQgb24gc2l0ZSEpXCJdfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBcIixcImZcIjpbXCJBZ2FpbiBwbGVudHkgb2YgcGFya2luZyFcIl19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImJlZXJcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImJlZXJfX2NsaXAtLWN0YlwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiYmVlcl9fY2xpcC0tZ3VuXCJ9fV19XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJzbGlkZV9fc2VjdGlvblwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwic2VjdGlvbl9faW5uZXItLWFkZHJlc3NcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwicFwiLFwiYVwiOntcImNsYXNzXCI6XCJzbGlkZV9fYWRkcmVzc1wifSxcImZcIjpbXCJIYXd0aGJ1c2ggRmFybVwiLHtcInRcIjo3LFwiZVwiOlwiYnJcIn0sXCIgR3VuIEhpbGxcIix7XCJ0XCI6NyxcImVcIjpcImJyXCJ9LFwiIEhlYXRoZmllbGRcIix7XCJ0XCI6NyxcImVcIjpcImJyXCJ9LFwiIEVhc3QgU3Vzc2V4XCIse1widFwiOjcsXCJlXCI6XCJiclwifSxcIiBUTjIxIDBKWVwiLHtcInRcIjo3LFwiZVwiOlwiYnJcIn0sXCIgKFROMjEgMEpYIGZvciBTYXROYXYpXCJdfV19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiZmxvd2VyLS0yXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJmbG93ZXItLTEzXCJ9fV19LFwiIFwiLHtcInRcIjo0LFwieFwiOntcInJcIjpbXCJzbGlkZVwiXSxcInNcIjpcIl8wPT0zXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJzbGlkZV9fZmVhdHVyZVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiZmVhdHVyZV9faW5uZXJcIn0sXCJmXCI6W1wi4pmrXCJdfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInNsaWRlX19zZWN0aW9uXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJzZWN0aW9uX19pbm5lclwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJwXCIsXCJmXCI6W1wiSGVyZSBhcmUgYSBmZXcgbmljZSBob3RlbHMgaWYgeW91IG5lZWQgYWNjb21vZGF0aW9uIG92ZXIgdGhlIHdlZWtlbmQ6XCJdfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInVsXCIsXCJhXCI6e1wiY2xhc3NcIjpcInNsaWRlX19saXN0XCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImxpXCIsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiYVwiLFwiYVwiOntcImhyZWZcIjpcImh0dHA6Ly93d3cuc2t5aG91c2VzdXNzZXguY29tL1wiLFwiY2xhc3NcIjpcInNsaWRlX19saW5rXCJ9LFwiZlwiOltcIlNreWhvdXNlXCJdfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwibGlcIixcImZcIjpbe1widFwiOjcsXCJlXCI6XCJhXCIsXCJhXCI6e1wiaHJlZlwiOlwiaHR0cDovL3d3dy5tYXlnYXJsYW5kaW5uLmNvLnVrL1wiLFwiY2xhc3NcIjpcInNsaWRlX19saW5rXCJ9LFwiZlwiOltcIk1heSBHYXJsYW5kIElublwiXX0sXCIgKGNsb3NlIHRvIHJlY2VwdGlvbilcIl19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwibGlcIixcImZcIjpbe1widFwiOjcsXCJlXCI6XCJhXCIsXCJhXCI6e1wiaHJlZlwiOlwiaHR0cDovL3d3dy5wb3dkZXJtaWxsc2hvdGVsLmNvbS9cIixcImNsYXNzXCI6XCJzbGlkZV9fbGlua1wifSxcImZcIjpbXCJQb3dkZXIgTWlsbHMgSG90ZWxcIl19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsaVwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImFcIixcImFcIjp7XCJocmVmXCI6XCJodHRwOi8vdGhlbGltZXMtYmFuZGIuY28udWsvXCIsXCJjbGFzc1wiOlwic2xpZGVfX2xpbmtcIn0sXCJmXCI6W1wiVGhlIExpbWVzIChjbG9zZSB0byBjZXJlbW9ueSlcIl19XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImhyXCJ9LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicFwiLFwiZlwiOltcIklmIHlvdSdkIGxpa2UgdG8gYnV5IHVzIGEgZ2lmdCB3ZSd2ZSBnb3QgYSBcIix7XCJ0XCI6NyxcImVcIjpcImFcIixcImFcIjp7XCJjbGFzc1wiOlwic2xpZGVfX2xpbmtcIixcImhyZWZcIjowfSxcImZcIjpbXCJ3ZWRkaW5nIGxpc3Qgb24gQW1hem9uXCJdfSxcIiA6KVwiXX1dfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInNsaWRlX19zZWN0aW9uXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJzZWN0aW9uX19pbm5lclwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJwXCIsXCJmXCI6W1wiTGV0IHVzIGtub3cgd2hhdCB0dW5lcyB5b3UnZCBsaWtlIHRvIGhlYXIgYXQgdGhlIHJlY2VwdGlvbiBpbiB0aGUgUlNWUCBiZWxvdy5cIl19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicFwiLFwiZlwiOltcIktlZXAgaXQgY2xhc3N5IC0gdGhpbmsgYWxvbmcgdGhlIGxpbmVzIG9mIEJhY2tzdHJlZXQgQm95cywgQ3JhaWcgRGF2aWQgJiBUb3Bsb2FkZXIuLi5cIl19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicFwiLFwiZlwiOltcIkFsbCByZXF1ZXN0cyBmb3IgUm9kIFN0ZXdhcnQgd2lsbCBiZSBpZ25vcmVkLiBPaywgbXVtLCB5b3UncmUgYWxsb3dlZCBvbmUgYmxhc3Qgb2YgTWFnZ2llIE1heSBidXQgVEhBVCdTIEFMTCFcIl19XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJmbG93ZXItLTExXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJmbG93ZXItLTEyXCJ9fV19XX1dfV19XX1dfV19XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MSxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwic2NlbmUgc2NlbmUtbW9ybmluZ1wifSxcInQxXCI6XCJmYWRlXCIsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImdyZWV0aW5nXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImgyXCIsXCJmXCI6W1wiRGVhciBcIix7XCJ0XCI6MixcInJcIjpcImd1ZXN0Lm5hbWVcIn1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBcIixcImZcIjpbXCJXZSBob3BlIHlvdSBjYW4gam9pbiB1cyB0byBjZWxlYnJhdGUgb3VyIG1hcnJpYWdlIG9uXCJdfSxcIiBcIix7XCJ0XCI6NCxcInhcIjp7XCJyXCI6W1wiZ3Vlc3QubmFtZVwiXSxcInNcIjpcIl8wPT1cXFwiSXp6eVxcXCJcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiYVwiOntcImNsYXNzXCI6XCJoYXNodGFnXCJ9LFwiZlwiOltcIiNCaWdnZXJUaGFuV29vZHN0b2NrXCJdfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiaDJcIixcImFcIjp7XCJjbGFzc1wiOlwiZGF0ZVwifSxcImZcIjpbXCI0dGggSnVseSAyMDE1XCJdfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBcIixcImZcIjpbe1widFwiOjcsXCJlXCI6XCJzcGFuXCIsXCJhXCI6e1wic3R5bGVcIjpcImNvbG9yOiNlNzRjM2M7XCJ9LFwiZlwiOltcIuKdpFwiXX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBcIixcImZcIjpbXCJBbGljZSAmIEx1a2VcIl19XX1dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjEsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInNjZW5lIHNjZW5lLW5pZ2h0XCJ9LFwidDFcIjp7XCJuXCI6XCJmbHlcIixcImFcIjpbe1wieFwiOlwiMCVcIixcInlcIjpcIjEwMCVcIixcIm9wYWNpdHlcIjoxfV19LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJwb3N0Y2FyZFwifSxcInQxXCI6XCJmYWRlXCIsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInBvc3RjYXJkX19pbm5lclwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwicG9zdGNhcmRfX3N0YW1wXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInNwYW5cIixcImFcIjp7XCJjbGFzc1wiOlwic3RhbXBfX251bWJlci0tMjBcIn0sXCJmXCI6W1wiMjBcIl19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwic3BhblwiLFwiYVwiOntcImNsYXNzXCI6XCJzdGFtcF9fbnVtYmVyLS0xNVwifSxcImZcIjpbXCIxNVwiXX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJzcGFuXCIsXCJhXCI6e1wiY2xhc3NcIjpcInN0YW1wX19sZXR0ZXItLWxcIn0sXCJmXCI6W1wiTFwiXX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJzcGFuXCIsXCJhXCI6e1wiY2xhc3NcIjpcInN0YW1wX19sZXR0ZXItLWFcIn0sXCJmXCI6W1wiQVwiXX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwic3RhbXBfX2xpbmVcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInN0YW1wX19saW5lLS1mbGlwcGVkXCJ9fV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInBvc3RjYXJkX19zZWN0aW9uLS1tZXNzYWdlXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInRleHRhcmVhXCIsXCJhXCI6e1wiY2xhc3NcIjpcIm1lc3NhZ2VcIixcIm5hbWVcIjpcIm1lc3NhZ2VcIixcImlkXCI6XCJtZXNzYWdlXCIsXCJjb2xzXCI6XCIzMFwiLFwicm93c1wiOlwiMTBcIixcInZhbHVlXCI6W3tcInRcIjoyLFwiclwiOlwibWVzc2FnZVwifV0sXCJwbGFjZWhvbGRlclwiOlwiUlNWUCBoZXJlLi4uXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJwb3N0Y2FyZF9fZnJvbVwifSxcImZcIjpbXCJmcm9tIFwiLHtcInRcIjoyLFwiclwiOlwiZ3Vlc3QubmFtZVwifV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInBvc3RjYXJkX19zZW5kXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImFcIixcInZcIjp7XCJ0YXBcIjpcInNlbmRNZXNzYWdlXCJ9LFwiZlwiOltcIlNlbmRcIl19XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJwb3N0Y2FyZF9fc2VjdGlvbi0tYWRkcmVzc1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwicG9zdGNhcmRfX2FkZHJlc3NcIn0sXCJmXCI6W1wiQWxpY2UgJiBMdWtlXCIse1widFwiOjcsXCJlXCI6XCJiclwifSxcIiBMb25kb25cIl19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInBvc3RjYXJkX19kZXNjcmlwdGlvblwifSxcImZcIjpbXCJIYXd0aGJ1c2ggRmFybSwgR3VuIEhpbGwgLSBjaXJjYSAyMDE1XCJdfV19XX1dfV19XX0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MSxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwic3RhZ2VcIn0sXCJmXCI6W3tcInhcIjp7XCJyXCI6W1widmlld1wiXSxcInNcIjpcInt2aWV3Ol8wfVwifSxcImZcIjpbe1widFwiOjgsXCJyXCI6XCJzdGFnZUNvbnRyb2xzXCJ9XSxcInRcIjo0LFwiblwiOjUzfSxcIiBcIix7XCJ0XCI6NCxcInhcIjp7XCJyXCI6W1widmlld1wiXSxcInNcIjpcIl8wPT1cXFwibW9ybmluZ1xcXCJcIn0sXCJmXCI6W3tcInRcIjo4LFwiclwiOlwic3VuXCJ9LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwidWktc2NlbmUtbW9ybmluZ1wiLFwiYVwiOntcImd1ZXN0XCI6W3tcInRcIjoyLFwiclwiOlwiZ3Vlc3RcIn1dfX1dfSxcIiBcIix7XCJ0XCI6NCxcInhcIjp7XCJyXCI6W1widmlld1wiXSxcInNcIjpcIl8wPT1cXFwibmlnaHRcXFwiXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInVpLXNjZW5lLW5pZ2h0XCIsXCJhXCI6e1wiY29kZVwiOlt7XCJ0XCI6MixcInJcIjpcImNvZGVcIn1dLFwiZ3Vlc3RcIjpbe1widFwiOjIsXCJyXCI6XCJndWVzdFwifV0sXCJtZXNzYWdlXCI6W3tcInRcIjoyLFwiclwiOlwibWVzc2FnZVwifV19fV19LFwiIFwiLHtcInRcIjo0LFwieFwiOntcInJcIjpbXCJ2aWV3XCJdLFwic1wiOlwiXzA9PVxcXCJkYXlcXFwiXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInVpLXNjZW5lLWRheVwiLFwiYVwiOntcImd1ZXN0XCI6W3tcInRcIjoyLFwiclwiOlwiZ3Vlc3RcIn1dLFwic2xpZGVzXCI6W3tcInRcIjoyLFwiclwiOlwiY29udGVudC5zbGlkZXNcIn1dfX1dfSxcIiBcIix7XCJ4XCI6e1wiclwiOltcInZpZXdcIl0sXCJzXCI6XCJ7dmlldzpfMH1cIn0sXCJmXCI6W3tcInRcIjo4LFwiclwiOlwiZmFybVwifV0sXCJ0XCI6NCxcIm5cIjo1M31dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjEsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpbXCJmYXJtLS1cIix7XCJ0XCI6MixcInJcIjpcInZpZXdcIn1dfSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiZmllbGRcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImNhbWJlclwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJzdmdcIixcImFcIjp7XCJ2ZXJzaW9uXCI6XCIxLjFcIixcInhtbG5zXCI6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwieG1sbnM6eGxpbmtcIjpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcInhcIjpcIjBweFwiLFwieVwiOlwiMHB4XCIsXCJ2aWV3Qm94XCI6XCIwIDAgNTkzLjIgMjguOFwiLFwiZW5hYmxlLWJhY2tncm91bmRcIjpcIm5ldyAwIDAgNTkzLjIgMjguOFwiLFwieG1sOnNwYWNlXCI6XCJwcmVzZXJ2ZVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJwYXRoXCIsXCJhXCI6e1wiZmlsbFwiOlwiIzdBQjQ5MFwiLFwic3Ryb2tlXCI6XCIjN0FCNDkwXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcImRcIjpcIk01OTMuMiwyOS4zSDBjMCwwLDAuNS0zLDAtMjBjNDMuNCwyMy4xLDUxOC43LTI0LjcsNTkzLjIsMCBDNTkyLjcsMjIuNiw1OTMuMiwyOS4zLDU5My4yLDI5LjN6XCJ9fV19XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJidW50aW5nXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJjYWJsZS0tbGVmdFwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJzdmdcIixcImFcIjp7XCJ2ZXJzaW9uXCI6XCIxLjFcIixcInhtbG5zXCI6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwieG1sbnM6eGxpbmtcIjpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcInhcIjpcIjBweFwiLFwieVwiOlwiMHB4XCIsXCJ2aWV3Qm94XCI6XCIwIDAgNjAwIDUxLjlcIixcImVuYWJsZS1iYWNrZ3JvdW5kXCI6XCJuZXcgMCAwIDYwMCA1MS45XCIsXCJ4bWw6c3BhY2VcIjpcInByZXNlcnZlXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInBhdGhcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiNGRkZGRkZcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwiZFwiOlwiTTAsMEwwLDBjMjY2LjgsMjUuMiw1OTkuOSwxMy42LDYwMCwwdjBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCIzLjIsMC41IDI4LjEsMi42IDEzLjMsMjkuNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCIzNS4yLDMuNSA2MC4xLDUuNiA0NS4zLDMyLjYgXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBvbHlnb25cIixcImFcIjp7XCJjbGFzc1wiOlwiZmxhZ1wiLFwiZmlsbFwiOlwiI0ZGRkZGRlwiLFwic3Ryb2tlXCI6XCJub25lXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcInBvaW50c1wiOlwiNjYsNS43IDkwLjksNy40IDc2LjYsMzQuNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCI5OCw3LjcgMTIyLjksOS40IDEwOC42LDM2LjYgXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBvbHlnb25cIixcImFcIjp7XCJjbGFzc1wiOlwiZmxhZ1wiLFwiZmlsbFwiOlwiI0ZGRkZGRlwiLFwic3Ryb2tlXCI6XCJub25lXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcInBvaW50c1wiOlwiMTMwLjcsOS45IDE1NS43LDExLjEgMTQxLjgsMzguNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCIxNjIuNywxMC45IDE4Ny42LDEyLjEgMTczLjksMzkuNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCIxOTMuNywxMS45IDIxOC42LDEzLjEgMjA0LjksNDAuNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCIyMjQuNCwxMy4xIDI0OS40LDEzLjkgMjM2LjEsNDEuNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCIyNTQuNCwxNC4xIDI3OS40LDE0LjkgMjY2LjEsNDIuNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCIyODQsMTQuNSAzMDksMTQuNSAyOTYuNSw0Mi42IFwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJwb2x5Z29uXCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYWdcIixcImZpbGxcIjpcIiNGRkZGRkZcIixcInN0cm9rZVwiOlwibm9uZVwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJwb2ludHNcIjpcIjMxNC4yLDE1LjMgMzM5LjIsMTUuNyAzMjYuMyw0My42IFwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJwb2x5Z29uXCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYWdcIixcImZpbGxcIjpcIiNGRkZGRkZcIixcInN0cm9rZVwiOlwibm9uZVwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJwb2ludHNcIjpcIjM0NiwxNS41IDM3MSwxNS41IDM1OC41LDQzLjYgXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBvbHlnb25cIixcImFcIjp7XCJjbGFzc1wiOlwiZmxhZ1wiLFwiZmlsbFwiOlwiI0ZGRkZGRlwiLFwic3Ryb2tlXCI6XCJub25lXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcInBvaW50c1wiOlwiMzc3LDE1LjUgNDAyLDE1LjUgMzg5LjUsNDMuNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCI0MDksMTQuNSA0MzQsMTQuNSA0MjEuNSw0Mi42IFwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJwb2x5Z29uXCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYWdcIixcImZpbGxcIjpcIiNGRkZGRkZcIixcInN0cm9rZVwiOlwibm9uZVwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJwb2ludHNcIjpcIjQ0MC42LDEzLjkgNDY1LjUsMTMuMSA0NTMuOSw0MS42IFwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJwb2x5Z29uXCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYWdcIixcImZpbGxcIjpcIiNGRkZGRkZcIixcInN0cm9rZVwiOlwibm9uZVwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJwb2ludHNcIjpcIjQ3MS42LDEyLjkgNDk2LjUsMTIuMSA0ODQuOSw0MC42IFwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJwb2x5Z29uXCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYWdcIixcImZpbGxcIjpcIiNGRkZGRkZcIixcInN0cm9rZVwiOlwibm9uZVwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJwb2ludHNcIjpcIjUwMi4zLDEyLjIgNTI3LjIsMTAuOCA1MTYuMywzOS42IFwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJwb2x5Z29uXCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYWdcIixcImZpbGxcIjpcIiNGRkZGRkZcIixcInN0cm9rZVwiOlwibm9uZVwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJwb2ludHNcIjpcIjUzMywxMC41IDU1Ny45LDguNiA1NDcuNiwzNy42IFwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJwb2x5Z29uXCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYWdcIixcImZpbGxcIjpcIiNGRkZGRkZcIixcInN0cm9rZVwiOlwibm9uZVwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJwb2ludHNcIjpcIjU2My40LDguMSA1ODguMiw1LjEgNTc5LjIsMzQuNSBcIn19XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJwb2xlXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJjYWJsZS0tcmlnaHRcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwic3ZnXCIsXCJhXCI6e1widmVyc2lvblwiOlwiMS4xXCIsXCJ4bWxuc1wiOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcInhtbG5zOnhsaW5rXCI6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXCJ4XCI6XCIwcHhcIixcInlcIjpcIjBweFwiLFwidmlld0JveFwiOlwiMCAwIDYwMCA1MS45XCIsXCJlbmFibGUtYmFja2dyb3VuZFwiOlwibmV3IDAgMCA2MDAgNTEuOVwiLFwieG1sOnNwYWNlXCI6XCJwcmVzZXJ2ZVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJwYXRoXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjRkZGRkZGXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcImRcIjpcIk0wLDBMMCwwYzI2Ni44LDI1LjIsNTk5LjksMTMuNiw2MDAsMHYwXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBvbHlnb25cIixcImFcIjp7XCJjbGFzc1wiOlwiZmxhZ1wiLFwiZmlsbFwiOlwiI0ZGRkZGRlwiLFwic3Ryb2tlXCI6XCJub25lXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcInBvaW50c1wiOlwiMy4yLDAuNSAyOC4xLDIuNiAxMy4zLDI5LjYgXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBvbHlnb25cIixcImFcIjp7XCJjbGFzc1wiOlwiZmxhZ1wiLFwiZmlsbFwiOlwiI0ZGRkZGRlwiLFwic3Ryb2tlXCI6XCJub25lXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcInBvaW50c1wiOlwiMzUuMiwzLjUgNjAuMSw1LjYgNDUuMywzMi42IFwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJwb2x5Z29uXCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYWdcIixcImZpbGxcIjpcIiNGRkZGRkZcIixcInN0cm9rZVwiOlwibm9uZVwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJwb2ludHNcIjpcIjY2LDUuNyA5MC45LDcuNCA3Ni42LDM0LjYgXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBvbHlnb25cIixcImFcIjp7XCJjbGFzc1wiOlwiZmxhZ1wiLFwiZmlsbFwiOlwiI0ZGRkZGRlwiLFwic3Ryb2tlXCI6XCJub25lXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcInBvaW50c1wiOlwiOTgsNy43IDEyMi45LDkuNCAxMDguNiwzNi42IFwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJwb2x5Z29uXCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYWdcIixcImZpbGxcIjpcIiNGRkZGRkZcIixcInN0cm9rZVwiOlwibm9uZVwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJwb2ludHNcIjpcIjEzMC43LDkuOSAxNTUuNywxMS4xIDE0MS44LDM4LjYgXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBvbHlnb25cIixcImFcIjp7XCJjbGFzc1wiOlwiZmxhZ1wiLFwiZmlsbFwiOlwiI0ZGRkZGRlwiLFwic3Ryb2tlXCI6XCJub25lXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcInBvaW50c1wiOlwiMTYyLjcsMTAuOSAxODcuNiwxMi4xIDE3My45LDM5LjYgXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBvbHlnb25cIixcImFcIjp7XCJjbGFzc1wiOlwiZmxhZ1wiLFwiZmlsbFwiOlwiI0ZGRkZGRlwiLFwic3Ryb2tlXCI6XCJub25lXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcInBvaW50c1wiOlwiMTkzLjcsMTEuOSAyMTguNiwxMy4xIDIwNC45LDQwLjYgXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBvbHlnb25cIixcImFcIjp7XCJjbGFzc1wiOlwiZmxhZ1wiLFwiZmlsbFwiOlwiI0ZGRkZGRlwiLFwic3Ryb2tlXCI6XCJub25lXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcInBvaW50c1wiOlwiMjI0LjQsMTMuMSAyNDkuNCwxMy45IDIzNi4xLDQxLjYgXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBvbHlnb25cIixcImFcIjp7XCJjbGFzc1wiOlwiZmxhZ1wiLFwiZmlsbFwiOlwiI0ZGRkZGRlwiLFwic3Ryb2tlXCI6XCJub25lXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcInBvaW50c1wiOlwiMjU0LjQsMTQuMSAyNzkuNCwxNC45IDI2Ni4xLDQyLjYgXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBvbHlnb25cIixcImFcIjp7XCJjbGFzc1wiOlwiZmxhZ1wiLFwiZmlsbFwiOlwiI0ZGRkZGRlwiLFwic3Ryb2tlXCI6XCJub25lXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcInBvaW50c1wiOlwiMjg0LDE0LjUgMzA5LDE0LjUgMjk2LjUsNDIuNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCIzMTQuMiwxNS4zIDMzOS4yLDE1LjcgMzI2LjMsNDMuNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCIzNDYsMTUuNSAzNzEsMTUuNSAzNTguNSw0My42IFwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJwb2x5Z29uXCIsXCJhXCI6e1wiY2xhc3NcIjpcImZsYWdcIixcImZpbGxcIjpcIiNGRkZGRkZcIixcInN0cm9rZVwiOlwibm9uZVwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJwb2ludHNcIjpcIjM3NywxNS41IDQwMiwxNS41IDM4OS41LDQzLjYgXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInBvbHlnb25cIixcImFcIjp7XCJjbGFzc1wiOlwiZmxhZ1wiLFwiZmlsbFwiOlwiI0ZGRkZGRlwiLFwic3Ryb2tlXCI6XCJub25lXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcInBvaW50c1wiOlwiNDA5LDE0LjUgNDM0LDE0LjUgNDIxLjUsNDIuNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCI0NDAuNiwxMy45IDQ2NS41LDEzLjEgNDUzLjksNDEuNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCI0NzEuNiwxMi45IDQ5Ni41LDEyLjEgNDg0LjksNDAuNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCI1MDIuMywxMi4yIDUyNy4yLDEwLjggNTE2LjMsMzkuNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCI1MzMsMTAuNSA1NTcuOSw4LjYgNTQ3LjYsMzcuNiBcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwicG9seWdvblwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFnXCIsXCJmaWxsXCI6XCIjRkZGRkZGXCIsXCJzdHJva2VcIjpcIm5vbmVcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwicG9pbnRzXCI6XCI1NjMuNCw4LjEgNTg4LjIsNS4xIDU3OS4yLDM0LjUgXCJ9fV19XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJ0cmVlc1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidHJlZS0tZGFya1wifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidHJlZVwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidHJlZS0tZGFya1wifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidHJlZVwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidHJlZS0tZ3JlZW5cIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInRyZWUtLWRhcmtcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInRyZWVcIn19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwidGVudHNcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInRlbnQtLXBpbmtcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImNhbnZhc1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiYXduaW5nXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFwc1wifX1dfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInRlbnQtLWJsdWVcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImNhbnZhc1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiYXduaW5nXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFwc1wifX1dfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInRlbnRcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcImNhbnZhc1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiYXduaW5nXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJmbGFwc1wifX1dfV19XX0sXCIgXCIse1widFwiOjQsXCJ4XCI6e1wiclwiOltcInZpZXdcIl0sXCJzXCI6XCJfMD09XFxcIm5pZ2h0XFxcIlwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwiZmlyZVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcImFcIjp7XCJjbGFzc1wiOlwibG9nc1wifX1dfV19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjoxLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJpbmZvLS1sb2FkaW5nXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJ0cmVlXCJ9fSxcIiBMb2FkaW5nLi4uXCJdfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjEsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJhXCI6e1wiY2xhc3NcIjpcInNob3d0aW1lX19jb250cm9sc1wifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJhXCIsXCJhXCI6e1wiY2xhc3NcIjpcInNob3d0aW1lX19jb250cm9sLS1wcmV2XCJ9LFwidDBcIjpcImZhZGVcIixcInZcIjp7XCJ0YXBcIjpcImdvUHJldlNsaWRlXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInN2Z1wiLFwiYVwiOntcInZlcnNpb25cIjpcIjEuMVwiLFwieG1sbnNcIjpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJ4bWxuczp4bGlua1wiOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFwieFwiOlwiMHB4XCIsXCJ5XCI6XCIwcHhcIixcInZpZXdCb3hcIjpcIjIyIC00IDU1IDEwN1wiLFwiZW5hYmxlLWJhY2tncm91bmRcIjpcIm5ldyAyMiAtNCA1NSAxMDdcIixcInhtbDpzcGFjZVwiOlwicHJlc2VydmVcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwicGF0aFwiLFwiYVwiOntcImZpbGxcIjpcIm5vbmVcIixcInN0cm9rZVwiOlwiIzAwMDAwMFwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJkXCI6XCJNNzIsOTkuM0wyOC41LDUxLjhjLTAuOS0xLTAuOS0yLjQsMC0zLjRMNzIsMS4xXCJ9fV19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJhXCIsXCJhXCI6e1wiY2xhc3NcIjpcInNob3d0aW1lX19jb250cm9sLS1uZXh0XCJ9LFwidDBcIjpcImZhZGVcIixcInZcIjp7XCJ0YXBcIjpcImdvTmV4dFNsaWRlXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInN2Z1wiLFwiYVwiOntcInZlcnNpb25cIjpcIjEuMVwiLFwieG1sbnNcIjpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJ4bWxuczp4bGlua1wiOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFwieFwiOlwiMHB4XCIsXCJ5XCI6XCIwcHhcIixcInZpZXdCb3hcIjpcIjIyIC00IDU1IDEwN1wiLFwiZW5hYmxlLWJhY2tncm91bmRcIjpcIm5ldyAyMiAtNCA1NSAxMDdcIixcInhtbDpzcGFjZVwiOlwicHJlc2VydmVcIn0sXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwicGF0aFwiLFwiYVwiOntcImZpbGxcIjpcIm5vbmVcIixcInN0cm9rZVwiOlwiIzAwMDAwMFwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJkXCI6XCJNMjcuOCwxLjFsNDMuNiw0Ny40YzAuOSwxLDAuOSwyLjQsMCwzLjRMMjcuOCw5OS4zXCJ9fV19XX1dfV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjEsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiYVwiLFwiYVwiOntcImNsYXNzXCI6XCJzdGFnZV9fY29udHJvbC0tcHJldlwifSxcInZcIjp7XCJ0YXBcIjpcImdvUHJldlNjZW5lXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInN2Z1wiLFwiYVwiOntcInZlcnNpb25cIjpcIjEuMVwiLFwieG1sbnNcIjpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJ4bWxuczp4bGlua1wiOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFwieFwiOlwiMHB4XCIsXCJ5XCI6XCIwcHhcIixcInZpZXdCb3hcIjpcIjAgMCA3MCAzMi4xXCIsXCJlbmFibGUtYmFja2dyb3VuZFwiOlwibmV3IDAgMCA3MCAzMi4xXCIsXCJ4bWw6c3BhY2VcIjpcInByZXNlcnZlXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInBhdGhcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiMwMDAwMDBcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwiZFwiOlwiTTAuNiwzMS42TDMzLjgsMS4yYzAuNy0wLjYsMS43LTAuNiwyLjQsMGwzMy4xLDMwLjRcIn19XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImFcIixcImFcIjp7XCJjbGFzc1wiOlwic3RhZ2VfX2NvbnRyb2wtLW5leHRcIn0sXCJ2XCI6e1widGFwXCI6XCJnb05leHRTY2VuZVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJzcGFuXCIsXCJhXCI6e1wiY2xhc3NcIjpcImNvbnRyb2xfX2xhYmVsXCJ9LFwiZlwiOlt7XCJ0XCI6NCxcInhcIjp7XCJyXCI6W1widmlld1wiXSxcInNcIjpcIl8wPT1cXFwibW9ybmluZ1xcXCJcIn0sXCJmXCI6W1wiV2hhdCdzIGhhcHBlbmluZz9cIl19LFwiIFwiLHtcInRcIjo0LFwieFwiOntcInJcIjpbXCJ2aWV3XCJdLFwic1wiOlwiXzA9PVxcXCJkYXlcXFwiXCJ9LFwiZlwiOltcIlJTVlAuLi5cIl19LFwiIFwiLHtcInRcIjo0LFwieFwiOntcInJcIjpbXCJ2aWV3XCJdLFwic1wiOlwiXzA9PVxcXCJuaWdodFxcXCJcIn0sXCJmXCI6W1wiVGhhdCdzIGFsbCBmb2xrcyFcIl19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJzdmdcIixcImFcIjp7XCJ2ZXJzaW9uXCI6XCIxLjFcIixcInhtbG5zXCI6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwieG1sbnM6eGxpbmtcIjpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcInhcIjpcIjBweFwiLFwieVwiOlwiMHB4XCIsXCJ2aWV3Qm94XCI6XCIwIDAgNzAgMzIuMVwiLFwiZW5hYmxlLWJhY2tncm91bmRcIjpcIm5ldyAwIDAgNzAgMzIuMVwiLFwieG1sOnNwYWNlXCI6XCJwcmVzZXJ2ZVwifSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJwYXRoXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjMDAwMDAwXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcImRcIjpcIk02OS4zLDAuN0wzNi4xLDMxLjJjLTAuNywwLjYtMS43LDAuNi0yLjQsMEwwLjYsMC43XCJ9fV19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjoxLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwiYVwiOntcImNsYXNzXCI6XCJzdW5cIn0sXCJ0MFwiOlwiZmFkZVwiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInN2Z1wiLFwiYVwiOntcInZlcnNpb25cIjpcIjEuMVwiLFwieG1sbnNcIjpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJ4bWxuczp4bGlua1wiOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFwieFwiOlwiMHB4XCIsXCJ5XCI6XCIwcHhcIixcInZpZXdCb3hcIjpcIjAgMCAxMDAgMTAwXCIsXCJlbmFibGUtYmFja2dyb3VuZFwiOlwibmV3IDAgMCAxMDAgMTAwXCIsXCJ4bWw6c3BhY2VcIjpcInByZXNlcnZlXCJ9LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImNpcmNsZVwiLFwiYVwiOntcImN4XCI6XCI1MFwiLFwiY3lcIjpcIjQ5LjlcIixcInJcIjpcIjI1XCIsXCJmaWxsXCI6XCIjRkRCODEzXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxpbmVcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiNGREI4MTNcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwieDFcIjpcIjIzXCIsXCJ5MVwiOlwiNDkuNVwiLFwieDJcIjpcIjJcIixcInkyXCI6XCI0OS41XCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxpbmVcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiNGREI4MTNcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwieDFcIjpcIjk4XCIsXCJ5MVwiOlwiNDkuNVwiLFwieDJcIjpcIjc3XCIsXCJ5MlwiOlwiNDkuNVwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsaW5lXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjRkRCODEzXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcIngxXCI6XCI0OS41XCIsXCJ5MVwiOlwiNzdcIixcIngyXCI6XCI0OS41XCIsXCJ5MlwiOlwiOThcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwibGluZVwiLFwiYVwiOntcImZpbGxcIjpcIm5vbmVcIixcInN0cm9rZVwiOlwiI0ZEQjgxM1wiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJ4MVwiOlwiNDkuNVwiLFwieTFcIjpcIjJcIixcIngyXCI6XCI0OS41XCIsXCJ5MlwiOlwiMjNcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwibGluZVwiLFwiYVwiOntcImZpbGxcIjpcIm5vbmVcIixcInN0cm9rZVwiOlwiI0ZEQjgxM1wiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJ4MVwiOlwiMzAuNlwiLFwieTFcIjpcIjY4LjdcIixcIngyXCI6XCIxNS43XCIsXCJ5MlwiOlwiODMuNlwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsaW5lXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjRkRCODEzXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcIngxXCI6XCI4My42XCIsXCJ5MVwiOlwiMTUuN1wiLFwieDJcIjpcIjY4LjdcIixcInkyXCI6XCIzMC42XCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxpbmVcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiNGREI4MTNcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwieDFcIjpcIjY4LjdcIixcInkxXCI6XCI2OS40XCIsXCJ4MlwiOlwiODMuNlwiLFwieTJcIjpcIjg0LjNcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwibGluZVwiLFwiYVwiOntcImZpbGxcIjpcIm5vbmVcIixcInN0cm9rZVwiOlwiI0ZEQjgxM1wiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJ4MVwiOlwiMTUuN1wiLFwieTFcIjpcIjE2LjRcIixcIngyXCI6XCIzMC42XCIsXCJ5MlwiOlwiMzEuM1wifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsaW5lXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjRkRCODEzXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcIngxXCI6XCIyNC45XCIsXCJ5MVwiOlwiNTkuOVwiLFwieDJcIjpcIjUuNVwiLFwieTJcIjpcIjY3LjlcIn19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwibGluZVwiLFwiYVwiOntcImZpbGxcIjpcIm5vbmVcIixcInN0cm9rZVwiOlwiI0ZEQjgxM1wiLFwic3Ryb2tlLW1pdGVybGltaXRcIjpcIjEwXCIsXCJ4MVwiOlwiOTQuMlwiLFwieTFcIjpcIjMxLjJcIixcIngyXCI6XCI3NC44XCIsXCJ5MlwiOlwiMzkuMlwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsaW5lXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjRkRCODEzXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcIngxXCI6XCI1OS45XCIsXCJ5MVwiOlwiNzUuMVwiLFwieDJcIjpcIjY3LjlcIixcInkyXCI6XCI5NC41XCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxpbmVcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiNGREI4MTNcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwieDFcIjpcIjMxLjJcIixcInkxXCI6XCI1LjhcIixcIngyXCI6XCIzOS4yXCIsXCJ5MlwiOlwiMjUuMlwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsaW5lXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjRkRCODEzXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcIngxXCI6XCIzOS4yXCIsXCJ5MVwiOlwiNzQuOFwiLFwieDJcIjpcIjMxLjJcIixcInkyXCI6XCI5NC4yXCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxpbmVcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiNGREI4MTNcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwieDFcIjpcIjY3LjlcIixcInkxXCI6XCI1LjVcIixcIngyXCI6XCI1OS45XCIsXCJ5MlwiOlwiMjQuOVwifX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsaW5lXCIsXCJhXCI6e1wiZmlsbFwiOlwibm9uZVwiLFwic3Ryb2tlXCI6XCIjRkRCODEzXCIsXCJzdHJva2UtbWl0ZXJsaW1pdFwiOlwiMTBcIixcIngxXCI6XCI3NC44XCIsXCJ5MVwiOlwiNjAuOFwiLFwieDJcIjpcIjk0LjJcIixcInkyXCI6XCI2OC44XCJ9fSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxpbmVcIixcImFcIjp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2VcIjpcIiNGREI4MTNcIixcInN0cm9rZS1taXRlcmxpbWl0XCI6XCIxMFwiLFwieDFcIjpcIjUuNVwiLFwieTFcIjpcIjMyLjFcIixcIngyXCI6XCIyNC45XCIsXCJ5MlwiOlwiNDAuMVwifX1dfV19XX0iLCIvKiFcbiAgKiBkb21yZWFkeSAoYykgRHVzdGluIERpYXogMjAxNCAtIExpY2Vuc2UgTUlUXG4gICovXG4hZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcblxuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnKSBkZWZpbmUoZGVmaW5pdGlvbilcbiAgZWxzZSB0aGlzW25hbWVdID0gZGVmaW5pdGlvbigpXG5cbn0oJ2RvbXJlYWR5JywgZnVuY3Rpb24gKCkge1xuXG4gIHZhciBmbnMgPSBbXSwgbGlzdGVuZXJcbiAgICAsIGRvYyA9IGRvY3VtZW50XG4gICAgLCBoYWNrID0gZG9jLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbFxuICAgICwgZG9tQ29udGVudExvYWRlZCA9ICdET01Db250ZW50TG9hZGVkJ1xuICAgICwgbG9hZGVkID0gKGhhY2sgPyAvXmxvYWRlZHxeYy8gOiAvXmxvYWRlZHxeaXxeYy8pLnRlc3QoZG9jLnJlYWR5U3RhdGUpXG5cblxuICBpZiAoIWxvYWRlZClcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoZG9tQ29udGVudExvYWRlZCwgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9tQ29udGVudExvYWRlZCwgbGlzdGVuZXIpXG4gICAgbG9hZGVkID0gMVxuICAgIHdoaWxlIChsaXN0ZW5lciA9IGZucy5zaGlmdCgpKSBsaXN0ZW5lcigpXG4gIH0pXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIGxvYWRlZCA/IGZuKCkgOiBmbnMucHVzaChmbilcbiAgfVxuXG59KTtcbiIsIi8qIVxuICogVkVSU0lPTjogMS4xNi4wXG4gKiBEQVRFOiAyMDE1LTAzLTAxXG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vZ3JlZW5zb2NrLmNvbVxuICogXG4gKiBJbmNsdWRlcyBhbGwgb2YgdGhlIGZvbGxvd2luZzogVHdlZW5MaXRlLCBUd2Vlbk1heCwgVGltZWxpbmVMaXRlLCBUaW1lbGluZU1heCwgRWFzZVBhY2ssIENTU1BsdWdpbiwgUm91bmRQcm9wc1BsdWdpbiwgQmV6aWVyUGx1Z2luLCBBdHRyUGx1Z2luLCBEaXJlY3Rpb25hbFJvdGF0aW9uUGx1Z2luXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTUsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICoqL1xudmFyIF9nc1Njb3BlID0gKHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZihnbG9iYWwpICE9PSBcInVuZGVmaW5lZFwiKSA/IGdsb2JhbCA6IHRoaXMgfHwgd2luZG93OyAvL2hlbHBzIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggQU1EL1JlcXVpcmVKUyBhbmQgQ29tbW9uSlMvTm9kZVxuKF9nc1Njb3BlLl9nc1F1ZXVlIHx8IChfZ3NTY29wZS5fZ3NRdWV1ZSA9IFtdKSkucHVzaCggZnVuY3Rpb24oKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0X2dzU2NvcGUuX2dzRGVmaW5lKFwiVHdlZW5NYXhcIiwgW1wiY29yZS5BbmltYXRpb25cIixcImNvcmUuU2ltcGxlVGltZWxpbmVcIixcIlR3ZWVuTGl0ZVwiXSwgZnVuY3Rpb24oQW5pbWF0aW9uLCBTaW1wbGVUaW1lbGluZSwgVHdlZW5MaXRlKSB7XG5cblx0XHR2YXIgX3NsaWNlID0gZnVuY3Rpb24oYSkgeyAvL2Rvbid0IHVzZSBbXS5zbGljZSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHR2YXIgYiA9IFtdLFxuXHRcdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpICE9PSBsOyBiLnB1c2goYVtpKytdKSk7XG5cdFx0XHRcdHJldHVybiBiO1xuXHRcdFx0fSxcblx0XHRcdFR3ZWVuTWF4ID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0XHRUd2VlbkxpdGUuY2FsbCh0aGlzLCB0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSAwO1xuXHRcdFx0XHR0aGlzLl95b3lvID0gKHRoaXMudmFycy55b3lvID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5fcmVwZWF0ID0gdGhpcy52YXJzLnJlcGVhdCB8fCAwO1xuXHRcdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHRoaXMudmFycy5yZXBlYXREZWxheSB8fCAwO1xuXHRcdFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7IC8vZW5zdXJlcyB0aGF0IGlmIHRoZXJlIGlzIGFueSByZXBlYXQsIHRoZSB0b3RhbER1cmF0aW9uIHdpbGwgZ2V0IHJlY2FsY3VsYXRlZCB0byBhY2N1cmF0ZWx5IHJlcG9ydCBpdC5cblx0XHRcdFx0dGhpcy5yZW5kZXIgPSBUd2Vlbk1heC5wcm90b3R5cGUucmVuZGVyOyAvL3NwZWVkIG9wdGltaXphdGlvbiAoYXZvaWQgcHJvdG90eXBlIGxvb2t1cCBvbiB0aGlzIFwiaG90XCIgbWV0aG9kKVxuXHRcdFx0fSxcblx0XHRcdF90aW55TnVtID0gMC4wMDAwMDAwMDAxLFxuXHRcdFx0VHdlZW5MaXRlSW50ZXJuYWxzID0gVHdlZW5MaXRlLl9pbnRlcm5hbHMsXG5cdFx0XHRfaXNTZWxlY3RvciA9IFR3ZWVuTGl0ZUludGVybmFscy5pc1NlbGVjdG9yLFxuXHRcdFx0X2lzQXJyYXkgPSBUd2VlbkxpdGVJbnRlcm5hbHMuaXNBcnJheSxcblx0XHRcdHAgPSBUd2Vlbk1heC5wcm90b3R5cGUgPSBUd2VlbkxpdGUudG8oe30sIDAuMSwge30pLFxuXHRcdFx0X2JsYW5rQXJyYXkgPSBbXTtcblxuXHRcdFR3ZWVuTWF4LnZlcnNpb24gPSBcIjEuMTYuMFwiO1xuXHRcdHAuY29uc3RydWN0b3IgPSBUd2Vlbk1heDtcblx0XHRwLmtpbGwoKS5fZ2MgPSBmYWxzZTtcblx0XHRUd2Vlbk1heC5raWxsVHdlZW5zT2YgPSBUd2Vlbk1heC5raWxsRGVsYXllZENhbGxzVG8gPSBUd2VlbkxpdGUua2lsbFR3ZWVuc09mO1xuXHRcdFR3ZWVuTWF4LmdldFR3ZWVuc09mID0gVHdlZW5MaXRlLmdldFR3ZWVuc09mO1xuXHRcdFR3ZWVuTWF4LmxhZ1Ntb290aGluZyA9IFR3ZWVuTGl0ZS5sYWdTbW9vdGhpbmc7XG5cdFx0VHdlZW5NYXgudGlja2VyID0gVHdlZW5MaXRlLnRpY2tlcjtcblx0XHRUd2Vlbk1heC5yZW5kZXIgPSBUd2VlbkxpdGUucmVuZGVyO1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl95b3lvID0gKHRoaXMudmFycy55b3lvID09PSB0cnVlKTtcblx0XHRcdHRoaXMuX3JlcGVhdCA9IHRoaXMudmFycy5yZXBlYXQgfHwgMDtcblx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdGhpcy52YXJzLnJlcGVhdERlbGF5IHx8IDA7XG5cdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0cmV0dXJuIFR3ZWVuTGl0ZS5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdH07XG5cdFx0XG5cdFx0cC51cGRhdGVUbyA9IGZ1bmN0aW9uKHZhcnMsIHJlc2V0RHVyYXRpb24pIHtcblx0XHRcdHZhciBjdXJSYXRpbyA9IHRoaXMucmF0aW8sXG5cdFx0XHRcdGltbWVkaWF0ZSA9IHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIgfHwgdmFycy5pbW1lZGlhdGVSZW5kZXIsXG5cdFx0XHRcdHA7XG5cdFx0XHRpZiAocmVzZXREdXJhdGlvbiAmJiB0aGlzLl9zdGFydFRpbWUgPCB0aGlzLl90aW1lbGluZS5fdGltZSkge1xuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSB0aGlzLl90aW1lbGluZS5fdGltZTtcblx0XHRcdFx0dGhpcy5fdW5jYWNoZShmYWxzZSk7XG5cdFx0XHRcdGlmICh0aGlzLl9nYykge1xuXHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWVsaW5lLmluc2VydCh0aGlzLCB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9kZWxheSk7IC8vZW5zdXJlcyB0aGF0IGFueSBuZWNlc3NhcnkgcmUtc2VxdWVuY2luZyBvZiBBbmltYXRpb25zIGluIHRoZSB0aW1lbGluZSBvY2N1cnMgdG8gbWFrZSBzdXJlIHRoZSByZW5kZXJpbmcgb3JkZXIgaXMgY29ycmVjdC5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0dGhpcy52YXJzW3BdID0gdmFyc1twXTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9pbml0dGVkIHx8IGltbWVkaWF0ZSkge1xuXHRcdFx0XHRpZiAocmVzZXREdXJhdGlvbikge1xuXHRcdFx0XHRcdHRoaXMuX2luaXR0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAoaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlcigwLCB0cnVlLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQgJiYgdGhpcy5fZmlyc3RQVCkge1xuXHRcdFx0XHRcdFx0VHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50KFwiX29uRGlzYWJsZVwiLCB0aGlzKTsgLy9pbiBjYXNlIGEgcGx1Z2luIGxpa2UgTW90aW9uQmx1ciBtdXN0IHBlcmZvcm0gc29tZSBjbGVhbnVwIHRhc2tzXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lIC8gdGhpcy5fZHVyYXRpb24gPiAwLjk5OCkgeyAvL2lmIHRoZSB0d2VlbiBoYXMgZmluaXNoZWQgKG9yIGNvbWUgZXh0cmVtZWx5IGNsb3NlIHRvIGZpbmlzaGluZyksIHdlIGp1c3QgbmVlZCB0byByZXdpbmQgaXQgdG8gMCBhbmQgdGhlbiByZW5kZXIgaXQgYWdhaW4gYXQgdGhlIGVuZCB3aGljaCBmb3JjZXMgaXQgdG8gcmUtaW5pdGlhbGl6ZSAocGFyc2luZyB0aGUgbmV3IHZhcnMpLiBXZSBhbGxvdyB0d2VlbnMgdGhhdCBhcmUgY2xvc2UgdG8gZmluaXNoaW5nIChidXQgaGF2ZW4ndCBxdWl0ZSBmaW5pc2hlZCkgdG8gd29yayB0aGlzIHdheSB0b28gYmVjYXVzZSBvdGhlcndpc2UsIHRoZSB2YWx1ZXMgYXJlIHNvIHNtYWxsIHdoZW4gZGV0ZXJtaW5pbmcgd2hlcmUgdG8gcHJvamVjdCB0aGUgc3RhcnRpbmcgdmFsdWVzIHRoYXQgYmluYXJ5IG1hdGggaXNzdWVzIGNyZWVwIGluIGFuZCBjYW4gbWFrZSB0aGUgdHdlZW4gYXBwZWFyIHRvIHJlbmRlciBpbmNvcnJlY3RseSB3aGVuIHJ1biBiYWNrd2FyZHMuIFxuXHRcdFx0XHRcdFx0dmFyIHByZXZUaW1lID0gdGhpcy5fdGltZTtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyKDAsIHRydWUsIGZhbHNlKTtcblx0XHRcdFx0XHRcdHRoaXMuX2luaXR0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyKHByZXZUaW1lLCB0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lID4gMCB8fCBpbW1lZGlhdGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2luaXR0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMuX2luaXQoKTtcblx0XHRcdFx0XHRcdHZhciBpbnYgPSAxIC8gKDEgLSBjdXJSYXRpbyksXG5cdFx0XHRcdFx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVCwgZW5kVmFsdWU7XG5cdFx0XHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBwdC5zICsgcHQuYzsgXG5cdFx0XHRcdFx0XHRcdHB0LmMgKj0gaW52O1xuXHRcdFx0XHRcdFx0XHRwdC5zID0gZW5kVmFsdWUgLSBwdC5jO1xuXHRcdFx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcdFx0XG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkgaWYgKHRoaXMuX2R1cmF0aW9uID09PSAwICYmIHRoaXMudmFycy5yZXBlYXQpIHsgLy96ZXJvIGR1cmF0aW9uIHR3ZWVucyB0aGF0IHJlbmRlciBpbW1lZGlhdGVseSBoYXZlIHJlbmRlcigpIGNhbGxlZCBmcm9tIFR3ZWVuTGl0ZSdzIGNvbnN0cnVjdG9yLCBiZWZvcmUgVHdlZW5NYXgncyBjb25zdHJ1Y3RvciBoYXMgZmluaXNoZWQgc2V0dGluZyBfcmVwZWF0LCBfcmVwZWF0RGVsYXksIGFuZCBfeW95byB3aGljaCBhcmUgY3JpdGljYWwgaW4gZGV0ZXJtaW5pbmcgdG90YWxEdXJhdGlvbigpIHNvIHdlIG5lZWQgdG8gY2FsbCBpbnZhbGlkYXRlKCkgd2hpY2ggaXMgYSBsb3cta2Igd2F5IHRvIGdldCB0aG9zZSBzZXQgcHJvcGVybHkuXG5cdFx0XHRcdHRoaXMuaW52YWxpZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRvdGFsRHVyID0gKCF0aGlzLl9kaXJ0eSkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy50b3RhbER1cmF0aW9uKCksXG5cdFx0XHRcdHByZXZUaW1lID0gdGhpcy5fdGltZSxcblx0XHRcdFx0cHJldlRvdGFsVGltZSA9IHRoaXMuX3RvdGFsVGltZSwgXG5cdFx0XHRcdHByZXZDeWNsZSA9IHRoaXMuX2N5Y2xlLFxuXHRcdFx0XHRkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uLFxuXHRcdFx0XHRwcmV2UmF3UHJldlRpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSxcblx0XHRcdFx0aXNDb21wbGV0ZSwgY2FsbGJhY2ssIHB0LCBjeWNsZUR1cmF0aW9uLCByLCB0eXBlLCBwb3csIHJhd1ByZXZUaW1lLCBpO1xuXHRcdFx0aWYgKHRpbWUgPj0gdG90YWxEdXIpIHtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdG90YWxEdXI7XG5cdFx0XHRcdHRoaXMuX2N5Y2xlID0gdGhpcy5fcmVwZWF0O1xuXHRcdFx0XHRpZiAodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLl9jYWxjRW5kID8gdGhpcy5fZWFzZS5nZXRSYXRpbygwKSA6IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1cmF0aW9uO1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLl9jYWxjRW5kID8gdGhpcy5fZWFzZS5nZXRSYXRpbygxKSA6IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwKSBpZiAodGhpcy5faW5pdHRlZCB8fCAhdGhpcy52YXJzLmxhenkgfHwgZm9yY2UpIHsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyBhcmUgdHJpY2t5IGJlY2F1c2Ugd2UgbXVzdCBkaXNjZXJuIHRoZSBtb21lbnR1bS9kaXJlY3Rpb24gb2YgdGltZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc3RhcnRpbmcgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCBvciB0aGUgZW5kaW5nIHZhbHVlcy4gSWYgdGhlIFwicGxheWhlYWRcIiBvZiBpdHMgdGltZWxpbmUgZ29lcyBwYXN0IHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBvciBsYW5kcyBkaXJlY3RseSBvbiBpdCwgdGhlIGVuZCB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkLCBidXQgaWYgdGhlIHRpbWVsaW5lJ3MgXCJwbGF5aGVhZFwiIG1vdmVzIHBhc3QgaXQgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiAoZnJvbSBhIHBvc3RpdGl2ZSB0aW1lIHRvIGEgbmVnYXRpdmUgdGltZSksIHRoZSBzdGFydGluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZC5cblx0XHRcdFx0XHRpZiAodGhpcy5fc3RhcnRUaW1lID09PSB0aGlzLl90aW1lbGluZS5fZHVyYXRpb24pIHsgLy9pZiBhIHplcm8tZHVyYXRpb24gdHdlZW4gaXMgYXQgdGhlIFZFUlkgZW5kIG9mIGEgdGltZWxpbmUgYW5kIHRoYXQgdGltZWxpbmUgcmVuZGVycyBhdCBpdHMgZW5kLCBpdCB3aWxsIHR5cGljYWxseSBhZGQgYSB0aW55IGJpdCBvZiBjdXNoaW9uIHRvIHRoZSByZW5kZXIgdGltZSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9ycyBmcm9tIGdldHRpbmcgaW4gdGhlIHdheSBvZiB0d2VlbnMgcmVuZGVyaW5nIHRoZWlyIFZFUlkgZW5kLiBJZiB3ZSB0aGVuIHJldmVyc2UoKSB0aGF0IHRpbWVsaW5lLCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiB3aWxsIHRyaWdnZXIgaXRzIG9uUmV2ZXJzZUNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5IHRoZSBwbGF5aGVhZCBkaWRuJ3QgcGFzcyBvdmVyIGl0IGFnYWluLiBJdCdzIGEgdmVyeSBzcGVjaWZpYyBlZGdlIGNhc2Ugd2UgbXVzdCBhY2NvbW1vZGF0ZS5cblx0XHRcdFx0XHRcdHRpbWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGltZSA9PT0gMCB8fCBwcmV2UmF3UHJldlRpbWUgPCAwIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0pIGlmIChwcmV2UmF3UHJldlRpbWUgIT09IHRpbWUpIHtcblx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPiBfdGlueU51bSkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByYXdQcmV2VGltZSA9ICghc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCBwcmV2UmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aGlzLl9jeWNsZSA9IDA7XG5cdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLl9jYWxjRW5kID8gdGhpcy5fZWFzZS5nZXRSYXRpbygwKSA6IDA7XG5cdFx0XHRcdGlmIChwcmV2VG90YWxUaW1lICE9PSAwIHx8IChkdXJhdGlvbiA9PT0gMCAmJiBwcmV2UmF3UHJldlRpbWUgPiAwKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDApIGlmICh0aGlzLl9pbml0dGVkIHx8ICF0aGlzLnZhcnMubGF6eSB8fCBmb3JjZSkgeyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIGFyZSB0cmlja3kgYmVjYXVzZSB3ZSBtdXN0IGRpc2Nlcm4gdGhlIG1vbWVudHVtL2RpcmVjdGlvbiBvZiB0aW1lIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkIG9yIHRoZSBlbmRpbmcgdmFsdWVzLiBJZiB0aGUgXCJwbGF5aGVhZFwiIG9mIGl0cyB0aW1lbGluZSBnb2VzIHBhc3QgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uIG9yIGxhbmRzIGRpcmVjdGx5IG9uIGl0LCB0aGUgZW5kIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQsIGJ1dCBpZiB0aGUgdGltZWxpbmUncyBcInBsYXloZWFkXCIgbW92ZXMgcGFzdCBpdCBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uIChmcm9tIGEgcG9zdGl0aXZlIHRpbWUgdG8gYSBuZWdhdGl2ZSB0aW1lKSwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkLlxuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmF3UHJldlRpbWUgPSAoIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgcHJldlJhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7IC8vaWYgd2UgcmVuZGVyIHRoZSB2ZXJ5IGJlZ2lubmluZyAodGltZSA9PSAwKSBvZiBhIGZyb21UbygpLCB3ZSBtdXN0IGZvcmNlIHRoZSByZW5kZXIgKG5vcm1hbCB0d2VlbnMgd291bGRuJ3QgbmVlZCB0byByZW5kZXIgYXQgYSB0aW1lIG9mIDAgd2hlbiB0aGUgcHJldlRpbWUgd2FzIGFsc28gMCkuIFRoaXMgaXMgYWxzbyBtYW5kYXRvcnkgdG8gbWFrZSBzdXJlIG92ZXJ3cml0aW5nIGtpY2tzIGluIGltbWVkaWF0ZWx5LlxuXHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRpbWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodGhpcy5fcmVwZWF0ICE9PSAwKSB7XG5cdFx0XHRcdFx0Y3ljbGVEdXJhdGlvbiA9IGR1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSAodGhpcy5fdG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbikgPj4gMDsgLy9vcmlnaW5hbGx5IF90b3RhbFRpbWUgJSBjeWNsZUR1cmF0aW9uIGJ1dCBmbG9hdGluZyBwb2ludCBlcnJvcnMgY2F1c2VkIHByb2JsZW1zLCBzbyBJIG5vcm1hbGl6ZWQgaXQuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBGbGFzaCByZXBvcnRzIGl0IGFzIDAuNzk5OTk5OTkhKVxuXHRcdFx0XHRcdGlmICh0aGlzLl9jeWNsZSAhPT0gMCkgaWYgKHRoaXMuX2N5Y2xlID09PSB0aGlzLl90b3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9jeWNsZS0tOyAvL290aGVyd2lzZSB3aGVuIHJlbmRlcmVkIGV4YWN0bHkgYXQgdGhlIGVuZCB0aW1lLCBpdCB3aWxsIGFjdCBhcyB0aG91Z2ggaXQgaXMgcmVwZWF0aW5nIChhdCB0aGUgYmVnaW5uaW5nKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lIC0gKHRoaXMuX2N5Y2xlICogY3ljbGVEdXJhdGlvbik7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3lveW8pIGlmICgodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1cmF0aW9uIC0gdGhpcy5fdGltZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgPiBkdXJhdGlvbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1cmF0aW9uO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fdGltZSA8IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLl9lYXNlVHlwZSkge1xuXHRcdFx0XHRcdHIgPSB0aGlzLl90aW1lIC8gZHVyYXRpb247XG5cdFx0XHRcdFx0dHlwZSA9IHRoaXMuX2Vhc2VUeXBlO1xuXHRcdFx0XHRcdHBvdyA9IHRoaXMuX2Vhc2VQb3dlcjtcblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMSB8fCAodHlwZSA9PT0gMyAmJiByID49IDAuNSkpIHtcblx0XHRcdFx0XHRcdHIgPSAxIC0gcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDMpIHtcblx0XHRcdFx0XHRcdHIgKj0gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBvdyA9PT0gMSkge1xuXHRcdFx0XHRcdFx0ciAqPSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSAyKSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSAzKSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByICogcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gNCkge1xuXHRcdFx0XHRcdFx0ciAqPSByICogciAqIHIgKiByO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0eXBlID09PSAxKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gMSAtIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAyKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgLyBkdXJhdGlvbiA8IDAuNSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHIgLyAyO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gMSAtIChyIC8gMik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8odGhpcy5fdGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRpZiAocHJldlRpbWUgPT09IHRoaXMuX3RpbWUgJiYgIWZvcmNlICYmIHByZXZDeWNsZSA9PT0gdGhpcy5fY3ljbGUpIHtcblx0XHRcdFx0aWYgKHByZXZUb3RhbFRpbWUgIT09IHRoaXMuX3RvdGFsVGltZSkgaWYgKHRoaXMuX29uVXBkYXRlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7IC8vc28gdGhhdCBvblVwZGF0ZSBmaXJlcyBldmVuIGR1cmluZyB0aGUgcmVwZWF0RGVsYXkgLSBhcyBsb25nIGFzIHRoZSB0b3RhbFRpbWUgY2hhbmdlZCwgd2Ugc2hvdWxkIHRyaWdnZXIgb25VcGRhdGUuXG5cdFx0XHRcdFx0dGhpcy5fb25VcGRhdGUuYXBwbHkodGhpcy52YXJzLm9uVXBkYXRlU2NvcGUgfHwgdGhpcywgdGhpcy52YXJzLm9uVXBkYXRlUGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdHRoaXMuX2luaXQoKTtcblx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkIHx8IHRoaXMuX2djKSB7IC8vaW1tZWRpYXRlUmVuZGVyIHR3ZWVucyB0eXBpY2FsbHkgd29uJ3QgaW5pdGlhbGl6ZSB1bnRpbCB0aGUgcGxheWhlYWQgYWR2YW5jZXMgKF90aW1lIGlzIGdyZWF0ZXIgdGhhbiAwKSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBvdmVyd3JpdGluZyBvY2N1cnMgcHJvcGVybHkuIEFsc28sIGlmIGFsbCBvZiB0aGUgdHdlZW5pbmcgcHJvcGVydGllcyBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4gKHdoaWNoIHdvdWxkIGNhdXNlIF9nYyB0byBiZSB0cnVlLCBhcyBzZXQgaW4gX2luaXQoKSksIHdlIHNob3VsZG4ndCBjb250aW51ZSBvdGhlcndpc2UgYW4gb25TdGFydCBjYWxsYmFjayBjb3VsZCBiZSBjYWxsZWQgZm9yIGV4YW1wbGUuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFmb3JjZSAmJiB0aGlzLl9maXJzdFBUICYmICgodGhpcy52YXJzLmxhenkgIT09IGZhbHNlICYmIHRoaXMuX2R1cmF0aW9uKSB8fCAodGhpcy52YXJzLmxhenkgJiYgIXRoaXMuX2R1cmF0aW9uKSkpIHsgLy93ZSBzdGljayBpdCBpbiB0aGUgcXVldWUgZm9yIHJlbmRlcmluZyBhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIHRpY2sgLSB0aGlzIGlzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIGJlY2F1c2UgYnJvd3NlcnMgaW52YWxpZGF0ZSBzdHlsZXMgYW5kIGZvcmNlIGEgcmVjYWxjdWxhdGlvbiBpZiB5b3UgcmVhZCwgd3JpdGUsIGFuZCB0aGVuIHJlYWQgc3R5bGUgZGF0YSAoc28gaXQncyBiZXR0ZXIgdG8gcmVhZC9yZWFkL3JlYWQvd3JpdGUvd3JpdGUvd3JpdGUgdGhhbiByZWFkL3dyaXRlL3JlYWQvd3JpdGUvcmVhZC93cml0ZSkuIFRoZSBkb3duIHNpZGUsIG9mIGNvdXJzZSwgaXMgdGhhdCB1c3VhbGx5IHlvdSBXQU5UIHRoaW5ncyB0byByZW5kZXIgaW1tZWRpYXRlbHkgYmVjYXVzZSB5b3UgbWF5IGhhdmUgY29kZSBydW5uaW5nIHJpZ2h0IGFmdGVyIHRoYXQgd2hpY2ggZGVwZW5kcyBvbiB0aGUgY2hhbmdlLiBMaWtlIGltYWdpbmUgcnVubmluZyBUd2VlbkxpdGUuc2V0KC4uLikgYW5kIHRoZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhhdCwgY3JlYXRpbmcgYSBub3RoZXIgdHdlZW4gdGhhdCBhbmltYXRlcyB0aGUgc2FtZSBwcm9wZXJ0eSB0byBhbm90aGVyIHZhbHVlOyB0aGUgc3RhcnRpbmcgdmFsdWVzIG9mIHRoYXQgMm5kIHR3ZWVuIHdvdWxkbid0IGJlIGFjY3VyYXRlIGlmIGxhenkgaXMgdHJ1ZS5cblx0XHRcdFx0XHR0aGlzLl90aW1lID0gcHJldlRpbWU7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gcHJldlRvdGFsVGltZTtcblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHByZXZSYXdQcmV2VGltZTtcblx0XHRcdFx0XHR0aGlzLl9jeWNsZSA9IHByZXZDeWNsZTtcblx0XHRcdFx0XHRUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVR3ZWVucy5wdXNoKHRoaXMpO1xuXHRcdFx0XHRcdHRoaXMuX2xhenkgPSBbdGltZSwgc3VwcHJlc3NFdmVudHNdO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL19lYXNlIGlzIGluaXRpYWxseSBzZXQgdG8gZGVmYXVsdEVhc2UsIHNvIG5vdyB0aGF0IGluaXQoKSBoYXMgcnVuLCBfZWFzZSBpcyBzZXQgcHJvcGVybHkgYW5kIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgdGhlIHJhdGlvLiBPdmVyYWxsIHRoaXMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY29uZGl0aW9uYWwgbG9naWMgZWFybGllciBpbiB0aGUgbWV0aG9kIHRvIGF2b2lkIGhhdmluZyB0byBzZXQgcmF0aW8gdHdpY2UgYmVjYXVzZSB3ZSBvbmx5IGluaXQoKSBvbmNlIGJ1dCByZW5kZXJUaW1lKCkgZ2V0cyBjYWxsZWQgVkVSWSBmcmVxdWVudGx5LlxuXHRcdFx0XHRpZiAodGhpcy5fdGltZSAmJiAhaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNDb21wbGV0ZSAmJiB0aGlzLl9lYXNlLl9jYWxjRW5kKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oKHRoaXMuX3RpbWUgPT09IDApID8gMCA6IDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fbGF6eSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgaWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fdGltZSAhPT0gcHJldlRpbWUgJiYgdGltZSA+PSAwKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7IC8vc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGEgdHdlZW4gKGFzIG9wcG9zZWQgdG8gdGhlIHRpbWVsaW5lIHJlbmRlcmluZyBpdCksIHRoZSB0aW1lbGluZSBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0d2VlbiBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZS5cblx0XHRcdH1cblx0XHRcdGlmIChwcmV2VG90YWxUaW1lID09PSAwKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9pbml0dGVkID09PSAyICYmIHRpbWUgPiAwKSB7XG5cdFx0XHRcdFx0Ly90aGlzLmludmFsaWRhdGUoKTtcblx0XHRcdFx0XHR0aGlzLl9pbml0KCk7IC8vd2lsbCBqdXN0IGFwcGx5IG92ZXJ3cml0aW5nIHNpbmNlIF9pbml0dGVkIG9mICgyKSBtZWFucyBpdCB3YXMgYSBmcm9tKCkgdHdlZW4gdGhhdCBoYWQgaW1tZWRpYXRlUmVuZGVyOnRydWVcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdGlmICh0aW1lID49IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJfZHVtbXlHU1wiOyAvL2lmIG5vIGNhbGxiYWNrIGlzIGRlZmluZWQsIHVzZSBhIGR1bW15IHZhbHVlIGp1c3Qgc28gdGhhdCB0aGUgY29uZGl0aW9uIGF0IHRoZSBlbmQgZXZhbHVhdGVzIGFzIHRydWUgYmVjYXVzZSBfc3RhcnRBdCBzaG91bGQgcmVuZGVyIEFGVEVSIHRoZSBub3JtYWwgcmVuZGVyIGxvb3Agd2hlbiB0aGUgdGltZSBpcyBuZWdhdGl2ZS4gV2UgY291bGQgaGFuZGxlIHRoaXMgaW4gYSBtb3JlIGludHVpdGl2ZSB3YXksIG9mIGNvdXJzZSwgYnV0IHRoZSByZW5kZXIgbG9vcCBpcyB0aGUgTU9TVCBpbXBvcnRhbnQgdGhpbmcgdG8gb3B0aW1pemUsIHNvIHRoaXMgdGVjaG5pcXVlIGFsbG93cyB1cyB0byBhdm9pZCBhZGRpbmcgZXh0cmEgY29uZGl0aW9uYWwgbG9naWMgaW4gYSBoaWdoLWZyZXF1ZW5jeSBhcmVhLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy52YXJzLm9uU3RhcnQpIGlmICh0aGlzLl90b3RhbFRpbWUgIT09IDAgfHwgZHVyYXRpb24gPT09IDApIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0XHR0aGlzLnZhcnMub25TdGFydC5hcHBseSh0aGlzLnZhcnMub25TdGFydFNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblN0YXJ0UGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdKHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucztcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIHtcblx0XHRcdFx0aWYgKHRpbWUgPCAwKSBpZiAodGhpcy5fc3RhcnRBdCAmJiB0aGlzLl9zdGFydFRpbWUpIHsgLy9pZiB0aGUgdHdlZW4gaXMgcG9zaXRpb25lZCBhdCB0aGUgVkVSWSBiZWdpbm5pbmcgKF9zdGFydFRpbWUgMCkgb2YgaXRzIHBhcmVudCB0aW1lbGluZSwgaXQncyBpbGxlZ2FsIGZvciB0aGUgcGxheWhlYWQgdG8gZ28gYmFjayBmdXJ0aGVyLCBzbyB3ZSBzaG91bGQgbm90IHJlbmRlciB0aGUgcmVjb3JkZWQgc3RhcnRBdCB2YWx1ZXMuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTsgLy9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgdHVjayB0aGlzIGNvbmRpdGlvbmFsIGxvZ2ljIGluc2lkZSBsZXNzIHRyYXZlbGVkIGFyZWFzIChtb3N0IHR3ZWVucyBkb24ndCBoYXZlIGFuIG9uVXBkYXRlKS4gV2UnZCBqdXN0IGhhdmUgaXQgYXQgdGhlIGVuZCBiZWZvcmUgdGhlIG9uQ29tcGxldGUsIGJ1dCB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkIGJlZm9yZSBhbnkgb25VcGRhdGUgaXMgY2FsbGVkLCBzbyB3ZSBBTFNPIHB1dCBpdCBoZXJlIGFuZCB0aGVuIGlmIGl0J3Mgbm90IGNhbGxlZCwgd2UgZG8gc28gbGF0ZXIgbmVhciB0aGUgb25Db21wbGV0ZS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzKSBpZiAodGhpcy5fdG90YWxUaW1lICE9PSBwcmV2VG90YWxUaW1lIHx8IGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHR0aGlzLl9vblVwZGF0ZS5hcHBseSh0aGlzLnZhcnMub25VcGRhdGVTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25VcGRhdGVQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IHByZXZDeWNsZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykgaWYgKCF0aGlzLl9nYykgaWYgKHRoaXMudmFycy5vblJlcGVhdCkge1xuXHRcdFx0XHR0aGlzLnZhcnMub25SZXBlYXQuYXBwbHkodGhpcy52YXJzLm9uUmVwZWF0U2NvcGUgfHwgdGhpcywgdGhpcy52YXJzLm9uUmVwZWF0UGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdH1cblx0XHRcdGlmIChjYWxsYmFjaykgaWYgKCF0aGlzLl9nYyB8fCBmb3JjZSkgeyAvL2NoZWNrIGdjIGJlY2F1c2UgdGhlcmUncyBhIGNoYW5jZSB0aGF0IGtpbGwoKSBjb3VsZCBiZSBjYWxsZWQgaW4gYW4gb25VcGRhdGVcblx0XHRcdFx0aWYgKHRpbWUgPCAwICYmIHRoaXMuX3N0YXJ0QXQgJiYgIXRoaXMuX29uVXBkYXRlICYmIHRoaXMuX3N0YXJ0VGltZSkgeyAvL2lmIHRoZSB0d2VlbiBpcyBwb3NpdGlvbmVkIGF0IHRoZSBWRVJZIGJlZ2lubmluZyAoX3N0YXJ0VGltZSAwKSBvZiBpdHMgcGFyZW50IHRpbWVsaW5lLCBpdCdzIGlsbGVnYWwgZm9yIHRoZSBwbGF5aGVhZCB0byBnbyBiYWNrIGZ1cnRoZXIsIHNvIHdlIHNob3VsZCBub3QgcmVuZGVyIHRoZSByZWNvcmRlZCBzdGFydEF0IHZhbHVlcy5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzICYmIHRoaXMudmFyc1tjYWxsYmFja10pIHtcblx0XHRcdFx0XHR0aGlzLnZhcnNbY2FsbGJhY2tdLmFwcGx5KHRoaXMudmFyc1tjYWxsYmFjayArIFwiU2NvcGVcIl0gfHwgdGhpcywgdGhpcy52YXJzW2NhbGxiYWNrICsgXCJQYXJhbXNcIl0gfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgcmF3UHJldlRpbWUgIT09IF90aW55TnVtKSB7IC8vdGhlIG9uQ29tcGxldGUgb3Igb25SZXZlcnNlQ29tcGxldGUgY291bGQgdHJpZ2dlciBtb3ZlbWVudCBvZiB0aGUgcGxheWhlYWQgYW5kIGZvciB6ZXJvLWR1cmF0aW9uIHR3ZWVucyAod2hpY2ggbXVzdCBkaXNjZXJuIGRpcmVjdGlvbikgdGhhdCBsYW5kIGRpcmVjdGx5IGJhY2sgb24gdGhlaXIgc3RhcnQgdGltZSwgd2UgZG9uJ3Qgd2FudCB0byBmaXJlIGFnYWluIG9uIHRoZSBuZXh0IHJlbmRlci4gVGhpbmsgb2Ygc2V2ZXJhbCBhZGRQYXVzZSgpJ3MgaW4gYSB0aW1lbGluZSB0aGF0IGZvcmNlcyB0aGUgcGxheWhlYWQgdG8gYSBjZXJ0YWluIHNwb3QsIGJ1dCB3aGF0IGlmIGl0J3MgYWxyZWFkeSBwYXVzZWQgYW5kIGFub3RoZXIgdHdlZW4gaXMgdHdlZW5pbmcgdGhlIFwidGltZVwiIG9mIHRoZSB0aW1lbGluZT8gRWFjaCB0aW1lIGl0IG1vdmVzIFtmb3J3YXJkXSBwYXN0IHRoYXQgc3BvdCwgaXQgd291bGQgbW92ZSBiYWNrLCBhbmQgc2luY2Ugc3VwcHJlc3NFdmVudHMgaXMgdHJ1ZSwgaXQnZCByZXNldCBfcmF3UHJldlRpbWUgdG8gX3RpbnlOdW0gc28gdGhhdCB3aGVuIGl0IGJlZ2lucyBhZ2FpbiwgdGhlIGNhbGxiYWNrIHdvdWxkIGZpcmUgKHNvIHVsdGltYXRlbHkgaXQgY291bGQgYm91bmNlIGJhY2sgYW5kIGZvcnRoIGR1cmluZyB0aGF0IHR3ZWVuKS4gQWdhaW4sIHRoaXMgaXMgYSB2ZXJ5IHVuY29tbW9uIHNjZW5hcmlvLCBidXQgcG9zc2libGUgbm9uZXRoZWxlc3MuXG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcbi8vLS0tLSBTVEFUSUMgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0XG5cdFx0VHdlZW5NYXgudG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguZnJvbSA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHZhcnMucnVuQmFja3dhcmRzID0gdHJ1ZTtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5NYXgodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5mcm9tVG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KHRhcmdldCwgZHVyYXRpb24sIHRvVmFycyk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5zdGFnZ2VyVG8gPSBUd2Vlbk1heC5hbGxUbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHN0YWdnZXIgPSBzdGFnZ2VyIHx8IDA7XG5cdFx0XHR2YXIgZGVsYXkgPSB2YXJzLmRlbGF5IHx8IDAsXG5cdFx0XHRcdGEgPSBbXSxcblx0XHRcdFx0ZmluYWxDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICh2YXJzLm9uQ29tcGxldGUpIHtcblx0XHRcdFx0XHRcdHZhcnMub25Db21wbGV0ZS5hcHBseSh2YXJzLm9uQ29tcGxldGVTY29wZSB8fCB0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvbkNvbXBsZXRlQWxsLmFwcGx5KG9uQ29tcGxldGVBbGxTY29wZSB8fCB0aGlzLCBvbkNvbXBsZXRlQWxsUGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0bCwgY29weSwgaSwgcDtcblx0XHRcdGlmICghX2lzQXJyYXkodGFyZ2V0cykpIHtcblx0XHRcdFx0aWYgKHR5cGVvZih0YXJnZXRzKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdHRhcmdldHMgPSBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0cykgfHwgdGFyZ2V0cztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2lzU2VsZWN0b3IodGFyZ2V0cykpIHtcblx0XHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRzID0gdGFyZ2V0cyB8fCBbXTtcblx0XHRcdGlmIChzdGFnZ2VyIDwgMCkge1xuXHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0XHR0YXJnZXRzLnJldmVyc2UoKTtcblx0XHRcdFx0c3RhZ2dlciAqPSAtMTtcblx0XHRcdH1cblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aCAtIDE7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDw9IGw7IGkrKykge1xuXHRcdFx0XHRjb3B5ID0ge307XG5cdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdFx0Y29weVtwXSA9IHZhcnNbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29weS5kZWxheSA9IGRlbGF5O1xuXHRcdFx0XHRpZiAoaSA9PT0gbCAmJiBvbkNvbXBsZXRlQWxsKSB7XG5cdFx0XHRcdFx0Y29weS5vbkNvbXBsZXRlID0gZmluYWxDb21wbGV0ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhW2ldID0gbmV3IFR3ZWVuTWF4KHRhcmdldHNbaV0sIGR1cmF0aW9uLCBjb3B5KTtcblx0XHRcdFx0ZGVsYXkgKz0gc3RhZ2dlcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguc3RhZ2dlckZyb20gPSBUd2Vlbk1heC5hbGxGcm9tID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dmFycy5ydW5CYWNrd2FyZHMgPSB0cnVlO1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIFR3ZWVuTWF4LnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LnN0YWdnZXJGcm9tVG8gPSBUd2Vlbk1heC5hbGxGcm9tVG8gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gVHdlZW5NYXguc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB0b1ZhcnMsIHN0YWdnZXIsIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblx0XHRcdFx0XG5cdFx0VHdlZW5NYXguZGVsYXllZENhbGwgPSBmdW5jdGlvbihkZWxheSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUsIHVzZUZyYW1lcykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heChjYWxsYmFjaywgMCwge2RlbGF5OmRlbGF5LCBvbkNvbXBsZXRlOmNhbGxiYWNrLCBvbkNvbXBsZXRlUGFyYW1zOnBhcmFtcywgb25Db21wbGV0ZVNjb3BlOnNjb3BlLCBvblJldmVyc2VDb21wbGV0ZTpjYWxsYmFjaywgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBvblJldmVyc2VDb21wbGV0ZVNjb3BlOnNjb3BlLCBpbW1lZGlhdGVSZW5kZXI6ZmFsc2UsIHVzZUZyYW1lczp1c2VGcmFtZXMsIG92ZXJ3cml0ZTowfSk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5NYXgodGFyZ2V0LCAwLCB2YXJzKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LmlzVHdlZW5pbmcgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRcdHJldHVybiAoVHdlZW5MaXRlLmdldFR3ZWVuc09mKHRhcmdldCwgdHJ1ZSkubGVuZ3RoID4gMCk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgX2dldENoaWxkcmVuT2YgPSBmdW5jdGlvbih0aW1lbGluZSwgaW5jbHVkZVRpbWVsaW5lcykge1xuXHRcdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRcdGNudCA9IDAsXG5cdFx0XHRcdFx0dHdlZW4gPSB0aW1lbGluZS5fZmlyc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdGlmICh0d2VlbiBpbnN0YW5jZW9mIFR3ZWVuTGl0ZSkge1xuXHRcdFx0XHRcdFx0YVtjbnQrK10gPSB0d2Vlbjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKGluY2x1ZGVUaW1lbGluZXMpIHtcblx0XHRcdFx0XHRcdFx0YVtjbnQrK10gPSB0d2Vlbjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGEgPSBhLmNvbmNhdChfZ2V0Q2hpbGRyZW5PZih0d2VlbiwgaW5jbHVkZVRpbWVsaW5lcykpO1xuXHRcdFx0XHRcdFx0Y250ID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHR9LCBcblx0XHRcdGdldEFsbFR3ZWVucyA9IFR3ZWVuTWF4LmdldEFsbFR3ZWVucyA9IGZ1bmN0aW9uKGluY2x1ZGVUaW1lbGluZXMpIHtcblx0XHRcdFx0cmV0dXJuIF9nZXRDaGlsZHJlbk9mKEFuaW1hdGlvbi5fcm9vdFRpbWVsaW5lLCBpbmNsdWRlVGltZWxpbmVzKS5jb25jYXQoIF9nZXRDaGlsZHJlbk9mKEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lLCBpbmNsdWRlVGltZWxpbmVzKSApO1xuXHRcdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5raWxsQWxsID0gZnVuY3Rpb24oY29tcGxldGUsIHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpIHtcblx0XHRcdGlmICh0d2VlbnMgPT0gbnVsbCkge1xuXHRcdFx0XHR0d2VlbnMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRlbGF5ZWRDYWxscyA9PSBudWxsKSB7XG5cdFx0XHRcdGRlbGF5ZWRDYWxscyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IGdldEFsbFR3ZWVucygodGltZWxpbmVzICE9IGZhbHNlKSksXG5cdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0YWxsVHJ1ZSA9ICh0d2VlbnMgJiYgZGVsYXllZENhbGxzICYmIHRpbWVsaW5lcyksXG5cdFx0XHRcdGlzREMsIHR3ZWVuLCBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR0d2VlbiA9IGFbaV07XG5cdFx0XHRcdGlmIChhbGxUcnVlIHx8ICh0d2VlbiBpbnN0YW5jZW9mIFNpbXBsZVRpbWVsaW5lKSB8fCAoKGlzREMgPSAodHdlZW4udGFyZ2V0ID09PSB0d2Vlbi52YXJzLm9uQ29tcGxldGUpKSAmJiBkZWxheWVkQ2FsbHMpIHx8ICh0d2VlbnMgJiYgIWlzREMpKSB7XG5cdFx0XHRcdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi50b3RhbFRpbWUodHdlZW4uX3JldmVyc2VkID8gMCA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR3ZWVuLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5raWxsQ2hpbGRUd2VlbnNPZiA9IGZ1bmN0aW9uKHBhcmVudCwgY29tcGxldGUpIHtcblx0XHRcdGlmIChwYXJlbnQgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgdGwgPSBUd2VlbkxpdGVJbnRlcm5hbHMudHdlZW5Mb29rdXAsXG5cdFx0XHRcdGEsIGN1clBhcmVudCwgcCwgaSwgbDtcblx0XHRcdGlmICh0eXBlb2YocGFyZW50KSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRwYXJlbnQgPSBUd2VlbkxpdGUuc2VsZWN0b3IocGFyZW50KSB8fCBwYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoX2lzU2VsZWN0b3IocGFyZW50KSkge1xuXHRcdFx0XHRwYXJlbnQgPSBfc2xpY2UocGFyZW50KTtcblx0XHRcdH1cblx0XHRcdGlmIChfaXNBcnJheShwYXJlbnQpKSB7XG5cdFx0XHRcdGkgPSBwYXJlbnQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRUd2Vlbk1heC5raWxsQ2hpbGRUd2VlbnNPZihwYXJlbnRbaV0sIGNvbXBsZXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRhID0gW107XG5cdFx0XHRmb3IgKHAgaW4gdGwpIHtcblx0XHRcdFx0Y3VyUGFyZW50ID0gdGxbcF0udGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0XHRcdHdoaWxlIChjdXJQYXJlbnQpIHtcblx0XHRcdFx0XHRpZiAoY3VyUGFyZW50ID09PSBwYXJlbnQpIHtcblx0XHRcdFx0XHRcdGEgPSBhLmNvbmNhdCh0bFtwXS50d2VlbnMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXJQYXJlbnQgPSBjdXJQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bCA9IGEubGVuZ3RoO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoY29tcGxldGUpIHtcblx0XHRcdFx0XHRhW2ldLnRvdGFsVGltZShhW2ldLnRvdGFsRHVyYXRpb24oKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YVtpXS5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgX2NoYW5nZVBhdXNlID0gZnVuY3Rpb24ocGF1c2UsIHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpIHtcblx0XHRcdHR3ZWVucyA9ICh0d2VlbnMgIT09IGZhbHNlKTtcblx0XHRcdGRlbGF5ZWRDYWxscyA9IChkZWxheWVkQ2FsbHMgIT09IGZhbHNlKTtcblx0XHRcdHRpbWVsaW5lcyA9ICh0aW1lbGluZXMgIT09IGZhbHNlKTtcblx0XHRcdHZhciBhID0gZ2V0QWxsVHdlZW5zKHRpbWVsaW5lcyksXG5cdFx0XHRcdGFsbFRydWUgPSAodHdlZW5zICYmIGRlbGF5ZWRDYWxscyAmJiB0aW1lbGluZXMpLFxuXHRcdFx0XHRpID0gYS5sZW5ndGgsXG5cdFx0XHRcdGlzREMsIHR3ZWVuO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHR3ZWVuID0gYVtpXTtcblx0XHRcdFx0aWYgKGFsbFRydWUgfHwgKHR3ZWVuIGluc3RhbmNlb2YgU2ltcGxlVGltZWxpbmUpIHx8ICgoaXNEQyA9ICh0d2Vlbi50YXJnZXQgPT09IHR3ZWVuLnZhcnMub25Db21wbGV0ZSkpICYmIGRlbGF5ZWRDYWxscykgfHwgKHR3ZWVucyAmJiAhaXNEQykpIHtcblx0XHRcdFx0XHR0d2Vlbi5wYXVzZWQocGF1c2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5wYXVzZUFsbCA9IGZ1bmN0aW9uKHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpIHtcblx0XHRcdF9jaGFuZ2VQYXVzZSh0cnVlLCB0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LnJlc3VtZUFsbCA9IGZ1bmN0aW9uKHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpIHtcblx0XHRcdF9jaGFuZ2VQYXVzZShmYWxzZSwgdHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTWF4Lmdsb2JhbFRpbWVTY2FsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgdGwgPSBBbmltYXRpb24uX3Jvb3RUaW1lbGluZSxcblx0XHRcdFx0dCA9IFR3ZWVuTGl0ZS50aWNrZXIudGltZTtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGwuX3RpbWVTY2FsZTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gdmFsdWUgfHwgX3RpbnlOdW07IC8vY2FuJ3QgYWxsb3cgemVybyBiZWNhdXNlIGl0J2xsIHRocm93IHRoZSBtYXRoIG9mZlxuXHRcdFx0dGwuX3N0YXJ0VGltZSA9IHQgLSAoKHQgLSB0bC5fc3RhcnRUaW1lKSAqIHRsLl90aW1lU2NhbGUgLyB2YWx1ZSk7XG5cdFx0XHR0bCA9IEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lO1xuXHRcdFx0dCA9IFR3ZWVuTGl0ZS50aWNrZXIuZnJhbWU7XG5cdFx0XHR0bC5fc3RhcnRUaW1lID0gdCAtICgodCAtIHRsLl9zdGFydFRpbWUpICogdGwuX3RpbWVTY2FsZSAvIHZhbHVlKTtcblx0XHRcdHRsLl90aW1lU2NhbGUgPSBBbmltYXRpb24uX3Jvb3RUaW1lbGluZS5fdGltZVNjYWxlID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblx0XHRcblx0XG4vLy0tLS0gR0VUVEVSUyAvIFNFVFRFUlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdFxuXHRcdHAucHJvZ3Jlc3MgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90aW1lIC8gdGhpcy5kdXJhdGlvbigpIDogdGhpcy50b3RhbFRpbWUoIHRoaXMuZHVyYXRpb24oKSAqICgodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpLCBmYWxzZSk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90b3RhbFRpbWUgLyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKCB0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBmYWxzZSk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnRpbWUgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSA+IHRoaXMuX2R1cmF0aW9uKSB7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5fZHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkge1xuXHRcdFx0XHR2YWx1ZSA9ICh0aGlzLl9kdXJhdGlvbiAtIHZhbHVlKSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3JlcGVhdCAhPT0gMCkge1xuXHRcdFx0XHR2YWx1ZSArPSB0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZSh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLmR1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZHVyYXRpb247IC8vZG9uJ3Qgc2V0IF9kaXJ0eSA9IGZhbHNlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgcmVwZWF0cyB0aGF0IGhhdmVuJ3QgYmVlbiBmYWN0b3JlZCBpbnRvIHRoZSBfdG90YWxEdXJhdGlvbiB5ZXQuIE90aGVyd2lzZSwgaWYgeW91IGNyZWF0ZSBhIHJlcGVhdGVkIFR3ZWVuTWF4IGFuZCB0aGVuIGltbWVkaWF0ZWx5IGNoZWNrIGl0cyBkdXJhdGlvbigpLCBpdCB3b3VsZCBjYWNoZSB0aGUgdmFsdWUgYW5kIHRoZSB0b3RhbER1cmF0aW9uIHdvdWxkIG5vdCBiZSBjb3JyZWN0LCB0aHVzIHJlcGVhdHMgd291bGRuJ3QgdGFrZSBlZmZlY3QuXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQW5pbWF0aW9uLnByb3RvdHlwZS5kdXJhdGlvbi5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHR9O1xuXG5cdFx0cC50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHQvL2luc3RlYWQgb2YgSW5maW5pdHksIHdlIHVzZSA5OTk5OTk5OTk5OTkgc28gdGhhdCB3ZSBjYW4gYWNjb21tb2RhdGUgcmV2ZXJzZXNcblx0XHRcdFx0XHR0aGlzLl90b3RhbER1cmF0aW9uID0gKHRoaXMuX3JlcGVhdCA9PT0gLTEpID8gOTk5OTk5OTk5OTk5IDogdGhpcy5fZHVyYXRpb24gKiAodGhpcy5fcmVwZWF0ICsgMSkgKyAodGhpcy5fcmVwZWF0RGVsYXkgKiB0aGlzLl9yZXBlYXQpO1xuXHRcdFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsRHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHRoaXMuX3JlcGVhdCA9PT0gLTEpID8gdGhpcyA6IHRoaXMuZHVyYXRpb24oICh2YWx1ZSAtICh0aGlzLl9yZXBlYXQgKiB0aGlzLl9yZXBlYXREZWxheSkpIC8gKHRoaXMuX3JlcGVhdCArIDEpICk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnJlcGVhdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcGVhdDtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdCA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnlveW8gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl95b3lvO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5feW95byA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRyZXR1cm4gVHdlZW5NYXg7XG5cdFx0XG5cdH0sIHRydWUpO1xuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUaW1lbGluZUxpdGVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUaW1lbGluZUxpdGVcIiwgW1wiY29yZS5BbmltYXRpb25cIixcImNvcmUuU2ltcGxlVGltZWxpbmVcIixcIlR3ZWVuTGl0ZVwiXSwgZnVuY3Rpb24oQW5pbWF0aW9uLCBTaW1wbGVUaW1lbGluZSwgVHdlZW5MaXRlKSB7XG5cblx0XHR2YXIgVGltZWxpbmVMaXRlID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0XHRTaW1wbGVUaW1lbGluZS5jYWxsKHRoaXMsIHZhcnMpO1xuXHRcdFx0XHR0aGlzLl9sYWJlbHMgPSB7fTtcblx0XHRcdFx0dGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPSAodGhpcy52YXJzLmF1dG9SZW1vdmVDaGlsZHJlbiA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuc21vb3RoQ2hpbGRUaW1pbmcgPSAodGhpcy52YXJzLnNtb290aENoaWxkVGltaW5nID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5fc29ydENoaWxkcmVuID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fb25VcGRhdGUgPSB0aGlzLnZhcnMub25VcGRhdGU7XG5cdFx0XHRcdHZhciB2ID0gdGhpcy52YXJzLFxuXHRcdFx0XHRcdHZhbCwgcDtcblx0XHRcdFx0Zm9yIChwIGluIHYpIHtcblx0XHRcdFx0XHR2YWwgPSB2W3BdO1xuXHRcdFx0XHRcdGlmIChfaXNBcnJheSh2YWwpKSBpZiAodmFsLmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHZbcF0gPSB0aGlzLl9zd2FwU2VsZkluUGFyYW1zKHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfaXNBcnJheSh2LnR3ZWVucykpIHtcblx0XHRcdFx0XHR0aGlzLmFkZCh2LnR3ZWVucywgMCwgdi5hbGlnbiwgdi5zdGFnZ2VyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF90aW55TnVtID0gMC4wMDAwMDAwMDAxLFxuXHRcdFx0VHdlZW5MaXRlSW50ZXJuYWxzID0gVHdlZW5MaXRlLl9pbnRlcm5hbHMsXG5cdFx0XHRfaW50ZXJuYWxzID0gVGltZWxpbmVMaXRlLl9pbnRlcm5hbHMgPSB7fSxcblx0XHRcdF9pc1NlbGVjdG9yID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzU2VsZWN0b3IsXG5cdFx0XHRfaXNBcnJheSA9IFR3ZWVuTGl0ZUludGVybmFscy5pc0FycmF5LFxuXHRcdFx0X2xhenlUd2VlbnMgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVR3ZWVucyxcblx0XHRcdF9sYXp5UmVuZGVyID0gVHdlZW5MaXRlSW50ZXJuYWxzLmxhenlSZW5kZXIsXG5cdFx0XHRfYmxhbmtBcnJheSA9IFtdLFxuXHRcdFx0X2dsb2JhbHMgPSBfZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxcblx0XHRcdF9jb3B5ID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0XHR2YXIgY29weSA9IHt9LCBwO1xuXHRcdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRcdGNvcHlbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb3B5O1xuXHRcdFx0fSxcblx0XHRcdF9wYXVzZUNhbGxiYWNrID0gX2ludGVybmFscy5wYXVzZUNhbGxiYWNrID0gZnVuY3Rpb24odHdlZW4sIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0XHRcdHZhciB0bCA9IHR3ZWVuLl90aW1lbGluZSxcblx0XHRcdFx0XHR0aW1lID0gdGwuX3RvdGFsVGltZSxcblx0XHRcdFx0XHRzdGFydFRpbWUgPSB0d2Vlbi5fc3RhcnRUaW1lLFxuXHRcdFx0XHRcdG5leHQgPSB0d2Vlbi5yYXRpbyA/IF90aW55TnVtIDogMCxcblx0XHRcdFx0XHRwcmV2ID0gdHdlZW4ucmF0aW8gPyAwIDogX3RpbnlOdW0sXG5cdFx0XHRcdFx0c2libGluZztcblx0XHRcdFx0aWYgKGNhbGxiYWNrIHx8ICF0aGlzLl9mb3JjaW5nUGxheWhlYWQpIHsgLy9pZiB0aGUgdXNlciBjYWxscyBhIG1ldGhvZCB0aGF0IG1vdmVzIHRoZSBwbGF5aGVhZCAobGlrZSBwcm9ncmVzcygpIG9yIHRpbWUoKSksIGl0IHNob3VsZCBob25vciB0aGF0IGFuZCBza2lwIGFueSBwYXVzZXMgKGFsdGhvdWdoIGlmIHRoZXJlJ3MgYSBjYWxsYmFjayBwb3NpdGlvbmVkIGF0IHRoYXQgcGF1c2UsIGl0IG11c3QganVtcCB0aGVyZSBhbmQgbWFrZSB0aGUgY2FsbCB0byBlbnN1cmUgdGhlIHRpbWUgaXMgRVhBQ1RMWSB3aGF0IGl0IGlzIHN1cHBvc2VkIHRvIGJlLCBhbmQgdGhlbiBwcm9jZWVkIHRvIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBiZWluZyBmb3JjZWQpLiBPdGhlcndpc2UsIGltYWdpbmUgcGxhY2luZyBhIHBhdXNlIGluIHRoZSBtaWRkbGUgb2YgYSB0aW1lbGluZSBhbmQgdGhlbiBkb2luZyB0aW1lbGluZS5wcm9ncmVzcygwLjkpIC0gaXQgd291bGQgZ2V0IHN0dWNrIHdoZXJlIHRoZSBwYXVzZSBpcy5cblx0XHRcdFx0XHR0bC5wYXVzZShzdGFydFRpbWUpO1xuXHRcdFx0XHRcdC8vbm93IGZpbmQgc2libGluZyB0d2VlbnMgdGhhdCBhcmUgRVhBQ1RMWSBhdCB0aGUgc2FtZSBzcG90IG9uIHRoZSB0aW1lbGluZSBhbmQgYWRqdXN0IHRoZSBfcmF3UHJldlRpbWUgc28gdGhhdCB0aGV5IGZpcmUgKG9yIGRvbid0IGZpcmUpIGNvcnJlY3RseSBvbiB0aGUgbmV4dCByZW5kZXIuIFRoaXMgaXMgcHJpbWFyaWx5IHRvIGFjY29tbW9kYXRlIHplcm8tZHVyYXRpb24gdHdlZW5zL2NhbGxiYWNrcyB0aGF0IGFyZSBwb3NpdGlvbmVkIHJpZ2h0IG9uIHRvcCBvZiBhIHBhdXNlLiBGb3IgZXhhbXBsZSwgdGwudG8oLi4uKS5jYWxsKC4uLikuYWRkUGF1c2UoLi4uKS5jYWxsKC4uLikgLSBub3RpY2UgdGhhdCB0aGVyZSdzIGEgY2FsbCgpIG9uIGVhY2ggc2lkZSBvZiB0aGUgcGF1c2UsIHNvIHdoZW4gaXQncyBydW5uaW5nIGZvcndhcmQgaXQgc2hvdWxkIGNhbGwgdGhlIGZpcnN0IG9uZSBhbmQgdGhlbiBwYXVzZSwgYW5kIHRoZW4gd2hlbiByZXN1bWVkLCBjYWxsIHRoZSBvdGhlci4gWmVyby1kdXJhdGlvbiB0d2VlbnMgdXNlIF9yYXdQcmV2VGltZSB0byBzZW5zZSBtb21lbnR1bSBmaWd1cmUgb3V0IGlmIGV2ZW50cyB3ZXJlIHN1cHByZXNzZWQgd2hlbiBhcnJpdmluZyBkaXJlY3RseSBvbiB0b3Agb2YgdGhhdCB0aW1lLlxuXHRcdFx0XHRcdHNpYmxpbmcgPSB0d2Vlbi5fcHJldjtcblx0XHRcdFx0XHR3aGlsZSAoc2libGluZyAmJiBzaWJsaW5nLl9zdGFydFRpbWUgPT09IHN0YXJ0VGltZSkge1xuXHRcdFx0XHRcdFx0c2libGluZy5fcmF3UHJldlRpbWUgPSBwcmV2O1xuXHRcdFx0XHRcdFx0c2libGluZyA9IHNpYmxpbmcuX3ByZXY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNpYmxpbmcgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0XHR3aGlsZSAoc2libGluZyAmJiBzaWJsaW5nLl9zdGFydFRpbWUgPT09IHN0YXJ0VGltZSkge1xuXHRcdFx0XHRcdFx0c2libGluZy5fcmF3UHJldlRpbWUgPSBuZXh0O1xuXHRcdFx0XHRcdFx0c2libGluZyA9IHNpYmxpbmcuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoc2NvcGUgfHwgdGwsIHBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl9mb3JjaW5nUGxheWhlYWQpIHtcblx0XHRcdFx0XHRcdHRsLnNlZWsodGltZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3NsaWNlID0gZnVuY3Rpb24oYSkgeyAvL2Rvbid0IHVzZSBbXS5zbGljZSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHR2YXIgYiA9IFtdLFxuXHRcdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpICE9PSBsOyBiLnB1c2goYVtpKytdKSk7XG5cdFx0XHRcdHJldHVybiBiO1xuXHRcdFx0fSxcblx0XHRcdHAgPSBUaW1lbGluZUxpdGUucHJvdG90eXBlID0gbmV3IFNpbXBsZVRpbWVsaW5lKCk7XG5cblx0XHRUaW1lbGluZUxpdGUudmVyc2lvbiA9IFwiMS4xNi4wXCI7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFRpbWVsaW5lTGl0ZTtcblx0XHRwLmtpbGwoKS5fZ2MgPSBwLl9mb3JjaW5nUGxheWhlYWQgPSBmYWxzZTtcblxuXHRcdC8qIG1pZ2h0IHVzZSBsYXRlci4uLlxuXHRcdC8vdHJhbnNsYXRlcyBhIGxvY2FsIHRpbWUgaW5zaWRlIGFuIGFuaW1hdGlvbiB0byB0aGUgY29ycmVzcG9uZGluZyB0aW1lIG9uIHRoZSByb290L2dsb2JhbCB0aW1lbGluZSwgZmFjdG9yaW5nIGluIGFsbCBuZXN0aW5nIGFuZCB0aW1lU2NhbGVzLlxuXHRcdGZ1bmN0aW9uIGxvY2FsVG9HbG9iYWwodGltZSwgYW5pbWF0aW9uKSB7XG5cdFx0XHR3aGlsZSAoYW5pbWF0aW9uKSB7XG5cdFx0XHRcdHRpbWUgPSAodGltZSAvIGFuaW1hdGlvbi5fdGltZVNjYWxlKSArIGFuaW1hdGlvbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24udGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGltZTtcblx0XHR9XG5cblx0XHQvL3RyYW5zbGF0ZXMgdGhlIHN1cHBsaWVkIHRpbWUgb24gdGhlIHJvb3QvZ2xvYmFsIHRpbWVsaW5lIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbG9jYWwgdGltZSBpbnNpZGUgYSBwYXJ0aWN1bGFyIGFuaW1hdGlvbiwgZmFjdG9yaW5nIGluIGFsbCBuZXN0aW5nIGFuZCB0aW1lU2NhbGVzXG5cdFx0ZnVuY3Rpb24gZ2xvYmFsVG9Mb2NhbCh0aW1lLCBhbmltYXRpb24pIHtcblx0XHRcdHZhciBzY2FsZSA9IDE7XG5cdFx0XHR0aW1lIC09IGxvY2FsVG9HbG9iYWwoMCwgYW5pbWF0aW9uKTtcblx0XHRcdHdoaWxlIChhbmltYXRpb24pIHtcblx0XHRcdFx0c2NhbGUgKj0gYW5pbWF0aW9uLl90aW1lU2NhbGU7XG5cdFx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aW1lICogc2NhbGU7XG5cdFx0fVxuXHRcdCovXG5cblx0XHRwLnRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycywgcG9zaXRpb24pIHtcblx0XHRcdHZhciBFbmdpbmUgPSAodmFycy5yZXBlYXQgJiYgX2dsb2JhbHMuVHdlZW5NYXgpIHx8IFR3ZWVuTGl0ZTtcblx0XHRcdHJldHVybiBkdXJhdGlvbiA/IHRoaXMuYWRkKCBuZXcgRW5naW5lKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpLCBwb3NpdGlvbikgOiB0aGlzLnNldCh0YXJnZXQsIHZhcnMsIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5mcm9tID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycywgcG9zaXRpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCggKCh2YXJzLnJlcGVhdCAmJiBfZ2xvYmFscy5Ud2Vlbk1heCkgfHwgVHdlZW5MaXRlKS5mcm9tKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuZnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgcG9zaXRpb24pIHtcblx0XHRcdHZhciBFbmdpbmUgPSAodG9WYXJzLnJlcGVhdCAmJiBfZ2xvYmFscy5Ud2Vlbk1heCkgfHwgVHdlZW5MaXRlO1xuXHRcdFx0cmV0dXJuIGR1cmF0aW9uID8gdGhpcy5hZGQoIEVuZ2luZS5mcm9tVG8odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycyksIHBvc2l0aW9uKSA6IHRoaXMuc2V0KHRhcmdldCwgdG9WYXJzLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuc3RhZ2dlclRvID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHZhciB0bCA9IG5ldyBUaW1lbGluZUxpdGUoe29uQ29tcGxldGU6b25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZVBhcmFtczpvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlU2NvcGU6b25Db21wbGV0ZUFsbFNjb3BlLCBzbW9vdGhDaGlsZFRpbWluZzp0aGlzLnNtb290aENoaWxkVGltaW5nfSksXG5cdFx0XHRcdGk7XG5cdFx0XHRpZiAodHlwZW9mKHRhcmdldHMpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHRhcmdldHMgPSBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0cykgfHwgdGFyZ2V0cztcblx0XHRcdH1cblx0XHRcdHRhcmdldHMgPSB0YXJnZXRzIHx8IFtdO1xuXHRcdFx0aWYgKF9pc1NlbGVjdG9yKHRhcmdldHMpKSB7IC8vc2Vuc2VzIGlmIHRoZSB0YXJnZXRzIG9iamVjdCBpcyBhIHNlbGVjdG9yLiBJZiBpdCBpcywgd2Ugc2hvdWxkIHRyYW5zbGF0ZSBpdCBpbnRvIGFuIGFycmF5LlxuXHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0fVxuXHRcdFx0c3RhZ2dlciA9IHN0YWdnZXIgfHwgMDtcblx0XHRcdGlmIChzdGFnZ2VyIDwgMCkge1xuXHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0XHR0YXJnZXRzLnJldmVyc2UoKTtcblx0XHRcdFx0c3RhZ2dlciAqPSAtMTtcblx0XHRcdH1cblx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh2YXJzLnN0YXJ0QXQpIHtcblx0XHRcdFx0XHR2YXJzLnN0YXJ0QXQgPSBfY29weSh2YXJzLnN0YXJ0QXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRsLnRvKHRhcmdldHNbaV0sIGR1cmF0aW9uLCBfY29weSh2YXJzKSwgaSAqIHN0YWdnZXIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHRsLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuc3RhZ2dlckZyb20gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0dmFycy5ydW5CYWNrd2FyZHMgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKTtcblx0XHR9O1xuXG5cdFx0cC5zdGFnZ2VyRnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG5cdFx0XHR0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UgJiYgZnJvbVZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKTtcblx0XHR9O1xuXG5cdFx0cC5jYWxsID0gZnVuY3Rpb24oY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUsIHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQoIFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSksIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24sIDAsIHRydWUpO1xuXHRcdFx0aWYgKHZhcnMuaW1tZWRpYXRlUmVuZGVyID09IG51bGwpIHtcblx0XHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAocG9zaXRpb24gPT09IHRoaXMuX3RpbWUgJiYgIXRoaXMuX3BhdXNlZCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQoIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCAwLCB2YXJzKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRUaW1lbGluZUxpdGUuZXhwb3J0Um9vdCA9IGZ1bmN0aW9uKHZhcnMsIGlnbm9yZURlbGF5ZWRDYWxscykge1xuXHRcdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0XHRpZiAodmFycy5zbW9vdGhDaGlsZFRpbWluZyA9PSBudWxsKSB7XG5cdFx0XHRcdHZhcnMuc21vb3RoQ2hpbGRUaW1pbmcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRsID0gbmV3IFRpbWVsaW5lTGl0ZSh2YXJzKSxcblx0XHRcdFx0cm9vdCA9IHRsLl90aW1lbGluZSxcblx0XHRcdFx0dHdlZW4sIG5leHQ7XG5cdFx0XHRpZiAoaWdub3JlRGVsYXllZENhbGxzID09IG51bGwpIHtcblx0XHRcdFx0aWdub3JlRGVsYXllZENhbGxzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJvb3QuX3JlbW92ZSh0bCwgdHJ1ZSk7XG5cdFx0XHR0bC5fc3RhcnRUaW1lID0gMDtcblx0XHRcdHRsLl9yYXdQcmV2VGltZSA9IHRsLl90aW1lID0gdGwuX3RvdGFsVGltZSA9IHJvb3QuX3RpbWU7XG5cdFx0XHR0d2VlbiA9IHJvb3QuX2ZpcnN0O1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0aWYgKCFpZ25vcmVEZWxheWVkQ2FsbHMgfHwgISh0d2VlbiBpbnN0YW5jZW9mIFR3ZWVuTGl0ZSAmJiB0d2Vlbi50YXJnZXQgPT09IHR3ZWVuLnZhcnMub25Db21wbGV0ZSkpIHtcblx0XHRcdFx0XHR0bC5hZGQodHdlZW4sIHR3ZWVuLl9zdGFydFRpbWUgLSB0d2Vlbi5fZGVsYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdH1cblx0XHRcdHJvb3QuYWRkKHRsLCAwKTtcblx0XHRcdHJldHVybiB0bDtcblx0XHR9O1xuXG5cdFx0cC5hZGQgPSBmdW5jdGlvbih2YWx1ZSwgcG9zaXRpb24sIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHR2YXIgY3VyVGltZSwgbCwgaSwgY2hpbGQsIHRsLCBiZWZvcmVSYXdUaW1lO1xuXHRcdFx0aWYgKHR5cGVvZihwb3NpdGlvbikgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uLCAwLCB0cnVlLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFuaW1hdGlvbikpIHtcblx0XHRcdFx0aWYgKCh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB8fCAodmFsdWUgJiYgdmFsdWUucHVzaCAmJiBfaXNBcnJheSh2YWx1ZSkpKSB7XG5cdFx0XHRcdFx0YWxpZ24gPSBhbGlnbiB8fCBcIm5vcm1hbFwiO1xuXHRcdFx0XHRcdHN0YWdnZXIgPSBzdGFnZ2VyIHx8IDA7XG5cdFx0XHRcdFx0Y3VyVGltZSA9IHBvc2l0aW9uO1xuXHRcdFx0XHRcdGwgPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKF9pc0FycmF5KGNoaWxkID0gdmFsdWVbaV0pKSB7XG5cdFx0XHRcdFx0XHRcdGNoaWxkID0gbmV3IFRpbWVsaW5lTGl0ZSh7dHdlZW5zOmNoaWxkfSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLmFkZChjaGlsZCwgY3VyVGltZSk7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKGNoaWxkKSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YoY2hpbGQpICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFsaWduID09PSBcInNlcXVlbmNlXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRjdXJUaW1lID0gY2hpbGQuX3N0YXJ0VGltZSArIChjaGlsZC50b3RhbER1cmF0aW9uKCkgLyBjaGlsZC5fdGltZVNjYWxlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChhbGlnbiA9PT0gXCJzdGFydFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGQuX3N0YXJ0VGltZSAtPSBjaGlsZC5kZWxheSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjdXJUaW1lICs9IHN0YWdnZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hZGRMYWJlbCh2YWx1ZSwgcG9zaXRpb24pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHZhbHVlID0gVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyhcIkNhbm5vdCBhZGQgXCIgKyB2YWx1ZSArIFwiIGludG8gdGhlIHRpbWVsaW5lOyBpdCBpcyBub3QgYSB0d2VlbiwgdGltZWxpbmUsIGZ1bmN0aW9uLCBvciBzdHJpbmcuXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCB2YWx1ZSwgcG9zaXRpb24pO1xuXG5cdFx0XHQvL2lmIHRoZSB0aW1lbGluZSBoYXMgYWxyZWFkeSBlbmRlZCBidXQgdGhlIGluc2VydGVkIHR3ZWVuL3RpbWVsaW5lIGV4dGVuZHMgdGhlIGR1cmF0aW9uLCB3ZSBzaG91bGQgZW5hYmxlIHRoaXMgdGltZWxpbmUgYWdhaW4gc28gdGhhdCBpdCByZW5kZXJzIHByb3Blcmx5LiBXZSBzaG91bGQgYWxzbyBhbGlnbiB0aGUgcGxheWhlYWQgd2l0aCB0aGUgcGFyZW50IHRpbWVsaW5lJ3Mgd2hlbiBhcHByb3ByaWF0ZS5cblx0XHRcdGlmICh0aGlzLl9nYyB8fCB0aGlzLl90aW1lID09PSB0aGlzLl9kdXJhdGlvbikgaWYgKCF0aGlzLl9wYXVzZWQpIGlmICh0aGlzLl9kdXJhdGlvbiA8IHRoaXMuZHVyYXRpb24oKSkge1xuXHRcdFx0XHQvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvcnMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLi4uXG5cdFx0XHRcdHRsID0gdGhpcztcblx0XHRcdFx0YmVmb3JlUmF3VGltZSA9ICh0bC5yYXdUaW1lKCkgPiB2YWx1ZS5fc3RhcnRUaW1lKTsgLy9pZiB0aGUgdHdlZW4gaXMgcGxhY2VkIG9uIHRoZSB0aW1lbGluZSBzbyB0aGF0IGl0IHN0YXJ0cyBCRUZPUkUgdGhlIGN1cnJlbnQgcmF3VGltZSwgd2Ugc2hvdWxkIGFsaWduIHRoZSBwbGF5aGVhZCAobW92ZSB0aGUgdGltZWxpbmUpLiBUaGlzIGlzIGJlY2F1c2Ugc29tZXRpbWVzIHVzZXJzIHdpbGwgY3JlYXRlIGEgdGltZWxpbmUsIGxldCBpdCBmaW5pc2gsIGFuZCBtdWNoIGxhdGVyIGFwcGVuZCBhIHR3ZWVuIGFuZCBleHBlY3QgaXQgdG8gcnVuIGluc3RlYWQgb2YganVtcGluZyB0byBpdHMgZW5kIHN0YXRlLiBXaGlsZSB0ZWNobmljYWxseSBvbmUgY291bGQgYXJndWUgdGhhdCBpdCBzaG91bGQganVtcCB0byBpdHMgZW5kIHN0YXRlLCB0aGF0J3Mgbm90IHdoYXQgdXNlcnMgaW50dWl0aXZlbHkgZXhwZWN0LlxuXHRcdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0aWYgKGJlZm9yZVJhd1RpbWUgJiYgdGwuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0XHR0bC50b3RhbFRpbWUodGwuX3RvdGFsVGltZSwgdHJ1ZSk7IC8vbW92ZXMgdGhlIHRpbWVsaW5lIChzaGlmdHMgaXRzIHN0YXJ0VGltZSkgaWYgbmVjZXNzYXJ5LCBhbmQgYWxzbyBlbmFibGVzIGl0LlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGwuX2djKSB7XG5cdFx0XHRcdFx0XHR0bC5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBBbmltYXRpb24pIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlbW92ZSh2YWx1ZSwgZmFsc2UpO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5IHx8ICh2YWx1ZSAmJiB2YWx1ZS5wdXNoICYmIF9pc0FycmF5KHZhbHVlKSkpIHtcblx0XHRcdFx0dmFyIGkgPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlKHZhbHVlW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVMYWJlbCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5raWxsKG51bGwsIHZhbHVlKTtcblx0XHR9O1xuXG5cdFx0cC5fcmVtb3ZlID0gZnVuY3Rpb24odHdlZW4sIHNraXBEaXNhYmxlKSB7XG5cdFx0XHRTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUuX3JlbW92ZS5jYWxsKHRoaXMsIHR3ZWVuLCBza2lwRGlzYWJsZSk7XG5cdFx0XHR2YXIgbGFzdCA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRpZiAoIWxhc3QpIHtcblx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPiBsYXN0Ll9zdGFydFRpbWUgKyBsYXN0Ll90b3RhbER1cmF0aW9uIC8gbGFzdC5fdGltZVNjYWxlKSB7XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLmR1cmF0aW9uKCk7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RvdGFsRHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5hcHBlbmQgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0T3JMYWJlbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHZhbHVlLCB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKG51bGwsIG9mZnNldE9yTGFiZWwsIHRydWUsIHZhbHVlKSk7XG5cdFx0fTtcblxuXHRcdHAuaW5zZXJ0ID0gcC5pbnNlcnRNdWx0aXBsZSA9IGZ1bmN0aW9uKHZhbHVlLCBwb3NpdGlvbiwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh2YWx1ZSwgcG9zaXRpb24gfHwgMCwgYWxpZ24sIHN0YWdnZXIpO1xuXHRcdH07XG5cblx0XHRwLmFwcGVuZE11bHRpcGxlID0gZnVuY3Rpb24odHdlZW5zLCBvZmZzZXRPckxhYmVsLCBhbGlnbiwgc3RhZ2dlcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHR3ZWVucywgdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChudWxsLCBvZmZzZXRPckxhYmVsLCB0cnVlLCB0d2VlbnMpLCBhbGlnbiwgc3RhZ2dlcik7XG5cdFx0fTtcblxuXHRcdHAuYWRkTGFiZWwgPSBmdW5jdGlvbihsYWJlbCwgcG9zaXRpb24pIHtcblx0XHRcdHRoaXMuX2xhYmVsc1tsYWJlbF0gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmFkZFBhdXNlID0gZnVuY3Rpb24ocG9zaXRpb24sIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0XHR2YXIgdCA9IFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLCBfcGF1c2VDYWxsYmFjaywgW1wie3NlbGZ9XCIsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlXSwgdGhpcyk7XG5cdFx0XHR0LmRhdGEgPSBcImlzUGF1c2VcIjsgLy8gd2UgdXNlIHRoaXMgZmxhZyBpbiBUd2VlbkxpdGUncyByZW5kZXIoKSBtZXRob2QgdG8gaWRlbnRpZnkgaXQgYXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBzaG91bGRuJ3QgYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIHZpcnR1YWwgcGxheWhlYWQgaXMgTEVBVklORyB0aGUgZXhhY3QgcG9zaXRpb24gd2hlcmUgdGhlIHBhdXNlIGlzLCBvdGhlcndpc2UgdGltZWxpbmUuYWRkUGF1c2UoMSkucGxheSgxKSB3b3VsZCBlbmQgdXAgcGF1c2VkIG9uIHRoZSB2ZXJ5IG5leHQgdGljay5cblx0XHRcdHJldHVybiB0aGlzLmFkZCh0LCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlTGFiZWwgPSBmdW5jdGlvbihsYWJlbCkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2xhYmVsc1tsYWJlbF07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5nZXRMYWJlbFRpbWUgPSBmdW5jdGlvbihsYWJlbCkge1xuXHRcdFx0cmV0dXJuICh0aGlzLl9sYWJlbHNbbGFiZWxdICE9IG51bGwpID8gdGhpcy5fbGFiZWxzW2xhYmVsXSA6IC0xO1xuXHRcdH07XG5cblx0XHRwLl9wYXJzZVRpbWVPckxhYmVsID0gZnVuY3Rpb24odGltZU9yTGFiZWwsIG9mZnNldE9yTGFiZWwsIGFwcGVuZElmQWJzZW50LCBpZ25vcmUpIHtcblx0XHRcdHZhciBpO1xuXHRcdFx0Ly9pZiB3ZSdyZSBhYm91dCB0byBhZGQgYSB0d2Vlbi90aW1lbGluZSAob3IgYW4gYXJyYXkgb2YgdGhlbSkgdGhhdCdzIGFscmVhZHkgYSBjaGlsZCBvZiB0aGlzIHRpbWVsaW5lLCB3ZSBzaG91bGQgcmVtb3ZlIGl0IGZpcnN0IHNvIHRoYXQgaXQgZG9lc24ndCBjb250YW1pbmF0ZSB0aGUgZHVyYXRpb24oKS5cblx0XHRcdGlmIChpZ25vcmUgaW5zdGFuY2VvZiBBbmltYXRpb24gJiYgaWdub3JlLnRpbWVsaW5lID09PSB0aGlzKSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlKGlnbm9yZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGlnbm9yZSAmJiAoKGlnbm9yZSBpbnN0YW5jZW9mIEFycmF5KSB8fCAoaWdub3JlLnB1c2ggJiYgX2lzQXJyYXkoaWdub3JlKSkpKSB7XG5cdFx0XHRcdGkgPSBpZ25vcmUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoaWdub3JlW2ldIGluc3RhbmNlb2YgQW5pbWF0aW9uICYmIGlnbm9yZVtpXS50aW1lbGluZSA9PT0gdGhpcykge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmUoaWdub3JlW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2Yob2Zmc2V0T3JMYWJlbCkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BhcnNlVGltZU9yTGFiZWwob2Zmc2V0T3JMYWJlbCwgKGFwcGVuZElmQWJzZW50ICYmIHR5cGVvZih0aW1lT3JMYWJlbCkgPT09IFwibnVtYmVyXCIgJiYgdGhpcy5fbGFiZWxzW29mZnNldE9yTGFiZWxdID09IG51bGwpID8gdGltZU9yTGFiZWwgLSB0aGlzLmR1cmF0aW9uKCkgOiAwLCBhcHBlbmRJZkFic2VudCk7XG5cdFx0XHR9XG5cdFx0XHRvZmZzZXRPckxhYmVsID0gb2Zmc2V0T3JMYWJlbCB8fCAwO1xuXHRcdFx0aWYgKHR5cGVvZih0aW1lT3JMYWJlbCkgPT09IFwic3RyaW5nXCIgJiYgKGlzTmFOKHRpbWVPckxhYmVsKSB8fCB0aGlzLl9sYWJlbHNbdGltZU9yTGFiZWxdICE9IG51bGwpKSB7IC8vaWYgdGhlIHN0cmluZyBpcyBhIG51bWJlciBsaWtlIFwiMVwiLCBjaGVjayB0byBzZWUgaWYgdGhlcmUncyBhIGxhYmVsIHdpdGggdGhhdCBuYW1lLCBvdGhlcndpc2UgaW50ZXJwcmV0IGl0IGFzIGEgbnVtYmVyIChhYnNvbHV0ZSB2YWx1ZSkuXG5cdFx0XHRcdGkgPSB0aW1lT3JMYWJlbC5pbmRleE9mKFwiPVwiKTtcblx0XHRcdFx0aWYgKGkgPT09IC0xKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGFwcGVuZElmQWJzZW50ID8gKHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gPSB0aGlzLmR1cmF0aW9uKCkgKyBvZmZzZXRPckxhYmVsKSA6IG9mZnNldE9yTGFiZWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9sYWJlbHNbdGltZU9yTGFiZWxdICsgb2Zmc2V0T3JMYWJlbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRvZmZzZXRPckxhYmVsID0gcGFyc2VJbnQodGltZU9yTGFiZWwuY2hhckF0KGktMSkgKyBcIjFcIiwgMTApICogTnVtYmVyKHRpbWVPckxhYmVsLnN1YnN0cihpKzEpKTtcblx0XHRcdFx0dGltZU9yTGFiZWwgPSAoaSA+IDEpID8gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbCh0aW1lT3JMYWJlbC5zdWJzdHIoMCwgaS0xKSwgMCwgYXBwZW5kSWZBYnNlbnQpIDogdGhpcy5kdXJhdGlvbigpO1xuXHRcdFx0fSBlbHNlIGlmICh0aW1lT3JMYWJlbCA9PSBudWxsKSB7XG5cdFx0XHRcdHRpbWVPckxhYmVsID0gdGhpcy5kdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE51bWJlcih0aW1lT3JMYWJlbCkgKyBvZmZzZXRPckxhYmVsO1xuXHRcdH07XG5cblx0XHRwLnNlZWsgPSBmdW5jdGlvbihwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZSgodHlwZW9mKHBvc2l0aW9uKSA9PT0gXCJudW1iZXJcIikgPyBwb3NpdGlvbiA6IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24pLCAoc3VwcHJlc3NFdmVudHMgIT09IGZhbHNlKSk7XG5cdFx0fTtcblxuXHRcdHAuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2VkKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLmdvdG9BbmRQbGF5ID0gZnVuY3Rpb24ocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wbGF5KHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAuZ290b0FuZFN0b3AgPSBmdW5jdGlvbihwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhdXNlKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdG90YWxEdXIgPSAoIXRoaXMuX2RpcnR5KSA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiB0aGlzLnRvdGFsRHVyYXRpb24oKSxcblx0XHRcdFx0cHJldlRpbWUgPSB0aGlzLl90aW1lLFxuXHRcdFx0XHRwcmV2U3RhcnQgPSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0XHRcdHByZXZUaW1lU2NhbGUgPSB0aGlzLl90aW1lU2NhbGUsXG5cdFx0XHRcdHByZXZQYXVzZWQgPSB0aGlzLl9wYXVzZWQsXG5cdFx0XHRcdHR3ZWVuLCBpc0NvbXBsZXRlLCBuZXh0LCBjYWxsYmFjaywgaW50ZXJuYWxGb3JjZTtcblx0XHRcdGlmICh0aW1lID49IHRvdGFsRHVyKSB7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0b3RhbER1cjtcblx0XHRcdFx0aWYgKCF0aGlzLl9yZXZlcnNlZCkgaWYgKCF0aGlzLl9oYXNQYXVzZWRDaGlsZCgpKSB7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpZiAodGhpcy5fZHVyYXRpb24gPT09IDApIGlmICh0aW1lID09PSAwIHx8IHRoaXMuX3Jhd1ByZXZUaW1lIDwgMCB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0pIGlmICh0aGlzLl9yYXdQcmV2VGltZSAhPT0gdGltZSAmJiB0aGlzLl9maXJzdCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fcmF3UHJldlRpbWUgPiBfdGlueU51bSkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAodGhpcy5fZHVyYXRpb24gfHwgIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lIG9yIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHR0aW1lID0gdG90YWxEdXIgKyAwLjAwMDE7IC8vdG8gYXZvaWQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgLSBzb21ldGltZXMgY2hpbGQgdHdlZW5zL3RpbWVsaW5lcyB3ZXJlIG5vdCBiZWluZyBmdWxseSBjb21wbGV0ZWQgKHRoZWlyIHByb2dyZXNzIG1pZ2h0IGJlIDAuOTk5OTk5OTk5OTk5OTk4IGluc3RlYWQgb2YgMSBiZWNhdXNlIHdoZW4gX3RpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lIGlzIHBlcmZvcm1lZCwgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIHdvdWxkIHJldHVybiBhIHZhbHVlIHRoYXQgd2FzIFNMSUdIVExZIG9mZikuIFRyeSAoOTk5OTk5OTk5OTk5LjcgLSA5OTk5OTk5OTk5OTkpICogMSA9IDAuNjk5OTUxMTcxODc1IGluc3RlYWQgb2YgMC43LlxuXG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPCAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLCByb3VuZCBzdXBlciBzbWFsbCB2YWx1ZXMgdG8gMC5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdGlmIChwcmV2VGltZSAhPT0gMCB8fCAodGhpcy5fZHVyYXRpb24gPT09IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgIT09IF90aW55TnVtICYmICh0aGlzLl9yYXdQcmV2VGltZSA+IDAgfHwgKHRpbWUgPCAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lID49IDApKSkpIHtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiAmJiB0aGlzLl9yZXZlcnNlZCkgeyAvL2Vuc3VyZXMgcHJvcGVyIEdDIGlmIGEgdGltZWxpbmUgaXMgcmVzdW1lZCBhZnRlciBpdCdzIGZpbmlzaGVkIHJldmVyc2luZy5cblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSBpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fcmF3UHJldlRpbWUgPj0gMCAmJiB0aGlzLl9maXJzdCkgeyAvL3doZW4gZ29pbmcgYmFjayBiZXlvbmQgdGhlIHN0YXJ0LCBmb3JjZSBhIHJlbmRlciBzbyB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIHRoYXQgc2l0IGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyByZW5kZXIgdGhlaXIgc3RhcnQgdmFsdWVzIHByb3Blcmx5LiBPdGhlcndpc2UsIGlmIHRoZSBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBsYW5kcyBleGFjdGx5IGF0IHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUsIGFuZCB0aGVuIG1vdmVzIGJhY2t3YXJkcywgdGhlIHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSBiZWdpbm5pbmcgd291bGQgc3RpbGwgYmUgYXQgdGhlaXIgZW5kIHN0YXRlLlxuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9ICh0aGlzLl9kdXJhdGlvbiB8fCAhc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgb3IgdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdFx0aWYgKHRpbWUgPT09IDAgJiYgaXNDb21wbGV0ZSkgeyAvL2lmIHRoZXJlJ3MgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiBhIHRpbWVsaW5lIGFuZCB0aGUgcGxheWhlYWQgbGFuZHMgRVhBQ1RMWSBhdCB0aW1lIDAsIHRoYXQgdHdlZW4gd2lsbCBjb3JyZWN0bHkgcmVuZGVyIGl0cyBlbmQgdmFsdWVzLCBidXQgd2UgbmVlZCB0byBrZWVwIHRoZSB0aW1lbGluZSBhbGl2ZSBmb3Igb25lIG1vcmUgcmVuZGVyIHNvIHRoYXQgdGhlIGJlZ2lubmluZyB2YWx1ZXMgcmVuZGVyIHByb3Blcmx5IGFzIHRoZSBwYXJlbnQncyBwbGF5aGVhZCBrZWVwcyBtb3ZpbmcgYmV5b25kIHRoZSBiZWdpbmluZy4gSW1hZ2luZSBvYmoueCBzdGFydHMgYXQgMCBhbmQgdGhlbiB3ZSBkbyB0bC5zZXQob2JqLCB7eDoxMDB9KS50byhvYmosIDEsIHt4OjIwMH0pIGFuZCB0aGVuIGxhdGVyIHdlIHRsLnJldmVyc2UoKS4uLnRoZSBnb2FsIGlzIHRvIGhhdmUgb2JqLnggcmV2ZXJ0IHRvIDAuIElmIHRoZSBwbGF5aGVhZCBoYXBwZW5zIHRvIGxhbmQgb24gZXhhY3RseSAwLCB3aXRob3V0IHRoaXMgY2h1bmsgb2YgY29kZSwgaXQnZCBjb21wbGV0ZSB0aGUgdGltZWxpbmUgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSByZW5kZXJpbmcgcXVldWUgKG5vdCBnb29kKS5cblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdFx0XHR3aGlsZSAodHdlZW4gJiYgdHdlZW4uX3N0YXJ0VGltZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9kdXJhdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdGlzQ29tcGxldGUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aW1lID0gMDsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyAoY291bGQgY2F1c2UgcHJvYmxlbXMgZXNwZWNpYWxseSB3aXRoIHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiB0aGUgdGltZWxpbmUpXG5cdFx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICgodGhpcy5fdGltZSA9PT0gcHJldlRpbWUgfHwgIXRoaXMuX2ZpcnN0KSAmJiAhZm9yY2UgJiYgIWludGVybmFsRm9yY2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0dGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmUpIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3RpbWUgIT09IHByZXZUaW1lICYmIHRpbWUgPiAwKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7ICAvL3NvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyB0aGUgdGltZWxpbmUgKGFzIG9wcG9zZWQgdG8gdGhlIHBhcmVudCB0aW1lbGluZSByZW5kZXJpbmcgaXQpLCBpdCBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0aW1lbGluZSBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZSwgZm9yIGV4YW1wbGUuXG5cdFx0XHR9XG5cblx0XHRcdGlmIChwcmV2VGltZSA9PT0gMCkgaWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdGltZSAhPT0gMCkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHR0aGlzLnZhcnMub25TdGFydC5hcHBseSh0aGlzLnZhcnMub25TdGFydFNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblN0YXJ0UGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX3RpbWUgPj0gcHJldlRpbWUpIHtcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9uZXh0OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0XHRpZiAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmdcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSB0aGlzLl90aW1lICYmICF0d2Vlbi5fcGF1c2VkICYmICF0d2Vlbi5fZ2MpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRuZXh0ID0gdHdlZW4uX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZ1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0d2Vlbi5fc3RhcnRUaW1lIDw9IHByZXZUaW1lICYmICF0d2Vlbi5fcGF1c2VkICYmICF0d2Vlbi5fZ2MpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uVXBkYXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlLmFwcGx5KHRoaXMudmFycy5vblVwZGF0ZVNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblVwZGF0ZVBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjYWxsYmFjaykgaWYgKCF0aGlzLl9nYykgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnRUaW1lIHx8IHByZXZUaW1lU2NhbGUgIT09IHRoaXMuX3RpbWVTY2FsZSkgaWYgKHRoaXMuX3RpbWUgPT09IDAgfHwgdG90YWxEdXIgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkpIHsgLy9pZiBvbmUgb2YgdGhlIHR3ZWVucyB0aGF0IHdhcyByZW5kZXJlZCBhbHRlcmVkIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgKGxpa2UgaWYgYW4gb25Db21wbGV0ZSByZXZlcnNlZCB0aGUgdGltZWxpbmUpLCBpdCBwcm9iYWJseSBpc24ndCBjb21wbGV0ZS4gSWYgaXQgaXMsIGRvbid0IHdvcnJ5LCBiZWNhdXNlIHdoYXRldmVyIGNhbGwgYWx0ZXJlZCB0aGUgc3RhcnRUaW1lIHdvdWxkIGNvbXBsZXRlIGlmIGl0IHdhcyBuZWNlc3NhcnkgYXQgdGhlIG5ldyB0aW1lLiBUaGUgb25seSBleGNlcHRpb24gaXMgdGhlIHRpbWVTY2FsZSBwcm9wZXJ0eS4gQWxzbyBjaGVjayBfZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvbkNvbXBsZXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy52YXJzW2NhbGxiYWNrXS5hcHBseSh0aGlzLnZhcnNbY2FsbGJhY2sgKyBcIlNjb3BlXCJdIHx8IHRoaXMsIHRoaXMudmFyc1tjYWxsYmFjayArIFwiUGFyYW1zXCJdIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLl9oYXNQYXVzZWRDaGlsZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0aWYgKHR3ZWVuLl9wYXVzZWQgfHwgKCh0d2VlbiBpbnN0YW5jZW9mIFRpbWVsaW5lTGl0ZSkgJiYgdHdlZW4uX2hhc1BhdXNlZENoaWxkKCkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uKG5lc3RlZCwgdHdlZW5zLCB0aW1lbGluZXMsIGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdGlnbm9yZUJlZm9yZVRpbWUgPSBpZ25vcmVCZWZvcmVUaW1lIHx8IC05OTk5OTk5OTk5O1xuXHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdCxcblx0XHRcdFx0Y250ID0gMDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA8IGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdFx0XHQvL2RvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIGlmICh0d2VlbiBpbnN0YW5jZW9mIFR3ZWVuTGl0ZSkge1xuXHRcdFx0XHRcdGlmICh0d2VlbnMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGltZWxpbmVzICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YVtjbnQrK10gPSB0d2Vlbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG5lc3RlZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGEgPSBhLmNvbmNhdCh0d2Vlbi5nZXRDaGlsZHJlbih0cnVlLCB0d2VlbnMsIHRpbWVsaW5lcykpO1xuXHRcdFx0XHRcdFx0Y250ID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cdFx0cC5nZXRUd2VlbnNPZiA9IGZ1bmN0aW9uKHRhcmdldCwgbmVzdGVkKSB7XG5cdFx0XHR2YXIgZGlzYWJsZWQgPSB0aGlzLl9nYyxcblx0XHRcdFx0YSA9IFtdLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHR0d2VlbnMsIGk7XG5cdFx0XHRpZiAoZGlzYWJsZWQpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCB0cnVlKTsgLy9nZXRUd2VlbnNPZigpIGZpbHRlcnMgb3V0IGRpc2FibGVkIHR3ZWVucywgYW5kIHdlIGhhdmUgdG8gbWFyayB0aGVtIGFzIF9nYyA9IHRydWUgd2hlbiB0aGUgdGltZWxpbmUgY29tcGxldGVzIGluIG9yZGVyIHRvIGFsbG93IGNsZWFuIGdhcmJhZ2UgY29sbGVjdGlvbiwgc28gdGVtcG9yYXJpbHkgcmUtZW5hYmxlIHRoZSB0aW1lbGluZSBoZXJlLlxuXHRcdFx0fVxuXHRcdFx0dHdlZW5zID0gVHdlZW5MaXRlLmdldFR3ZWVuc09mKHRhcmdldCk7XG5cdFx0XHRpID0gdHdlZW5zLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAodHdlZW5zW2ldLnRpbWVsaW5lID09PSB0aGlzIHx8IChuZXN0ZWQgJiYgdGhpcy5fY29udGFpbnModHdlZW5zW2ldKSkpIHtcblx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRpc2FibGVkKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXHRcdHAucmVjZW50ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVjZW50O1xuXHRcdH07XG5cblx0XHRwLl9jb250YWlucyA9IGZ1bmN0aW9uKHR3ZWVuKSB7XG5cdFx0XHR2YXIgdGwgPSB0d2Vlbi50aW1lbGluZTtcblx0XHRcdHdoaWxlICh0bCkge1xuXHRcdFx0XHRpZiAodGwgPT09IHRoaXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0bCA9IHRsLnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRwLnNoaWZ0Q2hpbGRyZW4gPSBmdW5jdGlvbihhbW91bnQsIGFkanVzdExhYmVscywgaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0aWdub3JlQmVmb3JlVGltZSA9IGlnbm9yZUJlZm9yZVRpbWUgfHwgMDtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0XHRsYWJlbHMgPSB0aGlzLl9sYWJlbHMsXG5cdFx0XHRcdHA7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPj0gaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0XHRcdHR3ZWVuLl9zdGFydFRpbWUgKz0gYW1vdW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYWRqdXN0TGFiZWxzKSB7XG5cdFx0XHRcdGZvciAocCBpbiBsYWJlbHMpIHtcblx0XHRcdFx0XHRpZiAobGFiZWxzW3BdID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdFx0XHRcdGxhYmVsc1twXSArPSBhbW91bnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0aWYgKCF2YXJzICYmICF0YXJnZXQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHZhciB0d2VlbnMgPSAoIXRhcmdldCkgPyB0aGlzLmdldENoaWxkcmVuKHRydWUsIHRydWUsIGZhbHNlKSA6IHRoaXMuZ2V0VHdlZW5zT2YodGFyZ2V0KSxcblx0XHRcdFx0aSA9IHR3ZWVucy5sZW5ndGgsXG5cdFx0XHRcdGNoYW5nZWQgPSBmYWxzZTtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAodHdlZW5zW2ldLl9raWxsKHZhcnMsIHRhcmdldCkpIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fTtcblxuXHRcdHAuY2xlYXIgPSBmdW5jdGlvbihsYWJlbHMpIHtcblx0XHRcdHZhciB0d2VlbnMgPSB0aGlzLmdldENoaWxkcmVuKGZhbHNlLCB0cnVlLCB0cnVlKSxcblx0XHRcdFx0aSA9IHR3ZWVucy5sZW5ndGg7XG5cdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lID0gMDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHR0d2VlbnNbaV0uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGlmIChsYWJlbHMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX2xhYmVscyA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0dHdlZW4uaW52YWxpZGF0ZSgpO1xuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEFuaW1hdGlvbi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpOztcblx0XHR9O1xuXG5cdFx0cC5fZW5hYmxlZCA9IGZ1bmN0aW9uKGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKSB7XG5cdFx0XHRpZiAoZW5hYmxlZCA9PT0gdGhpcy5fZ2MpIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdHR3ZWVuLl9lbmFibGVkKGVuYWJsZWQsIHRydWUpO1xuXHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUuX2VuYWJsZWQuY2FsbCh0aGlzLCBlbmFibGVkLCBpZ25vcmVUaW1lbGluZSk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxUaW1lID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIHVuY2FwcGVkKSB7XG5cdFx0XHR0aGlzLl9mb3JjaW5nUGxheWhlYWQgPSB0cnVlO1xuXHRcdFx0dmFyIHZhbCA9IEFuaW1hdGlvbi5wcm90b3R5cGUudG90YWxUaW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLl9mb3JjaW5nUGxheWhlYWQgPSBmYWxzZTtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fTtcblxuXHRcdHAuZHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpOyAvL2p1c3QgdHJpZ2dlcnMgcmVjYWxjdWxhdGlvblxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmR1cmF0aW9uKCkgIT09IDAgJiYgdmFsdWUgIT09IDApIHtcblx0XHRcdFx0dGhpcy50aW1lU2NhbGUodGhpcy5fZHVyYXRpb24gLyB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHR2YXIgbWF4ID0gMCxcblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fbGFzdCxcblx0XHRcdFx0XHRcdHByZXZTdGFydCA9IDk5OTk5OTk5OTk5OSxcblx0XHRcdFx0XHRcdHByZXYsIGVuZDtcblx0XHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRcdHByZXYgPSB0d2Vlbi5fcHJldjsgLy9yZWNvcmQgaXQgaGVyZSBpbiBjYXNlIHRoZSB0d2VlbiBjaGFuZ2VzIHBvc2l0aW9uIGluIHRoZSBzZXF1ZW5jZS4uLlxuXHRcdFx0XHRcdFx0aWYgKHR3ZWVuLl9kaXJ0eSkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi50b3RhbER1cmF0aW9uKCk7IC8vY291bGQgY2hhbmdlIHRoZSB0d2Vlbi5fc3RhcnRUaW1lLCBzbyBtYWtlIHN1cmUgdGhlIHR3ZWVuJ3MgY2FjaGUgaXMgY2xlYW4gYmVmb3JlIGFuYWx5emluZyBpdC5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lID4gcHJldlN0YXJ0ICYmIHRoaXMuX3NvcnRDaGlsZHJlbiAmJiAhdHdlZW4uX3BhdXNlZCkgeyAvL2luIGNhc2Ugb25lIG9mIHRoZSB0d2VlbnMgc2hpZnRlZCBvdXQgb2Ygb3JkZXIsIGl0IG5lZWRzIHRvIGJlIHJlLWluc2VydGVkIGludG8gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlXG5cdFx0XHRcdFx0XHRcdHRoaXMuYWRkKHR3ZWVuLCB0d2Vlbi5fc3RhcnRUaW1lIC0gdHdlZW4uX2RlbGF5KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHByZXZTdGFydCA9IHR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA8IDAgJiYgIXR3ZWVuLl9wYXVzZWQpIHsgLy9jaGlsZHJlbiBhcmVuJ3QgYWxsb3dlZCB0byBoYXZlIG5lZ2F0aXZlIHN0YXJ0VGltZXMgdW5sZXNzIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUsIHNvIGFkanVzdCBoZXJlIGlmIG9uZSBpcyBmb3VuZC5cblx0XHRcdFx0XHRcdFx0bWF4IC09IHR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSArPSB0d2Vlbi5fc3RhcnRUaW1lIC8gdGhpcy5fdGltZVNjYWxlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2hpZnRDaGlsZHJlbigtdHdlZW4uX3N0YXJ0VGltZSwgZmFsc2UsIC05OTk5OTk5OTk5KTtcblx0XHRcdFx0XHRcdFx0cHJldlN0YXJ0ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVuZCA9IHR3ZWVuLl9zdGFydFRpbWUgKyAodHdlZW4uX3RvdGFsRHVyYXRpb24gLyB0d2Vlbi5fdGltZVNjYWxlKTtcblx0XHRcdFx0XHRcdGlmIChlbmQgPiBtYXgpIHtcblx0XHRcdFx0XHRcdFx0bWF4ID0gZW5kO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHdlZW4gPSBwcmV2O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24gPSBtYXg7XG5cdFx0XHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxEdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnRvdGFsRHVyYXRpb24oKSAhPT0gMCkgaWYgKHZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHRoaXMudGltZVNjYWxlKHRoaXMuX3RvdGFsRHVyYXRpb24gLyB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5wYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCF2YWx1ZSkgeyAvL2lmIHRoZXJlJ3MgYSBwYXVzZSBkaXJlY3RseSBhdCB0aGUgc3BvdCBmcm9tIHdoZXJlIHdlJ3JlIHVucGF1c2luZywgc2tpcCBpdC5cblx0XHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lID09PSB0aW1lICYmIHR3ZWVuLmRhdGEgPT09IFwiaXNQYXVzZVwiKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5fcmF3UHJldlRpbWUgPSB0aW1lOyAvL3JlbWVtYmVyLCBfcmF3UHJldlRpbWUgaXMgaG93IHplcm8tZHVyYXRpb24gdHdlZW5zL2NhbGxiYWNrcyBzZW5zZSBkaXJlY3Rpb25hbGl0eSBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIGZpcmUuIElmIF9yYXdQcmV2VGltZSBpcyB0aGUgc2FtZSBhcyBfc3RhcnRUaW1lIG9uIHRoZSBuZXh0IHJlbmRlciwgaXQgd29uJ3QgZmlyZS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEFuaW1hdGlvbi5wcm90b3R5cGUucGF1c2VkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudXNlc0ZyYW1lcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRsID0gdGhpcy5fdGltZWxpbmU7XG5cdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0bCA9PT0gQW5pbWF0aW9uLl9yb290RnJhbWVzVGltZWxpbmUpO1xuXHRcdH07XG5cblx0XHRwLnJhd1RpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wYXVzZWQgPyB0aGlzLl90b3RhbFRpbWUgOiAodGhpcy5fdGltZWxpbmUucmF3VGltZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSAqIHRoaXMuX3RpbWVTY2FsZTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIFRpbWVsaW5lTGl0ZTtcblxuXHR9LCB0cnVlKTtcblx0XG5cblxuXG5cblxuXG5cblx0XG5cdFxuXHRcblx0XG5cdFxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRpbWVsaW5lTWF4XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0X2dzU2NvcGUuX2dzRGVmaW5lKFwiVGltZWxpbmVNYXhcIiwgW1wiVGltZWxpbmVMaXRlXCIsXCJUd2VlbkxpdGVcIixcImVhc2luZy5FYXNlXCJdLCBmdW5jdGlvbihUaW1lbGluZUxpdGUsIFR3ZWVuTGl0ZSwgRWFzZSkge1xuXG5cdFx0dmFyIFRpbWVsaW5lTWF4ID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0XHRUaW1lbGluZUxpdGUuY2FsbCh0aGlzLCB2YXJzKTtcblx0XHRcdFx0dGhpcy5fcmVwZWF0ID0gdGhpcy52YXJzLnJlcGVhdCB8fCAwO1xuXHRcdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHRoaXMudmFycy5yZXBlYXREZWxheSB8fCAwO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IDA7XG5cdFx0XHRcdHRoaXMuX3lveW8gPSAodGhpcy52YXJzLnlveW8gPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0X3RpbnlOdW0gPSAwLjAwMDAwMDAwMDEsXG5cdFx0XHRfYmxhbmtBcnJheSA9IFtdLFxuXHRcdFx0VHdlZW5MaXRlSW50ZXJuYWxzID0gVHdlZW5MaXRlLl9pbnRlcm5hbHMsXG5cdFx0XHRfbGF6eVR3ZWVucyA9IFR3ZWVuTGl0ZUludGVybmFscy5sYXp5VHdlZW5zLFxuXHRcdFx0X2xhenlSZW5kZXIgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVJlbmRlcixcblx0XHRcdF9lYXNlTm9uZSA9IG5ldyBFYXNlKG51bGwsIG51bGwsIDEsIDApLFxuXHRcdFx0cCA9IFRpbWVsaW5lTWF4LnByb3RvdHlwZSA9IG5ldyBUaW1lbGluZUxpdGUoKTtcblxuXHRcdHAuY29uc3RydWN0b3IgPSBUaW1lbGluZU1heDtcblx0XHRwLmtpbGwoKS5fZ2MgPSBmYWxzZTtcblx0XHRUaW1lbGluZU1heC52ZXJzaW9uID0gXCIxLjE2LjBcIjtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5feW95byA9ICh0aGlzLnZhcnMueW95byA9PT0gdHJ1ZSk7XG5cdFx0XHR0aGlzLl9yZXBlYXQgPSB0aGlzLnZhcnMucmVwZWF0IHx8IDA7XG5cdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHRoaXMudmFycy5yZXBlYXREZWxheSB8fCAwO1xuXHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdHJldHVybiBUaW1lbGluZUxpdGUucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcblx0XHR9O1xuXG5cdFx0cC5hZGRDYWxsYmFjayA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBwb3NpdGlvbiwgcGFyYW1zLCBzY29wZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKCBUd2VlbkxpdGUuZGVsYXllZENhbGwoMCwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlQ2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaywgcG9zaXRpb24pIHtcblx0XHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0XHRpZiAocG9zaXRpb24gPT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuX2tpbGwobnVsbCwgY2FsbGJhY2spO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBhID0gdGhpcy5nZXRUd2VlbnNPZihjYWxsYmFjaywgZmFsc2UpLFxuXHRcdFx0XHRcdFx0aSA9IGEubGVuZ3RoLFxuXHRcdFx0XHRcdFx0dGltZSA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24pO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKGFbaV0uX3N0YXJ0VGltZSA9PT0gdGltZSkge1xuXHRcdFx0XHRcdFx0XHRhW2ldLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5yZW1vdmVQYXVzZSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVDYWxsYmFjayhUaW1lbGluZUxpdGUuX2ludGVybmFscy5wYXVzZUNhbGxiYWNrLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAudHdlZW5UbyA9IGZ1bmN0aW9uKHBvc2l0aW9uLCB2YXJzKSB7XG5cdFx0XHR2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdHZhciBjb3B5ID0ge2Vhc2U6X2Vhc2VOb25lLCB1c2VGcmFtZXM6dGhpcy51c2VzRnJhbWVzKCksIGltbWVkaWF0ZVJlbmRlcjpmYWxzZX0sXG5cdFx0XHRcdGR1cmF0aW9uLCBwLCB0O1xuXHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0Y29weVtwXSA9IHZhcnNbcF07XG5cdFx0XHR9XG5cdFx0XHRjb3B5LnRpbWUgPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKTtcblx0XHRcdGR1cmF0aW9uID0gKE1hdGguYWJzKE51bWJlcihjb3B5LnRpbWUpIC0gdGhpcy5fdGltZSkgLyB0aGlzLl90aW1lU2NhbGUpIHx8IDAuMDAxO1xuXHRcdFx0dCA9IG5ldyBUd2VlbkxpdGUodGhpcywgZHVyYXRpb24sIGNvcHkpO1xuXHRcdFx0Y29weS5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHQudGFyZ2V0LnBhdXNlZCh0cnVlKTtcblx0XHRcdFx0aWYgKHQudmFycy50aW1lICE9PSB0LnRhcmdldC50aW1lKCkgJiYgZHVyYXRpb24gPT09IHQuZHVyYXRpb24oKSkgeyAvL2Rvbid0IG1ha2UgdGhlIGR1cmF0aW9uIHplcm8gLSBpZiBpdCdzIHN1cHBvc2VkIHRvIGJlIHplcm8sIGRvbid0IHdvcnJ5IGJlY2F1c2UgaXQncyBhbHJlYWR5IGluaXR0aW5nIHRoZSB0d2VlbiBhbmQgd2lsbCBjb21wbGV0ZSBpbW1lZGlhdGVseSwgZWZmZWN0aXZlbHkgbWFraW5nIHRoZSBkdXJhdGlvbiB6ZXJvIGFueXdheS4gSWYgd2UgbWFrZSBkdXJhdGlvbiB6ZXJvLCB0aGUgdHdlZW4gd29uJ3QgcnVuIGF0IGFsbC5cblx0XHRcdFx0XHR0LmR1cmF0aW9uKCBNYXRoLmFicyggdC52YXJzLnRpbWUgLSB0LnRhcmdldC50aW1lKCkpIC8gdC50YXJnZXQuX3RpbWVTY2FsZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2YXJzLm9uU3RhcnQpIHsgLy9pbiBjYXNlIHRoZSB1c2VyIGhhZCBhbiBvblN0YXJ0IGluIHRoZSB2YXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgaXQuXG5cdFx0XHRcdFx0dmFycy5vblN0YXJ0LmFwcGx5KHZhcnMub25TdGFydFNjb3BlIHx8IHQsIHZhcnMub25TdGFydFBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdDtcblx0XHR9O1xuXG5cdFx0cC50d2VlbkZyb21UbyA9IGZ1bmN0aW9uKGZyb21Qb3NpdGlvbiwgdG9Qb3NpdGlvbiwgdmFycykge1xuXHRcdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0XHRmcm9tUG9zaXRpb24gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKGZyb21Qb3NpdGlvbik7XG5cdFx0XHR2YXJzLnN0YXJ0QXQgPSB7b25Db21wbGV0ZTp0aGlzLnNlZWssIG9uQ29tcGxldGVQYXJhbXM6W2Zyb21Qb3NpdGlvbl0sIG9uQ29tcGxldGVTY29wZTp0aGlzfTtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSk7XG5cdFx0XHR2YXIgdCA9IHRoaXMudHdlZW5Ubyh0b1Bvc2l0aW9uLCB2YXJzKTtcblx0XHRcdHJldHVybiB0LmR1cmF0aW9uKChNYXRoLmFicyggdC52YXJzLnRpbWUgLSBmcm9tUG9zaXRpb24pIC8gdGhpcy5fdGltZVNjYWxlKSB8fCAwLjAwMSk7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdG90YWxEdXIgPSAoIXRoaXMuX2RpcnR5KSA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiB0aGlzLnRvdGFsRHVyYXRpb24oKSxcblx0XHRcdFx0ZHVyID0gdGhpcy5fZHVyYXRpb24sXG5cdFx0XHRcdHByZXZUaW1lID0gdGhpcy5fdGltZSxcblx0XHRcdFx0cHJldlRvdGFsVGltZSA9IHRoaXMuX3RvdGFsVGltZSxcblx0XHRcdFx0cHJldlN0YXJ0ID0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdFx0XHRwcmV2VGltZVNjYWxlID0gdGhpcy5fdGltZVNjYWxlLFxuXHRcdFx0XHRwcmV2UmF3UHJldlRpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSxcblx0XHRcdFx0cHJldlBhdXNlZCA9IHRoaXMuX3BhdXNlZCxcblx0XHRcdFx0cHJldkN5Y2xlID0gdGhpcy5fY3ljbGUsXG5cdFx0XHRcdHR3ZWVuLCBpc0NvbXBsZXRlLCBuZXh0LCBjYWxsYmFjaywgaW50ZXJuYWxGb3JjZSwgY3ljbGVEdXJhdGlvbjtcblx0XHRcdGlmICh0aW1lID49IHRvdGFsRHVyKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fbG9ja2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdG90YWxEdXI7XG5cdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSB0aGlzLl9yZXBlYXQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLl9yZXZlcnNlZCkgaWYgKCF0aGlzLl9oYXNQYXVzZWRDaGlsZCgpKSB7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpZiAodGhpcy5fZHVyYXRpb24gPT09IDApIGlmICh0aW1lID09PSAwIHx8IHByZXZSYXdQcmV2VGltZSA8IDAgfHwgcHJldlJhd1ByZXZUaW1lID09PSBfdGlueU51bSkgaWYgKHByZXZSYXdQcmV2VGltZSAhPT0gdGltZSAmJiB0aGlzLl9maXJzdCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID4gX3RpbnlOdW0pIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKHRoaXMuX2R1cmF0aW9uIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0aWYgKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGltZSA9IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1cjtcblx0XHRcdFx0XHR0aW1lID0gZHVyICsgMC4wMDAxOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIC0gc29tZXRpbWVzIGNoaWxkIHR3ZWVucy90aW1lbGluZXMgd2VyZSBub3QgYmVpbmcgZnVsbHkgY29tcGxldGVkICh0aGVpciBwcm9ncmVzcyBtaWdodCBiZSAwLjk5OTk5OTk5OTk5OTk5OCBpbnN0ZWFkIG9mIDEgYmVjYXVzZSB3aGVuIF90aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSBpcyBwZXJmb3JtZWQsIGZsb2F0aW5nIHBvaW50IGVycm9ycyB3b3VsZCByZXR1cm4gYSB2YWx1ZSB0aGF0IHdhcyBTTElHSFRMWSBvZmYpLiBUcnkgKDk5OTk5OTk5OTk5OS43IC0gOTk5OTk5OTk5OTk5KSAqIDEgPSAwLjY5OTk1MTE3MTg3NSBpbnN0ZWFkIG9mIDAuNy4gV2UgY2Fubm90IGRvIGxlc3MgdGhlbiAwLjAwMDEgYmVjYXVzZSB0aGUgc2FtZSBpc3N1ZSBjYW4gb2NjdXIgd2hlbiB0aGUgZHVyYXRpb24gaXMgZXh0cmVtZWx5IGxhcmdlIGxpa2UgOTk5OTk5OTk5OTk5IGluIHdoaWNoIGNhc2UgYWRkaW5nIDAuMDAwMDAwMDEsIGZvciBleGFtcGxlLCBjYXVzZXMgaXQgdG8gYWN0IGxpa2Ugbm90aGluZyB3YXMgYWRkZWQuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdGlmICghdGhpcy5fbG9ja2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fY3ljbGUgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IDAgfHwgKGR1ciA9PT0gMCAmJiBwcmV2UmF3UHJldlRpbWUgIT09IF90aW55TnVtICYmIChwcmV2UmF3UHJldlRpbWUgPiAwIHx8ICh0aW1lIDwgMCAmJiBwcmV2UmF3UHJldlRpbWUgPj0gMCkpICYmICF0aGlzLl9sb2NrZWQpKSB7IC8vZWRnZSBjYXNlIGZvciBjaGVja2luZyB0aW1lIDwgMCAmJiBwcmV2UmF3UHJldlRpbWUgPj0gMDogYSB6ZXJvLWR1cmF0aW9uIGZyb21UbygpIHR3ZWVuIGluc2lkZSBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgKHllYWgsIHZlcnkgcmFyZSlcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiAmJiB0aGlzLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwcmV2UmF3UHJldlRpbWUgPj0gMCAmJiB0aGlzLl9maXJzdCkgeyAvL3doZW4gZ29pbmcgYmFjayBiZXlvbmQgdGhlIHN0YXJ0LCBmb3JjZSBhIHJlbmRlciBzbyB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIHRoYXQgc2l0IGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyByZW5kZXIgdGhlaXIgc3RhcnQgdmFsdWVzIHByb3Blcmx5LiBPdGhlcndpc2UsIGlmIHRoZSBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBsYW5kcyBleGFjdGx5IGF0IHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUsIGFuZCB0aGVuIG1vdmVzIGJhY2t3YXJkcywgdGhlIHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSBiZWdpbm5pbmcgd291bGQgc3RpbGwgYmUgYXQgdGhlaXIgZW5kIHN0YXRlLlxuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IChkdXIgfHwgIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lIG9yIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHRcdGlmICh0aW1lID09PSAwICYmIGlzQ29tcGxldGUpIHsgLy9pZiB0aGVyZSdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgYSB0aW1lbGluZSBhbmQgdGhlIHBsYXloZWFkIGxhbmRzIEVYQUNUTFkgYXQgdGltZSAwLCB0aGF0IHR3ZWVuIHdpbGwgY29ycmVjdGx5IHJlbmRlciBpdHMgZW5kIHZhbHVlcywgYnV0IHdlIG5lZWQgdG8ga2VlcCB0aGUgdGltZWxpbmUgYWxpdmUgZm9yIG9uZSBtb3JlIHJlbmRlciBzbyB0aGF0IHRoZSBiZWdpbm5pbmcgdmFsdWVzIHJlbmRlciBwcm9wZXJseSBhcyB0aGUgcGFyZW50J3MgcGxheWhlYWQga2VlcHMgbW92aW5nIGJleW9uZCB0aGUgYmVnaW5pbmcuIEltYWdpbmUgb2JqLnggc3RhcnRzIGF0IDAgYW5kIHRoZW4gd2UgZG8gdGwuc2V0KG9iaiwge3g6MTAwfSkudG8ob2JqLCAxLCB7eDoyMDB9KSBhbmQgdGhlbiBsYXRlciB3ZSB0bC5yZXZlcnNlKCkuLi50aGUgZ29hbCBpcyB0byBoYXZlIG9iai54IHJldmVydCB0byAwLiBJZiB0aGUgcGxheWhlYWQgaGFwcGVucyB0byBsYW5kIG9uIGV4YWN0bHkgMCwgd2l0aG91dCB0aGlzIGNodW5rIG9mIGNvZGUsIGl0J2QgY29tcGxldGUgdGhlIHRpbWVsaW5lIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcmVuZGVyaW5nIHF1ZXVlIChub3QgZ29vZCkuXG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHR3ZWVuICYmIHR3ZWVuLl9zdGFydFRpbWUgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRpc0NvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGltZSA9IDA7IC8vdG8gYXZvaWQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgKGNvdWxkIGNhdXNlIHByb2JsZW1zIGVzcGVjaWFsbHkgd2l0aCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lKVxuXHRcdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChkdXIgPT09IDAgJiYgcHJldlJhd1ByZXZUaW1lIDwgMCkgeyAvL3dpdGhvdXQgdGhpcywgemVyby1kdXJhdGlvbiByZXBlYXRpbmcgdGltZWxpbmVzIChsaWtlIHdpdGggYSBzaW1wbGUgY2FsbGJhY2sgbmVzdGVkIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBhbmQgYSByZXBlYXREZWxheSkgd291bGRuJ3QgcmVuZGVyIHRoZSBmaXJzdCB0aW1lIHRocm91Z2guXG5cdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdFx0aWYgKCF0aGlzLl9sb2NrZWQpIHtcblx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aW1lO1xuXHRcdFx0XHRcdGlmICh0aGlzLl9yZXBlYXQgIT09IDApIHtcblx0XHRcdFx0XHRcdGN5Y2xlRHVyYXRpb24gPSBkdXIgKyB0aGlzLl9yZXBlYXREZWxheTtcblx0XHRcdFx0XHRcdHRoaXMuX2N5Y2xlID0gKHRoaXMuX3RvdGFsVGltZSAvIGN5Y2xlRHVyYXRpb24pID4+IDA7IC8vb3JpZ2luYWxseSBfdG90YWxUaW1lICUgY3ljbGVEdXJhdGlvbiBidXQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIGNhdXNlZCBwcm9ibGVtcywgc28gSSBub3JtYWxpemVkIGl0LiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgaXQgZ2V0cyByZXBvcnRlZCBhcyAwLjc5OTk5OTk5ISlcblx0XHRcdFx0XHRcdGlmICh0aGlzLl9jeWNsZSAhPT0gMCkgaWYgKHRoaXMuX2N5Y2xlID09PSB0aGlzLl90b3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2N5Y2xlLS07IC8vb3RoZXJ3aXNlIHdoZW4gcmVuZGVyZWQgZXhhY3RseSBhdCB0aGUgZW5kIHRpbWUsIGl0IHdpbGwgYWN0IGFzIHRob3VnaCBpdCBpcyByZXBlYXRpbmcgKGF0IHRoZSBiZWdpbm5pbmcpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lIC0gKHRoaXMuX2N5Y2xlICogY3ljbGVEdXJhdGlvbik7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5feW95bykgaWYgKCh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXIgLSB0aGlzLl90aW1lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgPiBkdXIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1cjtcblx0XHRcdFx0XHRcdFx0dGltZSA9IGR1ciArIDAuMDAwMTsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9yXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aW1lID0gMDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IHByZXZDeWNsZSkgaWYgKCF0aGlzLl9sb2NrZWQpIHtcblx0XHRcdFx0Lypcblx0XHRcdFx0bWFrZSBzdXJlIGNoaWxkcmVuIGF0IHRoZSBlbmQvYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSBhcmUgcmVuZGVyZWQgcHJvcGVybHkuIElmLCBmb3IgZXhhbXBsZSxcblx0XHRcdFx0YSAzLXNlY29uZCBsb25nIHRpbWVsaW5lIHJlbmRlcmVkIGF0IDIuOSBzZWNvbmRzIHByZXZpb3VzbHksIGFuZCBub3cgcmVuZGVycyBhdCAzLjIgc2Vjb25kcyAod2hpY2hcblx0XHRcdFx0d291bGQgZ2V0IHRyYW5zYXRlZCB0byAyLjggc2Vjb25kcyBpZiB0aGUgdGltZWxpbmUgeW95b3Mgb3IgMC4yIHNlY29uZHMgaWYgaXQganVzdCByZXBlYXRzKSwgdGhlcmVcblx0XHRcdFx0Y291bGQgYmUgYSBjYWxsYmFjayBvciBhIHNob3J0IHR3ZWVuIHRoYXQncyBhdCAyLjk1IG9yIDMgc2Vjb25kcyBpbiB3aGljaCB3b3VsZG4ndCByZW5kZXIuIFNvXG5cdFx0XHRcdHdlIG5lZWQgdG8gcHVzaCB0aGUgdGltZWxpbmUgdG8gdGhlIGVuZCAoYW5kL29yIGJlZ2lubmluZyBkZXBlbmRpbmcgb24gaXRzIHlveW8gdmFsdWUpLiBBbHNvIHdlIG11c3Rcblx0XHRcdFx0ZW5zdXJlIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgVGltZWxpbmVNYXggd29yay5cblx0XHRcdFx0Ki9cblx0XHRcdFx0dmFyIGJhY2t3YXJkcyA9ICh0aGlzLl95b3lvICYmIChwcmV2Q3ljbGUgJiAxKSAhPT0gMCksXG5cdFx0XHRcdFx0d3JhcCA9IChiYWNrd2FyZHMgPT09ICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSksXG5cdFx0XHRcdFx0cmVjVG90YWxUaW1lID0gdGhpcy5fdG90YWxUaW1lLFxuXHRcdFx0XHRcdHJlY0N5Y2xlID0gdGhpcy5fY3ljbGUsXG5cdFx0XHRcdFx0cmVjUmF3UHJldlRpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSxcblx0XHRcdFx0XHRyZWNUaW1lID0gdGhpcy5fdGltZTtcblxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSBwcmV2Q3ljbGUgKiBkdXI7XG5cdFx0XHRcdGlmICh0aGlzLl9jeWNsZSA8IHByZXZDeWNsZSkge1xuXHRcdFx0XHRcdGJhY2t3YXJkcyA9ICFiYWNrd2FyZHM7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lICs9IGR1cjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl90aW1lID0gcHJldlRpbWU7IC8vdGVtcG9yYXJpbHkgcmV2ZXJ0IF90aW1lIHNvIHRoYXQgcmVuZGVyKCkgcmVuZGVycyB0aGUgY2hpbGRyZW4gaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIFdpdGhvdXQgdGhpcywgdHdlZW5zIHdvbid0IHJld2luZCBjb3JyZWN0bHkuIFdlIGNvdWxkIGFyaGljdGVjdCB0aGluZ3MgaW4gYSBcImNsZWFuZXJcIiB3YXkgYnkgc3BsaXR0aW5nIG91dCB0aGUgcmVuZGVyaW5nIHF1ZXVlIGludG8gYSBzZXBhcmF0ZSBtZXRob2QgYnV0IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBrZXB0IGl0IGFsbCBpbnNpZGUgdGhpcyBtZXRob2QuXG5cblx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAoZHVyID09PSAwKSA/IHByZXZSYXdQcmV2VGltZSAtIDAuMDAwMSA6IHByZXZSYXdQcmV2VGltZTtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSBwcmV2Q3ljbGU7XG5cdFx0XHRcdHRoaXMuX2xvY2tlZCA9IHRydWU7IC8vcHJldmVudHMgY2hhbmdlcyB0byB0b3RhbFRpbWUgYW5kIHNraXBzIHJlcGVhdC95b3lvIGJlaGF2aW9yIHdoZW4gd2UgcmVjdXJzaXZlbHkgY2FsbCByZW5kZXIoKVxuXHRcdFx0XHRwcmV2VGltZSA9IChiYWNrd2FyZHMpID8gMCA6IGR1cjtcblx0XHRcdFx0dGhpcy5yZW5kZXIocHJldlRpbWUsIHN1cHByZXNzRXZlbnRzLCAoZHVyID09PSAwKSk7XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMpIGlmICghdGhpcy5fZ2MpIHtcblx0XHRcdFx0XHRpZiAodGhpcy52YXJzLm9uUmVwZWF0KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnZhcnMub25SZXBlYXQuYXBwbHkodGhpcy52YXJzLm9uUmVwZWF0U2NvcGUgfHwgdGhpcywgdGhpcy52YXJzLm9uUmVwZWF0UGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHdyYXApIHtcblx0XHRcdFx0XHRwcmV2VGltZSA9IChiYWNrd2FyZHMpID8gZHVyICsgMC4wMDAxIDogLTAuMDAwMTtcblx0XHRcdFx0XHR0aGlzLnJlbmRlcihwcmV2VGltZSwgdHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2xvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRpZiAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSB7IC8vaWYgdGhlIHJlbmRlcigpIHRyaWdnZXJlZCBjYWxsYmFjayB0aGF0IHBhdXNlZCB0aGlzIHRpbWVsaW5lLCB3ZSBzaG91bGQgYWJvcnQgKHZlcnkgcmFyZSwgYnV0IHBvc3NpYmxlKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl90aW1lID0gcmVjVGltZTtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gcmVjVG90YWxUaW1lO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IHJlY0N5Y2xlO1xuXHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJlY1Jhd1ByZXZUaW1lO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoKHRoaXMuX3RpbWUgPT09IHByZXZUaW1lIHx8ICF0aGlzLl9maXJzdCkgJiYgIWZvcmNlICYmICFpbnRlcm5hbEZvcmNlKSB7XG5cdFx0XHRcdGlmIChwcmV2VG90YWxUaW1lICE9PSB0aGlzLl90b3RhbFRpbWUpIGlmICh0aGlzLl9vblVwZGF0ZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykgeyAvL3NvIHRoYXQgb25VcGRhdGUgZmlyZXMgZXZlbiBkdXJpbmcgdGhlIHJlcGVhdERlbGF5IC0gYXMgbG9uZyBhcyB0aGUgdG90YWxUaW1lIGNoYW5nZWQsIHdlIHNob3VsZCB0cmlnZ2VyIG9uVXBkYXRlLlxuXHRcdFx0XHRcdHRoaXMuX29uVXBkYXRlLmFwcGx5KHRoaXMudmFycy5vblVwZGF0ZVNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblVwZGF0ZVBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0dGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmUpIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3RvdGFsVGltZSAhPT0gcHJldlRvdGFsVGltZSAmJiB0aW1lID4gMCkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlOyAgLy9zbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgdGhlIHRpbWVsaW5lIChhcyBvcHBvc2VkIHRvIHRoZSBwYXJlbnQgdGltZWxpbmUgcmVuZGVyaW5nIGl0KSwgaXQgaXMgZm9yY2VkIHRvIHJlLXJlbmRlciBhbmQgYWxpZ24gaXQgd2l0aCB0aGUgcHJvcGVyIHRpbWUvZnJhbWUgb24gdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlLiBNYXliZSB0aGUgdGltZWxpbmUgYWxyZWFkeSBmaW5pc2hlZCBidXQgdGhlIHVzZXIgbWFudWFsbHkgcmUtcmVuZGVycyBpdCBhcyBoYWxmd2F5IGRvbmUsIGZvciBleGFtcGxlLlxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJldlRvdGFsVGltZSA9PT0gMCkgaWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdG90YWxUaW1lICE9PSAwKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdHRoaXMudmFycy5vblN0YXJ0LmFwcGx5KHRoaXMudmFycy5vblN0YXJ0U2NvcGUgfHwgdGhpcywgdGhpcy52YXJzLm9uU3RhcnRQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdGltZSA+PSBwcmV2VGltZSkge1xuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRuZXh0ID0gdHdlZW4uX25leHQ7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZ1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0d2Vlbi5fc3RhcnRUaW1lIDw9IHRoaXMuX3RpbWUgJiYgIXR3ZWVuLl9wYXVzZWQgJiYgIXR3ZWVuLl9nYykpIHtcblx0XHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0XHRpZiAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmdcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSBwcmV2VGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCgoIXR3ZWVuLl9kaXJ0eSkgPyB0d2Vlbi5fdG90YWxEdXJhdGlvbiA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSkgLSAoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX29uVXBkYXRlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9vblVwZGF0ZS5hcHBseSh0aGlzLnZhcnMub25VcGRhdGVTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25VcGRhdGVQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNhbGxiYWNrKSBpZiAoIXRoaXMuX2xvY2tlZCkgaWYgKCF0aGlzLl9nYykgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnRUaW1lIHx8IHByZXZUaW1lU2NhbGUgIT09IHRoaXMuX3RpbWVTY2FsZSkgaWYgKHRoaXMuX3RpbWUgPT09IDAgfHwgdG90YWxEdXIgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkpIHsgLy9pZiBvbmUgb2YgdGhlIHR3ZWVucyB0aGF0IHdhcyByZW5kZXJlZCBhbHRlcmVkIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgKGxpa2UgaWYgYW4gb25Db21wbGV0ZSByZXZlcnNlZCB0aGUgdGltZWxpbmUpLCBpdCBwcm9iYWJseSBpc24ndCBjb21wbGV0ZS4gSWYgaXQgaXMsIGRvbid0IHdvcnJ5LCBiZWNhdXNlIHdoYXRldmVyIGNhbGwgYWx0ZXJlZCB0aGUgc3RhcnRUaW1lIHdvdWxkIGNvbXBsZXRlIGlmIGl0IHdhcyBuZWNlc3NhcnkgYXQgdGhlIG5ldyB0aW1lLiBUaGUgb25seSBleGNlcHRpb24gaXMgdGhlIHRpbWVTY2FsZSBwcm9wZXJ0eS4gQWxzbyBjaGVjayBfZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvbkNvbXBsZXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy52YXJzW2NhbGxiYWNrXS5hcHBseSh0aGlzLnZhcnNbY2FsbGJhY2sgKyBcIlNjb3BlXCJdIHx8IHRoaXMsIHRoaXMudmFyc1tjYWxsYmFjayArIFwiUGFyYW1zXCJdIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLmdldEFjdGl2ZSA9IGZ1bmN0aW9uKG5lc3RlZCwgdHdlZW5zLCB0aW1lbGluZXMpIHtcblx0XHRcdGlmIChuZXN0ZWQgPT0gbnVsbCkge1xuXHRcdFx0XHRuZXN0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR3ZWVucyA9PSBudWxsKSB7XG5cdFx0XHRcdHR3ZWVucyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGltZWxpbmVzID09IG51bGwpIHtcblx0XHRcdFx0dGltZWxpbmVzID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRhbGwgPSB0aGlzLmdldENoaWxkcmVuKG5lc3RlZCwgdHdlZW5zLCB0aW1lbGluZXMpLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRsID0gYWxsLmxlbmd0aCxcblx0XHRcdFx0aSwgdHdlZW47XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHR3ZWVuID0gYWxsW2ldO1xuXHRcdFx0XHRpZiAodHdlZW4uaXNBY3RpdmUoKSkge1xuXHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblxuXHRcdHAuZ2V0TGFiZWxBZnRlciA9IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRcdGlmICghdGltZSkgaWYgKHRpbWUgIT09IDApIHsgLy9mYXN0ZXIgdGhhbiBpc05hbigpXG5cdFx0XHRcdHRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzQXJyYXkoKSxcblx0XHRcdFx0bCA9IGxhYmVscy5sZW5ndGgsXG5cdFx0XHRcdGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0udGltZSA+IHRpbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbGFiZWxzW2ldLm5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cblx0XHRwLmdldExhYmVsQmVmb3JlID0gZnVuY3Rpb24odGltZSkge1xuXHRcdFx0aWYgKHRpbWUgPT0gbnVsbCkge1xuXHRcdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVsc0FycmF5KCksXG5cdFx0XHRcdGkgPSBsYWJlbHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0udGltZSA8IHRpbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbGFiZWxzW2ldLm5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cblx0XHRwLmdldExhYmVsc0FycmF5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRwO1xuXHRcdFx0Zm9yIChwIGluIHRoaXMuX2xhYmVscykge1xuXHRcdFx0XHRhW2NudCsrXSA9IHt0aW1lOnRoaXMuX2xhYmVsc1twXSwgbmFtZTpwfTtcblx0XHRcdH1cblx0XHRcdGEuc29ydChmdW5jdGlvbihhLGIpIHtcblx0XHRcdFx0cmV0dXJuIGEudGltZSAtIGIudGltZTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXG4vLy0tLS0gR0VUVEVSUyAvIFNFVFRFUlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5wcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90aW1lIC8gdGhpcy5kdXJhdGlvbigpIDogdGhpcy50b3RhbFRpbWUoIHRoaXMuZHVyYXRpb24oKSAqICgodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90b3RhbFRpbWUgLyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKCB0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0VGltZWxpbmVMaXRlLnByb3RvdHlwZS50b3RhbER1cmF0aW9uLmNhbGwodGhpcyk7IC8vanVzdCBmb3JjZXMgcmVmcmVzaFxuXHRcdFx0XHRcdC8vSW5zdGVhZCBvZiBJbmZpbml0eSwgd2UgdXNlIDk5OTk5OTk5OTk5OSBzbyB0aGF0IHdlIGNhbiBhY2NvbW1vZGF0ZSByZXZlcnNlcy5cblx0XHRcdFx0XHR0aGlzLl90b3RhbER1cmF0aW9uID0gKHRoaXMuX3JlcGVhdCA9PT0gLTEpID8gOTk5OTk5OTk5OTk5IDogdGhpcy5fZHVyYXRpb24gKiAodGhpcy5fcmVwZWF0ICsgMSkgKyAodGhpcy5fcmVwZWF0RGVsYXkgKiB0aGlzLl9yZXBlYXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0aGlzLl9yZXBlYXQgPT09IC0xKSA/IHRoaXMgOiB0aGlzLmR1cmF0aW9uKCAodmFsdWUgLSAodGhpcy5fcmVwZWF0ICogdGhpcy5fcmVwZWF0RGVsYXkpKSAvICh0aGlzLl9yZXBlYXQgKyAxKSApO1xuXHRcdH07XG5cblx0XHRwLnRpbWUgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSA+IHRoaXMuX2R1cmF0aW9uKSB7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5fZHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkge1xuXHRcdFx0XHR2YWx1ZSA9ICh0aGlzLl9kdXJhdGlvbiAtIHZhbHVlKSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3JlcGVhdCAhPT0gMCkge1xuXHRcdFx0XHR2YWx1ZSArPSB0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZSh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnJlcGVhdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcGVhdDtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdCA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAucmVwZWF0RGVsYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXBlYXREZWxheTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC55b3lvID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5feW95bztcblx0XHRcdH1cblx0XHRcdHRoaXMuX3lveW8gPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmN1cnJlbnRMYWJlbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxCZWZvcmUodGhpcy5fdGltZSArIDAuMDAwMDAwMDEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuc2Vlayh2YWx1ZSwgdHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHJldHVybiBUaW1lbGluZU1heDtcblxuXHR9LCB0cnVlKTtcblx0XG5cblxuXG5cblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQmV6aWVyUGx1Z2luXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0KGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcblx0XHRcdF9yMSA9IFtdLFxuXHRcdFx0X3IyID0gW10sXG5cdFx0XHRfcjMgPSBbXSxcblx0XHRcdF9jb3JQcm9wcyA9IHt9LFxuXHRcdFx0X2dsb2JhbHMgPSBfZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxcblx0XHRcdFNlZ21lbnQgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG5cdFx0XHRcdHRoaXMuYSA9IGE7XG5cdFx0XHRcdHRoaXMuYiA9IGI7XG5cdFx0XHRcdHRoaXMuYyA9IGM7XG5cdFx0XHRcdHRoaXMuZCA9IGQ7XG5cdFx0XHRcdHRoaXMuZGEgPSBkIC0gYTtcblx0XHRcdFx0dGhpcy5jYSA9IGMgLSBhO1xuXHRcdFx0XHR0aGlzLmJhID0gYiAtIGE7XG5cdFx0XHR9LFxuXHRcdFx0X2NvcnJlbGF0ZSA9IFwiLHgseSx6LGxlZnQsdG9wLHJpZ2h0LGJvdHRvbSxtYXJnaW5Ub3AsbWFyZ2luTGVmdCxtYXJnaW5SaWdodCxtYXJnaW5Cb3R0b20scGFkZGluZ0xlZnQscGFkZGluZ1RvcCxwYWRkaW5nUmlnaHQscGFkZGluZ0JvdHRvbSxiYWNrZ3JvdW5kUG9zaXRpb24sYmFja2dyb3VuZFBvc2l0aW9uX3ksXCIsXG5cdFx0XHRjdWJpY1RvUXVhZHJhdGljID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuXHRcdFx0XHR2YXIgcTEgPSB7YTphfSxcblx0XHRcdFx0XHRxMiA9IHt9LFxuXHRcdFx0XHRcdHEzID0ge30sXG5cdFx0XHRcdFx0cTQgPSB7YzpkfSxcblx0XHRcdFx0XHRtYWIgPSAoYSArIGIpIC8gMixcblx0XHRcdFx0XHRtYmMgPSAoYiArIGMpIC8gMixcblx0XHRcdFx0XHRtY2QgPSAoYyArIGQpIC8gMixcblx0XHRcdFx0XHRtYWJjID0gKG1hYiArIG1iYykgLyAyLFxuXHRcdFx0XHRcdG1iY2QgPSAobWJjICsgbWNkKSAvIDIsXG5cdFx0XHRcdFx0bTggPSAobWJjZCAtIG1hYmMpIC8gODtcblx0XHRcdFx0cTEuYiA9IG1hYiArIChhIC0gbWFiKSAvIDQ7XG5cdFx0XHRcdHEyLmIgPSBtYWJjICsgbTg7XG5cdFx0XHRcdHExLmMgPSBxMi5hID0gKHExLmIgKyBxMi5iKSAvIDI7XG5cdFx0XHRcdHEyLmMgPSBxMy5hID0gKG1hYmMgKyBtYmNkKSAvIDI7XG5cdFx0XHRcdHEzLmIgPSBtYmNkIC0gbTg7XG5cdFx0XHRcdHE0LmIgPSBtY2QgKyAoZCAtIG1jZCkgLyA0O1xuXHRcdFx0XHRxMy5jID0gcTQuYSA9IChxMy5iICsgcTQuYikgLyAyO1xuXHRcdFx0XHRyZXR1cm4gW3ExLCBxMiwgcTMsIHE0XTtcblx0XHRcdH0sXG5cdFx0XHRfY2FsY3VsYXRlQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKGEsIGN1cnZpbmVzcywgcXVhZCwgYmFzaWMsIGNvcnJlbGF0ZSkge1xuXHRcdFx0XHR2YXIgbCA9IGEubGVuZ3RoIC0gMSxcblx0XHRcdFx0XHRpaSA9IDAsXG5cdFx0XHRcdFx0Y3AxID0gYVswXS5hLFxuXHRcdFx0XHRcdGksIHAxLCBwMiwgcDMsIHNlZywgbTEsIG0yLCBtbSwgY3AyLCBxYiwgcjEsIHIyLCB0bDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHNlZyA9IGFbaWldO1xuXHRcdFx0XHRcdHAxID0gc2VnLmE7XG5cdFx0XHRcdFx0cDIgPSBzZWcuZDtcblx0XHRcdFx0XHRwMyA9IGFbaWkrMV0uZDtcblxuXHRcdFx0XHRcdGlmIChjb3JyZWxhdGUpIHtcblx0XHRcdFx0XHRcdHIxID0gX3IxW2ldO1xuXHRcdFx0XHRcdFx0cjIgPSBfcjJbaV07XG5cdFx0XHRcdFx0XHR0bCA9ICgocjIgKyByMSkgKiBjdXJ2aW5lc3MgKiAwLjI1KSAvIChiYXNpYyA/IDAuNSA6IF9yM1tpXSB8fCAwLjUpO1xuXHRcdFx0XHRcdFx0bTEgPSBwMiAtIChwMiAtIHAxKSAqIChiYXNpYyA/IGN1cnZpbmVzcyAqIDAuNSA6IChyMSAhPT0gMCA/IHRsIC8gcjEgOiAwKSk7XG5cdFx0XHRcdFx0XHRtMiA9IHAyICsgKHAzIC0gcDIpICogKGJhc2ljID8gY3VydmluZXNzICogMC41IDogKHIyICE9PSAwID8gdGwgLyByMiA6IDApKTtcblx0XHRcdFx0XHRcdG1tID0gcDIgLSAobTEgKyAoKChtMiAtIG0xKSAqICgocjEgKiAzIC8gKHIxICsgcjIpKSArIDAuNSkgLyA0KSB8fCAwKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG0xID0gcDIgLSAocDIgLSBwMSkgKiBjdXJ2aW5lc3MgKiAwLjU7XG5cdFx0XHRcdFx0XHRtMiA9IHAyICsgKHAzIC0gcDIpICogY3VydmluZXNzICogMC41O1xuXHRcdFx0XHRcdFx0bW0gPSBwMiAtIChtMSArIG0yKSAvIDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG0xICs9IG1tO1xuXHRcdFx0XHRcdG0yICs9IG1tO1xuXG5cdFx0XHRcdFx0c2VnLmMgPSBjcDIgPSBtMTtcblx0XHRcdFx0XHRpZiAoaSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0c2VnLmIgPSBjcDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlZy5iID0gY3AxID0gc2VnLmEgKyAoc2VnLmMgLSBzZWcuYSkgKiAwLjY7IC8vaW5zdGVhZCBvZiBwbGFjaW5nIGIgb24gYSBleGFjdGx5LCB3ZSBtb3ZlIGl0IGlubGluZSB3aXRoIGMgc28gdGhhdCBpZiB0aGUgdXNlciBzcGVjaWZpZXMgYW4gZWFzZSBsaWtlIEJhY2suZWFzZUluIG9yIEVsYXN0aWMuZWFzZUluIHdoaWNoIGdvZXMgQkVZT05EIHRoZSBiZWdpbm5pbmcsIGl0IHdpbGwgZG8gc28gc21vb3RobHkuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2VnLmRhID0gcDIgLSBwMTtcblx0XHRcdFx0XHRzZWcuY2EgPSBjcDIgLSBwMTtcblx0XHRcdFx0XHRzZWcuYmEgPSBjcDEgLSBwMTtcblxuXHRcdFx0XHRcdGlmIChxdWFkKSB7XG5cdFx0XHRcdFx0XHRxYiA9IGN1YmljVG9RdWFkcmF0aWMocDEsIGNwMSwgY3AyLCBwMik7XG5cdFx0XHRcdFx0XHRhLnNwbGljZShpaSwgMSwgcWJbMF0sIHFiWzFdLCBxYlsyXSwgcWJbM10pO1xuXHRcdFx0XHRcdFx0aWkgKz0gNDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWkrKztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjcDEgPSBtMjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWcgPSBhW2lpXTtcblx0XHRcdFx0c2VnLmIgPSBjcDE7XG5cdFx0XHRcdHNlZy5jID0gY3AxICsgKHNlZy5kIC0gY3AxKSAqIDAuNDsgLy9pbnN0ZWFkIG9mIHBsYWNpbmcgYyBvbiBkIGV4YWN0bHksIHdlIG1vdmUgaXQgaW5saW5lIHdpdGggYiBzbyB0aGF0IGlmIHRoZSB1c2VyIHNwZWNpZmllcyBhbiBlYXNlIGxpa2UgQmFjay5lYXNlT3V0IG9yIEVsYXN0aWMuZWFzZU91dCB3aGljaCBnb2VzIEJFWU9ORCB0aGUgZW5kLCBpdCB3aWxsIGRvIHNvIHNtb290aGx5LlxuXHRcdFx0XHRzZWcuZGEgPSBzZWcuZCAtIHNlZy5hO1xuXHRcdFx0XHRzZWcuY2EgPSBzZWcuYyAtIHNlZy5hO1xuXHRcdFx0XHRzZWcuYmEgPSBjcDEgLSBzZWcuYTtcblx0XHRcdFx0aWYgKHF1YWQpIHtcblx0XHRcdFx0XHRxYiA9IGN1YmljVG9RdWFkcmF0aWMoc2VnLmEsIGNwMSwgc2VnLmMsIHNlZy5kKTtcblx0XHRcdFx0XHRhLnNwbGljZShpaSwgMSwgcWJbMF0sIHFiWzFdLCBxYlsyXSwgcWJbM10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3BhcnNlQW5jaG9ycyA9IGZ1bmN0aW9uKHZhbHVlcywgcCwgY29ycmVsYXRlLCBwcmVwZW5kKSB7XG5cdFx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdFx0bCwgaSwgcDEsIHAyLCBwMywgdG1wO1xuXHRcdFx0XHRpZiAocHJlcGVuZCkge1xuXHRcdFx0XHRcdHZhbHVlcyA9IFtwcmVwZW5kXS5jb25jYXQodmFsdWVzKTtcblx0XHRcdFx0XHRpID0gdmFsdWVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YoICh0bXAgPSB2YWx1ZXNbaV1bcF0pICkgPT09IFwic3RyaW5nXCIpIGlmICh0bXAuY2hhckF0KDEpID09PSBcIj1cIikge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNbaV1bcF0gPSBwcmVwZW5kW3BdICsgTnVtYmVyKHRtcC5jaGFyQXQoMCkgKyB0bXAuc3Vic3RyKDIpKTsgLy9hY2NvbW1vZGF0ZSByZWxhdGl2ZSB2YWx1ZXMuIERvIGl0IGlubGluZSBpbnN0ZWFkIG9mIGJyZWFraW5nIGl0IG91dCBpbnRvIGEgZnVuY3Rpb24gZm9yIHNwZWVkIHJlYXNvbnNcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bCA9IHZhbHVlcy5sZW5ndGggLSAyO1xuXHRcdFx0XHRpZiAobCA8IDApIHtcblx0XHRcdFx0XHRhWzBdID0gbmV3IFNlZ21lbnQodmFsdWVzWzBdW3BdLCAwLCAwLCB2YWx1ZXNbKGwgPCAtMSkgPyAwIDogMV1bcF0pO1xuXHRcdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRwMSA9IHZhbHVlc1tpXVtwXTtcblx0XHRcdFx0XHRwMiA9IHZhbHVlc1tpKzFdW3BdO1xuXHRcdFx0XHRcdGFbaV0gPSBuZXcgU2VnbWVudChwMSwgMCwgMCwgcDIpO1xuXHRcdFx0XHRcdGlmIChjb3JyZWxhdGUpIHtcblx0XHRcdFx0XHRcdHAzID0gdmFsdWVzW2krMl1bcF07XG5cdFx0XHRcdFx0XHRfcjFbaV0gPSAoX3IxW2ldIHx8IDApICsgKHAyIC0gcDEpICogKHAyIC0gcDEpO1xuXHRcdFx0XHRcdFx0X3IyW2ldID0gKF9yMltpXSB8fCAwKSArIChwMyAtIHAyKSAqIChwMyAtIHAyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YVtpXSA9IG5ldyBTZWdtZW50KHZhbHVlc1tpXVtwXSwgMCwgMCwgdmFsdWVzW2krMV1bcF0pO1xuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH0sXG5cdFx0XHRiZXppZXJUaHJvdWdoID0gZnVuY3Rpb24odmFsdWVzLCBjdXJ2aW5lc3MsIHF1YWRyYXRpYywgYmFzaWMsIGNvcnJlbGF0ZSwgcHJlcGVuZCkge1xuXHRcdFx0XHR2YXIgb2JqID0ge30sXG5cdFx0XHRcdFx0cHJvcHMgPSBbXSxcblx0XHRcdFx0XHRmaXJzdCA9IHByZXBlbmQgfHwgdmFsdWVzWzBdLFxuXHRcdFx0XHRcdGksIHAsIGEsIGosIHIsIGwsIHNlYW1sZXNzLCBsYXN0O1xuXHRcdFx0XHRjb3JyZWxhdGUgPSAodHlwZW9mKGNvcnJlbGF0ZSkgPT09IFwic3RyaW5nXCIpID8gXCIsXCIrY29ycmVsYXRlK1wiLFwiIDogX2NvcnJlbGF0ZTtcblx0XHRcdFx0aWYgKGN1cnZpbmVzcyA9PSBudWxsKSB7XG5cdFx0XHRcdFx0Y3VydmluZXNzID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHAgaW4gdmFsdWVzWzBdKSB7XG5cdFx0XHRcdFx0cHJvcHMucHVzaChwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL2NoZWNrIHRvIHNlZSBpZiB0aGUgbGFzdCBhbmQgZmlyc3QgdmFsdWVzIGFyZSBpZGVudGljYWwgKHdlbGwsIHdpdGhpbiAwLjA1KS4gSWYgc28sIG1ha2Ugc2VhbWxlc3MgYnkgYXBwZW5kaW5nIHRoZSBzZWNvbmQgZWxlbWVudCB0byB0aGUgdmVyeSBlbmQgb2YgdGhlIHZhbHVlcyBhcnJheSBhbmQgdGhlIDJuZC10by1sYXN0IGVsZW1lbnQgdG8gdGhlIHZlcnkgYmVnaW5uaW5nICh3ZSdsbCByZW1vdmUgdGhvc2Ugc2VnbWVudHMgbGF0ZXIpXG5cdFx0XHRcdGlmICh2YWx1ZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGxhc3QgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdHNlYW1sZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0cCA9IHByb3BzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKE1hdGguYWJzKGZpcnN0W3BdIC0gbGFzdFtwXSkgPiAwLjA1KSB7IC8vYnVpbGQgaW4gYSB0b2xlcmFuY2Ugb2YgKy8tMC4wNSB0byBhY2NvbW1vZGF0ZSByb3VuZGluZyBlcnJvcnMuIEZvciBleGFtcGxlLCBpZiB5b3Ugc2V0IGFuIG9iamVjdCdzIHBvc2l0aW9uIHRvIDQuOTQ1LCBGbGFzaCB3aWxsIG1ha2UgaXQgNC45XG5cdFx0XHRcdFx0XHRcdHNlYW1sZXNzID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc2VhbWxlc3MpIHtcblx0XHRcdFx0XHRcdHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoKTsgLy9kdXBsaWNhdGUgdGhlIGFycmF5IHRvIGF2b2lkIGNvbnRhbWluYXRpbmcgdGhlIG9yaWdpbmFsIHdoaWNoIHRoZSB1c2VyIG1heSBiZSByZXVzaW5nIGZvciBvdGhlciB0d2VlbnNcblx0XHRcdFx0XHRcdGlmIChwcmVwZW5kKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlcy51bnNoaWZ0KHByZXBlbmQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2godmFsdWVzWzFdKTtcblx0XHRcdFx0XHRcdHByZXBlbmQgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDNdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRfcjEubGVuZ3RoID0gX3IyLmxlbmd0aCA9IF9yMy5sZW5ndGggPSAwO1xuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0X2NvclByb3BzW3BdID0gKGNvcnJlbGF0ZS5pbmRleE9mKFwiLFwiK3ArXCIsXCIpICE9PSAtMSk7XG5cdFx0XHRcdFx0b2JqW3BdID0gX3BhcnNlQW5jaG9ycyh2YWx1ZXMsIHAsIF9jb3JQcm9wc1twXSwgcHJlcGVuZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IF9yMS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdF9yMVtpXSA9IE1hdGguc3FydChfcjFbaV0pO1xuXHRcdFx0XHRcdF9yMltpXSA9IE1hdGguc3FydChfcjJbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghYmFzaWMpIHtcblx0XHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKF9jb3JQcm9wc1twXSkge1xuXHRcdFx0XHRcdFx0XHRhID0gb2JqW3Byb3BzW2ldXTtcblx0XHRcdFx0XHRcdFx0bCA9IGEubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuXHRcdFx0XHRcdFx0XHRcdHIgPSBhW2orMV0uZGEgLyBfcjJbal0gKyBhW2pdLmRhIC8gX3IxW2pdO1xuXHRcdFx0XHRcdFx0XHRcdF9yM1tqXSA9IChfcjNbal0gfHwgMCkgKyByICogcjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpID0gX3IzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdF9yM1tpXSA9IE1hdGguc3FydChfcjNbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRqID0gcXVhZHJhdGljID8gNCA6IDE7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRhID0gb2JqW3BdO1xuXHRcdFx0XHRcdF9jYWxjdWxhdGVDb250cm9sUG9pbnRzKGEsIGN1cnZpbmVzcywgcXVhZHJhdGljLCBiYXNpYywgX2NvclByb3BzW3BdKTsgLy90aGlzIG1ldGhvZCByZXF1aXJlcyB0aGF0IF9wYXJzZUFuY2hvcnMoKSBhbmQgX3NldFNlZ21lbnRSYXRpb3MoKSByYW4gZmlyc3Qgc28gdGhhdCBfcjEsIF9yMiwgYW5kIF9yMyB2YWx1ZXMgYXJlIHBvcHVsYXRlZCBmb3IgYWxsIHByb3BlcnRpZXNcblx0XHRcdFx0XHRpZiAoc2VhbWxlc3MpIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKDAsIGopO1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoYS5sZW5ndGggLSBqLCBqKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VCZXppZXJEYXRhID0gZnVuY3Rpb24odmFsdWVzLCB0eXBlLCBwcmVwZW5kKSB7XG5cdFx0XHRcdHR5cGUgPSB0eXBlIHx8IFwic29mdFwiO1xuXHRcdFx0XHR2YXIgb2JqID0ge30sXG5cdFx0XHRcdFx0aW5jID0gKHR5cGUgPT09IFwiY3ViaWNcIikgPyAzIDogMixcblx0XHRcdFx0XHRzb2Z0ID0gKHR5cGUgPT09IFwic29mdFwiKSxcblx0XHRcdFx0XHRwcm9wcyA9IFtdLFxuXHRcdFx0XHRcdGEsIGIsIGMsIGQsIGN1ciwgaSwgaiwgbCwgcCwgY250LCB0bXA7XG5cdFx0XHRcdGlmIChzb2Z0ICYmIHByZXBlbmQpIHtcblx0XHRcdFx0XHR2YWx1ZXMgPSBbcHJlcGVuZF0uY29uY2F0KHZhbHVlcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhbHVlcyA9PSBudWxsIHx8IHZhbHVlcy5sZW5ndGggPCBpbmMgKyAxKSB7IHRocm93IFwiaW52YWxpZCBCZXppZXIgZGF0YVwiOyB9XG5cdFx0XHRcdGZvciAocCBpbiB2YWx1ZXNbMF0pIHtcblx0XHRcdFx0XHRwcm9wcy5wdXNoKHApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRvYmpbcF0gPSBjdXIgPSBbXTtcblx0XHRcdFx0XHRjbnQgPSAwO1xuXHRcdFx0XHRcdGwgPSB2YWx1ZXMubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcblx0XHRcdFx0XHRcdGEgPSAocHJlcGVuZCA9PSBudWxsKSA/IHZhbHVlc1tqXVtwXSA6ICh0eXBlb2YoICh0bXAgPSB2YWx1ZXNbal1bcF0pICkgPT09IFwic3RyaW5nXCIgJiYgdG1wLmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcHJlcGVuZFtwXSArIE51bWJlcih0bXAuY2hhckF0KDApICsgdG1wLnN1YnN0cigyKSkgOiBOdW1iZXIodG1wKTtcblx0XHRcdFx0XHRcdGlmIChzb2Z0KSBpZiAoaiA+IDEpIGlmIChqIDwgbCAtIDEpIHtcblx0XHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IChhICsgY3VyW2NudC0yXSkgLyAyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGwgPSBjbnQgLSBpbmMgKyAxO1xuXHRcdFx0XHRcdGNudCA9IDA7XG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGogKz0gaW5jKSB7XG5cdFx0XHRcdFx0XHRhID0gY3VyW2pdO1xuXHRcdFx0XHRcdFx0YiA9IGN1cltqKzFdO1xuXHRcdFx0XHRcdFx0YyA9IGN1cltqKzJdO1xuXHRcdFx0XHRcdFx0ZCA9IChpbmMgPT09IDIpID8gMCA6IGN1cltqKzNdO1xuXHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IHRtcCA9IChpbmMgPT09IDMpID8gbmV3IFNlZ21lbnQoYSwgYiwgYywgZCkgOiBuZXcgU2VnbWVudChhLCAoMiAqIGIgKyBhKSAvIDMsICgyICogYiArIGMpIC8gMywgYyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1ci5sZW5ndGggPSBjbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sXG5cdFx0XHRfYWRkQ3ViaWNMZW5ndGhzID0gZnVuY3Rpb24oYSwgc3RlcHMsIHJlc29sdXRpb24pIHtcblx0XHRcdFx0dmFyIGluYyA9IDEgLyByZXNvbHV0aW9uLFxuXHRcdFx0XHRcdGogPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRkLCBkMSwgcywgZGEsIGNhLCBiYSwgcCwgaSwgaW52LCBiZXosIGluZGV4O1xuXHRcdFx0XHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRcdFx0XHRiZXogPSBhW2pdO1xuXHRcdFx0XHRcdHMgPSBiZXouYTtcblx0XHRcdFx0XHRkYSA9IGJlei5kIC0gcztcblx0XHRcdFx0XHRjYSA9IGJlei5jIC0gcztcblx0XHRcdFx0XHRiYSA9IGJlei5iIC0gcztcblx0XHRcdFx0XHRkID0gZDEgPSAwO1xuXHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPD0gcmVzb2x1dGlvbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRwID0gaW5jICogaTtcblx0XHRcdFx0XHRcdGludiA9IDEgLSBwO1xuXHRcdFx0XHRcdFx0ZCA9IGQxIC0gKGQxID0gKHAgKiBwICogZGEgKyAzICogaW52ICogKHAgKiBjYSArIGludiAqIGJhKSkgKiBwKTtcblx0XHRcdFx0XHRcdGluZGV4ID0gaiAqIHJlc29sdXRpb24gKyBpIC0gMTtcblx0XHRcdFx0XHRcdHN0ZXBzW2luZGV4XSA9IChzdGVwc1tpbmRleF0gfHwgMCkgKyBkICogZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VMZW5ndGhEYXRhID0gZnVuY3Rpb24ob2JqLCByZXNvbHV0aW9uKSB7XG5cdFx0XHRcdHJlc29sdXRpb24gPSByZXNvbHV0aW9uID4+IDAgfHwgNjtcblx0XHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0XHRsZW5ndGhzID0gW10sXG5cdFx0XHRcdFx0ZCA9IDAsXG5cdFx0XHRcdFx0dG90YWwgPSAwLFxuXHRcdFx0XHRcdHRocmVzaG9sZCA9IHJlc29sdXRpb24gLSAxLFxuXHRcdFx0XHRcdHNlZ21lbnRzID0gW10sXG5cdFx0XHRcdFx0Y3VyTFMgPSBbXSwgLy9jdXJyZW50IGxlbmd0aCBzZWdtZW50cyBhcnJheVxuXHRcdFx0XHRcdHAsIGksIGwsIGluZGV4O1xuXHRcdFx0XHRmb3IgKHAgaW4gb2JqKSB7XG5cdFx0XHRcdFx0X2FkZEN1YmljTGVuZ3RocyhvYmpbcF0sIGEsIHJlc29sdXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGwgPSBhLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGQgKz0gTWF0aC5zcXJ0KGFbaV0pO1xuXHRcdFx0XHRcdGluZGV4ID0gaSAlIHJlc29sdXRpb247XG5cdFx0XHRcdFx0Y3VyTFNbaW5kZXhdID0gZDtcblx0XHRcdFx0XHRpZiAoaW5kZXggPT09IHRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0dG90YWwgKz0gZDtcblx0XHRcdFx0XHRcdGluZGV4ID0gKGkgLyByZXNvbHV0aW9uKSA+PiAwO1xuXHRcdFx0XHRcdFx0c2VnbWVudHNbaW5kZXhdID0gY3VyTFM7XG5cdFx0XHRcdFx0XHRsZW5ndGhzW2luZGV4XSA9IHRvdGFsO1xuXHRcdFx0XHRcdFx0ZCA9IDA7XG5cdFx0XHRcdFx0XHRjdXJMUyA9IFtdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge2xlbmd0aDp0b3RhbCwgbGVuZ3RoczpsZW5ndGhzLCBzZWdtZW50czpzZWdtZW50c307XG5cdFx0XHR9LFxuXG5cblxuXHRcdFx0QmV6aWVyUGx1Z2luID0gX2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0XHRcdFx0cHJvcE5hbWU6IFwiYmV6aWVyXCIsXG5cdFx0XHRcdFx0cHJpb3JpdHk6IC0xLFxuXHRcdFx0XHRcdHZlcnNpb246IFwiMS4zLjRcIixcblx0XHRcdFx0XHRBUEk6IDIsXG5cdFx0XHRcdFx0Z2xvYmFsOnRydWUsXG5cblx0XHRcdFx0XHQvL2dldHMgY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0XHRcdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0XHRcdFx0aWYgKHZhcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRcdFx0XHR2YXJzID0ge3ZhbHVlczp2YXJzfTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX2Z1bmMgPSB7fTtcblx0XHRcdFx0XHRcdHRoaXMuX3JvdW5kID0ge307XG5cdFx0XHRcdFx0XHR0aGlzLl9wcm9wcyA9IFtdO1xuXHRcdFx0XHRcdFx0dGhpcy5fdGltZVJlcyA9ICh2YXJzLnRpbWVSZXNvbHV0aW9uID09IG51bGwpID8gNiA6IHBhcnNlSW50KHZhcnMudGltZVJlc29sdXRpb24sIDEwKTtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSB2YXJzLnZhbHVlcyB8fCBbXSxcblx0XHRcdFx0XHRcdFx0Zmlyc3QgPSB7fSxcblx0XHRcdFx0XHRcdFx0c2Vjb25kID0gdmFsdWVzWzBdLFxuXHRcdFx0XHRcdFx0XHRhdXRvUm90YXRlID0gdmFycy5hdXRvUm90YXRlIHx8IHR3ZWVuLnZhcnMub3JpZW50VG9CZXppZXIsXG5cdFx0XHRcdFx0XHRcdHAsIGlzRnVuYywgaSwgaiwgcHJlcGVuZDtcblxuXHRcdFx0XHRcdFx0dGhpcy5fYXV0b1JvdGF0ZSA9IGF1dG9Sb3RhdGUgPyAoYXV0b1JvdGF0ZSBpbnN0YW5jZW9mIEFycmF5KSA/IGF1dG9Sb3RhdGUgOiBbW1wieFwiLFwieVwiLFwicm90YXRpb25cIiwoKGF1dG9Sb3RhdGUgPT09IHRydWUpID8gMCA6IE51bWJlcihhdXRvUm90YXRlKSB8fCAwKV1dIDogbnVsbDtcblx0XHRcdFx0XHRcdGZvciAocCBpbiBzZWNvbmQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fcHJvcHMucHVzaChwKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aSA9IHRoaXMuX3Byb3BzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRwID0gdGhpcy5fcHJvcHNbaV07XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHRcdFx0XHRcdFx0aXNGdW5jID0gdGhpcy5fZnVuY1twXSA9ICh0eXBlb2YodGFyZ2V0W3BdKSA9PT0gXCJmdW5jdGlvblwiKTtcblx0XHRcdFx0XHRcdFx0Zmlyc3RbcF0gPSAoIWlzRnVuYykgPyBwYXJzZUZsb2F0KHRhcmdldFtwXSkgOiB0YXJnZXRbICgocC5pbmRleE9mKFwic2V0XCIpIHx8IHR5cGVvZih0YXJnZXRbXCJnZXRcIiArIHAuc3Vic3RyKDMpXSkgIT09IFwiZnVuY3Rpb25cIikgPyBwIDogXCJnZXRcIiArIHAuc3Vic3RyKDMpKSBdKCk7XG5cdFx0XHRcdFx0XHRcdGlmICghcHJlcGVuZCkgaWYgKGZpcnN0W3BdICE9PSB2YWx1ZXNbMF1bcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRwcmVwZW5kID0gZmlyc3Q7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX2JlemllcnMgPSAodmFycy50eXBlICE9PSBcImN1YmljXCIgJiYgdmFycy50eXBlICE9PSBcInF1YWRyYXRpY1wiICYmIHZhcnMudHlwZSAhPT0gXCJzb2Z0XCIpID8gYmV6aWVyVGhyb3VnaCh2YWx1ZXMsIGlzTmFOKHZhcnMuY3VydmluZXNzKSA/IDEgOiB2YXJzLmN1cnZpbmVzcywgZmFsc2UsICh2YXJzLnR5cGUgPT09IFwidGhydUJhc2ljXCIpLCB2YXJzLmNvcnJlbGF0ZSwgcHJlcGVuZCkgOiBfcGFyc2VCZXppZXJEYXRhKHZhbHVlcywgdmFycy50eXBlLCBmaXJzdCk7XG5cdFx0XHRcdFx0XHR0aGlzLl9zZWdDb3VudCA9IHRoaXMuX2JlemllcnNbcF0ubGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fdGltZVJlcykge1xuXHRcdFx0XHRcdFx0XHR2YXIgbGQgPSBfcGFyc2VMZW5ndGhEYXRhKHRoaXMuX2JlemllcnMsIHRoaXMuX3RpbWVSZXMpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sZW5ndGggPSBsZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2xlbmd0aHMgPSBsZC5sZW5ndGhzO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9zZWdtZW50cyA9IGxkLnNlZ21lbnRzO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sMSA9IHRoaXMuX2xpID0gdGhpcy5fczEgPSB0aGlzLl9zaSA9IDA7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2wyID0gdGhpcy5fbGVuZ3Roc1swXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fY3VyU2VnID0gdGhpcy5fc2VnbWVudHNbMF07XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3MyID0gdGhpcy5fY3VyU2VnWzBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9wcmVjID0gMSAvIHRoaXMuX2N1clNlZy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICgoYXV0b1JvdGF0ZSA9IHRoaXMuX2F1dG9Sb3RhdGUpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2luaXRpYWxSb3RhdGlvbnMgPSBbXTtcblx0XHRcdFx0XHRcdFx0aWYgKCEoYXV0b1JvdGF0ZVswXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2F1dG9Sb3RhdGUgPSBhdXRvUm90YXRlID0gW2F1dG9Sb3RhdGVdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGkgPSBhdXRvUm90YXRlLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IDM7IGorKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0cCA9IGF1dG9Sb3RhdGVbaV1bal07XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9mdW5jW3BdID0gKHR5cGVvZih0YXJnZXRbcF0pID09PSBcImZ1bmN0aW9uXCIpID8gdGFyZ2V0WyAoKHAuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKSkgXSA6IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRwID0gYXV0b1JvdGF0ZVtpXVsyXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9pbml0aWFsUm90YXRpb25zW2ldID0gdGhpcy5fZnVuY1twXSA/IHRoaXMuX2Z1bmNbcF0uY2FsbCh0aGlzLl90YXJnZXQpIDogdGhpcy5fdGFyZ2V0W3BdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydFJhdGlvID0gdHdlZW4udmFycy5ydW5CYWNrd2FyZHMgPyAxIDogMDsgLy93ZSBkZXRlcm1pbmUgdGhlIHN0YXJ0aW5nIHJhdGlvIHdoZW4gdGhlIHR3ZWVuIGluaXRzIHdoaWNoIGlzIGFsd2F5cyAwIHVubGVzcyB0aGUgdHdlZW4gaGFzIHJ1bkJhY2t3YXJkczp0cnVlIChpbmRpY2F0aW5nIGl0J3MgYSBmcm9tKCkgdHdlZW4pIGluIHdoaWNoIGNhc2UgaXQncyAxLlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vY2FsbGVkIGVhY2ggdGltZSB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkLCBhbmQgdGhlIHJhdGlvIGdldHMgcGFzc2VkIGFzIHRoZSBvbmx5IHBhcmFtZXRlciAodHlwaWNhbGx5IGl0J3MgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIGJ1dCBpdCBjYW4gZXhjZWVkIHRob3NlIHdoZW4gdXNpbmcgYW4gZWFzZSBsaWtlIEVsYXN0aWMuZWFzZU91dCBvciBCYWNrLmVhc2VPdXQsIGV0Yy4pXG5cdFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdDb3VudCxcblx0XHRcdFx0XHRcdFx0ZnVuYyA9IHRoaXMuX2Z1bmMsXG5cdFx0XHRcdFx0XHRcdHRhcmdldCA9IHRoaXMuX3RhcmdldCxcblx0XHRcdFx0XHRcdFx0bm90U3RhcnQgPSAodiAhPT0gdGhpcy5fc3RhcnRSYXRpbyksXG5cdFx0XHRcdFx0XHRcdGN1ckluZGV4LCBpbnYsIGksIHAsIGIsIHQsIHZhbCwgbCwgbGVuZ3RocywgY3VyU2VnO1xuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLl90aW1lUmVzKSB7XG5cdFx0XHRcdFx0XHRcdGN1ckluZGV4ID0gKHYgPCAwKSA/IDAgOiAodiA+PSAxKSA/IHNlZ21lbnRzIC0gMSA6IChzZWdtZW50cyAqIHYpID4+IDA7XG5cdFx0XHRcdFx0XHRcdHQgPSAodiAtIChjdXJJbmRleCAqICgxIC8gc2VnbWVudHMpKSkgKiBzZWdtZW50cztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxlbmd0aHMgPSB0aGlzLl9sZW5ndGhzO1xuXHRcdFx0XHRcdFx0XHRjdXJTZWcgPSB0aGlzLl9jdXJTZWc7XG5cdFx0XHRcdFx0XHRcdHYgKj0gdGhpcy5fbGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRpID0gdGhpcy5fbGk7XG5cdFx0XHRcdFx0XHRcdC8vZmluZCB0aGUgYXBwcm9wcmlhdGUgc2VnbWVudCAoaWYgdGhlIGN1cnJlbnRseSBjYWNoZWQgb25lIGlzbid0IGNvcnJlY3QpXG5cdFx0XHRcdFx0XHRcdGlmICh2ID4gdGhpcy5fbDIgJiYgaSA8IHNlZ21lbnRzIC0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdGwgPSBzZWdtZW50cyAtIDE7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBsICYmICh0aGlzLl9sMiA9IGxlbmd0aHNbKytpXSkgPD0gdikge1x0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2wxID0gbGVuZ3Roc1tpLTFdO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2xpID0gaTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jdXJTZWcgPSBjdXJTZWcgPSB0aGlzLl9zZWdtZW50c1tpXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMiA9IGN1clNlZ1sodGhpcy5fczEgPSB0aGlzLl9zaSA9IDApXTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2IDwgdGhpcy5fbDEgJiYgaSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoaSA+IDAgJiYgKHRoaXMuX2wxID0gbGVuZ3Roc1stLWldKSA+PSB2KSB7IH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoaSA9PT0gMCAmJiB2IDwgdGhpcy5fbDEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2wxID0gMDtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9sMiA9IGxlbmd0aHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fbGkgPSBpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2N1clNlZyA9IGN1clNlZyA9IHRoaXMuX3NlZ21lbnRzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MxID0gY3VyU2VnWyh0aGlzLl9zaSA9IGN1clNlZy5sZW5ndGggLSAxKSAtIDFdIHx8IDA7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSBjdXJTZWdbdGhpcy5fc2ldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGN1ckluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0Ly9ub3cgZmluZCB0aGUgYXBwcm9wcmlhdGUgc3ViLXNlZ21lbnQgKHdlIHNwbGl0IGl0IGludG8gdGhlIG51bWJlciBvZiBwaWVjZXMgdGhhdCB3YXMgZGVmaW5lZCBieSBcInByZWNpc2lvblwiIGFuZCBtZWFzdXJlZCBlYWNoIG9uZSlcblx0XHRcdFx0XHRcdFx0diAtPSB0aGlzLl9sMTtcblx0XHRcdFx0XHRcdFx0aSA9IHRoaXMuX3NpO1xuXHRcdFx0XHRcdFx0XHRpZiAodiA+IHRoaXMuX3MyICYmIGkgPCBjdXJTZWcubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdGwgPSBjdXJTZWcubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoaSA8IGwgJiYgKHRoaXMuX3MyID0gY3VyU2VnWysraV0pIDw9IHYpIHtcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMSA9IGN1clNlZ1tpLTFdO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NpID0gaTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2IDwgdGhpcy5fczEgJiYgaSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoaSA+IDAgJiYgKHRoaXMuX3MxID0gY3VyU2VnWy0taV0pID49IHYpIHtcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoaSA9PT0gMCAmJiB2IDwgdGhpcy5fczEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MxID0gMDtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMiA9IGN1clNlZ1tpXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zaSA9IGk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dCA9IChpICsgKHYgLSB0aGlzLl9zMSkgLyAodGhpcy5fczIgLSB0aGlzLl9zMSkpICogdGhpcy5fcHJlYztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGludiA9IDEgLSB0O1xuXG5cdFx0XHRcdFx0XHRpID0gdGhpcy5fcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHAgPSB0aGlzLl9wcm9wc1tpXTtcblx0XHRcdFx0XHRcdFx0YiA9IHRoaXMuX2JlemllcnNbcF1bY3VySW5kZXhdO1xuXHRcdFx0XHRcdFx0XHR2YWwgPSAodCAqIHQgKiBiLmRhICsgMyAqIGludiAqICh0ICogYi5jYSArIGludiAqIGIuYmEpKSAqIHQgKyBiLmE7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLl9yb3VuZFtwXSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhbCA9IE1hdGgucm91bmQodmFsKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoZnVuY1twXSkge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwXSh2YWwpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwXSA9IHZhbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fYXV0b1JvdGF0ZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYXIgPSB0aGlzLl9hdXRvUm90YXRlLFxuXHRcdFx0XHRcdFx0XHRcdGIyLCB4MSwgeTEsIHgyLCB5MiwgYWRkLCBjb252O1xuXHRcdFx0XHRcdFx0XHRpID0gYXIubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRwID0gYXJbaV1bMl07XG5cdFx0XHRcdFx0XHRcdFx0YWRkID0gYXJbaV1bM10gfHwgMDtcblx0XHRcdFx0XHRcdFx0XHRjb252ID0gKGFyW2ldWzRdID09PSB0cnVlKSA/IDEgOiBfUkFEMkRFRztcblx0XHRcdFx0XHRcdFx0XHRiID0gdGhpcy5fYmV6aWVyc1thcltpXVswXV07XG5cdFx0XHRcdFx0XHRcdFx0YjIgPSB0aGlzLl9iZXppZXJzW2FyW2ldWzFdXTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChiICYmIGIyKSB7IC8vaW4gY2FzZSBvbmUgb2YgdGhlIHByb3BlcnRpZXMgZ290IG92ZXJ3cml0dGVuLlxuXHRcdFx0XHRcdFx0XHRcdFx0YiA9IGJbY3VySW5kZXhdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YjIgPSBiMltjdXJJbmRleF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdHgxID0gYi5hICsgKGIuYiAtIGIuYSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eDIgPSBiLmIgKyAoYi5jIC0gYi5iKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR4MSArPSAoeDIgLSB4MSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eDIgKz0gKChiLmMgKyAoYi5kIC0gYi5jKSAqIHQpIC0geDIpICogdDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0eTEgPSBiMi5hICsgKGIyLmIgLSBiMi5hKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR5MiA9IGIyLmIgKyAoYjIuYyAtIGIyLmIpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHkxICs9ICh5MiAtIHkxKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR5MiArPSAoKGIyLmMgKyAoYjIuZCAtIGIyLmMpICogdCkgLSB5MikgKiB0O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWwgPSBub3RTdGFydCA/IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkgKiBjb252ICsgYWRkIDogdGhpcy5faW5pdGlhbFJvdGF0aW9uc1tpXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGZ1bmNbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdKHZhbCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0gPSB2YWw7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0fSksXG5cdFx0XHRwID0gQmV6aWVyUGx1Z2luLnByb3RvdHlwZTtcblxuXG5cdFx0QmV6aWVyUGx1Z2luLmJlemllclRocm91Z2ggPSBiZXppZXJUaHJvdWdoO1xuXHRcdEJlemllclBsdWdpbi5jdWJpY1RvUXVhZHJhdGljID0gY3ViaWNUb1F1YWRyYXRpYztcblx0XHRCZXppZXJQbHVnaW4uX2F1dG9DU1MgPSB0cnVlOyAvL2luZGljYXRlcyB0aGF0IHRoaXMgcGx1Z2luIGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBcImNzc1wiIG9iamVjdCB1c2luZyB0aGUgYXV0b0NTUyBmZWF0dXJlIG9mIFR3ZWVuTGl0ZVxuXHRcdEJlemllclBsdWdpbi5xdWFkcmF0aWNUb0N1YmljID0gZnVuY3Rpb24oYSwgYiwgYykge1xuXHRcdFx0cmV0dXJuIG5ldyBTZWdtZW50KGEsICgyICogYiArIGEpIC8gMywgKDIgKiBiICsgYykgLyAzLCBjKTtcblx0XHR9O1xuXG5cdFx0QmV6aWVyUGx1Z2luLl9jc3NSZWdpc3RlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIENTU1BsdWdpbiA9IF9nbG9iYWxzLkNTU1BsdWdpbjtcblx0XHRcdGlmICghQ1NTUGx1Z2luKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBfaW50ZXJuYWxzID0gQ1NTUGx1Z2luLl9pbnRlcm5hbHMsXG5cdFx0XHRcdF9wYXJzZVRvUHJveHkgPSBfaW50ZXJuYWxzLl9wYXJzZVRvUHJveHksXG5cdFx0XHRcdF9zZXRQbHVnaW5SYXRpbyA9IF9pbnRlcm5hbHMuX3NldFBsdWdpblJhdGlvLFxuXHRcdFx0XHRDU1NQcm9wVHdlZW4gPSBfaW50ZXJuYWxzLkNTU1Byb3BUd2Vlbjtcblx0XHRcdF9pbnRlcm5hbHMuX3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmV6aWVyXCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcHJvcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0XHRpZiAoZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdFx0ZSA9IHt2YWx1ZXM6ZX07XG5cdFx0XHRcdH1cblx0XHRcdFx0cGx1Z2luID0gbmV3IEJlemllclBsdWdpbigpO1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gZS52YWx1ZXMsXG5cdFx0XHRcdFx0bCA9IHZhbHVlcy5sZW5ndGggLSAxLFxuXHRcdFx0XHRcdHBsdWdpblZhbHVlcyA9IFtdLFxuXHRcdFx0XHRcdHYgPSB7fSxcblx0XHRcdFx0XHRpLCBwLCBkYXRhO1xuXHRcdFx0XHRpZiAobCA8IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8PSBsOyBpKyspIHtcblx0XHRcdFx0XHRkYXRhID0gX3BhcnNlVG9Qcm94eSh0LCB2YWx1ZXNbaV0sIGNzc3AsIHB0LCBwbHVnaW4sIChsICE9PSBpKSk7XG5cdFx0XHRcdFx0cGx1Z2luVmFsdWVzW2ldID0gZGF0YS5lbmQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChwIGluIGUpIHtcblx0XHRcdFx0XHR2W3BdID0gZVtwXTsgLy9kdXBsaWNhdGUgdGhlIHZhcnMgb2JqZWN0IGJlY2F1c2Ugd2UgbmVlZCB0byBhbHRlciBzb21lIHRoaW5ncyB3aGljaCB3b3VsZCBjYXVzZSBwcm9ibGVtcyBpZiB0aGUgdXNlciBwbGFucyB0byByZXVzZSB0aGUgc2FtZSB2YXJzIG9iamVjdCBmb3IgYW5vdGhlciB0d2Vlbi5cblx0XHRcdFx0fVxuXHRcdFx0XHR2LnZhbHVlcyA9IHBsdWdpblZhbHVlcztcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIFwiYmV6aWVyXCIsIDAsIDAsIGRhdGEucHQsIDIpO1xuXHRcdFx0XHRwdC5kYXRhID0gZGF0YTtcblx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRwdC5zZXRSYXRpbyA9IF9zZXRQbHVnaW5SYXRpbztcblx0XHRcdFx0aWYgKHYuYXV0b1JvdGF0ZSA9PT0gMCkge1xuXHRcdFx0XHRcdHYuYXV0b1JvdGF0ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYuYXV0b1JvdGF0ZSAmJiAhKHYuYXV0b1JvdGF0ZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0XHRcdGkgPSAodi5hdXRvUm90YXRlID09PSB0cnVlKSA/IDAgOiBOdW1iZXIodi5hdXRvUm90YXRlKTtcblx0XHRcdFx0XHR2LmF1dG9Sb3RhdGUgPSAoZGF0YS5lbmQubGVmdCAhPSBudWxsKSA/IFtbXCJsZWZ0XCIsXCJ0b3BcIixcInJvdGF0aW9uXCIsaSxmYWxzZV1dIDogKGRhdGEuZW5kLnggIT0gbnVsbCkgPyBbW1wieFwiLFwieVwiLFwicm90YXRpb25cIixpLGZhbHNlXV0gOiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodi5hdXRvUm90YXRlKSB7XG5cdFx0XHRcdFx0aWYgKCFjc3NwLl90cmFuc2Zvcm0pIHtcblx0XHRcdFx0XHRcdGNzc3AuX2VuYWJsZVRyYW5zZm9ybXMoZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhLmF1dG9Sb3RhdGUgPSBjc3NwLl90YXJnZXQuX2dzVHJhbnNmb3JtO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBsdWdpbi5fb25Jbml0VHdlZW4oZGF0YS5wcm94eSwgdiwgY3NzcC5fdHdlZW4pO1xuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9fSk7XG5cdFx0fTtcblxuXHRcdHAuX3JvdW5kUHJvcHMgPSBmdW5jdGlvbihsb29rdXAsIHZhbHVlKSB7XG5cdFx0XHR2YXIgb3AgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0aSA9IG9wLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAobG9va3VwW29wW2ldXSB8fCBsb29rdXAuYmV6aWVyIHx8IGxvb2t1cC5iZXppZXJUaHJvdWdoKSB7XG5cdFx0XHRcdFx0dGhpcy5fcm91bmRbb3BbaV1dID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIGEgPSB0aGlzLl9wcm9wcyxcblx0XHRcdFx0cCwgaTtcblx0XHRcdGZvciAocCBpbiB0aGlzLl9iZXppZXJzKSB7XG5cdFx0XHRcdGlmIChwIGluIGxvb2t1cCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9iZXppZXJzW3BdO1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9mdW5jW3BdO1xuXHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmIChhW2ldID09PSBwKSB7XG5cdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3N1cGVyLl9raWxsLmNhbGwodGhpcywgbG9va3VwKTtcblx0XHR9O1xuXG5cdH0oKSk7XG5cblxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDU1NQbHVnaW5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJwbHVnaW5zLkNTU1BsdWdpblwiLCBbXCJwbHVnaW5zLlR3ZWVuUGx1Z2luXCIsXCJUd2VlbkxpdGVcIl0sIGZ1bmN0aW9uKFR3ZWVuUGx1Z2luLCBUd2VlbkxpdGUpIHtcblxuXHRcdC8qKiBAY29uc3RydWN0b3IgKiovXG5cdFx0dmFyIENTU1BsdWdpbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRUd2VlblBsdWdpbi5jYWxsKHRoaXMsIFwiY3NzXCIpO1xuXHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5sZW5ndGggPSAwO1xuXHRcdFx0XHR0aGlzLnNldFJhdGlvID0gQ1NTUGx1Z2luLnByb3RvdHlwZS5zZXRSYXRpbzsgLy9zcGVlZCBvcHRpbWl6YXRpb24gKGF2b2lkIHByb3RvdHlwZSBsb29rdXAgb24gdGhpcyBcImhvdFwiIG1ldGhvZClcblx0XHRcdH0sXG5cdFx0XHRfZ2xvYmFscyA9IF9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLFxuXHRcdFx0X2hhc1ByaW9yaXR5LCAvL3R1cm5zIHRydWUgd2hlbmV2ZXIgYSBDU1NQcm9wVHdlZW4gaW5zdGFuY2UgaXMgY3JlYXRlZCB0aGF0IGhhcyBhIHByaW9yaXR5IG90aGVyIHRoYW4gMC4gVGhpcyBoZWxwcyB1cyBkaXNjZXJuIHdoZXRoZXIgb3Igbm90IHdlIHNob3VsZCBzcGVuZCB0aGUgdGltZSBvcmdhbml6aW5nIHRoZSBsaW5rZWQgbGlzdCBvciBub3QgYWZ0ZXIgYSBDU1NQbHVnaW4ncyBfb25Jbml0VHdlZW4oKSBtZXRob2QgaXMgY2FsbGVkLlxuXHRcdFx0X3N1ZmZpeE1hcCwgLy93ZSBzZXQgdGhpcyBpbiBfb25Jbml0VHdlZW4oKSBlYWNoIHRpbWUgYXMgYSB3YXkgdG8gaGF2ZSBhIHBlcnNpc3RlbnQgdmFyaWFibGUgd2UgY2FuIHVzZSBpbiBvdGhlciBtZXRob2RzIGxpa2UgX3BhcnNlKCkgd2l0aG91dCBoYXZpbmcgdG8gcGFzcyBpdCBhcm91bmQgYXMgYSBwYXJhbWV0ZXIgYW5kIHdlIGtlZXAgX3BhcnNlKCkgZGVjb3VwbGVkIGZyb20gYSBwYXJ0aWN1bGFyIENTU1BsdWdpbiBpbnN0YW5jZVxuXHRcdFx0X2NzLCAvL2NvbXB1dGVkIHN0eWxlICh3ZSBzdG9yZSB0aGlzIGluIGEgc2hhcmVkIHZhcmlhYmxlIHRvIGNvbnNlcnZlIG1lbW9yeSBhbmQgbWFrZSBtaW5pZmljYXRpb24gdGlnaHRlclxuXHRcdFx0X292ZXJ3cml0ZVByb3BzLCAvL2FsaWFzIHRvIHRoZSBjdXJyZW50bHkgaW5zdGFudGlhdGluZyBDU1NQbHVnaW4ncyBfb3ZlcndyaXRlUHJvcHMgYXJyYXkuIFdlIHVzZSB0aGlzIGNsb3N1cmUgaW4gb3JkZXIgdG8gYXZvaWQgaGF2aW5nIHRvIHBhc3MgYSByZWZlcmVuY2UgYXJvdW5kIGZyb20gbWV0aG9kIHRvIG1ldGhvZCBhbmQgYWlkIGluIG1pbmlmaWNhdGlvbi5cblx0XHRcdF9zcGVjaWFsUHJvcHMgPSB7fSxcblx0XHRcdHAgPSBDU1NQbHVnaW4ucHJvdG90eXBlID0gbmV3IFR3ZWVuUGx1Z2luKFwiY3NzXCIpO1xuXG5cdFx0cC5jb25zdHJ1Y3RvciA9IENTU1BsdWdpbjtcblx0XHRDU1NQbHVnaW4udmVyc2lvbiA9IFwiMS4xNi4wXCI7XG5cdFx0Q1NTUGx1Z2luLkFQSSA9IDI7XG5cdFx0Q1NTUGx1Z2luLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IDA7XG5cdFx0Q1NTUGx1Z2luLmRlZmF1bHRTa2V3VHlwZSA9IFwiY29tcGVuc2F0ZWRcIjtcblx0XHRwID0gXCJweFwiOyAvL3dlJ2xsIHJldXNlIHRoZSBcInBcIiB2YXJpYWJsZSB0byBrZWVwIGZpbGUgc2l6ZSBkb3duXG5cdFx0Q1NTUGx1Z2luLnN1ZmZpeE1hcCA9IHt0b3A6cCwgcmlnaHQ6cCwgYm90dG9tOnAsIGxlZnQ6cCwgd2lkdGg6cCwgaGVpZ2h0OnAsIGZvbnRTaXplOnAsIHBhZGRpbmc6cCwgbWFyZ2luOnAsIHBlcnNwZWN0aXZlOnAsIGxpbmVIZWlnaHQ6XCJcIn07XG5cblxuXHRcdHZhciBfbnVtRXhwID0gLyg/OlxcZHxcXC1cXGR8XFwuXFxkfFxcLVxcLlxcZCkrL2csXG5cdFx0XHRfcmVsTnVtRXhwID0gLyg/OlxcZHxcXC1cXGR8XFwuXFxkfFxcLVxcLlxcZHxcXCs9XFxkfFxcLT1cXGR8XFwrPS5cXGR8XFwtPVxcLlxcZCkrL2csXG5cdFx0XHRfdmFsdWVzRXhwID0gLyg/OlxcKz18XFwtPXxcXC18XFxiKVtcXGRcXC1cXC5dK1thLXpBLVowLTldKig/OiV8XFxiKS9naSwgLy9maW5kcyBhbGwgdGhlIHZhbHVlcyB0aGF0IGJlZ2luIHdpdGggbnVtYmVycyBvciArPSBvciAtPSBhbmQgdGhlbiBhIG51bWJlci4gSW5jbHVkZXMgc3VmZml4ZXMuIFdlIHVzZSB0aGlzIHRvIHNwbGl0IGNvbXBsZXggdmFsdWVzIGFwYXJ0IGxpa2UgXCIxcHggNXB4IDIwcHggcmdiKDI1NSwxMDIsNTEpXCJcblx0XHRcdF9OYU5FeHAgPSAvKD8hWystXT9cXGQqXFwuP1xcZCt8WystXXxlWystXVxcZCspW14wLTldL2csIC8vYWxzbyBhbGxvd3Mgc2NpZW50aWZpYyBub3RhdGlvbiBhbmQgZG9lc24ndCBraWxsIHRoZSBsZWFkaW5nIC0vKyBpbiAtPSBhbmQgKz1cblx0XHRcdF9zdWZmaXhFeHAgPSAvKD86XFxkfFxcLXxcXCt8PXwjfFxcLikqL2csXG5cdFx0XHRfb3BhY2l0eUV4cCA9IC9vcGFjaXR5ICo9ICooW14pXSopL2ksXG5cdFx0XHRfb3BhY2l0eVZhbEV4cCA9IC9vcGFjaXR5OihbXjtdKikvaSxcblx0XHRcdF9hbHBoYUZpbHRlckV4cCA9IC9hbHBoYVxcKG9wYWNpdHkgKj0uKz9cXCkvaSxcblx0XHRcdF9yZ2Joc2xFeHAgPSAvXihyZ2J8aHNsKS8sXG5cdFx0XHRfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG5cdFx0XHRfY2FtZWxFeHAgPSAvLShbYS16XSkvZ2ksXG5cdFx0XHRfdXJsRXhwID0gLyheKD86dXJsXFwoXFxcInx1cmxcXCgpKXwoPzooXFxcIlxcKSkkfFxcKSQpL2dpLCAvL2ZvciBwdWxsaW5nIG91dCB1cmxzIGZyb20gdXJsKC4uLikgb3IgdXJsKFwiLi4uXCIpIHN0cmluZ3MgKHNvbWUgYnJvd3NlcnMgd3JhcCB1cmxzIGluIHF1b3Rlcywgc29tZSBkb24ndCB3aGVuIHJlcG9ydGluZyB0aGluZ3MgbGlrZSBiYWNrZ3JvdW5kSW1hZ2UpXG5cdFx0XHRfY2FtZWxGdW5jID0gZnVuY3Rpb24ocywgZykgeyByZXR1cm4gZy50b1VwcGVyQ2FzZSgpOyB9LFxuXHRcdFx0X2hvcml6RXhwID0gLyg/OkxlZnR8UmlnaHR8V2lkdGgpL2ksXG5cdFx0XHRfaWVHZXRNYXRyaXhFeHAgPSAvKE0xMXxNMTJ8TTIxfE0yMik9W1xcZFxcLVxcLmVdKy9naSxcblx0XHRcdF9pZVNldE1hdHJpeEV4cCA9IC9wcm9naWRcXDpEWEltYWdlVHJhbnNmb3JtXFwuTWljcm9zb2Z0XFwuTWF0cml4XFwoLis/XFwpL2ksXG5cdFx0XHRfY29tbWFzT3V0c2lkZVBhcmVuRXhwID0gLywoPz1bXlxcKV0qKD86XFwofCQpKS9naSwgLy9maW5kcyBhbnkgY29tbWFzIHRoYXQgYXJlIG5vdCB3aXRoaW4gcGFyZW50aGVzaXNcblx0XHRcdF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcblx0XHRcdF9mb3JjZVBUID0ge30sXG5cdFx0XHRfZG9jID0gZG9jdW1lbnQsXG5cdFx0XHRfY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0cmV0dXJuIF9kb2MuY3JlYXRlRWxlbWVudE5TID8gX2RvYy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsIHR5cGUpIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpO1xuXHRcdFx0fSxcblx0XHRcdF90ZW1wRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdFx0XHRfdGVtcEltZyA9IF9jcmVhdGVFbGVtZW50KFwiaW1nXCIpLFxuXHRcdFx0X2ludGVybmFscyA9IENTU1BsdWdpbi5faW50ZXJuYWxzID0ge19zcGVjaWFsUHJvcHM6X3NwZWNpYWxQcm9wc30sIC8vcHJvdmlkZXMgYSBob29rIHRvIGEgZmV3IGludGVybmFsIG1ldGhvZHMgdGhhdCB3ZSBuZWVkIHRvIGFjY2VzcyBmcm9tIGluc2lkZSBvdGhlciBwbHVnaW5zXG5cdFx0XHRfYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuXHRcdFx0X2F1dG9Sb3VuZCxcblx0XHRcdF9yZXFTYWZhcmlGaXgsIC8vd2Ugd29uJ3QgYXBwbHkgdGhlIFNhZmFyaSB0cmFuc2Zvcm0gZml4IHVudGlsIHdlIGFjdHVhbGx5IGNvbWUgYWNyb3NzIGEgdHdlZW4gdGhhdCBhZmZlY3RzIGEgdHJhbnNmb3JtIHByb3BlcnR5ICh0byBtYWludGFpbiBiZXN0IHBlcmZvcm1hbmNlKS5cblxuXHRcdFx0X2lzU2FmYXJpLFxuXHRcdFx0X2lzRmlyZWZveCwgLy9GaXJlZm94IGhhcyBhIGJ1ZyB0aGF0IGNhdXNlcyAzRCB0cmFuc2Zvcm1lZCBlbGVtZW50cyB0byByYW5kb21seSBkaXNhcHBlYXIgdW5sZXNzIGEgcmVwYWludCBpcyBmb3JjZWQgYWZ0ZXIgZWFjaCB1cGRhdGUgb24gZWFjaCBlbGVtZW50LlxuXHRcdFx0X2lzU2FmYXJpTFQ2LCAvL1NhZmFyaSAoYW5kIEFuZHJvaWQgNCB3aGljaCB1c2VzIGEgZmxhdm9yIG9mIFNhZmFyaSkgaGFzIGEgYnVnIHRoYXQgcHJldmVudHMgY2hhbmdlcyB0byBcInRvcFwiIGFuZCBcImxlZnRcIiBwcm9wZXJ0aWVzIGZyb20gcmVuZGVyaW5nIHByb3Blcmx5IGlmIGNoYW5nZWQgb24gdGhlIHNhbWUgZnJhbWUgYXMgYSB0cmFuc2Zvcm0gVU5MRVNTIHdlIHNldCB0aGUgZWxlbWVudCdzIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSB0byBoaWRkZW4gKHdlaXJkLCBJIGtub3cpLiBEb2luZyB0aGlzIGZvciBBbmRyb2lkIDMgYW5kIGVhcmxpZXIgc2VlbXMgdG8gYWN0dWFsbHkgY2F1c2Ugb3RoZXIgcHJvYmxlbXMsIHRob3VnaCAoZnVuISlcblx0XHRcdF9pZVZlcnMsXG5cdFx0XHRfc3VwcG9ydHNPcGFjaXR5ID0gKGZ1bmN0aW9uKCkgeyAvL3dlIHNldCBfaXNTYWZhcmksIF9pZVZlcnMsIF9pc0ZpcmVmb3gsIGFuZCBfc3VwcG9ydHNPcGFjaXR5IGFsbCBpbiBvbmUgZnVuY3Rpb24gaGVyZSB0byByZWR1Y2UgZmlsZSBzaXplIHNsaWdodGx5LCBlc3BlY2lhbGx5IGluIHRoZSBtaW5pZmllZCB2ZXJzaW9uLlxuXHRcdFx0XHR2YXIgaSA9IF9hZ2VudC5pbmRleE9mKFwiQW5kcm9pZFwiKSxcblx0XHRcdFx0XHRhID0gX2NyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdFx0XHRfaXNTYWZhcmkgPSAoX2FnZW50LmluZGV4T2YoXCJTYWZhcmlcIikgIT09IC0xICYmIF9hZ2VudC5pbmRleE9mKFwiQ2hyb21lXCIpID09PSAtMSAmJiAoaSA9PT0gLTEgfHwgTnVtYmVyKF9hZ2VudC5zdWJzdHIoaSs4LCAxKSkgPiAzKSk7XG5cdFx0XHRcdF9pc1NhZmFyaUxUNiA9IChfaXNTYWZhcmkgJiYgKE51bWJlcihfYWdlbnQuc3Vic3RyKF9hZ2VudC5pbmRleE9mKFwiVmVyc2lvbi9cIikrOCwgMSkpIDwgNikpO1xuXHRcdFx0XHRfaXNGaXJlZm94ID0gKF9hZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSAhPT0gLTEpO1xuXHRcdFx0XHRpZiAoKC9NU0lFIChbMC05XXsxLH1bXFwuMC05XXswLH0pLykuZXhlYyhfYWdlbnQpIHx8ICgvVHJpZGVudFxcLy4qcnY6KFswLTldezEsfVtcXC4wLTldezAsfSkvKS5leGVjKF9hZ2VudCkpIHtcblx0XHRcdFx0XHRfaWVWZXJzID0gcGFyc2VGbG9hdCggUmVnRXhwLiQxICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFhKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGEuc3R5bGUuY3NzVGV4dCA9IFwidG9wOjFweDtvcGFjaXR5Oi41NTtcIjtcblx0XHRcdFx0cmV0dXJuIC9eMC41NS8udGVzdChhLnN0eWxlLm9wYWNpdHkpO1xuXHRcdFx0fSgpKSxcblx0XHRcdF9nZXRJRU9wYWNpdHkgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHJldHVybiAoX29wYWNpdHlFeHAudGVzdCggKCh0eXBlb2YodikgPT09IFwic3RyaW5nXCIpID8gdiA6ICh2LmN1cnJlbnRTdHlsZSA/IHYuY3VycmVudFN0eWxlLmZpbHRlciA6IHYuc3R5bGUuZmlsdGVyKSB8fCBcIlwiKSApID8gKCBwYXJzZUZsb2F0KCBSZWdFeHAuJDEgKSAvIDEwMCApIDogMSk7XG5cdFx0XHR9LFxuXHRcdFx0X2xvZyA9IGZ1bmN0aW9uKHMpIHsvL2ZvciBsb2dnaW5nIG1lc3NhZ2VzLCBidXQgaW4gYSB3YXkgdGhhdCB3b24ndCB0aHJvdyBlcnJvcnMgaW4gb2xkIHZlcnNpb25zIG9mIElFLlxuXHRcdFx0XHRpZiAod2luZG93LmNvbnNvbGUpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X3ByZWZpeENTUyA9IFwiXCIsIC8vdGhlIG5vbi1jYW1lbENhc2UgdmVuZG9yIHByZWZpeCBsaWtlIFwiLW8tXCIsIFwiLW1vei1cIiwgXCItbXMtXCIsIG9yIFwiLXdlYmtpdC1cIlxuXHRcdFx0X3ByZWZpeCA9IFwiXCIsIC8vY2FtZWxDYXNlIHZlbmRvciBwcmVmaXggbGlrZSBcIk9cIiwgXCJtc1wiLCBcIldlYmtpdFwiLCBvciBcIk1velwiLlxuXG5cdFx0XHQvLyBAcHJpdmF0ZSBmZWVkIGluIGEgY2FtZWxDYXNlIHByb3BlcnR5IG5hbWUgbGlrZSBcInRyYW5zZm9ybVwiIGFuZCBpdCB3aWxsIGNoZWNrIHRvIHNlZSBpZiBpdCBpcyB2YWxpZCBhcy1pcyBvciBpZiBpdCBuZWVkcyBhIHZlbmRvciBwcmVmaXguIEl0IHJldHVybnMgdGhlIGNvcnJlY3RlZCBjYW1lbENhc2UgcHJvcGVydHkgbmFtZSAoaS5lLiBcIldlYmtpdFRyYW5zZm9ybVwiIG9yIFwiTW96VHJhbnNmb3JtXCIgb3IgXCJ0cmFuc2Zvcm1cIiBvciBudWxsIGlmIG5vIHN1Y2ggcHJvcGVydHkgaXMgZm91bmQsIGxpa2UgaWYgdGhlIGJyb3dzZXIgaXMgSUU4IG9yIGJlZm9yZSwgXCJ0cmFuc2Zvcm1cIiB3b24ndCBiZSBmb3VuZCBhdCBhbGwpXG5cdFx0XHRfY2hlY2tQcm9wUHJlZml4ID0gZnVuY3Rpb24ocCwgZSkge1xuXHRcdFx0XHRlID0gZSB8fCBfdGVtcERpdjtcblx0XHRcdFx0dmFyIHMgPSBlLnN0eWxlLFxuXHRcdFx0XHRcdGEsIGk7XG5cdFx0XHRcdGlmIChzW3BdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwID0gcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHAuc3Vic3RyKDEpO1xuXHRcdFx0XHRhID0gW1wiT1wiLFwiTW96XCIsXCJtc1wiLFwiTXNcIixcIldlYmtpdFwiXTtcblx0XHRcdFx0aSA9IDU7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSAmJiBzW2FbaV0rcF0gPT09IHVuZGVmaW5lZCkgeyB9XG5cdFx0XHRcdGlmIChpID49IDApIHtcblx0XHRcdFx0XHRfcHJlZml4ID0gKGkgPT09IDMpID8gXCJtc1wiIDogYVtpXTtcblx0XHRcdFx0XHRfcHJlZml4Q1NTID0gXCItXCIgKyBfcHJlZml4LnRvTG93ZXJDYXNlKCkgKyBcIi1cIjtcblx0XHRcdFx0XHRyZXR1cm4gX3ByZWZpeCArIHA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9LFxuXG5cdFx0XHRfZ2V0Q29tcHV0ZWRTdHlsZSA9IF9kb2MuZGVmYXVsdFZpZXcgPyBfZG9jLmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUgOiBmdW5jdGlvbigpIHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFJldHVybnMgdGhlIGNzcyBzdHlsZSBmb3IgYSBwYXJ0aWN1bGFyIHByb3BlcnR5IG9mIGFuIGVsZW1lbnQuIEZvciBleGFtcGxlLCB0byBnZXQgd2hhdGV2ZXIgdGhlIGN1cnJlbnQgXCJsZWZ0XCIgY3NzIHZhbHVlIGZvciBhbiBlbGVtZW50IHdpdGggYW4gSUQgb2YgXCJteUVsZW1lbnRcIiwgeW91IGNvdWxkIGRvOlxuXHRcdFx0ICogdmFyIGN1cnJlbnRMZWZ0ID0gQ1NTUGx1Z2luLmdldFN0eWxlKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15RWxlbWVudFwiKSwgXCJsZWZ0XCIpO1xuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgZWxlbWVudCB3aG9zZSBzdHlsZSBwcm9wZXJ0eSB5b3Ugd2FudCB0byBxdWVyeVxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKGxpa2UgXCJsZWZ0XCIgb3IgXCJ0b3BcIiBvciBcIm1hcmdpblRvcFwiLCBldGMuKVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBjcyBDb21wdXRlZCBzdHlsZSBvYmplY3QuIFRoaXMganVzdCBwcm92aWRlcyBhIHdheSB0byBzcGVlZCBwcm9jZXNzaW5nIGlmIHlvdSdyZSBnb2luZyB0byBnZXQgc2V2ZXJhbCBwcm9wZXJ0aWVzIG9uIHRoZSBzYW1lIGVsZW1lbnQgaW4gcXVpY2sgc3VjY2Vzc2lvbiAtIHlvdSBjYW4gcmV1c2UgdGhlIHJlc3VsdCBvZiB0aGUgZ2V0Q29tcHV0ZWRTdHlsZSgpIGNhbGwuXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBjYWxjIElmIHRydWUsIHRoZSB2YWx1ZSB3aWxsIG5vdCBiZSByZWFkIGRpcmVjdGx5IGZyb20gdGhlIGVsZW1lbnQncyBcInN0eWxlXCIgcHJvcGVydHkgKGlmIGl0IGV4aXN0cyB0aGVyZSksIGJ1dCBpbnN0ZWFkIHRoZSBnZXRDb21wdXRlZFN0eWxlKCkgcmVzdWx0IHdpbGwgYmUgdXNlZC4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgdGhlIGJyb3dzZXIgaXRzZWxmIGlzIGludGVycHJldGluZyB0aGUgdmFsdWUuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IGRmbHQgRGVmYXVsdCB2YWx1ZSB0aGF0IHNob3VsZCBiZSByZXR1cm5lZCBpbiB0aGUgcGxhY2Ugb2YgbnVsbCwgXCJub25lXCIsIFwiYXV0b1wiIG9yIFwiYXV0byBhdXRvXCIuXG5cdFx0XHQgKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgY3VycmVudCBwcm9wZXJ0eSB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHRfZ2V0U3R5bGUgPSBDU1NQbHVnaW4uZ2V0U3R5bGUgPSBmdW5jdGlvbih0LCBwLCBjcywgY2FsYywgZGZsdCkge1xuXHRcdFx0XHR2YXIgcnY7XG5cdFx0XHRcdGlmICghX3N1cHBvcnRzT3BhY2l0eSkgaWYgKHAgPT09IFwib3BhY2l0eVwiKSB7IC8vc2V2ZXJhbCB2ZXJzaW9ucyBvZiBJRSBkb24ndCB1c2UgdGhlIHN0YW5kYXJkIFwib3BhY2l0eVwiIHByb3BlcnR5IC0gdGhleSB1c2UgdGhpbmdzIGxpa2UgZmlsdGVyOmFscGhhKG9wYWNpdHk9NTApLCBzbyB3ZSBwYXJzZSB0aGF0IGhlcmUuXG5cdFx0XHRcdFx0cmV0dXJuIF9nZXRJRU9wYWNpdHkodCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFjYWxjICYmIHQuc3R5bGVbcF0pIHtcblx0XHRcdFx0XHRydiA9IHQuc3R5bGVbcF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoKGNzID0gY3MgfHwgX2dldENvbXB1dGVkU3R5bGUodCkpKSB7XG5cdFx0XHRcdFx0cnYgPSBjc1twXSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHApIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocC5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0LmN1cnJlbnRTdHlsZSkge1xuXHRcdFx0XHRcdHJ2ID0gdC5jdXJyZW50U3R5bGVbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIChkZmx0ICE9IG51bGwgJiYgKCFydiB8fCBydiA9PT0gXCJub25lXCIgfHwgcnYgPT09IFwiYXV0b1wiIHx8IHJ2ID09PSBcImF1dG8gYXV0b1wiKSkgPyBkZmx0IDogcnY7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFBhc3MgdGhlIHRhcmdldCBlbGVtZW50LCB0aGUgcHJvcGVydHkgbmFtZSwgdGhlIG51bWVyaWMgdmFsdWUsIGFuZCB0aGUgc3VmZml4IChsaWtlIFwiJVwiLCBcImVtXCIsIFwicHhcIiwgZXRjLikgYW5kIGl0IHdpbGwgc3BpdCBiYWNrIHRoZSBlcXVpdmFsZW50IHBpeGVsIG51bWJlci5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKGxpa2UgXCJsZWZ0XCIsIFwidG9wXCIsIFwibWFyZ2luTGVmdFwiLCBldGMuKVxuXHRcdFx0ICogQHBhcmFtIHshbnVtYmVyfSB2IFZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IHNmeCBTdWZmaXggKGxpa2UgXCJweFwiIG9yIFwiJVwiIG9yIFwiZW1cIilcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlY3Vyc2UgSWYgdHJ1ZSwgdGhlIGNhbGwgaXMgYSByZWN1cnNpdmUgb25lLiBJbiBzb21lIGJyb3dzZXJzIChsaWtlIElFNy84KSwgb2NjYXNpb25hbGx5IHRoZSB2YWx1ZSBpc24ndCBhY2N1cmF0ZWx5IHJlcG9ydGVkIGluaXRpYWxseSwgYnV0IGlmIHdlIHJ1biB0aGUgZnVuY3Rpb24gYWdhaW4gaXQgd2lsbCB0YWtlIGVmZmVjdC5cblx0XHRcdCAqIEByZXR1cm4ge251bWJlcn0gdmFsdWUgaW4gcGl4ZWxzXG5cdFx0XHQgKi9cblx0XHRcdF9jb252ZXJ0VG9QaXhlbHMgPSBfaW50ZXJuYWxzLmNvbnZlcnRUb1BpeGVscyA9IGZ1bmN0aW9uKHQsIHAsIHYsIHNmeCwgcmVjdXJzZSkge1xuXHRcdFx0XHRpZiAoc2Z4ID09PSBcInB4XCIgfHwgIXNmeCkgeyByZXR1cm4gdjsgfVxuXHRcdFx0XHRpZiAoc2Z4ID09PSBcImF1dG9cIiB8fCAhdikgeyByZXR1cm4gMDsgfVxuXHRcdFx0XHR2YXIgaG9yaXogPSBfaG9yaXpFeHAudGVzdChwKSxcblx0XHRcdFx0XHRub2RlID0gdCxcblx0XHRcdFx0XHRzdHlsZSA9IF90ZW1wRGl2LnN0eWxlLFxuXHRcdFx0XHRcdG5lZyA9ICh2IDwgMCksXG5cdFx0XHRcdFx0cGl4LCBjYWNoZSwgdGltZTtcblx0XHRcdFx0aWYgKG5lZykge1xuXHRcdFx0XHRcdHYgPSAtdjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc2Z4ID09PSBcIiVcIiAmJiBwLmluZGV4T2YoXCJib3JkZXJcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0cGl4ID0gKHYgLyAxMDApICogKGhvcml6ID8gdC5jbGllbnRXaWR0aCA6IHQuY2xpZW50SGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MCBzb2xpZCByZWQ7cG9zaXRpb246XCIgKyBfZ2V0U3R5bGUodCwgXCJwb3NpdGlvblwiKSArIFwiO2xpbmUtaGVpZ2h0OjA7XCI7XG5cdFx0XHRcdFx0aWYgKHNmeCA9PT0gXCIlXCIgfHwgIW5vZGUuYXBwZW5kQ2hpbGQpIHtcblx0XHRcdFx0XHRcdG5vZGUgPSB0LnBhcmVudE5vZGUgfHwgX2RvYy5ib2R5O1xuXHRcdFx0XHRcdFx0Y2FjaGUgPSBub2RlLl9nc0NhY2hlO1xuXHRcdFx0XHRcdFx0dGltZSA9IFR3ZWVuTGl0ZS50aWNrZXIuZnJhbWU7XG5cdFx0XHRcdFx0XHRpZiAoY2FjaGUgJiYgaG9yaXogJiYgY2FjaGUudGltZSA9PT0gdGltZSkgeyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogd2UgcmVjb3JkIHRoZSB3aWR0aCBvZiBlbGVtZW50cyBhbG9uZyB3aXRoIHRoZSB0aWNrZXIgZnJhbWUgc28gdGhhdCB3ZSBjYW4gcXVpY2tseSBnZXQgaXQgYWdhaW4gb24gdGhlIHNhbWUgdGljayAoc2VlbXMgcmVsYXRpdmVseSBzYWZlIHRvIGFzc3VtZSBpdCB3b3VsZG4ndCBjaGFuZ2Ugb24gdGhlIHNhbWUgdGljaylcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNhY2hlLndpZHRoICogdiAvIDEwMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0eWxlWyhob3JpeiA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIpXSA9IHYgKyBzZng7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0eWxlWyhob3JpeiA/IFwiYm9yZGVyTGVmdFdpZHRoXCIgOiBcImJvcmRlclRvcFdpZHRoXCIpXSA9IHYgKyBzZng7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0XHRcdHBpeCA9IHBhcnNlRmxvYXQoX3RlbXBEaXZbKGhvcml6ID8gXCJvZmZzZXRXaWR0aFwiIDogXCJvZmZzZXRIZWlnaHRcIildKTtcblx0XHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKF90ZW1wRGl2KTtcblx0XHRcdFx0XHRpZiAoaG9yaXogJiYgc2Z4ID09PSBcIiVcIiAmJiBDU1NQbHVnaW4uY2FjaGVXaWR0aHMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRjYWNoZSA9IG5vZGUuX2dzQ2FjaGUgPSBub2RlLl9nc0NhY2hlIHx8IHt9O1xuXHRcdFx0XHRcdFx0Y2FjaGUudGltZSA9IHRpbWU7XG5cdFx0XHRcdFx0XHRjYWNoZS53aWR0aCA9IHBpeCAvIHYgKiAxMDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwaXggPT09IDAgJiYgIXJlY3Vyc2UpIHtcblx0XHRcdFx0XHRcdHBpeCA9IF9jb252ZXJ0VG9QaXhlbHModCwgcCwgdiwgc2Z4LCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5lZyA/IC1waXggOiBwaXg7XG5cdFx0XHR9LFxuXHRcdFx0X2NhbGN1bGF0ZU9mZnNldCA9IF9pbnRlcm5hbHMuY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24odCwgcCwgY3MpIHsgLy9mb3IgZmlndXJpbmcgb3V0IFwidG9wXCIgb3IgXCJsZWZ0XCIgaW4gcHggd2hlbiBpdCdzIFwiYXV0b1wiLiBXZSBuZWVkIHRvIGZhY3RvciBpbiBtYXJnaW4gd2l0aCB0aGUgb2Zmc2V0TGVmdC9vZmZzZXRUb3Bcblx0XHRcdFx0aWYgKF9nZXRTdHlsZSh0LCBcInBvc2l0aW9uXCIsIGNzKSAhPT0gXCJhYnNvbHV0ZVwiKSB7IHJldHVybiAwOyB9XG5cdFx0XHRcdHZhciBkaW0gPSAoKHAgPT09IFwibGVmdFwiKSA/IFwiTGVmdFwiIDogXCJUb3BcIiksXG5cdFx0XHRcdFx0diA9IF9nZXRTdHlsZSh0LCBcIm1hcmdpblwiICsgZGltLCBjcyk7XG5cdFx0XHRcdHJldHVybiB0W1wib2Zmc2V0XCIgKyBkaW1dIC0gKF9jb252ZXJ0VG9QaXhlbHModCwgcCwgcGFyc2VGbG9hdCh2KSwgdi5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpKSB8fCAwKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBwcml2YXRlIHJldHVybnMgYXQgb2JqZWN0IGNvbnRhaW5pbmcgQUxMIG9mIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGluIGNhbWVsQ2FzZSBhbmQgdGhlaXIgYXNzb2NpYXRlZCB2YWx1ZXMuXG5cdFx0XHRfZ2V0QWxsU3R5bGVzID0gZnVuY3Rpb24odCwgY3MpIHtcblx0XHRcdFx0dmFyIHMgPSB7fSxcblx0XHRcdFx0XHRpLCB0ciwgcDtcblx0XHRcdFx0aWYgKChjcyA9IGNzIHx8IF9nZXRDb21wdXRlZFN0eWxlKHQsIG51bGwpKSkge1xuXHRcdFx0XHRcdGlmICgoaSA9IGNzLmxlbmd0aCkpIHtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRwID0gY3NbaV07XG5cdFx0XHRcdFx0XHRcdGlmIChwLmluZGV4T2YoXCItdHJhbnNmb3JtXCIpID09PSAtMSB8fCBfdHJhbnNmb3JtUHJvcENTUyA9PT0gcCkgeyAvL1NvbWUgd2Via2l0IGJyb3dzZXJzIGR1cGxpY2F0ZSB0cmFuc2Zvcm0gdmFsdWVzLCBvbmUgbm9uLXByZWZpeGVkIGFuZCBvbmUgcHJlZml4ZWQgKFwidHJhbnNmb3JtXCIgYW5kIFwiV2Via2l0VHJhbnNmb3JtXCIpLCBzbyB3ZSBtdXN0IHdlZWQgb3V0IHRoZSBleHRyYSBvbmUgaGVyZS5cblx0XHRcdFx0XHRcdFx0XHRzW3AucmVwbGFjZShfY2FtZWxFeHAsIF9jYW1lbEZ1bmMpXSA9IGNzLmdldFByb3BlcnR5VmFsdWUocCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgeyAvL3NvbWUgYnJvd3NlcnMgYmVoYXZlIGRpZmZlcmVudGx5IC0gY3MubGVuZ3RoIGlzIGFsd2F5cyAwLCBzbyB3ZSBtdXN0IGRvIGEgZm9yLi4uaW4gbG9vcC5cblx0XHRcdFx0XHRcdGZvciAoaSBpbiBjcykge1xuXHRcdFx0XHRcdFx0XHRpZiAoaS5pbmRleE9mKFwiVHJhbnNmb3JtXCIpID09PSAtMSB8fCBfdHJhbnNmb3JtUHJvcCA9PT0gaSkgeyAvL1NvbWUgd2Via2l0IGJyb3dzZXJzIGR1cGxpY2F0ZSB0cmFuc2Zvcm0gdmFsdWVzLCBvbmUgbm9uLXByZWZpeGVkIGFuZCBvbmUgcHJlZml4ZWQgKFwidHJhbnNmb3JtXCIgYW5kIFwiV2Via2l0VHJhbnNmb3JtXCIpLCBzbyB3ZSBtdXN0IHdlZWQgb3V0IHRoZSBleHRyYSBvbmUgaGVyZS5cblx0XHRcdFx0XHRcdFx0XHRzW2ldID0gY3NbaV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoKGNzID0gdC5jdXJyZW50U3R5bGUgfHwgdC5zdHlsZSkpIHtcblx0XHRcdFx0XHRmb3IgKGkgaW4gY3MpIHtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YoaSkgPT09IFwic3RyaW5nXCIgJiYgc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdHNbaS5yZXBsYWNlKF9jYW1lbEV4cCwgX2NhbWVsRnVuYyldID0gY3NbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghX3N1cHBvcnRzT3BhY2l0eSkge1xuXHRcdFx0XHRcdHMub3BhY2l0eSA9IF9nZXRJRU9wYWNpdHkodCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHIgPSBfZ2V0VHJhbnNmb3JtKHQsIGNzLCBmYWxzZSk7XG5cdFx0XHRcdHMucm90YXRpb24gPSB0ci5yb3RhdGlvbjtcblx0XHRcdFx0cy5za2V3WCA9IHRyLnNrZXdYO1xuXHRcdFx0XHRzLnNjYWxlWCA9IHRyLnNjYWxlWDtcblx0XHRcdFx0cy5zY2FsZVkgPSB0ci5zY2FsZVk7XG5cdFx0XHRcdHMueCA9IHRyLng7XG5cdFx0XHRcdHMueSA9IHRyLnk7XG5cdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdHMueiA9IHRyLno7XG5cdFx0XHRcdFx0cy5yb3RhdGlvblggPSB0ci5yb3RhdGlvblg7XG5cdFx0XHRcdFx0cy5yb3RhdGlvblkgPSB0ci5yb3RhdGlvblk7XG5cdFx0XHRcdFx0cy5zY2FsZVogPSB0ci5zY2FsZVo7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHMuZmlsdGVycykge1xuXHRcdFx0XHRcdGRlbGV0ZSBzLmZpbHRlcnM7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAcHJpdmF0ZSBhbmFseXplcyB0d28gc3R5bGUgb2JqZWN0cyAoYXMgcmV0dXJuZWQgYnkgX2dldEFsbFN0eWxlcygpKSBhbmQgb25seSBsb29rcyBmb3IgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGVtIHRoYXQgY29udGFpbiB0d2VlbmFibGUgdmFsdWVzIChsaWtlIGEgbnVtYmVyIG9yIGNvbG9yKS4gSXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIFwiZGlmc1wiIHByb3BlcnR5IHdoaWNoIHJlZmVycyB0byBhbiBvYmplY3QgY29udGFpbmluZyBvbmx5IHRob3NlIGlzb2xhdGVkIHByb3BlcnRpZXMgYW5kIHZhbHVlcyBmb3IgdHdlZW5pbmcsIGFuZCBhIFwiZmlyc3RNUFRcIiBwcm9wZXJ0eSB3aGljaCByZWZlcnMgdG8gdGhlIGZpcnN0IE1pbmlQcm9wVHdlZW4gaW5zdGFuY2UgaW4gYSBsaW5rZWQgbGlzdCB0aGF0IHJlY29yZGVkIGFsbCB0aGUgc3RhcnRpbmcgdmFsdWVzIG9mIHRoZSBkaWZmZXJlbnQgcHJvcGVydGllcyBzbyB0aGF0IHdlIGNhbiByZXZlcnQgdG8gdGhlbSBhdCB0aGUgZW5kIG9yIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gLSB3ZSBkb24ndCB3YW50IHRoZSBjYXNjYWRpbmcgdG8gZ2V0IG1lc3NlZCB1cC4gVGhlIGZvcmNlTG9va3VwIHBhcmFtZXRlciBpcyBhbiBvcHRpb25hbCBnZW5lcmljIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgZm9yY2VkIGludG8gdGhlIHJlc3VsdHMgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY2xhc3NOYW1lIHR3ZWVucyB0aGF0IGFyZSBvdmVyd3JpdGluZyBvdGhlcnMgYmVjYXVzZSBpbWFnaW5lIGEgc2NlbmFyaW8gd2hlcmUgYSByb2xsb3Zlci9yb2xsb3V0IGFkZHMvcmVtb3ZlcyBhIGNsYXNzIGFuZCB0aGUgdXNlciBzd2lwZXMgdGhlIG1vdXNlIG92ZXIgdGhlIHRhcmdldCBTVVBFUiBmYXN0LCB0aHVzIG5vdGhpbmcgYWN0dWFsbHkgY2hhbmdlZCB5ZXQgYW5kIHRoZSBzdWJzZXF1ZW50IGNvbXBhcmlzb24gb2YgdGhlIHByb3BlcnRpZXMgd291bGQgaW5kaWNhdGUgdGhleSBtYXRjaCAoZXNwZWNpYWxseSB3aGVuIHB4IHJvdW5kaW5nIGlzIHRha2VuIGludG8gY29uc2lkZXJhdGlvbiksIHRodXMgbm8gdHdlZW5pbmcgaXMgbmVjZXNzYXJ5IGV2ZW4gdGhvdWdoIGl0IFNIT1VMRCB0d2VlbiBhbmQgcmVtb3ZlIHRob3NlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIHR3ZWVuIChvdGhlcndpc2UgdGhlIGlubGluZSBzdHlsZXMgd2lsbCBjb250YW1pbmF0ZSB0aGluZ3MpLiBTZWUgdGhlIGNsYXNzTmFtZSBTcGVjaWFsUHJvcCBjb2RlIGZvciBkZXRhaWxzLlxuXHRcdFx0X2Nzc0RpZiA9IGZ1bmN0aW9uKHQsIHMxLCBzMiwgdmFycywgZm9yY2VMb29rdXApIHtcblx0XHRcdFx0dmFyIGRpZnMgPSB7fSxcblx0XHRcdFx0XHRzdHlsZSA9IHQuc3R5bGUsXG5cdFx0XHRcdFx0dmFsLCBwLCBtcHQ7XG5cdFx0XHRcdGZvciAocCBpbiBzMikge1xuXHRcdFx0XHRcdGlmIChwICE9PSBcImNzc1RleHRcIikgaWYgKHAgIT09IFwibGVuZ3RoXCIpIGlmIChpc05hTihwKSkgaWYgKHMxW3BdICE9PSAodmFsID0gczJbcF0pIHx8IChmb3JjZUxvb2t1cCAmJiBmb3JjZUxvb2t1cFtwXSkpIGlmIChwLmluZGV4T2YoXCJPcmlnaW5cIikgPT09IC0xKSBpZiAodHlwZW9mKHZhbCkgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mKHZhbCkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdGRpZnNbcF0gPSAodmFsID09PSBcImF1dG9cIiAmJiAocCA9PT0gXCJsZWZ0XCIgfHwgcCA9PT0gXCJ0b3BcIikpID8gX2NhbGN1bGF0ZU9mZnNldCh0LCBwKSA6ICgodmFsID09PSBcIlwiIHx8IHZhbCA9PT0gXCJhdXRvXCIgfHwgdmFsID09PSBcIm5vbmVcIikgJiYgdHlwZW9mKHMxW3BdKSA9PT0gXCJzdHJpbmdcIiAmJiBzMVtwXS5yZXBsYWNlKF9OYU5FeHAsIFwiXCIpICE9PSBcIlwiKSA/IDAgOiB2YWw7IC8vaWYgdGhlIGVuZGluZyB2YWx1ZSBpcyBkZWZhdWx0aW5nIChcIlwiIG9yIFwiYXV0b1wiKSwgd2UgY2hlY2sgdGhlIHN0YXJ0aW5nIHZhbHVlIGFuZCBpZiBpdCBjYW4gYmUgcGFyc2VkIGludG8gYSBudW1iZXIgKGEgc3RyaW5nIHdoaWNoIGNvdWxkIGhhdmUgYSBzdWZmaXggdG9vLCBsaWtlIDcwMHB4KSwgdGhlbiB3ZSBzd2FwIGluIDAgZm9yIFwiXCIgb3IgXCJhdXRvXCIgc28gdGhhdCB0aGluZ3MgYWN0dWFsbHkgdHdlZW4uXG5cdFx0XHRcdFx0XHRpZiAoc3R5bGVbcF0gIT09IHVuZGVmaW5lZCkgeyAvL2ZvciBjbGFzc05hbWUgdHdlZW5zLCB3ZSBtdXN0IHJlbWVtYmVyIHdoaWNoIHByb3BlcnRpZXMgYWxyZWFkeSBleGlzdGVkIGlubGluZSAtIHRoZSBvbmVzIHRoYXQgZGlkbid0IHNob3VsZCBiZSByZW1vdmVkIHdoZW4gdGhlIHR3ZWVuIGlzbid0IGluIHByb2dyZXNzIGJlY2F1c2UgdGhleSB3ZXJlIG9ubHkgaW50cm9kdWNlZCB0byBmYWNpbGl0YXRlIHRoZSB0cmFuc2l0aW9uIGJldHdlZW4gY2xhc3Nlcy5cblx0XHRcdFx0XHRcdFx0bXB0ID0gbmV3IE1pbmlQcm9wVHdlZW4oc3R5bGUsIHAsIHN0eWxlW3BdLCBtcHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodmFycykge1xuXHRcdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7IC8vY29weSBwcm9wZXJ0aWVzIChleGNlcHQgY2xhc3NOYW1lKVxuXHRcdFx0XHRcdFx0aWYgKHAgIT09IFwiY2xhc3NOYW1lXCIpIHtcblx0XHRcdFx0XHRcdFx0ZGlmc1twXSA9IHZhcnNbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7ZGlmczpkaWZzLCBmaXJzdE1QVDptcHR9O1xuXHRcdFx0fSxcblx0XHRcdF9kaW1lbnNpb25zID0ge3dpZHRoOltcIkxlZnRcIixcIlJpZ2h0XCJdLCBoZWlnaHQ6W1wiVG9wXCIsXCJCb3R0b21cIl19LFxuXHRcdFx0X21hcmdpbnMgPSBbXCJtYXJnaW5MZWZ0XCIsXCJtYXJnaW5SaWdodFwiLFwibWFyZ2luVG9wXCIsXCJtYXJnaW5Cb3R0b21cIl0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgR2V0cyB0aGUgd2lkdGggb3IgaGVpZ2h0IG9mIGFuIGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWUgKFwid2lkdGhcIiBvciBcImhlaWdodFwiKVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBjcyBDb21wdXRlZCBzdHlsZSBvYmplY3QgKGlmIG9uZSBleGlzdHMpLiBKdXN0IGEgc3BlZWQgb3B0aW1pemF0aW9uLlxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSBEaW1lbnNpb24gKGluIHBpeGVscylcblx0XHRcdCAqL1xuXHRcdFx0X2dldERpbWVuc2lvbiA9IGZ1bmN0aW9uKHQsIHAsIGNzKSB7XG5cdFx0XHRcdHZhciB2ID0gcGFyc2VGbG9hdCgocCA9PT0gXCJ3aWR0aFwiKSA/IHQub2Zmc2V0V2lkdGggOiB0Lm9mZnNldEhlaWdodCksXG5cdFx0XHRcdFx0YSA9IF9kaW1lbnNpb25zW3BdLFxuXHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0Y3MgPSBjcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0LCBudWxsKTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0diAtPSBwYXJzZUZsb2F0KCBfZ2V0U3R5bGUodCwgXCJwYWRkaW5nXCIgKyBhW2ldLCBjcywgdHJ1ZSkgKSB8fCAwO1xuXHRcdFx0XHRcdHYgLT0gcGFyc2VGbG9hdCggX2dldFN0eWxlKHQsIFwiYm9yZGVyXCIgKyBhW2ldICsgXCJXaWR0aFwiLCBjcywgdHJ1ZSkgKSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHByaXZhdGUgUGFyc2VzIHBvc2l0aW9uLXJlbGF0ZWQgY29tcGxleCBzdHJpbmdzIGxpa2UgXCJ0b3AgbGVmdFwiIG9yIFwiNTBweCAxMHB4XCIgb3IgXCI3MCUgMjAlXCIsIGV0Yy4gd2hpY2ggYXJlIHVzZWQgZm9yIHRoaW5ncyBsaWtlIHRyYW5zZm9ybU9yaWdpbiBvciBiYWNrZ3JvdW5kUG9zaXRpb24uIE9wdGlvbmFsbHkgZGVjb3JhdGVzIGEgc3VwcGxpZWQgb2JqZWN0IChyZWNPYmopIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiBcIm94XCIgKG9mZnNldFgpLCBcIm95XCIgKG9mZnNldFkpLCBcIm94cFwiIChpZiB0cnVlLCBcIm94XCIgaXMgYSBwZXJjZW50YWdlIG5vdCBhIHBpeGVsIHZhbHVlKSwgYW5kIFwib3h5XCIgKGlmIHRydWUsIFwib3lcIiBpcyBhIHBlcmNlbnRhZ2Ugbm90IGEgcGl4ZWwgdmFsdWUpXG5cdFx0XHRfcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uKHYsIHJlY09iaikge1xuXHRcdFx0XHRpZiAodiA9PSBudWxsIHx8IHYgPT09IFwiXCIgfHwgdiA9PT0gXCJhdXRvXCIgfHwgdiA9PT0gXCJhdXRvIGF1dG9cIikgeyAvL25vdGU6IEZpcmVmb3ggdXNlcyBcImF1dG8gYXV0b1wiIGFzIGRlZmF1bHQgd2hlcmVhcyBDaHJvbWUgdXNlcyBcImF1dG9cIi5cblx0XHRcdFx0XHR2ID0gXCIwIDBcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgYSA9IHYuc3BsaXQoXCIgXCIpLFxuXHRcdFx0XHRcdHggPSAodi5pbmRleE9mKFwibGVmdFwiKSAhPT0gLTEpID8gXCIwJVwiIDogKHYuaW5kZXhPZihcInJpZ2h0XCIpICE9PSAtMSkgPyBcIjEwMCVcIiA6IGFbMF0sXG5cdFx0XHRcdFx0eSA9ICh2LmluZGV4T2YoXCJ0b3BcIikgIT09IC0xKSA/IFwiMCVcIiA6ICh2LmluZGV4T2YoXCJib3R0b21cIikgIT09IC0xKSA/IFwiMTAwJVwiIDogYVsxXTtcblx0XHRcdFx0aWYgKHkgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHkgPSAoeCA9PT0gXCJjZW50ZXJcIikgPyBcIjUwJVwiIDogXCIwXCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoeSA9PT0gXCJjZW50ZXJcIikge1xuXHRcdFx0XHRcdHkgPSBcIjUwJVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh4ID09PSBcImNlbnRlclwiIHx8IChpc05hTihwYXJzZUZsb2F0KHgpKSAmJiAoeCArIFwiXCIpLmluZGV4T2YoXCI9XCIpID09PSAtMSkpIHsgLy9yZW1lbWJlciwgdGhlIHVzZXIgY291bGQgZmxpcC1mbG9wIHRoZSB2YWx1ZXMgYW5kIHNheSBcImJvdHRvbSBjZW50ZXJcIiBvciBcImNlbnRlciBib3R0b21cIiwgZXRjLiBcImNlbnRlclwiIGlzIGFtYmlndW91cyBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWQgdG8gZGVzY3JpYmUgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCwgaGVuY2UgdGhlIGlzTmFOKCkuIElmIHRoZXJlJ3MgYW4gXCI9XCIgc2lnbiBpbiB0aGUgdmFsdWUsIGl0J3MgcmVsYXRpdmUuXG5cdFx0XHRcdFx0eCA9IFwiNTAlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlY09iaikge1xuXHRcdFx0XHRcdHJlY09iai5veHAgPSAoeC5pbmRleE9mKFwiJVwiKSAhPT0gLTEpO1xuXHRcdFx0XHRcdHJlY09iai5veXAgPSAoeS5pbmRleE9mKFwiJVwiKSAhPT0gLTEpO1xuXHRcdFx0XHRcdHJlY09iai5veHIgPSAoeC5jaGFyQXQoMSkgPT09IFwiPVwiKTtcblx0XHRcdFx0XHRyZWNPYmoub3lyID0gKHkuY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdFx0cmVjT2JqLm94ID0gcGFyc2VGbG9hdCh4LnJlcGxhY2UoX05hTkV4cCwgXCJcIikpO1xuXHRcdFx0XHRcdHJlY09iai5veSA9IHBhcnNlRmxvYXQoeS5yZXBsYWNlKF9OYU5FeHAsIFwiXCIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4geCArIFwiIFwiICsgeSArICgoYS5sZW5ndGggPiAyKSA/IFwiIFwiICsgYVsyXSA6IFwiXCIpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBUYWtlcyBhbiBlbmRpbmcgdmFsdWUgKHR5cGljYWxseSBhIHN0cmluZywgYnV0IGNhbiBiZSBhIG51bWJlcikgYW5kIGEgc3RhcnRpbmcgdmFsdWUgYW5kIHJldHVybnMgdGhlIGNoYW5nZSBiZXR3ZWVuIHRoZSB0d28sIGxvb2tpbmcgZm9yIHJlbGF0aXZlIHZhbHVlIGluZGljYXRvcnMgbGlrZSArPSBhbmQgLT0gYW5kIGl0IGFsc28gaWdub3JlcyBzdWZmaXhlcyAoYnV0IG1ha2Ugc3VyZSB0aGUgZW5kaW5nIHZhbHVlIHN0YXJ0cyB3aXRoIGEgbnVtYmVyIG9yICs9Ly09IGFuZCB0aGF0IHRoZSBzdGFydGluZyB2YWx1ZSBpcyBhIE5VTUJFUiEpXG5cdFx0XHQgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gZSBFbmQgdmFsdWUgd2hpY2ggaXMgdHlwaWNhbGx5IGEgc3RyaW5nLCBidXQgY291bGQgYmUgYSBudW1iZXJcblx0XHRcdCAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpfSBiIEJlZ2lubmluZyB2YWx1ZSB3aGljaCBpcyB0eXBpY2FsbHkgYSBzdHJpbmcgYnV0IGNvdWxkIGJlIGEgbnVtYmVyXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IEFtb3VudCBvZiBjaGFuZ2UgYmV0d2VlbiB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIChyZWxhdGl2ZSB2YWx1ZXMgdGhhdCBoYXZlIGEgXCIrPVwiIG9yIFwiLT1cIiBhcmUgcmVjb2duaXplZClcblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlQ2hhbmdlID0gZnVuY3Rpb24oZSwgYikge1xuXHRcdFx0XHRyZXR1cm4gKHR5cGVvZihlKSA9PT0gXCJzdHJpbmdcIiAmJiBlLmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcGFyc2VJbnQoZS5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdChlLnN1YnN0cigyKSkgOiBwYXJzZUZsb2F0KGUpIC0gcGFyc2VGbG9hdChiKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgVGFrZXMgYSB2YWx1ZSBhbmQgYSBkZWZhdWx0IG51bWJlciwgY2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyByZWxhdGl2ZSwgbnVsbCwgb3IgbnVtZXJpYyBhbmQgc3BpdHMgYmFjayBhIG5vcm1hbGl6ZWQgbnVtYmVyIGFjY29yZGluZ2x5LiBQcmltYXJpbHkgdXNlZCBpbiB0aGUgX3BhcnNlVHJhbnNmb3JtKCkgZnVuY3Rpb24uXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gdiBWYWx1ZSB0byBiZSBwYXJzZWRcblx0XHRcdCAqIEBwYXJhbSB7IW51bWJlcn0gZCBEZWZhdWx0IHZhbHVlICh3aGljaCBpcyBhbHNvIHVzZWQgZm9yIHJlbGF0aXZlIGNhbGN1bGF0aW9ucyBpZiBcIis9XCIgb3IgXCItPVwiIGlzIGZvdW5kIGluIHRoZSBmaXJzdCBwYXJhbWV0ZXIpXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IFBhcnNlZCB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VWYWwgPSBmdW5jdGlvbih2LCBkKSB7XG5cdFx0XHRcdHJldHVybiAodiA9PSBudWxsKSA/IGQgOiAodHlwZW9mKHYpID09PSBcInN0cmluZ1wiICYmIHYuY2hhckF0KDEpID09PSBcIj1cIikgPyBwYXJzZUludCh2LmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBwYXJzZUZsb2F0KHYuc3Vic3RyKDIpKSArIGQgOiBwYXJzZUZsb2F0KHYpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBUcmFuc2xhdGVzIHN0cmluZ3MgbGlrZSBcIjQwZGVnXCIgb3IgXCI0MFwiIG9yIDQwcmFkXCIgb3IgXCIrPTQwZGVnXCIgb3IgXCIyNzBfc2hvcnRcIiBvciBcIi05MF9jd1wiIG9yIFwiKz00NV9jY3dcIiB0byBhIG51bWVyaWMgcmFkaWFuIGFuZ2xlLiBPZiBjb3Vyc2UgYSBzdGFydGluZy9kZWZhdWx0IHZhbHVlIG11c3QgYmUgZmVkIGluIHRvbyBzbyB0aGF0IHJlbGF0aXZlIHZhbHVlcyBjYW4gYmUgY2FsY3VsYXRlZCBwcm9wZXJseS5cblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB2IFZhbHVlIHRvIGJlIHBhcnNlZFxuXHRcdFx0ICogQHBhcmFtIHshbnVtYmVyfSBkIERlZmF1bHQgdmFsdWUgKHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgcmVsYXRpdmUgY2FsY3VsYXRpb25zIGlmIFwiKz1cIiBvciBcIi09XCIgaXMgZm91bmQgaW4gdGhlIGZpcnN0IHBhcmFtZXRlcilcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gcCBwcm9wZXJ0eSBuYW1lIGZvciBkaXJlY3Rpb25hbEVuZCAob3B0aW9uYWwgLSBvbmx5IHVzZWQgd2hlbiB0aGUgcGFyc2VkIHZhbHVlIGlzIGRpcmVjdGlvbmFsIChcIl9zaG9ydFwiLCBcIl9jd1wiLCBvciBcIl9jY3dcIiBzdWZmaXgpLiBXZSBuZWVkIGEgd2F5IHRvIHN0b3JlIHRoZSB1bmNvbXBlbnNhdGVkIHZhbHVlIHNvIHRoYXQgYXQgdGhlIGVuZCBvZiB0aGUgdHdlZW4sIHdlIHNldCBpdCB0byBleGFjdGx5IHdoYXQgd2FzIHJlcXVlc3RlZCB3aXRoIG5vIGRpcmVjdGlvbmFsIGNvbXBlbnNhdGlvbikuIFByb3BlcnR5IG5hbWUgd291bGQgYmUgXCJyb3RhdGlvblwiLCBcInJvdGF0aW9uWFwiLCBvciBcInJvdGF0aW9uWVwiXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdD19IGRpcmVjdGlvbmFsRW5kIEFuIG9iamVjdCB0aGF0IHdpbGwgc3RvcmUgdGhlIHJhdyBlbmQgdmFsdWVzIGZvciBkaXJlY3Rpb25hbCBhbmdsZXMgKFwiX3Nob3J0XCIsIFwiX2N3XCIsIG9yIFwiX2Njd1wiIHN1ZmZpeCkuIFdlIG5lZWQgYSB3YXkgdG8gc3RvcmUgdGhlIHVuY29tcGVuc2F0ZWQgdmFsdWUgc28gdGhhdCBhdCB0aGUgZW5kIG9mIHRoZSB0d2Vlbiwgd2Ugc2V0IGl0IHRvIGV4YWN0bHkgd2hhdCB3YXMgcmVxdWVzdGVkIHdpdGggbm8gZGlyZWN0aW9uYWwgY29tcGVuc2F0aW9uLlxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSBwYXJzZWQgYW5nbGUgaW4gcmFkaWFuc1xuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VBbmdsZSA9IGZ1bmN0aW9uKHYsIGQsIHAsIGRpcmVjdGlvbmFsRW5kKSB7XG5cdFx0XHRcdHZhciBtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0XHRjYXAsIHNwbGl0LCBkaWYsIHJlc3VsdCwgaXNSZWxhdGl2ZTtcblx0XHRcdFx0aWYgKHYgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IGQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHYpID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gdjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYXAgPSAzNjA7XG5cdFx0XHRcdFx0c3BsaXQgPSB2LnNwbGl0KFwiX1wiKTtcblx0XHRcdFx0XHRpc1JlbGF0aXZlID0gKHYuY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdFx0ZGlmID0gKGlzUmVsYXRpdmUgPyBwYXJzZUludCh2LmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBwYXJzZUZsb2F0KHNwbGl0WzBdLnN1YnN0cigyKSkgOiBwYXJzZUZsb2F0KHNwbGl0WzBdKSkgKiAoKHYuaW5kZXhPZihcInJhZFwiKSA9PT0gLTEpID8gMSA6IF9SQUQyREVHKSAtIChpc1JlbGF0aXZlID8gMCA6IGQpO1xuXHRcdFx0XHRcdGlmIChzcGxpdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmIChkaXJlY3Rpb25hbEVuZCkge1xuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb25hbEVuZFtwXSA9IGQgKyBkaWY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwic2hvcnRcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IGRpZiAlIGNhcDtcblx0XHRcdFx0XHRcdFx0aWYgKGRpZiAhPT0gZGlmICUgKGNhcCAvIDIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlmID0gKGRpZiA8IDApID8gZGlmICsgY2FwIDogZGlmIC0gY2FwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwiX2N3XCIpICE9PSAtMSAmJiBkaWYgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9ICgoZGlmICsgY2FwICogOTk5OTk5OTk5OSkgJSBjYXApIC0gKChkaWYgLyBjYXApIHwgMCkgKiBjYXA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYuaW5kZXhPZihcImNjd1wiKSAhPT0gLTEgJiYgZGlmID4gMCkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoKGRpZiAtIGNhcCAqIDk5OTk5OTk5OTkpICUgY2FwKSAtICgoZGlmIC8gY2FwKSB8IDApICogY2FwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHQgPSBkICsgZGlmO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXN1bHQgPCBtaW4gJiYgcmVzdWx0ID4gLW1pbikge1xuXHRcdFx0XHRcdHJlc3VsdCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0sXG5cblx0XHRcdF9jb2xvckxvb2t1cCA9IHthcXVhOlswLDI1NSwyNTVdLFxuXHRcdFx0XHRsaW1lOlswLDI1NSwwXSxcblx0XHRcdFx0c2lsdmVyOlsxOTIsMTkyLDE5Ml0sXG5cdFx0XHRcdGJsYWNrOlswLDAsMF0sXG5cdFx0XHRcdG1hcm9vbjpbMTI4LDAsMF0sXG5cdFx0XHRcdHRlYWw6WzAsMTI4LDEyOF0sXG5cdFx0XHRcdGJsdWU6WzAsMCwyNTVdLFxuXHRcdFx0XHRuYXZ5OlswLDAsMTI4XSxcblx0XHRcdFx0d2hpdGU6WzI1NSwyNTUsMjU1XSxcblx0XHRcdFx0ZnVjaHNpYTpbMjU1LDAsMjU1XSxcblx0XHRcdFx0b2xpdmU6WzEyOCwxMjgsMF0sXG5cdFx0XHRcdHllbGxvdzpbMjU1LDI1NSwwXSxcblx0XHRcdFx0b3JhbmdlOlsyNTUsMTY1LDBdLFxuXHRcdFx0XHRncmF5OlsxMjgsMTI4LDEyOF0sXG5cdFx0XHRcdHB1cnBsZTpbMTI4LDAsMTI4XSxcblx0XHRcdFx0Z3JlZW46WzAsMTI4LDBdLFxuXHRcdFx0XHRyZWQ6WzI1NSwwLDBdLFxuXHRcdFx0XHRwaW5rOlsyNTUsMTkyLDIwM10sXG5cdFx0XHRcdGN5YW46WzAsMjU1LDI1NV0sXG5cdFx0XHRcdHRyYW5zcGFyZW50OlsyNTUsMjU1LDI1NSwwXX0sXG5cblx0XHRcdF9odWUgPSBmdW5jdGlvbihoLCBtMSwgbTIpIHtcblx0XHRcdFx0aCA9IChoIDwgMCkgPyBoICsgMSA6IChoID4gMSkgPyBoIC0gMSA6IGg7XG5cdFx0XHRcdHJldHVybiAoKCgoaCAqIDYgPCAxKSA/IG0xICsgKG0yIC0gbTEpICogaCAqIDYgOiAoaCA8IDAuNSkgPyBtMiA6IChoICogMyA8IDIpID8gbTEgKyAobTIgLSBtMSkgKiAoMiAvIDMgLSBoKSAqIDYgOiBtMSkgKiAyNTUpICsgMC41KSB8IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFBhcnNlcyBhIGNvbG9yIChsaWtlICM5RjAsICNGRjk5MDAsIG9yIHJnYigyNTUsNTEsMTUzKSkgaW50byBhbiBhcnJheSB3aXRoIDMgZWxlbWVudHMgZm9yIHJlZCwgZ3JlZW4sIGFuZCBibHVlLiBBbHNvIGhhbmRsZXMgcmdiYSgpIHZhbHVlcyAoc3BsaXRzIGludG8gYXJyYXkgb2YgNCBlbGVtZW50cyBvZiBjb3Vyc2UpXG5cdFx0XHQgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKX0gdiBUaGUgdmFsdWUgdGhlIHNob3VsZCBiZSBwYXJzZWQgd2hpY2ggY291bGQgYmUgYSBzdHJpbmcgbGlrZSAjOUYwIG9yIHJnYigyNTUsMTAyLDUxKSBvciByZ2JhKDI1NSwwLDAsMC41KSBvciBpdCBjb3VsZCBiZSBhIG51bWJlciBsaWtlIDB4RkYwMENDIG9yIGV2ZW4gYSBuYW1lZCBjb2xvciBsaWtlIHJlZCwgYmx1ZSwgcHVycGxlLCBldGMuXG5cdFx0XHQgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gQW4gYXJyYXkgY29udGFpbmluZyByZWQsIGdyZWVuLCBhbmQgYmx1ZSAoYW5kIG9wdGlvbmFsbHkgYWxwaGEpIGluIHRoYXQgb3JkZXIuXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZUNvbG9yID0gQ1NTUGx1Z2luLnBhcnNlQ29sb3IgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciBjMSwgYzIsIGMzLCBoLCBzLCBsO1xuXHRcdFx0XHRpZiAoIXYgfHwgdiA9PT0gXCJcIikge1xuXHRcdFx0XHRcdHJldHVybiBfY29sb3JMb29rdXAuYmxhY2s7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZih2KSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdHJldHVybiBbdiA+PiAxNiwgKHYgPj4gOCkgJiAyNTUsIHYgJiAyNTVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2LmNoYXJBdCh2Lmxlbmd0aCAtIDEpID09PSBcIixcIikgeyAvL3NvbWV0aW1lcyBhIHRyYWlsaW5nIGNvbW1tYSBpcyBpbmNsdWRlZCBhbmQgd2Ugc2hvdWxkIGNob3AgaXQgb2ZmICh0eXBpY2FsbHkgZnJvbSBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcyBsaWtlIGEgdGV4dFNoYWRvdzpcIjJweCAycHggMnB4IGJsdWUsIDVweCA1cHggNXB4IHJnYigyNTUsMCwwKVwiIC0gaW4gdGhpcyBleGFtcGxlIFwiYmx1ZSxcIiBoYXMgYSB0cmFpbGluZyBjb21tYS4gV2UgY291bGQgc3RyaXAgaXQgb3V0IGluc2lkZSBwYXJzZUNvbXBsZXgoKSBidXQgd2UnZCBuZWVkIHRvIGRvIGl0IHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgcGx1cyBpdCB3b3VsZG4ndCBwcm92aWRlIHByb3RlY3Rpb24gZnJvbSBvdGhlciBwb3RlbnRpYWwgc2NlbmFyaW9zIGxpa2UgaWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgc2ltaWxhciB2YWx1ZS5cblx0XHRcdFx0XHR2ID0gdi5zdWJzdHIoMCwgdi5sZW5ndGggLSAxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2NvbG9yTG9va3VwW3ZdKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9jb2xvckxvb2t1cFt2XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodi5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG5cdFx0XHRcdFx0aWYgKHYubGVuZ3RoID09PSA0KSB7IC8vZm9yIHNob3J0aGFuZCBsaWtlICM5RjBcblx0XHRcdFx0XHRcdGMxID0gdi5jaGFyQXQoMSksXG5cdFx0XHRcdFx0XHRjMiA9IHYuY2hhckF0KDIpLFxuXHRcdFx0XHRcdFx0YzMgPSB2LmNoYXJBdCgzKTtcblx0XHRcdFx0XHRcdHYgPSBcIiNcIiArIGMxICsgYzEgKyBjMiArIGMyICsgYzMgKyBjMztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0diA9IHBhcnNlSW50KHYuc3Vic3RyKDEpLCAxNik7XG5cdFx0XHRcdFx0cmV0dXJuIFt2ID4+IDE2LCAodiA+PiA4KSAmIDI1NSwgdiAmIDI1NV07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYuc3Vic3RyKDAsIDMpID09PSBcImhzbFwiKSB7XG5cdFx0XHRcdFx0diA9IHYubWF0Y2goX251bUV4cCk7XG5cdFx0XHRcdFx0aCA9IChOdW1iZXIodlswXSkgJSAzNjApIC8gMzYwO1xuXHRcdFx0XHRcdHMgPSBOdW1iZXIodlsxXSkgLyAxMDA7XG5cdFx0XHRcdFx0bCA9IE51bWJlcih2WzJdKSAvIDEwMDtcblx0XHRcdFx0XHRjMiA9IChsIDw9IDAuNSkgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG5cdFx0XHRcdFx0YzEgPSBsICogMiAtIGMyO1xuXHRcdFx0XHRcdGlmICh2Lmxlbmd0aCA+IDMpIHtcblx0XHRcdFx0XHRcdHZbM10gPSBOdW1iZXIodlszXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZbMF0gPSBfaHVlKGggKyAxIC8gMywgYzEsIGMyKTtcblx0XHRcdFx0XHR2WzFdID0gX2h1ZShoLCBjMSwgYzIpO1xuXHRcdFx0XHRcdHZbMl0gPSBfaHVlKGggLSAxIC8gMywgYzEsIGMyKTtcblx0XHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2ID0gdi5tYXRjaChfbnVtRXhwKSB8fCBfY29sb3JMb29rdXAudHJhbnNwYXJlbnQ7XG5cdFx0XHRcdHZbMF0gPSBOdW1iZXIodlswXSk7XG5cdFx0XHRcdHZbMV0gPSBOdW1iZXIodlsxXSk7XG5cdFx0XHRcdHZbMl0gPSBOdW1iZXIodlsyXSk7XG5cdFx0XHRcdGlmICh2Lmxlbmd0aCA+IDMpIHtcblx0XHRcdFx0XHR2WzNdID0gTnVtYmVyKHZbM10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0fSxcblx0XHRcdF9jb2xvckV4cCA9IFwiKD86XFxcXGIoPzooPzpyZ2J8cmdiYXxoc2x8aHNsYSlcXFxcKC4rP1xcXFwpKXxcXFxcQiMuKz9cXFxcYlwiOyAvL3dlJ2xsIGR5bmFtaWNhbGx5IGJ1aWxkIHRoaXMgUmVndWxhciBFeHByZXNzaW9uIHRvIGNvbnNlcnZlIGZpbGUgc2l6ZS4gQWZ0ZXIgYnVpbGRpbmcgaXQsIGl0IHdpbGwgYmUgYWJsZSB0byBmaW5kIHJnYigpLCByZ2JhKCksICMgKGhleGFkZWNpbWFsKSwgYW5kIG5hbWVkIGNvbG9yIHZhbHVlcyBsaWtlIHJlZCwgYmx1ZSwgcHVycGxlLCBldGMuXG5cblx0XHRmb3IgKHAgaW4gX2NvbG9yTG9va3VwKSB7XG5cdFx0XHRfY29sb3JFeHAgKz0gXCJ8XCIgKyBwICsgXCJcXFxcYlwiO1xuXHRcdH1cblx0XHRfY29sb3JFeHAgPSBuZXcgUmVnRXhwKF9jb2xvckV4cCtcIilcIiwgXCJnaVwiKTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlIFJldHVybnMgYSBmb3JtYXR0ZXIgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIHRha2luZyBhIHN0cmluZyAob3IgbnVtYmVyIGluIHNvbWUgY2FzZXMpIGFuZCByZXR1cm5pbmcgYSBjb25zaXN0ZW50bHkgZm9ybWF0dGVkIG9uZSBpbiB0ZXJtcyBvZiBkZWxpbWl0ZXJzLCBxdWFudGl0eSBvZiB2YWx1ZXMsIGV0Yy4gRm9yIGV4YW1wbGUsIHdlIG1heSBnZXQgYm94U2hhZG93IHZhbHVlcyBkZWZpbmVkIGFzIFwiMHB4IHJlZFwiIG9yIFwiMHB4IDBweCAxMHB4IHJnYigyNTUsMCwwKVwiIG9yIFwiMHB4IDBweCAyMHB4IDIwcHggI0YwMFwiIGFuZCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHdoYXQgd2UgZ2V0IGJhY2sgaXMgZGVzY3JpYmVkIHdpdGggNCBudW1iZXJzIGFuZCBhIGNvbG9yLiBUaGlzIGFsbG93cyB1cyB0byBmZWVkIGl0IGludG8gdGhlIF9wYXJzZUNvbXBsZXgoKSBtZXRob2QgYW5kIHNwbGl0IHRoZSB2YWx1ZXMgdXAgYXBwcm9wcmlhdGVseS4gVGhlIG5lYXQgdGhpbmcgYWJvdXQgdGhpcyBfZ2V0Rm9ybWF0dGVyKCkgZnVuY3Rpb24gaXMgdGhhdCB0aGUgZGZsdCBkZWZpbmVzIGEgcGF0dGVybiBhcyB3ZWxsIGFzIGEgZGVmYXVsdCwgc28gZm9yIGV4YW1wbGUsIF9nZXRGb3JtYXR0ZXIoXCIwcHggMHB4IDBweCAwcHggIzc3N1wiLCB0cnVlKSBub3Qgb25seSBzZXRzIHRoZSBkZWZhdWx0IGFzIDBweCBmb3IgYWxsIGRpc3RhbmNlcyBhbmQgIzc3NyBmb3IgdGhlIGNvbG9yLCBidXQgYWxzbyBzZXRzIHRoZSBwYXR0ZXJuIHN1Y2ggdGhhdCA0IG51bWJlcnMgYW5kIGEgY29sb3Igd2lsbCBhbHdheXMgZ2V0IHJldHVybmVkLlxuXHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gZGZsdCBUaGUgZGVmYXVsdCB2YWx1ZSBhbmQgcGF0dGVybiB0byBmb2xsb3cuIFNvIFwiMHB4IDBweCAwcHggMHB4ICM3NzdcIiB3aWxsIGVuc3VyZSB0aGF0IDQgbnVtYmVycyBhbmQgYSBjb2xvciB3aWxsIGFsd2F5cyBnZXQgcmV0dXJuZWQuXG5cdFx0ICogQHBhcmFtIHtib29sZWFuPX0gY2xyIElmIHRydWUsIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHNlYXJjaGVkIGZvciBjb2xvci1yZWxhdGVkIGRhdGEuIEZvciBleGFtcGxlLCBib3hTaGFkb3cgdmFsdWVzIHR5cGljYWxseSBjb250YWluIGEgY29sb3Igd2hlcmVhcyBib3JkZXJSYWRpdXMgZG9uJ3QuXG5cdFx0ICogQHBhcmFtIHtib29sZWFuPX0gY29sbGFwc2libGUgSWYgdHJ1ZSwgdGhlIHZhbHVlIGlzIGEgdG9wL2xlZnQvcmlnaHQvYm90dG9tIHN0eWxlIG9uZSB0aGF0IGFjdHMgbGlrZSBtYXJnaW4gb3IgcGFkZGluZywgd2hlcmUgaWYgb25seSBvbmUgdmFsdWUgaXMgcmVjZWl2ZWQsIGl0J3MgdXNlZCBmb3IgYWxsIDQ7IGlmIDIgYXJlIHJlY2VpdmVkLCB0aGUgZmlyc3QgaXMgZHVwbGljYXRlZCBmb3IgM3JkIChib3R0b20pIGFuZCB0aGUgMm5kIGlzIGR1cGxpY2F0ZWQgZm9yIHRoZSA0dGggc3BvdCAobGVmdCksIGV0Yy5cblx0XHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gZm9ybWF0dGVyIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0dmFyIF9nZXRGb3JtYXR0ZXIgPSBmdW5jdGlvbihkZmx0LCBjbHIsIGNvbGxhcHNpYmxlLCBtdWx0aSkge1xuXHRcdFx0XHRpZiAoZGZsdCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHYpIHtyZXR1cm4gdjt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBkQ29sb3IgPSBjbHIgPyAoZGZsdC5tYXRjaChfY29sb3JFeHApIHx8IFtcIlwiXSlbMF0gOiBcIlwiLFxuXHRcdFx0XHRcdGRWYWxzID0gZGZsdC5zcGxpdChkQ29sb3IpLmpvaW4oXCJcIikubWF0Y2goX3ZhbHVlc0V4cCkgfHwgW10sXG5cdFx0XHRcdFx0cGZ4ID0gZGZsdC5zdWJzdHIoMCwgZGZsdC5pbmRleE9mKGRWYWxzWzBdKSksXG5cdFx0XHRcdFx0c2Z4ID0gKGRmbHQuY2hhckF0KGRmbHQubGVuZ3RoIC0gMSkgPT09IFwiKVwiKSA/IFwiKVwiIDogXCJcIixcblx0XHRcdFx0XHRkZWxpbSA9IChkZmx0LmluZGV4T2YoXCIgXCIpICE9PSAtMSkgPyBcIiBcIiA6IFwiLFwiLFxuXHRcdFx0XHRcdG51bVZhbHMgPSBkVmFscy5sZW5ndGgsXG5cdFx0XHRcdFx0ZFNmeCA9IChudW1WYWxzID4gMCkgPyBkVmFsc1swXS5yZXBsYWNlKF9udW1FeHAsIFwiXCIpIDogXCJcIixcblx0XHRcdFx0XHRmb3JtYXR0ZXI7XG5cdFx0XHRcdGlmICghbnVtVmFscykge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbih2KSB7cmV0dXJuIHY7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2xyKSB7XG5cdFx0XHRcdFx0Zm9ybWF0dGVyID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdFx0dmFyIGNvbG9yLCB2YWxzLCBpLCBhO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZih2KSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdFx0XHR2ICs9IGRTZng7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG11bHRpICYmIF9jb21tYXNPdXRzaWRlUGFyZW5FeHAudGVzdCh2KSkge1xuXHRcdFx0XHRcdFx0XHRhID0gdi5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwifFwiKS5zcGxpdChcInxcIik7XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0YVtpXSA9IGZvcm1hdHRlcihhW2ldKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYS5qb2luKFwiLFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbG9yID0gKHYubWF0Y2goX2NvbG9yRXhwKSB8fCBbZENvbG9yXSlbMF07XG5cdFx0XHRcdFx0XHR2YWxzID0gdi5zcGxpdChjb2xvcikuam9pbihcIlwiKS5tYXRjaChfdmFsdWVzRXhwKSB8fCBbXTtcblx0XHRcdFx0XHRcdGkgPSB2YWxzLmxlbmd0aDtcblx0XHRcdFx0XHRcdGlmIChudW1WYWxzID4gaS0tKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgrK2kgPCBudW1WYWxzKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsc1tpXSA9IGNvbGxhcHNpYmxlID8gdmFsc1soKChpIC0gMSkgLyAyKSB8IDApXSA6IGRWYWxzW2ldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gcGZ4ICsgdmFscy5qb2luKGRlbGltKSArIGRlbGltICsgY29sb3IgKyBzZnggKyAodi5pbmRleE9mKFwiaW5zZXRcIikgIT09IC0xID8gXCIgaW5zZXRcIiA6IFwiXCIpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmV0dXJuIGZvcm1hdHRlcjtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvcm1hdHRlciA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0XHR2YXIgdmFscywgYSwgaTtcblx0XHRcdFx0XHRpZiAodHlwZW9mKHYpID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0XHR2ICs9IGRTZng7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChtdWx0aSAmJiBfY29tbWFzT3V0c2lkZVBhcmVuRXhwLnRlc3QodikpIHtcblx0XHRcdFx0XHRcdGEgPSB2LnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCJ8XCIpLnNwbGl0KFwifFwiKTtcblx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGFbaV0gPSBmb3JtYXR0ZXIoYVtpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gYS5qb2luKFwiLFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFscyA9IHYubWF0Y2goX3ZhbHVlc0V4cCkgfHwgW107XG5cdFx0XHRcdFx0aSA9IHZhbHMubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChudW1WYWxzID4gaS0tKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoKytpIDwgbnVtVmFscykge1xuXHRcdFx0XHRcdFx0XHR2YWxzW2ldID0gY29sbGFwc2libGUgPyB2YWxzWygoKGkgLSAxKSAvIDIpIHwgMCldIDogZFZhbHNbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBwZnggKyB2YWxzLmpvaW4oZGVsaW0pICsgc2Z4O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gZm9ybWF0dGVyO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSByZXR1cm5zIGEgZm9ybWF0dGVyIGZ1bmN0aW9uIHRoYXQncyB1c2VkIGZvciBlZGdlLXJlbGF0ZWQgdmFsdWVzIGxpa2UgbWFyZ2luVG9wLCBtYXJnaW5MZWZ0LCBwYWRkaW5nQm90dG9tLCBwYWRkaW5nUmlnaHQsIGV0Yy4gSnVzdCBwYXNzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgcmVsYXRlZCB0byB0aGUgZWRnZXMuXG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHByb3BzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgaW4gb3JkZXIgZnJvbSB0b3AgdG8gbGVmdCwgbGlrZSBcIm1hcmdpblRvcCxtYXJnaW5SaWdodCxtYXJnaW5Cb3R0b20sbWFyZ2luTGVmdFwiXG5cdFx0XHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmb3JtYXR0ZXIgZnVuY3Rpb25cblx0XHRcdCAqL1xuXHRcdFx0X2dldEVkZ2VQYXJzZXIgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdFx0XHRwcm9wcyA9IHByb3BzLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdFx0XHR2YXIgYSA9IChlICsgXCJcIikuc3BsaXQoXCIgXCIpLFxuXHRcdFx0XHRcdFx0aTtcblx0XHRcdFx0XHR2YXJzID0ge307XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyc1twcm9wc1tpXV0gPSBhW2ldID0gYVtpXSB8fCBhWygoKGkgLSAxKSAvIDIpID4+IDApXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGNzc3AucGFyc2UodCwgdmFycywgcHQsIHBsdWdpbik7XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAcHJpdmF0ZSB1c2VkIHdoZW4gb3RoZXIgcGx1Z2lucyBtdXN0IHR3ZWVuIHZhbHVlcyBmaXJzdCwgbGlrZSBCZXppZXJQbHVnaW4gb3IgVGhyb3dQcm9wc1BsdWdpbiwgZXRjLiBUaGF0IHBsdWdpbidzIHNldFJhdGlvKCkgZ2V0cyBjYWxsZWQgZmlyc3Qgc28gdGhhdCB0aGUgdmFsdWVzIGFyZSB1cGRhdGVkLCBhbmQgdGhlbiB3ZSBsb29wIHRocm91Z2ggdGhlIE1pbmlQcm9wVHdlZW5zICB3aGljaCBoYW5kbGUgY29weWluZyB0aGUgdmFsdWVzIGludG8gdGhlaXIgYXBwcm9wcmlhdGUgc2xvdHMgc28gdGhhdCB0aGV5IGNhbiB0aGVuIGJlIGFwcGxpZWQgY29ycmVjdGx5IGluIHRoZSBtYWluIENTU1BsdWdpbiBzZXRSYXRpbygpIG1ldGhvZC4gUmVtZW1iZXIsIHdlIHR5cGljYWxseSBjcmVhdGUgYSBwcm94eSBvYmplY3QgdGhhdCBoYXMgYSBidW5jaCBvZiB1bmlxdWVseS1uYW1lZCBwcm9wZXJ0aWVzIHRoYXQgd2UgZmVlZCB0byB0aGUgc3ViLXBsdWdpbiBhbmQgaXQgZG9lcyBpdHMgbWFnaWMgbm9ybWFsbHksIGFuZCB0aGVuIHdlIG11c3QgaW50ZXJwcmV0IHRob3NlIHZhbHVlcyBhbmQgYXBwbHkgdGhlbSB0byB0aGUgY3NzIGJlY2F1c2Ugb2Z0ZW4gbnVtYmVycyBtdXN0IGdldCBjb21iaW5lZC9jb25jYXRlbmF0ZWQsIHN1ZmZpeGVzIGFkZGVkLCBldGMuIHRvIHdvcmsgd2l0aCBjc3MsIGxpa2UgYm94U2hhZG93IGNvdWxkIGhhdmUgNCB2YWx1ZXMgcGx1cyBhIGNvbG9yLlxuXHRcdFx0X3NldFBsdWdpblJhdGlvID0gX2ludGVybmFscy5fc2V0UGx1Z2luUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHRoaXMucGx1Z2luLnNldFJhdGlvKHYpO1xuXHRcdFx0XHR2YXIgZCA9IHRoaXMuZGF0YSxcblx0XHRcdFx0XHRwcm94eSA9IGQucHJveHksXG5cdFx0XHRcdFx0bXB0ID0gZC5maXJzdE1QVCxcblx0XHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0XHR2YWwsIHB0LCBpLCBzdHI7XG5cdFx0XHRcdHdoaWxlIChtcHQpIHtcblx0XHRcdFx0XHR2YWwgPSBwcm94eVttcHQudl07XG5cdFx0XHRcdFx0aWYgKG1wdC5yKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWwgPCBtaW4gJiYgdmFsID4gLW1pbikge1xuXHRcdFx0XHRcdFx0dmFsID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bXB0LnRbbXB0LnBdID0gdmFsO1xuXHRcdFx0XHRcdG1wdCA9IG1wdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZC5hdXRvUm90YXRlKSB7XG5cdFx0XHRcdFx0ZC5hdXRvUm90YXRlLnJvdGF0aW9uID0gcHJveHkucm90YXRpb247XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9hdCB0aGUgZW5kLCB3ZSBtdXN0IHNldCB0aGUgQ1NTUHJvcFR3ZWVuJ3MgXCJlXCIgKGVuZCkgdmFsdWUgZHluYW1pY2FsbHkgaGVyZSBiZWNhdXNlIHRoYXQncyB3aGF0IGlzIHVzZWQgaW4gdGhlIGZpbmFsIHNldFJhdGlvKCkgbWV0aG9kLlxuXHRcdFx0XHRpZiAodiA9PT0gMSkge1xuXHRcdFx0XHRcdG1wdCA9IGQuZmlyc3RNUFQ7XG5cdFx0XHRcdFx0d2hpbGUgKG1wdCkge1xuXHRcdFx0XHRcdFx0cHQgPSBtcHQudDtcblx0XHRcdFx0XHRcdGlmICghcHQudHlwZSkge1xuXHRcdFx0XHRcdFx0XHRwdC5lID0gcHQucyArIHB0LnhzMDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocHQudHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRzdHIgPSBwdC54czAgKyBwdC5zICsgcHQueHMxO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDwgcHQubDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RyICs9IHB0W1wieG5cIitpXSArIHB0W1wieHNcIisoaSsxKV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHQuZSA9IHN0cjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1wdCA9IG1wdC5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgQGNvbnN0cnVjdG9yIFVzZWQgYnkgYSBmZXcgU3BlY2lhbFByb3BzIHRvIGhvbGQgaW1wb3J0YW50IHZhbHVlcyBmb3IgcHJveGllcy4gRm9yIGV4YW1wbGUsIF9wYXJzZVRvUHJveHkoKSBjcmVhdGVzIGEgTWluaVByb3BUd2VlbiBpbnN0YW5jZSBmb3IgZWFjaCBwcm9wZXJ0eSB0aGF0IG11c3QgZ2V0IHR3ZWVuZWQgb24gdGhlIHByb3h5LCBhbmQgd2UgcmVjb3JkIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBuYW1lIGFzIHdlbGwgYXMgdGhlIHVuaXF1ZSBvbmUgd2UgY3JlYXRlIGZvciB0aGUgcHJveHksIHBsdXMgd2hldGhlciBvciBub3QgdGhlIHZhbHVlIG5lZWRzIHRvIGJlIHJvdW5kZWQgcGx1cyB0aGUgb3JpZ2luYWwgdmFsdWUuXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgdGFyZ2V0IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSB3ZSdyZSB0d2VlbmluZyAob2Z0ZW4gYSBDU1NQcm9wVHdlZW4pXG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgcHJvcGVydHkgbmFtZVxuXHRcdFx0ICogQHBhcmFtIHsobnVtYmVyfHN0cmluZ3xvYmplY3QpfSB2IHZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge01pbmlQcm9wVHdlZW49fSBuZXh0IG5leHQgTWluaVByb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHIgaWYgdHJ1ZSwgdGhlIHR3ZWVuZWQgdmFsdWUgc2hvdWxkIGJlIHJvdW5kZWQgdG8gdGhlIG5lYXJlc3QgaW50ZWdlclxuXHRcdFx0ICovXG5cdFx0XHRNaW5pUHJvcFR3ZWVuID0gZnVuY3Rpb24odCwgcCwgdiwgbmV4dCwgcikge1xuXHRcdFx0XHR0aGlzLnQgPSB0O1xuXHRcdFx0XHR0aGlzLnAgPSBwO1xuXHRcdFx0XHR0aGlzLnYgPSB2O1xuXHRcdFx0XHR0aGlzLnIgPSByO1xuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdG5leHQuX3ByZXYgPSB0aGlzO1xuXHRcdFx0XHRcdHRoaXMuX25leHQgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIE1vc3Qgb3RoZXIgcGx1Z2lucyAobGlrZSBCZXppZXJQbHVnaW4gYW5kIFRocm93UHJvcHNQbHVnaW4gYW5kIG90aGVycykgY2FuIG9ubHkgdHdlZW4gbnVtZXJpYyB2YWx1ZXMsIGJ1dCBDU1NQbHVnaW4gbXVzdCBhY2NvbW1vZGF0ZSBzcGVjaWFsIHZhbHVlcyB0aGF0IGhhdmUgYSBidW5jaCBvZiBleHRyYSBkYXRhIChsaWtlIGEgc3VmZml4IG9yIHN0cmluZ3MgYmV0d2VlbiBudW1lcmljIHZhbHVlcywgZXRjLikuIEZvciBleGFtcGxlLCBib3hTaGFkb3cgaGFzIHZhbHVlcyBsaWtlIFwiMTBweCAxMHB4IDIwcHggMzBweCByZ2IoMjU1LDAsMClcIiB3aGljaCB3b3VsZCB1dHRlcmx5IGNvbmZ1c2Ugb3RoZXIgcGx1Z2lucy4gVGhpcyBtZXRob2QgYWxsb3dzIHVzIHRvIHNwbGl0IHRoYXQgZGF0YSBhcGFydCBhbmQgZ3JhYiBvbmx5IHRoZSBudW1lcmljIGRhdGEgYW5kIGF0dGFjaCBpdCB0byB1bmlxdWVseS1uYW1lZCBwcm9wZXJ0aWVzIG9mIGEgZ2VuZXJpYyBwcm94eSBvYmplY3QgKHt9KSBzbyB0aGF0IHdlIGNhbiBmZWVkIHRoYXQgdG8gdmlydHVhbGx5IGFueSBwbHVnaW4gdG8gaGF2ZSB0aGUgbnVtYmVycyB0d2VlbmVkLiBIb3dldmVyLCB3ZSBtdXN0IGFsc28ga2VlcCB0cmFjayBvZiB3aGljaCBwcm9wZXJ0aWVzIGZyb20gdGhlIHByb3h5IGdvIHdpdGggd2hpY2ggQ1NTUHJvcFR3ZWVuIHZhbHVlcyBhbmQgaW5zdGFuY2VzLiBTbyB3ZSBjcmVhdGUgYSBsaW5rZWQgbGlzdCBvZiBNaW5pUHJvcFR3ZWVucy4gRWFjaCBvbmUgcmVjb3JkcyBhIHRhcmdldCAodGhlIG9yaWdpbmFsIENTU1Byb3BUd2VlbiksIHByb3BlcnR5IChsaWtlIFwic1wiIG9yIFwieG4xXCIgb3IgXCJ4bjJcIikgdGhhdCB3ZSdyZSB0d2VlbmluZyBhbmQgdGhlIHVuaXF1ZSBwcm9wZXJ0eSBuYW1lIHRoYXQgd2FzIHVzZWQgZm9yIHRoZSBwcm94eSAobGlrZSBcImJveFNoYWRvd194bjFcIiBhbmQgXCJib3hTaGFkb3dfeG4yXCIpIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGV5IG5lZWQgdG8gYmUgcm91bmRlZC4gVGhhdCB3YXksIGluIHRoZSBfc2V0UGx1Z2luUmF0aW8oKSBtZXRob2Qgd2UgY2FuIHNpbXBseSBjb3B5IHRoZSB2YWx1ZXMgb3ZlciBmcm9tIHRoZSBwcm94eSB0byB0aGUgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlKHMpLiBUaGVuLCB3aGVuIHRoZSBtYWluIENTU1BsdWdpbiBzZXRSYXRpbygpIG1ldGhvZCBydW5zIGFuZCBhcHBsaWVzIHRoZSBDU1NQcm9wVHdlZW4gdmFsdWVzIGFjY29yZGluZ2x5LCB0aGV5J3JlIHVwZGF0ZWQgbmljZWx5LiBTbyB0aGUgZXh0ZXJuYWwgcGx1Z2luIHR3ZWVucyB0aGUgbnVtYmVycywgX3NldFBsdWdpblJhdGlvKCkgY29waWVzIHRoZW0gb3ZlciwgYW5kIHNldFJhdGlvKCkgYWN0cyBub3JtYWxseSwgYXBwbHlpbmcgY3NzLXNwZWNpZmljIHZhbHVlcyB0byB0aGUgZWxlbWVudC5cblx0XHRcdCAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0XHRcdCAqICAtIHByb3h5OiBhIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHN0YXJ0aW5nIHZhbHVlcyBmb3IgYWxsIHRoZSBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSB0d2VlbmVkIGJ5IHRoZSBleHRlcm5hbCBwbHVnaW4uICBUaGlzIGlzIHdoYXQgd2UgZmVlZCB0byB0aGUgZXh0ZXJuYWwgX29uSW5pdFR3ZWVuKCkgYXMgdGhlIHRhcmdldFxuXHRcdFx0ICogIC0gZW5kOiBhIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVuZGluZyB2YWx1ZXMgZm9yIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgdHdlZW5lZCBieSB0aGUgZXh0ZXJuYWwgcGx1Z2luLiBUaGlzIGlzIHdoYXQgd2UgZmVlZCB0byB0aGUgZXh0ZXJuYWwgcGx1Z2luJ3MgX29uSW5pdFR3ZWVuKCkgYXMgdGhlIGRlc3RpbmF0aW9uIHZhbHVlc1xuXHRcdFx0ICogIC0gZmlyc3RNUFQ6IHRoZSBmaXJzdCBNaW5pUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdFxuXHRcdFx0ICogIC0gcHQ6IHRoZSBmaXJzdCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0IHRoYXQgd2FzIGNyZWF0ZWQgd2hlbiBwYXJzaW5nLiBJZiBzaGFsbG93IGlzIHRydWUsIHRoaXMgbGlua2VkIGxpc3Qgd2lsbCBOT1QgYXR0YWNoIHRvIHRoZSBvbmUgcGFzc2VkIGludG8gdGhlIF9wYXJzZVRvUHJveHkoKSBhcyB0aGUgXCJwdFwiICg0dGgpIHBhcmFtZXRlci5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCB0YXJnZXQgb2JqZWN0IHRvIGJlIHR3ZWVuZWRcblx0XHRcdCAqIEBwYXJhbSB7IShPYmplY3R8c3RyaW5nKX0gdmFycyB0aGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0d2VlbmluZyB2YWx1ZXMgKHR5cGljYWxseSB0aGUgZW5kL2Rlc3RpbmF0aW9uIHZhbHVlcykgdGhhdCBzaG91bGQgYmUgcGFyc2VkXG5cdFx0XHQgKiBAcGFyYW0geyFDU1NQbHVnaW59IGNzc3AgVGhlIENTU1BsdWdpbiBpbnN0YW5jZVxuXHRcdFx0ICogQHBhcmFtIHtDU1NQcm9wVHdlZW49fSBwdCB0aGUgbmV4dCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIHRoZSBleHRlcm5hbCBUd2VlblBsdWdpbiBpbnN0YW5jZSB0aGF0IHdpbGwgYmUgaGFuZGxpbmcgdHdlZW5pbmcgdGhlIG51bWVyaWMgdmFsdWVzXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaGFsbG93IGlmIHRydWUsIHRoZSByZXN1bHRpbmcgbGlua2VkIGxpc3QgZnJvbSB0aGUgcGFyc2Ugd2lsbCBOT1QgYmUgYXR0YWNoZWQgdG8gdGhlIENTU1Byb3BUd2VlbiB0aGF0IHdhcyBwYXNzZWQgaW4gYXMgdGhlIFwicHRcIiAoNHRoKSBwYXJhbWV0ZXIuXG5cdFx0XHQgKiBAcmV0dXJuIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczogcHJveHksIGVuZCwgZmlyc3RNUFQsIGFuZCBwdCAoc2VlIGFib3ZlIGZvciBkZXNjcmlwdGlvbnMpXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZVRvUHJveHkgPSBfaW50ZXJuYWxzLl9wYXJzZVRvUHJveHkgPSBmdW5jdGlvbih0LCB2YXJzLCBjc3NwLCBwdCwgcGx1Z2luLCBzaGFsbG93KSB7XG5cdFx0XHRcdHZhciBicHQgPSBwdCxcblx0XHRcdFx0XHRzdGFydCA9IHt9LFxuXHRcdFx0XHRcdGVuZCA9IHt9LFxuXHRcdFx0XHRcdHRyYW5zZm9ybSA9IGNzc3AuX3RyYW5zZm9ybSxcblx0XHRcdFx0XHRvbGRGb3JjZSA9IF9mb3JjZVBULFxuXHRcdFx0XHRcdGksIHAsIHhwLCBtcHQsIGZpcnN0UFQ7XG5cdFx0XHRcdGNzc3AuX3RyYW5zZm9ybSA9IG51bGw7XG5cdFx0XHRcdF9mb3JjZVBUID0gdmFycztcblx0XHRcdFx0cHQgPSBmaXJzdFBUID0gY3NzcC5wYXJzZSh0LCB2YXJzLCBwdCwgcGx1Z2luKTtcblx0XHRcdFx0X2ZvcmNlUFQgPSBvbGRGb3JjZTtcblx0XHRcdFx0Ly9icmVhayBvZmYgZnJvbSB0aGUgbGlua2VkIGxpc3Qgc28gdGhlIG5ldyBvbmVzIGFyZSBpc29sYXRlZC5cblx0XHRcdFx0aWYgKHNoYWxsb3cpIHtcblx0XHRcdFx0XHRjc3NwLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cdFx0XHRcdFx0aWYgKGJwdCkge1xuXHRcdFx0XHRcdFx0YnB0Ll9wcmV2ID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmIChicHQuX3ByZXYpIHtcblx0XHRcdFx0XHRcdFx0YnB0Ll9wcmV2Ll9uZXh0ID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0d2hpbGUgKHB0ICYmIHB0ICE9PSBicHQpIHtcblx0XHRcdFx0XHRpZiAocHQudHlwZSA8PSAxKSB7XG5cdFx0XHRcdFx0XHRwID0gcHQucDtcblx0XHRcdFx0XHRcdGVuZFtwXSA9IHB0LnMgKyBwdC5jO1xuXHRcdFx0XHRcdFx0c3RhcnRbcF0gPSBwdC5zO1xuXHRcdFx0XHRcdFx0aWYgKCFzaGFsbG93KSB7XG5cdFx0XHRcdFx0XHRcdG1wdCA9IG5ldyBNaW5pUHJvcFR3ZWVuKHB0LCBcInNcIiwgcCwgbXB0LCBwdC5yKTtcblx0XHRcdFx0XHRcdFx0cHQuYyA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAocHQudHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRpID0gcHQubDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHR4cCA9IFwieG5cIiArIGk7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IHB0LnAgKyBcIl9cIiArIHhwO1xuXHRcdFx0XHRcdFx0XHRcdGVuZFtwXSA9IHB0LmRhdGFbeHBdO1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0W3BdID0gcHRbeHBdO1xuXHRcdFx0XHRcdFx0XHRcdGlmICghc2hhbGxvdykge1xuXHRcdFx0XHRcdFx0XHRcdFx0bXB0ID0gbmV3IE1pbmlQcm9wVHdlZW4ocHQsIHhwLCBwLCBtcHQsIHB0LnJ4cFt4cF0pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7cHJveHk6c3RhcnQsIGVuZDplbmQsIGZpcnN0TVBUOm1wdCwgcHQ6Zmlyc3RQVH07XG5cdFx0XHR9LFxuXG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAY29uc3RydWN0b3IgRWFjaCBwcm9wZXJ0eSB0aGF0IGlzIHR3ZWVuZWQgaGFzIGF0IGxlYXN0IG9uZSBDU1NQcm9wVHdlZW4gYXNzb2NpYXRlZCB3aXRoIGl0LiBUaGVzZSBpbnN0YW5jZXMgc3RvcmUgaW1wb3J0YW50IGluZm9ybWF0aW9uIGxpa2UgdGhlIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0aW5nIHZhbHVlLCBhbW91bnQgb2YgY2hhbmdlLCBldGMuIFRoZXkgY2FuIGFsc28gb3B0aW9uYWxseSBoYXZlIGEgbnVtYmVyIG9mIFwiZXh0cmFcIiBzdHJpbmdzIGFuZCBudW1lcmljIHZhbHVlcyBuYW1lZCB4czEsIHhuMSwgeHMyLCB4bjIsIHhzMywgeG4zLCBldGMuIHdoZXJlIFwic1wiIGluZGljYXRlcyBzdHJpbmcgYW5kIFwiblwiIGluZGljYXRlcyBudW1iZXIuIFRoZXNlIGNhbiBiZSBwaWVjZWQgdG9nZXRoZXIgaW4gYSBjb21wbGV4LXZhbHVlIHR3ZWVuICh0eXBlOjEpIHRoYXQgaGFzIGFsdGVybmF0aW5nIHR5cGVzIG9mIGRhdGEgbGlrZSBhIHN0cmluZywgbnVtYmVyLCBzdHJpbmcsIG51bWJlciwgZXRjLiBGb3IgZXhhbXBsZSwgYm94U2hhZG93IGNvdWxkIGJlIFwiNXB4IDVweCA4cHggcmdiKDEwMiwgMTAyLCA1MSlcIi4gSW4gdGhhdCB2YWx1ZSwgdGhlcmUgYXJlIDYgbnVtYmVycyB0aGF0IG1heSBuZWVkIHRvIHR3ZWVuIGFuZCB0aGVuIHBpZWNlZCBiYWNrIHRvZ2V0aGVyIGludG8gYSBzdHJpbmcgYWdhaW4gd2l0aCBzcGFjZXMsIHN1ZmZpeGVzLCBldGMuIHhzMCBpcyBzcGVjaWFsIGluIHRoYXQgaXQgc3RvcmVzIHRoZSBzdWZmaXggZm9yIHN0YW5kYXJkICh0eXBlOjApIHR3ZWVucywgLU9SLSB0aGUgZmlyc3Qgc3RyaW5nIChwcmVmaXgpIGluIGEgY29tcGxleC12YWx1ZSAodHlwZToxKSBDU1NQcm9wVHdlZW4gLU9SLSBpdCBjYW4gYmUgdGhlIG5vbi10d2VlbmluZyB2YWx1ZSBpbiBhIHR5cGU6LTEgQ1NTUHJvcFR3ZWVuLiBXZSBkbyB0aGlzIHRvIGNvbnNlcnZlIG1lbW9yeS5cblx0XHRcdCAqIENTU1Byb3BUd2VlbnMgaGF2ZSB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIHByb3BlcnRpZXMgYXMgd2VsbCAobm90IGRlZmluZWQgdGhyb3VnaCB0aGUgY29uc3RydWN0b3IpOlxuXHRcdFx0ICogIC0gbDogTGVuZ3RoIGluIHRlcm1zIG9mIHRoZSBudW1iZXIgb2YgZXh0cmEgcHJvcGVydGllcyB0aGF0IHRoZSBDU1NQcm9wVHdlZW4gaGFzIChkZWZhdWx0OiAwKS4gRm9yIGV4YW1wbGUsIGZvciBhIGJveFNoYWRvdyB3ZSBtYXkgbmVlZCB0byB0d2VlbiA1IG51bWJlcnMgaW4gd2hpY2ggY2FzZSBsIHdvdWxkIGJlIDU7IEtlZXAgaW4gbWluZCB0aGF0IHRoZSBzdGFydC9lbmQgdmFsdWVzIGZvciB0aGUgZmlyc3QgbnVtYmVyIHRoYXQncyB0d2VlbmVkIGFyZSBhbHdheXMgc3RvcmVkIGluIHRoZSBzIGFuZCBjIHByb3BlcnRpZXMgdG8gY29uc2VydmUgbWVtb3J5LiBBbGwgYWRkaXRpb25hbCB2YWx1ZXMgdGhlcmVhZnRlciBhcmUgc3RvcmVkIGluIHhuMSwgeG4yLCBldGMuXG5cdFx0XHQgKiAgLSB4Zmlyc3Q6IFRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgc3ViLUNTU1Byb3BUd2VlbnMgdGhhdCBhcmUgdHdlZW5pbmcgcHJvcGVydGllcyBvZiB0aGlzIGluc3RhbmNlLiBGb3IgZXhhbXBsZSwgd2UgbWF5IHNwbGl0IHVwIGEgYm94U2hhZG93IHR3ZWVuIHNvIHRoYXQgdGhlcmUncyBhIG1haW4gQ1NTUHJvcFR3ZWVuIG9mIHR5cGU6MSB0aGF0IGhhcyB2YXJpb3VzIHhzKiBhbmQgeG4qIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGgtc2hhZG93LCB2LXNoYWRvdywgYmx1ciwgY29sb3IsIGV0Yy4gVGhlbiB3ZSBzcGF3biBhIENTU1Byb3BUd2VlbiBmb3IgZWFjaCBvZiB0aG9zZSB0aGF0IGhhcyBhIGhpZ2hlciBwcmlvcml0eSBhbmQgcnVucyBCRUZPUkUgdGhlIG1haW4gQ1NTUHJvcFR3ZWVuIHNvIHRoYXQgdGhlIHZhbHVlcyBhcmUgYWxsIHNldCBieSB0aGUgdGltZSBpdCBuZWVkcyB0byByZS1hc3NlbWJsZSB0aGVtLiBUaGUgeGZpcnN0IGdpdmVzIHVzIGFuIGVhc3kgd2F5IHRvIGlkZW50aWZ5IHRoZSBmaXJzdCBvbmUgaW4gdGhhdCBjaGFpbiB3aGljaCB0eXBpY2FsbHkgZW5kcyBhdCB0aGUgbWFpbiBvbmUgKGJlY2F1c2UgdGhleSdyZSBhbGwgcHJlcGVuZGUgdG8gdGhlIGxpbmtlZCBsaXN0KVxuXHRcdFx0ICogIC0gcGx1Z2luOiBUaGUgVHdlZW5QbHVnaW4gaW5zdGFuY2UgdGhhdCB3aWxsIGhhbmRsZSB0aGUgdHdlZW5pbmcgb2YgYW55IGNvbXBsZXggdmFsdWVzLiBGb3IgZXhhbXBsZSwgc29tZXRpbWVzIHdlIGRvbid0IHdhbnQgdG8gdXNlIG5vcm1hbCBzdWJ0d2VlbnMgKGxpa2UgeGZpcnN0IHJlZmVycyB0bykgdG8gdHdlZW4gdGhlIHZhbHVlcyAtIHdlIG1pZ2h0IHdhbnQgVGhyb3dQcm9wc1BsdWdpbiBvciBCZXppZXJQbHVnaW4gc29tZSBvdGhlciBwbHVnaW4gdG8gZG8gdGhlIGFjdHVhbCB0d2VlbmluZywgc28gd2UgY3JlYXRlIGEgcGx1Z2luIGluc3RhbmNlIGFuZCBzdG9yZSBhIHJlZmVyZW5jZSBoZXJlLiBXZSBuZWVkIHRoaXMgcmVmZXJlbmNlIHNvIHRoYXQgaWYgd2UgZ2V0IGEgcmVxdWVzdCB0byByb3VuZCB2YWx1ZXMgb3IgZGlzYWJsZSBhIHR3ZWVuLCB3ZSBjYW4gcGFzcyBhbG9uZyB0aGF0IHJlcXVlc3QuXG5cdFx0XHQgKiAgLSBkYXRhOiBBcmJpdHJhcnkgZGF0YSB0aGF0IG5lZWRzIHRvIGJlIHN0b3JlZCB3aXRoIHRoZSBDU1NQcm9wVHdlZW4uIFR5cGljYWxseSBpZiB3ZSdyZSBnb2luZyB0byBoYXZlIGEgcGx1Z2luIGhhbmRsZSB0aGUgdHdlZW5pbmcgb2YgYSBjb21wbGV4LXZhbHVlIHR3ZWVuLCB3ZSBjcmVhdGUgYSBnZW5lcmljIG9iamVjdCB0aGF0IHN0b3JlcyB0aGUgRU5EIHZhbHVlcyB0aGF0IHdlJ3JlIHR3ZWVuaW5nIHRvIGFuZCB0aGUgQ1NTUHJvcFR3ZWVuJ3MgeHMxLCB4czIsIGV0Yy4gaGF2ZSB0aGUgc3RhcnRpbmcgdmFsdWVzLiBXZSBzdG9yZSB0aGF0IG9iamVjdCBhcyBkYXRhLiBUaGF0IHdheSwgd2UgY2FuIHNpbXBseSBwYXNzIHRoYXQgb2JqZWN0IHRvIHRoZSBwbHVnaW4gYW5kIHVzZSB0aGUgQ1NTUHJvcFR3ZWVuIGFzIHRoZSB0YXJnZXQuXG5cdFx0XHQgKiAgLSBzZXRSYXRpbzogT25seSB1c2VkIGZvciB0eXBlOjIgdHdlZW5zIHRoYXQgcmVxdWlyZSBjdXN0b20gZnVuY3Rpb25hbGl0eS4gSW4gdGhpcyBjYXNlLCB3ZSBjYWxsIHRoZSBDU1NQcm9wVHdlZW4ncyBzZXRSYXRpbygpIG1ldGhvZCBhbmQgcGFzcyB0aGUgcmF0aW8gZWFjaCB0aW1lIHRoZSB0d2VlbiB1cGRhdGVzLiBUaGlzIGlzbid0IHF1aXRlIGFzIGVmZmljaWVudCBhcyBkb2luZyB0aGluZ3MgZGlyZWN0bHkgaW4gdGhlIENTU1BsdWdpbidzIHNldFJhdGlvKCkgbWV0aG9kLCBidXQgaXQncyB2ZXJ5IGNvbnZlbmllbnQgYW5kIGZsZXhpYmxlLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgd2lsbCBiZSB0d2VlbmVkLiBPZnRlbiBhIERPTSBlbGVtZW50LCBidXQgbm90IGFsd2F5cy4gSXQgY291bGQgYmUgYW55dGhpbmcuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcCBQcm9wZXJ0eSB0byB0d2VlbiAobmFtZSkuIEZvciBleGFtcGxlLCB0byB0d2VlbiBlbGVtZW50LndpZHRoLCBwIHdvdWxkIGJlIFwid2lkdGhcIi5cblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBzIFN0YXJ0aW5nIG51bWVyaWMgdmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBjIENoYW5nZSBpbiBudW1lcmljIHZhbHVlIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgZW50aXJlIHR3ZWVuLiBGb3IgZXhhbXBsZSwgaWYgZWxlbWVudC53aWR0aCBzdGFydHMgYXQgNSBhbmQgc2hvdWxkIGVuZCBhdCAxMDAsIGMgd291bGQgYmUgOTUuXG5cdFx0XHQgKiBAcGFyYW0ge0NTU1Byb3BUd2Vlbj19IG5leHQgVGhlIG5leHQgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdC4gSWYgb25lIGlzIGRlZmluZWQsIHdlIHdpbGwgZGVmaW5lIGl0cyBfcHJldiBhcyB0aGUgbmV3IGluc3RhbmNlLCBhbmQgdGhlIG5ldyBpbnN0YW5jZSdzIF9uZXh0IHdpbGwgYmUgcG9pbnRlZCBhdCBpdC5cblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyPX0gdHlwZSBUaGUgdHlwZSBvZiBDU1NQcm9wVHdlZW4gd2hlcmUgLTEgPSBhIG5vbi10d2VlbmluZyB2YWx1ZSwgMCA9IGEgc3RhbmRhcmQgc2ltcGxlIHR3ZWVuLCAxID0gYSBjb21wbGV4IHZhbHVlIChsaWtlIG9uZSB0aGF0IGhhcyBtdWx0aXBsZSBudW1iZXJzIGluIGEgY29tbWEtIG9yIHNwYWNlLWRlbGltaXRlZCBzdHJpbmcgbGlrZSBib3JkZXI6XCIxcHggc29saWQgcmVkXCIpLCBhbmQgMiA9IG9uZSB0aGF0IHVzZXMgYSBjdXN0b20gc2V0UmF0aW8gZnVuY3Rpb24gdGhhdCBkb2VzIGFsbCBvZiB0aGUgd29yayBvZiBhcHBseWluZyB0aGUgdmFsdWVzIG9uIGVhY2ggdXBkYXRlLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBuIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIG92ZXJ3cml0aW5nIHB1cnBvc2VzIHdoaWNoIGlzIHR5cGljYWxseSB0aGUgc2FtZSBhcyBwIGJ1dCBub3QgYWx3YXlzLiBGb3IgZXhhbXBsZSwgd2UgbWF5IG5lZWQgdG8gY3JlYXRlIGEgc3VidHdlZW4gZm9yIHRoZSAybmQgcGFydCBvZiBhIFwiY2xpcDpyZWN0KC4uLilcIiB0d2VlbiBpbiB3aGljaCBjYXNlIFwicFwiIG1pZ2h0IGJlIHhzMSBidXQgXCJuXCIgaXMgc3RpbGwgXCJjbGlwXCJcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHIgSWYgdHJ1ZSwgdGhlIHZhbHVlKHMpIHNob3VsZCBiZSByb3VuZGVkXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcj19IHByIFByaW9yaXR5IGluIHRoZSBsaW5rZWQgbGlzdCBvcmRlci4gSGlnaGVyIHByaW9yaXR5IENTU1Byb3BUd2VlbnMgd2lsbCBiZSB1cGRhdGVkIGJlZm9yZSBsb3dlciBwcmlvcml0eSBvbmVzLiBUaGUgZGVmYXVsdCBwcmlvcml0eSBpcyAwLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBiIEJlZ2lubmluZyB2YWx1ZS4gV2Ugc3RvcmUgdGhpcyB0byBlbnN1cmUgdGhhdCBpdCBpcyBFWEFDVExZIHdoYXQgaXQgd2FzIHdoZW4gdGhlIHR3ZWVuIGJlZ2FuIHdpdGhvdXQgYW55IHJpc2sgb2YgaW50ZXJwcmV0YXRpb24gaXNzdWVzLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBlIEVuZGluZyB2YWx1ZS4gV2Ugc3RvcmUgdGhpcyB0byBlbnN1cmUgdGhhdCBpdCBpcyBFWEFDVExZIHdoYXQgdGhlIHVzZXIgZGVmaW5lZCBhdCB0aGUgZW5kIG9mIHRoZSB0d2VlbiB3aXRob3V0IGFueSByaXNrIG9mIGludGVycHJldGF0aW9uIGlzc3Vlcy5cblx0XHRcdCAqL1xuXHRcdFx0Q1NTUHJvcFR3ZWVuID0gX2ludGVybmFscy5DU1NQcm9wVHdlZW4gPSBmdW5jdGlvbih0LCBwLCBzLCBjLCBuZXh0LCB0eXBlLCBuLCByLCBwciwgYiwgZSkge1xuXHRcdFx0XHR0aGlzLnQgPSB0OyAvL3RhcmdldFxuXHRcdFx0XHR0aGlzLnAgPSBwOyAvL3Byb3BlcnR5XG5cdFx0XHRcdHRoaXMucyA9IHM7IC8vc3RhcnRpbmcgdmFsdWVcblx0XHRcdFx0dGhpcy5jID0gYzsgLy9jaGFuZ2UgdmFsdWVcblx0XHRcdFx0dGhpcy5uID0gbiB8fCBwOyAvL25hbWUgdGhhdCB0aGlzIENTU1Byb3BUd2VlbiBzaG91bGQgYmUgYXNzb2NpYXRlZCB0byAodXN1YWxseSB0aGUgc2FtZSBhcyBwLCBidXQgbm90IGFsd2F5cyAtIG4gaXMgd2hhdCBvdmVyd3JpdGluZyBsb29rcyBhdClcblx0XHRcdFx0aWYgKCEodCBpbnN0YW5jZW9mIENTU1Byb3BUd2VlbikpIHtcblx0XHRcdFx0XHRfb3ZlcndyaXRlUHJvcHMucHVzaCh0aGlzLm4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuciA9IHI7IC8vcm91bmQgKGJvb2xlYW4pXG5cdFx0XHRcdHRoaXMudHlwZSA9IHR5cGUgfHwgMDsgLy8wID0gbm9ybWFsIHR3ZWVuLCAtMSA9IG5vbi10d2VlbmluZyAoaW4gd2hpY2ggY2FzZSB4czAgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSB0YXJnZXQncyBwcm9wZXJ0eSwgbGlrZSB0cC50W3RwLnBdID0gdHAueHMwKSwgMSA9IGNvbXBsZXgtdmFsdWUgU3BlY2lhbFByb3AsIDIgPSBjdXN0b20gc2V0UmF0aW8oKSB0aGF0IGRvZXMgYWxsIHRoZSB3b3JrXG5cdFx0XHRcdGlmIChwcikge1xuXHRcdFx0XHRcdHRoaXMucHIgPSBwcjtcblx0XHRcdFx0XHRfaGFzUHJpb3JpdHkgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYiA9IChiID09PSB1bmRlZmluZWQpID8gcyA6IGI7XG5cdFx0XHRcdHRoaXMuZSA9IChlID09PSB1bmRlZmluZWQpID8gcyArIGMgOiBlO1xuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdHRoaXMuX25leHQgPSBuZXh0O1xuXHRcdFx0XHRcdG5leHQuX3ByZXYgPSB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRha2VzIGEgdGFyZ2V0LCB0aGUgYmVnaW5uaW5nIHZhbHVlIGFuZCBlbmRpbmcgdmFsdWUgKGFzIHN0cmluZ3MpIGFuZCBwYXJzZXMgdGhlbSBpbnRvIGEgQ1NTUHJvcFR3ZWVuIChwb3NzaWJseSB3aXRoIGNoaWxkIENTU1Byb3BUd2VlbnMpIHRoYXQgYWNjb21tb2RhdGVzIG11bHRpcGxlIG51bWJlcnMsIGNvbG9ycywgY29tbWEtZGVsaW1pdGVkIHZhbHVlcywgZXRjLiBGb3IgZXhhbXBsZTpcblx0XHRcdCAqIHNwLnBhcnNlQ29tcGxleChlbGVtZW50LCBcImJveFNoYWRvd1wiLCBcIjVweCAxMHB4IDIwcHggcmdiKDI1NSwxMDIsNTEpXCIsIFwiMHB4IDBweCAwcHggcmVkXCIsIHRydWUsIFwiMHB4IDBweCAwcHggcmdiKDAsMCwwLDApXCIsIHB0KTtcblx0XHRcdCAqIEl0IHdpbGwgd2FsayB0aHJvdWdoIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgKHdoaWNoIHNob3VsZCBiZSBpbiB0aGUgc2FtZSBmb3JtYXQgd2l0aCB0aGUgc2FtZSBudW1iZXIgYW5kIHR5cGUgb2YgdmFsdWVzKSBhbmQgZmlndXJlIG91dCB3aGljaCBwYXJ0cyBhcmUgbnVtYmVycywgd2hhdCBzdHJpbmdzIHNlcGFyYXRlIHRoZSBudW1lcmljL3R3ZWVuYWJsZSB2YWx1ZXMsIGFuZCB0aGVuIGNyZWF0ZSB0aGUgQ1NTUHJvcFR3ZWVucyBhY2NvcmRpbmdseS4gSWYgYSBwbHVnaW4gaXMgZGVmaW5lZCwgbm8gY2hpbGQgQ1NTUHJvcFR3ZWVucyB3aWxsIGJlIGNyZWF0ZWQuIEluc3RlYWQsIHRoZSBlbmRpbmcgdmFsdWVzIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBcImRhdGFcIiBwcm9wZXJ0eSBvZiB0aGUgcmV0dXJuZWQgQ1NTUHJvcFR3ZWVuIGxpa2U6IHtzOi01LCB4bjE6LTEwLCB4bjI6LTIwLCB4bjM6MjU1LCB4bjQ6MCwgeG41OjB9IHNvIHRoYXQgaXQgY2FuIGJlIGZlZCB0byBhbnkgb3RoZXIgcGx1Z2luIGFuZCBpdCdsbCBiZSBwbGFpbiBudW1lcmljIHR3ZWVucyBidXQgdGhlIHJlY29tcG9zaXRpb24gb2YgdGhlIGNvbXBsZXggdmFsdWUgd2lsbCBiZSBoYW5kbGVkIGluc2lkZSBDU1NQbHVnaW4ncyBzZXRSYXRpbygpLlxuXHRcdFx0ICogSWYgYSBzZXRSYXRpbyBpcyBkZWZpbmVkLCB0aGUgdHlwZSBvZiB0aGUgQ1NTUHJvcFR3ZWVuIHdpbGwgYmUgc2V0IHRvIDIgYW5kIHJlY29tcG9zaXRpb24gb2YgdGhlIHZhbHVlcyB3aWxsIGJlIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGF0IG1ldGhvZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IHdob3NlIHByb3BlcnR5IHdpbGwgYmUgdHdlZW5lZFxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IHRoYXQgd2lsbCBiZSB0d2VlbmVkIChpdHMgbmFtZSwgbGlrZSBcImxlZnRcIiBvciBcImJhY2tncm91bmRDb2xvclwiIG9yIFwiYm94U2hhZG93XCIpXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gYiBCZWdpbm5pbmcgdmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBlIEVuZGluZyB2YWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFufSBjbHJzIElmIHRydWUsIHRoZSB2YWx1ZSBjb3VsZCBjb250YWluIGEgY29sb3IgdmFsdWUgbGlrZSBcInJnYigyNTUsMCwwKVwiIG9yIFwiI0YwMFwiIG9yIFwicmVkXCIuIFRoZSBkZWZhdWx0IGlzIGZhbHNlLCBzbyBubyBjb2xvcnMgd2lsbCBiZSByZWNvZ25pemVkIChhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbilcblx0XHRcdCAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXJ8T2JqZWN0KX0gZGZsdCBUaGUgZGVmYXVsdCBiZWdpbm5pbmcgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBpZiBubyB2YWxpZCBiZWdpbm5pbmcgdmFsdWUgaXMgZGVmaW5lZCBvciBpZiB0aGUgbnVtYmVyIG9mIHZhbHVlcyBpbnNpZGUgdGhlIGNvbXBsZXggYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIGRvbid0IG1hdGNoXG5cdFx0XHQgKiBAcGFyYW0gez9DU1NQcm9wVHdlZW59IHB0IENTU1Byb3BUd2VlbiBpbnN0YW5jZSB0aGF0IGlzIHRoZSBjdXJyZW50IGhlYWQgb2YgdGhlIGxpbmtlZCBsaXN0ICh3ZSdsbCBwcmVwZW5kIHRvIHRoaXMpLlxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXI9fSBwciBQcmlvcml0eSBpbiB0aGUgbGlua2VkIGxpc3Qgb3JkZXIuIEhpZ2hlciBwcmlvcml0eSBwcm9wZXJ0aWVzIHdpbGwgYmUgdXBkYXRlZCBiZWZvcmUgbG93ZXIgcHJpb3JpdHkgb25lcy4gVGhlIGRlZmF1bHQgcHJpb3JpdHkgaXMgMC5cblx0XHRcdCAqIEBwYXJhbSB7VHdlZW5QbHVnaW49fSBwbHVnaW4gSWYgYSBwbHVnaW4gc2hvdWxkIGhhbmRsZSB0aGUgdHdlZW5pbmcgb2YgZXh0cmEgcHJvcGVydGllcywgcGFzcyB0aGUgcGx1Z2luIGluc3RhbmNlIGhlcmUuIElmIG9uZSBpcyBkZWZpbmVkLCB0aGVuIE5PIHN1YnR3ZWVucyB3aWxsIGJlIGNyZWF0ZWQgZm9yIGFueSBleHRyYSBwcm9wZXJ0aWVzICh0aGUgcHJvcGVydGllcyB3aWxsIGJlIGNyZWF0ZWQgLSBqdXN0IG5vdCBhZGRpdGlvbmFsIENTU1Byb3BUd2VlbiBpbnN0YW5jZXMgdG8gdHdlZW4gdGhlbSkgYmVjYXVzZSB0aGUgcGx1Z2luIGlzIGV4cGVjdGVkIHRvIGRvIHNvLiBIb3dldmVyLCB0aGUgZW5kIHZhbHVlcyBXSUxMIGJlIHBvcHVsYXRlZCBpbiB0aGUgXCJkYXRhXCIgcHJvcGVydHksIGxpa2Uge3M6MTAwLCB4bjE6NTAsIHhuMjozMDB9XG5cdFx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik9fSBzZXRSYXRpbyBJZiB2YWx1ZXMgc2hvdWxkIGJlIHNldCBpbiBhIGN1c3RvbSBmdW5jdGlvbiBpbnN0ZWFkIG9mIGJlaW5nIHBpZWNlZCB0b2dldGhlciBpbiBhIHR5cGU6MSAoY29tcGxleC12YWx1ZSkgQ1NTUHJvcFR3ZWVuLCBkZWZpbmUgdGhhdCBjdXN0b20gZnVuY3Rpb24gaGVyZS5cblx0XHRcdCAqIEByZXR1cm4ge0NTU1Byb3BUd2Vlbn0gVGhlIGZpcnN0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Qgd2hpY2ggaW5jbHVkZXMgdGhlIG5ldyBvbmUocykgYWRkZWQgYnkgdGhlIHBhcnNlQ29tcGxleCgpIGNhbGwuXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZUNvbXBsZXggPSBDU1NQbHVnaW4ucGFyc2VDb21wbGV4ID0gZnVuY3Rpb24odCwgcCwgYiwgZSwgY2xycywgZGZsdCwgcHQsIHByLCBwbHVnaW4sIHNldFJhdGlvKSB7XG5cdFx0XHRcdC8vREVCVUc6IF9sb2coXCJwYXJzZUNvbXBsZXg6IFwiK3ArXCIsIGI6IFwiK2IrXCIsIGU6IFwiK2UpO1xuXHRcdFx0XHRiID0gYiB8fCBkZmx0IHx8IFwiXCI7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCBwdCwgKHNldFJhdGlvID8gMiA6IDEpLCBudWxsLCBmYWxzZSwgcHIsIGIsIGUpO1xuXHRcdFx0XHRlICs9IFwiXCI7IC8vZW5zdXJlcyBpdCdzIGEgc3RyaW5nXG5cdFx0XHRcdHZhciBiYSA9IGIuc3BsaXQoXCIsIFwiKS5qb2luKFwiLFwiKS5zcGxpdChcIiBcIiksIC8vYmVnaW5uaW5nIGFycmF5XG5cdFx0XHRcdFx0ZWEgPSBlLnNwbGl0KFwiLCBcIikuam9pbihcIixcIikuc3BsaXQoXCIgXCIpLCAvL2VuZGluZyBhcnJheVxuXHRcdFx0XHRcdGwgPSBiYS5sZW5ndGgsXG5cdFx0XHRcdFx0YXV0b1JvdW5kID0gKF9hdXRvUm91bmQgIT09IGZhbHNlKSxcblx0XHRcdFx0XHRpLCB4aSwgbmksIGJ2LCBldiwgYm51bXMsIGVudW1zLCBibiwgcmdiYSwgdGVtcCwgY3YsIHN0cjtcblx0XHRcdFx0aWYgKGUuaW5kZXhPZihcIixcIikgIT09IC0xIHx8IGIuaW5kZXhPZihcIixcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0YmEgPSBiYS5qb2luKFwiIFwiKS5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwiLCBcIikuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdGVhID0gZWEuam9pbihcIiBcIikucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcIiwgXCIpLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRsID0gYmEubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsICE9PSBlYS5sZW5ndGgpIHtcblx0XHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwibWlzbWF0Y2hlZCBmb3JtYXR0aW5nIGRldGVjdGVkIG9uIFwiICsgcCArIFwiIChcIiArIGIgKyBcIiB2cyBcIiArIGUgKyBcIilcIik7XG5cdFx0XHRcdFx0YmEgPSAoZGZsdCB8fCBcIlwiKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0bCA9IGJhLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHB0LnNldFJhdGlvID0gc2V0UmF0aW87XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRidiA9IGJhW2ldO1xuXHRcdFx0XHRcdGV2ID0gZWFbaV07XG5cdFx0XHRcdFx0Ym4gPSBwYXJzZUZsb2F0KGJ2KTtcblxuXHRcdFx0XHRcdC8vaWYgdGhlIHZhbHVlIGJlZ2lucyB3aXRoIGEgbnVtYmVyIChtb3N0IGNvbW1vbikuIEl0J3MgZmluZSBpZiBpdCBoYXMgYSBzdWZmaXggbGlrZSBweFxuXHRcdFx0XHRcdGlmIChibiB8fCBibiA9PT0gMCkge1xuXHRcdFx0XHRcdFx0cHQuYXBwZW5kWHRyYShcIlwiLCBibiwgX3BhcnNlQ2hhbmdlKGV2LCBibiksIGV2LnJlcGxhY2UoX3JlbE51bUV4cCwgXCJcIiksIChhdXRvUm91bmQgJiYgZXYuaW5kZXhPZihcInB4XCIpICE9PSAtMSksIHRydWUpO1xuXG5cdFx0XHRcdFx0Ly9pZiB0aGUgdmFsdWUgaXMgYSBjb2xvclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY2xycyAmJiAoYnYuY2hhckF0KDApID09PSBcIiNcIiB8fCBfY29sb3JMb29rdXBbYnZdIHx8IF9yZ2Joc2xFeHAudGVzdChidikpKSB7XG5cdFx0XHRcdFx0XHRzdHIgPSBldi5jaGFyQXQoZXYubGVuZ3RoIC0gMSkgPT09IFwiLFwiID8gXCIpLFwiIDogXCIpXCI7IC8vaWYgdGhlcmUncyBhIGNvbW1hIGF0IHRoZSBlbmQsIHJldGFpbiBpdC5cblx0XHRcdFx0XHRcdGJ2ID0gX3BhcnNlQ29sb3IoYnYpO1xuXHRcdFx0XHRcdFx0ZXYgPSBfcGFyc2VDb2xvcihldik7XG5cdFx0XHRcdFx0XHRyZ2JhID0gKGJ2Lmxlbmd0aCArIGV2Lmxlbmd0aCA+IDYpO1xuXHRcdFx0XHRcdFx0aWYgKHJnYmEgJiYgIV9zdXBwb3J0c09wYWNpdHkgJiYgZXZbM10gPT09IDApIHsgLy9vbGRlciB2ZXJzaW9ucyBvZiBJRSBkb24ndCBzdXBwb3J0IHJnYmEoKSwgc28gaWYgdGhlIGRlc3RpbmF0aW9uIGFscGhhIGlzIDAsIGp1c3QgdXNlIFwidHJhbnNwYXJlbnRcIiBmb3IgdGhlIGVuZCBjb2xvclxuXHRcdFx0XHRcdFx0XHRwdFtcInhzXCIgKyBwdC5sXSArPSBwdC5sID8gXCIgdHJhbnNwYXJlbnRcIiA6IFwidHJhbnNwYXJlbnRcIjtcblx0XHRcdFx0XHRcdFx0cHQuZSA9IHB0LmUuc3BsaXQoZWFbaV0pLmpvaW4oXCJ0cmFuc3BhcmVudFwiKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmICghX3N1cHBvcnRzT3BhY2l0eSkgeyAvL29sZCB2ZXJzaW9ucyBvZiBJRSBkb24ndCBzdXBwb3J0IHJnYmEoKS5cblx0XHRcdFx0XHRcdFx0XHRyZ2JhID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHQuYXBwZW5kWHRyYSgocmdiYSA/IFwicmdiYShcIiA6IFwicmdiKFwiKSwgYnZbMF0sIGV2WzBdIC0gYnZbMF0sIFwiLFwiLCB0cnVlLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHRcdC5hcHBlbmRYdHJhKFwiXCIsIGJ2WzFdLCBldlsxXSAtIGJ2WzFdLCBcIixcIiwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kWHRyYShcIlwiLCBidlsyXSwgZXZbMl0gLSBidlsyXSwgKHJnYmEgPyBcIixcIiA6IHN0ciksIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRpZiAocmdiYSkge1xuXHRcdFx0XHRcdFx0XHRcdGJ2ID0gKGJ2Lmxlbmd0aCA8IDQpID8gMSA6IGJ2WzNdO1xuXHRcdFx0XHRcdFx0XHRcdHB0LmFwcGVuZFh0cmEoXCJcIiwgYnYsICgoZXYubGVuZ3RoIDwgNCkgPyAxIDogZXZbM10pIC0gYnYsIHN0ciwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ym51bXMgPSBidi5tYXRjaChfbnVtRXhwKTsgLy9nZXRzIGVhY2ggZ3JvdXAgb2YgbnVtYmVycyBpbiB0aGUgYmVnaW5uaW5nIHZhbHVlIHN0cmluZyBhbmQgZHJvcHMgdGhlbSBpbnRvIGFuIGFycmF5XG5cblx0XHRcdFx0XHRcdC8vaWYgbm8gbnVtYmVyIGlzIGZvdW5kLCB0cmVhdCBpdCBhcyBhIG5vbi10d2VlbmluZyB2YWx1ZSBhbmQganVzdCBhcHBlbmQgdGhlIHN0cmluZyB0byB0aGUgY3VycmVudCB4cy5cblx0XHRcdFx0XHRcdGlmICghYm51bXMpIHtcblx0XHRcdFx0XHRcdFx0cHRbXCJ4c1wiICsgcHQubF0gKz0gcHQubCA/IFwiIFwiICsgYnYgOiBidjtcblxuXHRcdFx0XHRcdFx0Ly9sb29wIHRocm91Z2ggYWxsIHRoZSBudW1iZXJzIHRoYXQgYXJlIGZvdW5kIGFuZCBjb25zdHJ1Y3QgdGhlIGV4dHJhIHZhbHVlcyBvbiB0aGUgcHQuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRlbnVtcyA9IGV2Lm1hdGNoKF9yZWxOdW1FeHApOyAvL2dldCBlYWNoIGdyb3VwIG9mIG51bWJlcnMgaW4gdGhlIGVuZCB2YWx1ZSBzdHJpbmcgYW5kIGRyb3AgdGhlbSBpbnRvIGFuIGFycmF5LiBXZSBhbGxvdyByZWxhdGl2ZSB2YWx1ZXMgdG9vLCBsaWtlICs9NTAgb3IgLT0uNVxuXHRcdFx0XHRcdFx0XHRpZiAoIWVudW1zIHx8IGVudW1zLmxlbmd0aCAhPT0gYm51bXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcIm1pc21hdGNoZWQgZm9ybWF0dGluZyBkZXRlY3RlZCBvbiBcIiArIHAgKyBcIiAoXCIgKyBiICsgXCIgdnMgXCIgKyBlICsgXCIpXCIpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRuaSA9IDA7XG5cdFx0XHRcdFx0XHRcdGZvciAoeGkgPSAwOyB4aSA8IGJudW1zLmxlbmd0aDsgeGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGN2ID0gYm51bXNbeGldO1xuXHRcdFx0XHRcdFx0XHRcdHRlbXAgPSBidi5pbmRleE9mKGN2LCBuaSk7XG5cdFx0XHRcdFx0XHRcdFx0cHQuYXBwZW5kWHRyYShidi5zdWJzdHIobmksIHRlbXAgLSBuaSksIE51bWJlcihjdiksIF9wYXJzZUNoYW5nZShlbnVtc1t4aV0sIGN2KSwgXCJcIiwgKGF1dG9Sb3VuZCAmJiBidi5zdWJzdHIodGVtcCArIGN2Lmxlbmd0aCwgMikgPT09IFwicHhcIiksICh4aSA9PT0gMCkpO1xuXHRcdFx0XHRcdFx0XHRcdG5pID0gdGVtcCArIGN2Lmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwdFtcInhzXCIgKyBwdC5sXSArPSBidi5zdWJzdHIobmkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvL2lmIHRoZXJlIGFyZSByZWxhdGl2ZSB2YWx1ZXMgKFwiKz1cIiBvciBcIi09XCIgcHJlZml4KSwgd2UgbmVlZCB0byBhZGp1c3QgdGhlIGVuZGluZyB2YWx1ZSB0byBlbGltaW5hdGUgdGhlIHByZWZpeGVzIGFuZCBjb21iaW5lIHRoZSB2YWx1ZXMgcHJvcGVybHkuXG5cdFx0XHRcdGlmIChlLmluZGV4T2YoXCI9XCIpICE9PSAtMSkgaWYgKHB0LmRhdGEpIHtcblx0XHRcdFx0XHRzdHIgPSBwdC54czAgKyBwdC5kYXRhLnM7XG5cdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8IHB0Lmw7IGkrKykge1xuXHRcdFx0XHRcdFx0c3RyICs9IHB0W1wieHNcIiArIGldICsgcHQuZGF0YVtcInhuXCIgKyBpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQuZSA9IHN0ciArIHB0W1wieHNcIiArIGldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghcHQubCkge1xuXHRcdFx0XHRcdHB0LnR5cGUgPSAtMTtcblx0XHRcdFx0XHRwdC54czAgPSBwdC5lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwdC54Zmlyc3QgfHwgcHQ7XG5cdFx0XHR9LFxuXHRcdFx0aSA9IDk7XG5cblxuXHRcdHAgPSBDU1NQcm9wVHdlZW4ucHJvdG90eXBlO1xuXHRcdHAubCA9IHAucHIgPSAwOyAvL2xlbmd0aCAobnVtYmVyIG9mIGV4dHJhIHByb3BlcnRpZXMgbGlrZSB4bjEsIHhuMiwgeG4zLCBldGMuXG5cdFx0d2hpbGUgKC0taSA+IDApIHtcblx0XHRcdHBbXCJ4blwiICsgaV0gPSAwO1xuXHRcdFx0cFtcInhzXCIgKyBpXSA9IFwiXCI7XG5cdFx0fVxuXHRcdHAueHMwID0gXCJcIjtcblx0XHRwLl9uZXh0ID0gcC5fcHJldiA9IHAueGZpcnN0ID0gcC5kYXRhID0gcC5wbHVnaW4gPSBwLnNldFJhdGlvID0gcC5yeHAgPSBudWxsO1xuXG5cblx0XHQvKipcblx0XHQgKiBBcHBlbmRzIGFuZCBleHRyYSB0d2VlbmluZyB2YWx1ZSB0byBhIENTU1Byb3BUd2VlbiBhbmQgYXV0b21hdGljYWxseSBtYW5hZ2VzIGFueSBwcmVmaXggYW5kIHN1ZmZpeCBzdHJpbmdzLiBUaGUgZmlyc3QgZXh0cmEgdmFsdWUgaXMgc3RvcmVkIGluIHRoZSBzIGFuZCBjIG9mIHRoZSBtYWluIENTU1Byb3BUd2VlbiBpbnN0YW5jZSwgYnV0IHRoZXJlYWZ0ZXIgYW55IGV4dHJhcyBhcmUgc3RvcmVkIGluIHRoZSB4bjEsIHhuMiwgeG4zLCBldGMuIFRoZSBwcmVmaXhlcyBhbmQgc3VmZml4ZXMgYXJlIHN0b3JlZCBpbiB0aGUgeHMwLCB4czEsIHhzMiwgZXRjLiBwcm9wZXJ0aWVzLiBGb3IgZXhhbXBsZSwgaWYgSSB3YWxrIHRocm91Z2ggYSBjbGlwIHZhbHVlIGxpa2UgXCJyZWN0KDEwcHgsIDVweCwgMHB4LCAyMHB4KVwiLCB0aGUgdmFsdWVzIHdvdWxkIGJlIHN0b3JlZCBsaWtlIHRoaXM6XG5cdFx0ICogeHMwOlwicmVjdChcIiwgczoxMCwgeHMxOlwicHgsIFwiLCB4bjE6NSwgeHMyOlwicHgsIFwiLCB4bjI6MCwgeHMzOlwicHgsIFwiLCB4bjM6MjAsIHhuNDpcInB4KVwiXG5cdFx0ICogQW5kIHRoZXknZCBhbGwgZ2V0IGpvaW5lZCB0b2dldGhlciB3aGVuIHRoZSBDU1NQbHVnaW4gcmVuZGVycyAoaW4gdGhlIHNldFJhdGlvKCkgbWV0aG9kKS5cblx0XHQgKiBAcGFyYW0ge3N0cmluZz19IHBmeCBQcmVmaXggKGlmIGFueSlcblx0XHQgKiBAcGFyYW0geyFudW1iZXJ9IHMgU3RhcnRpbmcgdmFsdWVcblx0XHQgKiBAcGFyYW0geyFudW1iZXJ9IGMgQ2hhbmdlIGluIG51bWVyaWMgdmFsdWUgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBlbnRpcmUgdHdlZW4uIEZvciBleGFtcGxlLCBpZiB0aGUgc3RhcnQgaXMgNSBhbmQgdGhlIGVuZCBpcyAxMDAsIHRoZSBjaGFuZ2Ugd291bGQgYmUgOTUuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBzZnggU3VmZml4IChpZiBhbnkpXG5cdFx0ICogQHBhcmFtIHtib29sZWFuPX0gciBSb3VuZCAoaWYgdHJ1ZSkuXG5cdFx0ICogQHBhcmFtIHtib29sZWFuPX0gcGFkIElmIHRydWUsIHRoaXMgZXh0cmEgdmFsdWUgc2hvdWxkIGJlIHNlcGFyYXRlZCBieSB0aGUgcHJldmlvdXMgb25lIGJ5IGEgc3BhY2UuIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGV4dHJhIGFuZCBwYWQgaXMgdHJ1ZSwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGRyb3AgdGhlIHNwYWNlLlxuXHRcdCAqIEByZXR1cm4ge0NTU1Byb3BUd2Vlbn0gcmV0dXJucyBpdHNlbGYgc28gdGhhdCBtdWx0aXBsZSBtZXRob2RzIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLlxuXHRcdCAqL1xuXHRcdHAuYXBwZW5kWHRyYSA9IGZ1bmN0aW9uKHBmeCwgcywgYywgc2Z4LCByLCBwYWQpIHtcblx0XHRcdHZhciBwdCA9IHRoaXMsXG5cdFx0XHRcdGwgPSBwdC5sO1xuXHRcdFx0cHRbXCJ4c1wiICsgbF0gKz0gKHBhZCAmJiBsKSA/IFwiIFwiICsgcGZ4IDogcGZ4IHx8IFwiXCI7XG5cdFx0XHRpZiAoIWMpIGlmIChsICE9PSAwICYmICFwdC5wbHVnaW4pIHsgLy90eXBpY2FsbHkgd2UnbGwgY29tYmluZSBub24tY2hhbmdpbmcgdmFsdWVzIHJpZ2h0IGludG8gdGhlIHhzIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlLCBidXQgd2UgZG9uJ3QgY29tYmluZSB0aGVtIHdoZW4gdGhlcmUncyBhIHBsdWdpbiB0aGF0IHdpbGwgYmUgdHdlZW5pbmcgdGhlIHZhbHVlcyBiZWNhdXNlIGl0IG1heSBkZXBlbmQgb24gdGhlIHZhbHVlcyBiZWluZyBzcGxpdCBhcGFydCwgbGlrZSBmb3IgYSBiZXppZXIsIGlmIGEgdmFsdWUgZG9lc24ndCBjaGFuZ2UgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIHNlY29uZCBpdGVyYXRpb24gYnV0IHRoZW4gaXQgZG9lcyBvbiB0aGUgM3JkLCB3ZSdsbCBydW4gaW50byB0cm91YmxlIGJlY2F1c2UgdGhlcmUncyBubyB4biBzbG90IGZvciB0aGF0IHZhbHVlIVxuXHRcdFx0XHRwdFtcInhzXCIgKyBsXSArPSBzICsgKHNmeCB8fCBcIlwiKTtcblx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0fVxuXHRcdFx0cHQubCsrO1xuXHRcdFx0cHQudHlwZSA9IHB0LnNldFJhdGlvID8gMiA6IDE7XG5cdFx0XHRwdFtcInhzXCIgKyBwdC5sXSA9IHNmeCB8fCBcIlwiO1xuXHRcdFx0aWYgKGwgPiAwKSB7XG5cdFx0XHRcdHB0LmRhdGFbXCJ4blwiICsgbF0gPSBzICsgYztcblx0XHRcdFx0cHQucnhwW1wieG5cIiArIGxdID0gcjsgLy9yb3VuZCBleHRyYSBwcm9wZXJ0eSAod2UgbmVlZCB0byB0YXAgaW50byB0aGlzIGluIHRoZSBfcGFyc2VUb1Byb3h5KCkgbWV0aG9kKVxuXHRcdFx0XHRwdFtcInhuXCIgKyBsXSA9IHM7XG5cdFx0XHRcdGlmICghcHQucGx1Z2luKSB7XG5cdFx0XHRcdFx0cHQueGZpcnN0ID0gbmV3IENTU1Byb3BUd2VlbihwdCwgXCJ4blwiICsgbCwgcywgYywgcHQueGZpcnN0IHx8IHB0LCAwLCBwdC5uLCByLCBwdC5wcik7XG5cdFx0XHRcdFx0cHQueGZpcnN0LnhzMCA9IDA7IC8vanVzdCB0byBlbnN1cmUgdGhhdCB0aGUgcHJvcGVydHkgc3RheXMgbnVtZXJpYyB3aGljaCBoZWxwcyBtb2Rlcm4gYnJvd3NlcnMgc3BlZWQgdXAgcHJvY2Vzc2luZy4gUmVtZW1iZXIsIGluIHRoZSBzZXRSYXRpbygpIG1ldGhvZCwgd2UgZG8gcHQudFtwdC5wXSA9IHZhbCArIHB0LnhzMCBzbyBpZiBwdC54czAgaXMgXCJcIiAodGhlIGRlZmF1bHQpLCBpdCdsbCBjYXN0IHRoZSBlbmQgdmFsdWUgYXMgYSBzdHJpbmcuIFdoZW4gYSBwcm9wZXJ0eSBpcyBhIG51bWJlciBzb21ldGltZXMgYW5kIGEgc3RyaW5nIHNvbWV0aW1lcywgaXQgcHJldmVudHMgdGhlIGNvbXBpbGVyIGZyb20gbG9ja2luZyBpbiB0aGUgZGF0YSB0eXBlLCBzbG93aW5nIHRoaW5ncyBkb3duIHNsaWdodGx5LlxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH1cblx0XHRcdHB0LmRhdGEgPSB7czpzICsgY307XG5cdFx0XHRwdC5yeHAgPSB7fTtcblx0XHRcdHB0LnMgPSBzO1xuXHRcdFx0cHQuYyA9IGM7XG5cdFx0XHRwdC5yID0gcjtcblx0XHRcdHJldHVybiBwdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQGNvbnN0cnVjdG9yIEEgU3BlY2lhbFByb3AgaXMgYmFzaWNhbGx5IGEgY3NzIHByb3BlcnR5IHRoYXQgbmVlZHMgdG8gYmUgdHJlYXRlZCBpbiBhIG5vbi1zdGFuZGFyZCB3YXksIGxpa2UgaWYgaXQgbWF5IGNvbnRhaW4gYSBjb21wbGV4IHZhbHVlIGxpa2UgYm94U2hhZG93OlwiNXB4IDEwcHggMTVweCByZ2IoMjU1LCAxMDIsIDUxKVwiIG9yIGlmIGl0IGlzIGFzc29jaWF0ZWQgd2l0aCBhbm90aGVyIHBsdWdpbiBsaWtlIFRocm93UHJvcHNQbHVnaW4gb3IgQmV6aWVyUGx1Z2luLiBFdmVyeSBTcGVjaWFsUHJvcCBpcyBhc3NvY2lhdGVkIHdpdGggYSBwYXJ0aWN1bGFyIHByb3BlcnR5IG5hbWUgbGlrZSBcImJveFNoYWRvd1wiIG9yIFwidGhyb3dQcm9wc1wiIG9yIFwiYmV6aWVyXCIgYW5kIGl0IHdpbGwgaW50ZXJjZXB0IHRob3NlIHZhbHVlcyBpbiB0aGUgdmFycyBvYmplY3QgdGhhdCdzIHBhc3NlZCB0byB0aGUgQ1NTUGx1Z2luIGFuZCBoYW5kbGUgdGhlbSBhY2NvcmRpbmdseS5cblx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgUHJvcGVydHkgbmFtZSAobGlrZSBcImJveFNoYWRvd1wiIG9yIFwidGhyb3dQcm9wc1wiKVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBhbnkgb2YgdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9uIG9wdGlvbnM6XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBkZWZhdWx0VmFsdWU6IHRoZSBkZWZhdWx0IHZhbHVlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBwYXJzZXI6IEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgbmFtZSBpcyBmb3VuZCBpbiB0aGUgdmFycy4gVGhpcyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlIGFuZCBpdCBzaG91bGQgZW5zdXJlIHRoYXQgaXQgaXMgcHJvcGVybHkgaW5zZXJ0ZWQgaW50byB0aGUgbGlua2VkIGxpc3QuIEl0IHdpbGwgcmVjZWl2ZSA0IHBhcmFtdGVyczogMSkgVGhlIHRhcmdldCwgMikgVGhlIHZhbHVlIGRlZmluZWQgaW4gdGhlIHZhcnMsIDMpIFRoZSBDU1NQbHVnaW4gaW5zdGFuY2UgKHdob3NlIF9maXJzdFBUIHNob3VsZCBiZSB1c2VkIGZvciB0aGUgbGlua2VkIGxpc3QpLCBhbmQgNCkgQSBjb21wdXRlZCBzdHlsZSBvYmplY3QgaWYgb25lIHdhcyBjYWxjdWxhdGVkICh0aGlzIGlzIGEgc3BlZWQgb3B0aW1pemF0aW9uIHRoYXQgYWxsb3dzIHJldHJpZXZhbCBvZiBzdGFydGluZyB2YWx1ZXMgcXVpY2tlcilcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGZvcm1hdHRlcjogYSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYW55IHZhbHVlIHJlY2VpdmVkIGZvciB0aGlzIHNwZWNpYWwgcHJvcGVydHkgKGZvciBleGFtcGxlLCBib3hTaGFkb3cgY291bGQgdGFrZSBcIjVweCA1cHggcmVkXCIgYW5kIGZvcm1hdCBpdCB0byBcIjVweCA1cHggMHB4IDBweCByZWRcIiBzbyB0aGF0IGJvdGggdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBoYXZlIGEgY29tbW9uIG9yZGVyIGFuZCBxdWFudGl0eSBvZiB2YWx1ZXMuKVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gcHJlZml4OiBpZiB0cnVlLCB3ZSdsbCBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdGhpcyBwcm9wZXJ0eSByZXF1aXJlcyBhIHZlbmRvciBwcmVmaXggKGxpa2UgV2Via2l0IG9yIE1veiBvciBtcyBvciBPKVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gY29sb3I6IHNldCB0aGlzIHRvIHRydWUgaWYgdGhlIHZhbHVlIGZvciB0aGlzIFNwZWNpYWxQcm9wIG1heSBjb250YWluIGNvbG9yLXJlbGF0ZWQgdmFsdWVzIGxpa2UgcmdiKCksIHJnYmEoKSwgZXRjLlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gcHJpb3JpdHk6IHByaW9yaXR5IGluIHRoZSBsaW5rZWQgbGlzdCBvcmRlci4gSGlnaGVyIHByaW9yaXR5IFNwZWNpYWxQcm9wcyB3aWxsIGJlIHVwZGF0ZWQgYmVmb3JlIGxvd2VyIHByaW9yaXR5IG9uZXMuIFRoZSBkZWZhdWx0IHByaW9yaXR5IGlzIDAuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBtdWx0aTogaWYgdHJ1ZSwgdGhlIGZvcm1hdHRlciBzaG91bGQgYWNjb21tb2RhdGUgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMsIGxpa2UgYm94U2hhZG93IGNvdWxkIGhhdmUgbXVsdGlwbGUgYm94U2hhZG93cyBsaXN0ZWQgb3V0LlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gY29sbGFwc2libGU6IGlmIHRydWUsIHRoZSBmb3JtYXR0ZXIgc2hvdWxkIHRyZWF0IHRoZSB2YWx1ZSBsaWtlIGl0J3MgYSB0b3AvcmlnaHQvYm90dG9tL2xlZnQgdmFsdWUgdGhhdCBjb3VsZCBiZSBjb2xsYXBzZWQsIGxpa2UgXCI1cHhcIiB3b3VsZCBhcHBseSB0byBhbGwsIFwiNXB4LCAxMHB4XCIgd291bGQgdXNlIDVweCBmb3IgdG9wL2JvdHRvbSBhbmQgMTBweCBmb3IgcmlnaHQvbGVmdCwgZXRjLlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0ga2V5d29yZDogYSBzcGVjaWFsIGtleXdvcmQgdGhhdCBjYW4gW29wdGlvbmFsbHldIGJlIGZvdW5kIGluc2lkZSB0aGUgdmFsdWUgKGxpa2UgXCJpbnNldFwiIGZvciBib3hTaGFkb3cpLiBUaGlzIGFsbG93cyB1cyB0byB2YWxpZGF0ZSBiZWdpbm5pbmcvZW5kaW5nIHZhbHVlcyB0byBtYWtlIHN1cmUgdGhleSBtYXRjaCAoaWYgdGhlIGtleXdvcmQgaXMgZm91bmQgaW4gb25lLCBpdCdsbCBiZSBhZGRlZCB0byB0aGUgb3RoZXIgZm9yIGNvbnNpc3RlbmN5IGJ5IGRlZmF1bHQpLlxuXHRcdCAqL1xuXHRcdHZhciBTcGVjaWFsUHJvcCA9IGZ1bmN0aW9uKHAsIG9wdGlvbnMpIHtcblx0XHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRcdHRoaXMucCA9IG9wdGlvbnMucHJlZml4ID8gX2NoZWNrUHJvcFByZWZpeChwKSB8fCBwIDogcDtcblx0XHRcdFx0X3NwZWNpYWxQcm9wc1twXSA9IF9zcGVjaWFsUHJvcHNbdGhpcy5wXSA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXR0ZXIgfHwgX2dldEZvcm1hdHRlcihvcHRpb25zLmRlZmF1bHRWYWx1ZSwgb3B0aW9ucy5jb2xvciwgb3B0aW9ucy5jb2xsYXBzaWJsZSwgb3B0aW9ucy5tdWx0aSk7XG5cdFx0XHRcdGlmIChvcHRpb25zLnBhcnNlcikge1xuXHRcdFx0XHRcdHRoaXMucGFyc2UgPSBvcHRpb25zLnBhcnNlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmNscnMgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0XHR0aGlzLm11bHRpID0gb3B0aW9ucy5tdWx0aTtcblx0XHRcdFx0dGhpcy5rZXl3b3JkID0gb3B0aW9ucy5rZXl3b3JkO1xuXHRcdFx0XHR0aGlzLmRmbHQgPSBvcHRpb25zLmRlZmF1bHRWYWx1ZTtcblx0XHRcdFx0dGhpcy5wciA9IG9wdGlvbnMucHJpb3JpdHkgfHwgMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vc2hvcnRjdXQgZm9yIGNyZWF0aW5nIGEgbmV3IFNwZWNpYWxQcm9wIHRoYXQgY2FuIGFjY2VwdCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGFzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3QgKGhlbHBzIG1pbmlmaWNhdGlvbikuIGRmbHQgY2FuIGJlIGFuIGFycmF5IGZvciBtdWx0aXBsZSB2YWx1ZXMgKHdlIGRvbid0IGRvIGEgY29tbWEtZGVsaW1pdGVkIGxpc3QgYmVjYXVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBtYXkgY29udGFpbiBjb21tYXMsIGxpa2UgcmVjdCgwcHgsMHB4LDBweCwwcHgpKS4gV2UgYXR0YWNoIHRoaXMgbWV0aG9kIHRvIHRoZSBTcGVjaWFsUHJvcCBjbGFzcy9vYmplY3QgaW5zdGVhZCBvZiB1c2luZyBhIHByaXZhdGUgX2NyZWF0ZVNwZWNpYWxQcm9wKCkgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIHRhcCBpbnRvIGl0IGV4dGVybmFsbHkgaWYgbmVjZXNzYXJ5LCBsaWtlIGZyb20gYW5vdGhlciBwbHVnaW4uXG5cdFx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AgPSBfaW50ZXJuYWxzLl9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcCA9IGZ1bmN0aW9uKHAsIG9wdGlvbnMsIGRlZmF1bHRzKSB7XG5cdFx0XHRcdGlmICh0eXBlb2Yob3B0aW9ucykgIT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0XHRvcHRpb25zID0ge3BhcnNlcjpkZWZhdWx0c307IC8vdG8gbWFrZSBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIEJlemllclBsdWdpbiBhbmQgVGhyb3dQcm9wc1BsdWdpblxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBhID0gcC5zcGxpdChcIixcIiksXG5cdFx0XHRcdFx0ZCA9IG9wdGlvbnMuZGVmYXVsdFZhbHVlLFxuXHRcdFx0XHRcdGksIHRlbXA7XG5cdFx0XHRcdGRlZmF1bHRzID0gZGVmYXVsdHMgfHwgW2RdO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG9wdGlvbnMucHJlZml4ID0gKGkgPT09IDAgJiYgb3B0aW9ucy5wcmVmaXgpO1xuXHRcdFx0XHRcdG9wdGlvbnMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdHNbaV0gfHwgZDtcblx0XHRcdFx0XHR0ZW1wID0gbmV3IFNwZWNpYWxQcm9wKGFbaV0sIG9wdGlvbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2NyZWF0ZXMgYSBwbGFjZWhvbGRlciBzcGVjaWFsIHByb3AgZm9yIGEgcGx1Z2luIHNvIHRoYXQgdGhlIHByb3BlcnR5IGdldHMgY2F1Z2h0IHRoZSBmaXJzdCB0aW1lIGEgdHdlZW4gb2YgaXQgaXMgYXR0ZW1wdGVkLCBhbmQgYXQgdGhhdCB0aW1lIGl0IG1ha2VzIHRoZSBwbHVnaW4gcmVnaXN0ZXIgaXRzZWxmLCB0aHVzIHRha2luZyBvdmVyIGZvciBhbGwgZnV0dXJlIHR3ZWVucyBvZiB0aGF0IHByb3BlcnR5LiBUaGlzIGFsbG93cyB1cyB0byBub3QgbWFuZGF0ZSB0aGF0IHRoaW5ncyBsb2FkIGluIGEgcGFydGljdWxhciBvcmRlciBhbmQgaXQgYWxzbyBhbGxvd3MgdXMgdG8gbG9nKCkgYW4gZXJyb3IgdGhhdCBpbmZvcm1zIHRoZSB1c2VyIHdoZW4gdGhleSBhdHRlbXB0IHRvIHR3ZWVuIGFuIGV4dGVybmFsIHBsdWdpbi1yZWxhdGVkIHByb3BlcnR5IHdpdGhvdXQgbG9hZGluZyBpdHMgLmpzIGZpbGUuXG5cdFx0XHRfcmVnaXN0ZXJQbHVnaW5Qcm9wID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRpZiAoIV9zcGVjaWFsUHJvcHNbcF0pIHtcblx0XHRcdFx0XHR2YXIgcGx1Z2luTmFtZSA9IHAuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwLnN1YnN0cigxKSArIFwiUGx1Z2luXCI7XG5cdFx0XHRcdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKHAsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0XHRcdFx0dmFyIHBsdWdpbkNsYXNzID0gX2dsb2JhbHMuY29tLmdyZWVuc29jay5wbHVnaW5zW3BsdWdpbk5hbWVdO1xuXHRcdFx0XHRcdFx0aWYgKCFwbHVnaW5DbGFzcykge1xuXHRcdFx0XHRcdFx0XHRfbG9nKFwiRXJyb3I6IFwiICsgcGx1Z2luTmFtZSArIFwiIGpzIGZpbGUgbm90IGxvYWRlZC5cIik7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBsdWdpbkNsYXNzLl9jc3NSZWdpc3RlcigpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIF9zcGVjaWFsUHJvcHNbcF0ucGFyc2UodCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycyk7XG5cdFx0XHRcdFx0fX0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cblx0XHRwID0gU3BlY2lhbFByb3AucHJvdG90eXBlO1xuXG5cdFx0LyoqXG5cdFx0ICogQWxpYXMgZm9yIF9wYXJzZUNvbXBsZXgoKSB0aGF0IGF1dG9tYXRpY2FsbHkgcGx1Z3MgaW4gY2VydGFpbiB2YWx1ZXMgZm9yIHRoaXMgU3BlY2lhbFByb3AsIGxpa2UgaXRzIHByb3BlcnR5IG5hbWUsIHdoZXRoZXIgb3Igbm90IGNvbG9ycyBzaG91bGQgYmUgc2Vuc2VkLCB0aGUgZGVmYXVsdCB2YWx1ZSwgYW5kIHByaW9yaXR5LiBJdCBhbHNvIGxvb2tzIGZvciBhbnkga2V5d29yZCB0aGF0IHRoZSBTcGVjaWFsUHJvcCBkZWZpbmVzIChsaWtlIFwiaW5zZXRcIiBmb3IgYm94U2hhZG93KSBhbmQgZW5zdXJlcyB0aGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgdmFsdWVzIGZvciBTcGVjaWFsUHJvcHMgd2hlcmUgbXVsdGkgaXMgdHJ1ZSAobGlrZSBib3hTaGFkb3cgYW5kIHRleHRTaGFkb3cgY2FuIGhhdmUgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdClcblx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgdGFyZ2V0IGVsZW1lbnRcblx0XHQgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyfG9iamVjdCl9IGIgYmVnaW5uaW5nIHZhbHVlXG5cdFx0ICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxvYmplY3QpfSBlIGVuZGluZyAoZGVzdGluYXRpb24pIHZhbHVlXG5cdFx0ICogQHBhcmFtIHtDU1NQcm9wVHdlZW49fSBwdCBuZXh0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIElmIGFub3RoZXIgcGx1Z2luIHdpbGwgYmUgdHdlZW5pbmcgdGhlIGNvbXBsZXggdmFsdWUsIHRoYXQgVHdlZW5QbHVnaW4gaW5zdGFuY2UgZ29lcyBoZXJlLlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb249fSBzZXRSYXRpbyBJZiBhIGN1c3RvbSBzZXRSYXRpbygpIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBoYW5kbGUgdGhpcyBjb21wbGV4IHZhbHVlLCB0aGF0IGdvZXMgaGVyZS5cblx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW49fSBGaXJzdCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0ICovXG5cdFx0cC5wYXJzZUNvbXBsZXggPSBmdW5jdGlvbih0LCBiLCBlLCBwdCwgcGx1Z2luLCBzZXRSYXRpbykge1xuXHRcdFx0dmFyIGt3ZCA9IHRoaXMua2V5d29yZCxcblx0XHRcdFx0aSwgYmEsIGVhLCBsLCBiaSwgZWk7XG5cdFx0XHQvL2lmIHRoaXMgU3BlY2lhbFByb3AncyB2YWx1ZSBjYW4gY29udGFpbiBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcyAobGlrZSBib3hTaGFkb3cgb3IgdGV4dFNoYWRvdyksIHdlIG11c3QgcGFyc2UgdGhlbSBpbiBhIHNwZWNpYWwgd2F5LCBhbmQgbG9vayBmb3IgYSBrZXl3b3JkIChsaWtlIFwiaW5zZXRcIiBmb3IgYm94U2hhZG93KSBhbmQgZW5zdXJlIHRoYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIEJPVEggaGF2ZSBpdCBpZiB0aGUgZW5kIGRlZmluZXMgaXQgYXMgc3VjaC4gV2UgYWxzbyBtdXN0IGVuc3VyZSB0aGF0IHRoZXJlIGFyZSBhbiBlcXVhbCBudW1iZXIgb2YgdmFsdWVzIHNwZWNpZmllZCAod2UgY2FuJ3QgdHdlZW4gMSBib3hTaGFkb3cgdG8gMyBmb3IgZXhhbXBsZSlcblx0XHRcdGlmICh0aGlzLm11bHRpKSBpZiAoX2NvbW1hc091dHNpZGVQYXJlbkV4cC50ZXN0KGUpIHx8IF9jb21tYXNPdXRzaWRlUGFyZW5FeHAudGVzdChiKSkge1xuXHRcdFx0XHRiYSA9IGIucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcInxcIikuc3BsaXQoXCJ8XCIpO1xuXHRcdFx0XHRlYSA9IGUucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcInxcIikuc3BsaXQoXCJ8XCIpO1xuXHRcdFx0fSBlbHNlIGlmIChrd2QpIHtcblx0XHRcdFx0YmEgPSBbYl07XG5cdFx0XHRcdGVhID0gW2VdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVhKSB7XG5cdFx0XHRcdGwgPSAoZWEubGVuZ3RoID4gYmEubGVuZ3RoKSA/IGVhLmxlbmd0aCA6IGJhLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGIgPSBiYVtpXSA9IGJhW2ldIHx8IHRoaXMuZGZsdDtcblx0XHRcdFx0XHRlID0gZWFbaV0gPSBlYVtpXSB8fCB0aGlzLmRmbHQ7XG5cdFx0XHRcdFx0aWYgKGt3ZCkge1xuXHRcdFx0XHRcdFx0YmkgPSBiLmluZGV4T2Yoa3dkKTtcblx0XHRcdFx0XHRcdGVpID0gZS5pbmRleE9mKGt3ZCk7XG5cdFx0XHRcdFx0XHRpZiAoYmkgIT09IGVpKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChlaSA9PT0gLTEpIHsgLy9pZiB0aGUga2V5d29yZCBpc24ndCBpbiB0aGUgZW5kIHZhbHVlLCByZW1vdmUgaXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9uZS5cblx0XHRcdFx0XHRcdFx0XHRiYVtpXSA9IGJhW2ldLnNwbGl0KGt3ZCkuam9pbihcIlwiKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChiaSA9PT0gLTEpIHsgLy9pZiB0aGUga2V5d29yZCBpc24ndCBpbiB0aGUgYmVnaW5uaW5nLCBhZGQgaXQuXG5cdFx0XHRcdFx0XHRcdFx0YmFbaV0gKz0gXCIgXCIgKyBrd2Q7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YiA9IGJhLmpvaW4oXCIsIFwiKTtcblx0XHRcdFx0ZSA9IGVhLmpvaW4oXCIsIFwiKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBfcGFyc2VDb21wbGV4KHQsIHRoaXMucCwgYiwgZSwgdGhpcy5jbHJzLCB0aGlzLmRmbHQsIHB0LCB0aGlzLnByLCBwbHVnaW4sIHNldFJhdGlvKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQWNjZXB0cyBhIHRhcmdldCBhbmQgZW5kIHZhbHVlIGFuZCBzcGl0cyBiYWNrIGEgQ1NTUHJvcFR3ZWVuIHRoYXQgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byB0aGUgQ1NTUGx1Z2luJ3MgbGlua2VkIGxpc3QgYW5kIGNvbmZvcm1zIHdpdGggYWxsIHRoZSBjb252ZW50aW9ucyB3ZSB1c2UgaW50ZXJuYWxseSwgbGlrZSB0eXBlOi0xLCAwLCAxLCBvciAyLCBzZXR0aW5nIHVwIGFueSBleHRyYSBwcm9wZXJ0eSB0d2VlbnMsIHByaW9yaXR5LCBldGMuIEZvciBleGFtcGxlLCBpZiB3ZSBoYXZlIGEgYm94U2hhZG93IFNwZWNpYWxQcm9wIGFuZCBjYWxsOlxuXHRcdCAqIHRoaXMuX2ZpcnN0UFQgPSBzcC5wYXJzZShlbGVtZW50LCBcIjVweCAxMHB4IDIwcHggcmdiKDI1NTAsMTAyLDUxKVwiLCBcImJveFNoYWRvd1wiLCB0aGlzKTtcblx0XHQgKiBJdCBzaG91bGQgZmlndXJlIG91dCB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgdGhlIGVsZW1lbnQncyBib3hTaGFkb3csIGNvbXBhcmUgaXQgdG8gdGhlIHByb3ZpZGVkIGVuZCB2YWx1ZSBhbmQgY3JlYXRlIGFsbCB0aGUgbmVjZXNzYXJ5IENTU1Byb3BUd2VlbnMgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGVzIHRvIHR3ZWVuIHRoZSBib3hTaGFkb3cuIFRoZSBDU1NQcm9wVHdlZW4gdGhhdCBnZXRzIHNwaXQgYmFjayBzaG91bGQgYWxyZWFkeSBiZSBpbnNlcnRlZCBpbnRvIHRoZSBsaW5rZWQgbGlzdCAodGhlIDR0aCBwYXJhbWV0ZXIgaXMgdGhlIGN1cnJlbnQgaGVhZCwgc28gcHJlcGVuZCB0byB0aGF0KS5cblx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBpcyBiZWluZyB0d2VlbmVkXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGUgRW5kIHZhbHVlIGFzIHByb3ZpZGVkIGluIHRoZSB2YXJzIG9iamVjdCAodHlwaWNhbGx5IGEgc3RyaW5nLCBidXQgbm90IGFsd2F5cyAtIGxpa2UgYSB0aHJvd1Byb3BzIHdvdWxkIGJlIGFuIG9iamVjdCkuXG5cdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWVcblx0XHQgKiBAcGFyYW0geyFDU1NQbHVnaW59IGNzc3AgVGhlIENTU1BsdWdpbiBpbnN0YW5jZSB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0d2Vlbi5cblx0XHQgKiBAcGFyYW0gez9DU1NQcm9wVHdlZW59IHB0IFRoZSBDU1NQcm9wVHdlZW4gdGhhdCBpcyB0aGUgY3VycmVudCBoZWFkIG9mIHRoZSBsaW5rZWQgbGlzdCAod2UnbGwgcHJlcGVuZCB0byBpdClcblx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIElmIGEgcGx1Z2luIHdpbGwgYmUgdXNlZCB0byB0d2VlbiB0aGUgcGFyc2VkIHZhbHVlLCB0aGlzIGlzIHRoZSBwbHVnaW4gaW5zdGFuY2UuXG5cdFx0ICogQHBhcmFtIHtPYmplY3Q9fSB2YXJzIE9yaWdpbmFsIHZhcnMgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEgZm9yIHBhcnNpbmcuXG5cdFx0ICogQHJldHVybiB7Q1NTUHJvcFR3ZWVufSBUaGUgZmlyc3QgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdCB3aGljaCBpbmNsdWRlcyB0aGUgbmV3IG9uZShzKSBhZGRlZCBieSB0aGUgcGFyc2UoKSBjYWxsLlxuXHRcdCAqL1xuXHRcdHAucGFyc2UgPSBmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNvbXBsZXgodC5zdHlsZSwgdGhpcy5mb3JtYXQoX2dldFN0eWxlKHQsIHRoaXMucCwgX2NzLCBmYWxzZSwgdGhpcy5kZmx0KSksIHRoaXMuZm9ybWF0KGUpLCBwdCwgcGx1Z2luKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXJzIGEgc3BlY2lhbCBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSBpbnRlcmNlcHRlZCBmcm9tIGFueSBcImNzc1wiIG9iamVjdHMgZGVmaW5lZCBpbiB0d2VlbnMuIFRoaXMgYWxsb3dzIHlvdSB0byBoYW5kbGUgdGhlbSBob3dldmVyIHlvdSB3YW50IHdpdGhvdXQgQ1NTUGx1Z2luIGRvaW5nIGl0IGZvciB5b3UuIFRoZSAybmQgcGFyYW1ldGVyIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyAzIHBhcmFtZXRlcnM6XG5cdFx0ICogIDEpIFRhcmdldCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgc2hvdWxkIGJlIHR3ZWVuZWQgKHR5cGljYWxseSBhIERPTSBlbGVtZW50KVxuXHRcdCAqICAyKSBUaGUgZW5kL2Rlc3RpbmF0aW9uIHZhbHVlIChjb3VsZCBiZSBhIHN0cmluZywgbnVtYmVyLCBvYmplY3QsIG9yIHdoYXRldmVyIHlvdSB3YW50KVxuXHRcdCAqICAzKSBUaGUgdHdlZW4gaW5zdGFuY2UgKHlvdSBwcm9iYWJseSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoaXMsIGJ1dCBpdCBjYW4gYmUgdXNlZnVsIGZvciBsb29raW5nIHVwIGluZm9ybWF0aW9uIGxpa2UgdGhlIGR1cmF0aW9uKVxuXHRcdCAqXG5cdFx0ICogVGhlbiwgeW91ciBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZWFjaCB0aW1lIHRoZSB0d2VlbiBnZXRzIHJlbmRlcmVkLCBwYXNzaW5nIGEgbnVtZXJpYyBcInJhdGlvXCIgcGFyYW1ldGVyIHRvIHlvdXIgZnVuY3Rpb24gdGhhdCBpbmRpY2F0ZXMgdGhlIGNoYW5nZSBmYWN0b3IgKHVzdWFsbHkgYmV0d2VlbiAwIGFuZCAxKS4gRm9yIGV4YW1wbGU6XG5cdFx0ICpcblx0XHQgKiBDU1NQbHVnaW4ucmVnaXN0ZXJTcGVjaWFsUHJvcChcIm15Q3VzdG9tUHJvcFwiLCBmdW5jdGlvbih0YXJnZXQsIHZhbHVlLCB0d2Vlbikge1xuXHRcdCAqICAgICAgdmFyIHN0YXJ0ID0gdGFyZ2V0LnN0eWxlLndpZHRoO1xuXHRcdCAqICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJhdGlvKSB7XG5cdFx0ICogICAgICAgICAgICAgIHRhcmdldC5zdHlsZS53aWR0aCA9IChzdGFydCArIHZhbHVlICogcmF0aW8pICsgXCJweFwiO1xuXHRcdCAqICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInNldCB3aWR0aCB0byBcIiArIHRhcmdldC5zdHlsZS53aWR0aCk7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqIH0sIDApO1xuXHRcdCAqXG5cdFx0ICogVGhlbiwgd2hlbiBJIGRvIHRoaXMgdHdlZW4sIGl0IHdpbGwgdHJpZ2dlciBteSBzcGVjaWFsIHByb3BlcnR5OlxuXHRcdCAqXG5cdFx0ICogVHdlZW5MaXRlLnRvKGVsZW1lbnQsIDEsIHtjc3M6e215Q3VzdG9tUHJvcDoxMDB9fSk7XG5cdFx0ICpcblx0XHQgKiBJbiB0aGUgZXhhbXBsZSwgb2YgY291cnNlLCB3ZSdyZSBqdXN0IGNoYW5naW5nIHRoZSB3aWR0aCwgYnV0IHlvdSBjYW4gZG8gYW55dGhpbmcgeW91IHdhbnQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IG5hbWUgUHJvcGVydHkgbmFtZSAob3IgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMpIHRoYXQgc2hvdWxkIGJlIGludGVyY2VwdGVkIGFuZCBoYW5kbGVkIGJ5IHlvdXIgZnVuY3Rpb24uIEZvciBleGFtcGxlLCBpZiBJIGRlZmluZSBcIm15Q3VzdG9tUHJvcFwiLCB0aGVuIGl0IHdvdWxkIGhhbmRsZSB0aGF0IHBvcnRpb24gb2YgdGhlIGZvbGxvd2luZyB0d2VlbjogVHdlZW5MaXRlLnRvKGVsZW1lbnQsIDEsIHtjc3M6e215Q3VzdG9tUHJvcDoxMDB9fSlcblx0XHQgKiBAcGFyYW0geyFmdW5jdGlvbihPYmplY3QsIE9iamVjdCwgT2JqZWN0LCBzdHJpbmcpOmZ1bmN0aW9uKG51bWJlcil9IG9uSW5pdFR3ZWVuIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSB0d2VlbiBvZiB0aGlzIHNwZWNpYWwgcHJvcGVydHkgaXMgcGVyZm9ybWVkLiBUaGUgZnVuY3Rpb24gd2lsbCByZWNlaXZlIDQgcGFyYW1ldGVyczogMSkgVGFyZ2V0IG9iamVjdCB0aGF0IHNob3VsZCBiZSB0d2VlbmVkLCAyKSBWYWx1ZSB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIHR3ZWVuLCAzKSBUaGUgdHdlZW4gaW5zdGFuY2UgaXRzZWxmIChyYXJlbHkgdXNlZCksIGFuZCA0KSBUaGUgcHJvcGVydHkgbmFtZSB0aGF0J3MgYmVpbmcgdHdlZW5lZC4gWW91ciBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIG9uIGV2ZXJ5IHVwZGF0ZSBvZiB0aGUgdHdlZW4uIFRoYXQgZnVuY3Rpb24gd2lsbCByZWNlaXZlIGEgc2luZ2xlIHBhcmFtZXRlciB0aGF0IGlzIGEgXCJjaGFuZ2UgZmFjdG9yXCIgdmFsdWUgKHR5cGljYWxseSBiZXR3ZWVuIDAgYW5kIDEpIGluZGljYXRpbmcgdGhlIGFtb3VudCBvZiBjaGFuZ2UgYXMgYSByYXRpby4gWW91IGNhbiB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaG93IHRvIHNldCB0aGUgdmFsdWVzIGFwcHJvcHJpYXRlbHkgaW4geW91ciBmdW5jdGlvbi5cblx0XHQgKiBAcGFyYW0ge251bWJlcj19IHByaW9yaXR5IFByaW9yaXR5IHRoYXQgaGVscHMgdGhlIGVuZ2luZSBkZXRlcm1pbmUgdGhlIG9yZGVyIGluIHdoaWNoIHRvIHNldCB0aGUgcHJvcGVydGllcyAoZGVmYXVsdDogMCkuIEhpZ2hlciBwcmlvcml0eSBwcm9wZXJ0aWVzIHdpbGwgYmUgdXBkYXRlZCBiZWZvcmUgbG93ZXIgcHJpb3JpdHkgb25lcy5cblx0XHQgKi9cblx0XHRDU1NQbHVnaW4ucmVnaXN0ZXJTcGVjaWFsUHJvcCA9IGZ1bmN0aW9uKG5hbWUsIG9uSW5pdFR3ZWVuLCBwcmlvcml0eSkge1xuXHRcdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKG5hbWUsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0XHR2YXIgcnYgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHB0LCAyLCBwLCBmYWxzZSwgcHJpb3JpdHkpO1xuXHRcdFx0XHRydi5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHJ2LnNldFJhdGlvID0gb25Jbml0VHdlZW4odCwgZSwgY3NzcC5fdHdlZW4sIHApO1xuXHRcdFx0XHRyZXR1cm4gcnY7XG5cdFx0XHR9LCBwcmlvcml0eTpwcmlvcml0eX0pO1xuXHRcdH07XG5cblxuXG5cblxuXG5cdFx0Ly90cmFuc2Zvcm0tcmVsYXRlZCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzXG5cdFx0Q1NTUGx1Z2luLnVzZVNWR1RyYW5zZm9ybUF0dHIgPSBfaXNTYWZhcmk7IC8vU2FmYXJpIGhhcyBzb21lIHJlbmRlcmluZyBidWdzIHdoZW4gYXBwbHlpbmcgQ1NTIHRyYW5zZm9ybXMgdG8gU1ZHIGVsZW1lbnRzLCBzbyBkZWZhdWx0IHRvIHVzaW5nIHRoZSBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSBpbnN0ZWFkLlxuXHRcdHZhciBfdHJhbnNmb3JtUHJvcHMgPSAoXCJzY2FsZVgsc2NhbGVZLHNjYWxlWix4LHkseixza2V3WCxza2V3WSxyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHBlcnNwZWN0aXZlLHhQZXJjZW50LHlQZXJjZW50XCIpLnNwbGl0KFwiLFwiKSxcblx0XHRcdF90cmFuc2Zvcm1Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChcInRyYW5zZm9ybVwiKSwgLy90aGUgSmF2YXNjcmlwdCAoY2FtZWxDYXNlKSB0cmFuc2Zvcm0gcHJvcGVydHksIGxpa2UgbXNUcmFuc2Zvcm0sIFdlYmtpdFRyYW5zZm9ybSwgTW96VHJhbnNmb3JtLCBvciBPVHJhbnNmb3JtLlxuXHRcdFx0X3RyYW5zZm9ybVByb3BDU1MgPSBfcHJlZml4Q1NTICsgXCJ0cmFuc2Zvcm1cIixcblx0XHRcdF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChcInRyYW5zZm9ybU9yaWdpblwiKSxcblx0XHRcdF9zdXBwb3J0czNEID0gKF9jaGVja1Byb3BQcmVmaXgoXCJwZXJzcGVjdGl2ZVwiKSAhPT0gbnVsbCksXG5cdFx0XHRUcmFuc2Zvcm0gPSBfaW50ZXJuYWxzLlRyYW5zZm9ybSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBlcnNwZWN0aXZlID0gcGFyc2VGbG9hdChDU1NQbHVnaW4uZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlKSB8fCAwO1xuXHRcdFx0XHR0aGlzLmZvcmNlM0QgPSAoQ1NTUGx1Z2luLmRlZmF1bHRGb3JjZTNEID09PSBmYWxzZSB8fCAhX3N1cHBvcnRzM0QpID8gZmFsc2UgOiBDU1NQbHVnaW4uZGVmYXVsdEZvcmNlM0QgfHwgXCJhdXRvXCI7XG5cdFx0XHR9LFxuXHRcdFx0X1NWR0VsZW1lbnQgPSB3aW5kb3cuU1ZHRWxlbWVudCxcblx0XHRcdF91c2VTVkdUcmFuc2Zvcm1BdHRyLFxuXHRcdFx0Ly9Tb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3ggYW5kIElFKSBkb24ndCBob25vciB0cmFuc2Zvcm0tb3JpZ2luIHByb3Blcmx5IGluIFNWRyBlbGVtZW50cywgc28gd2UgbmVlZCB0byBtYW51YWxseSBhZGp1c3QgdGhlIG1hdHJpeCBhY2NvcmRpbmdseS4gV2UgZmVhdHVyZSBkZXRlY3QgaGVyZSByYXRoZXIgdGhhbiBhbHdheXMgZG9pbmcgdGhlIGNvbnZlcnNpb24gZm9yIGNlcnRhaW4gYnJvd3NlcnMgYmVjYXVzZSB0aGV5IG1heSBmaXggdGhlIHByb2JsZW0gYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLlxuXG5cdFx0XHRfY3JlYXRlU1ZHID0gZnVuY3Rpb24odHlwZSwgY29udGFpbmVyLCBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gX2RvYy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB0eXBlKSxcblx0XHRcdFx0XHRyZWcgPSAvKFthLXpdKShbQS1aXSkvZyxcblx0XHRcdFx0XHRwO1xuXHRcdFx0XHRmb3IgKHAgaW4gYXR0cmlidXRlcykge1xuXHRcdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgcC5yZXBsYWNlKHJlZywgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpLCBhdHRyaWJ1dGVzW3BdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cdFx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdFx0fSxcblx0XHRcdF9kb2NFbGVtZW50ID0gX2RvYy5kb2N1bWVudEVsZW1lbnQsXG5cdFx0XHRfZm9yY2VTVkdUcmFuc2Zvcm1BdHRyID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvL0lFIGFuZCBBbmRyb2lkIHN0b2NrIGRvbid0IHN1cHBvcnQgQ1NTIHRyYW5zZm9ybXMgb24gU1ZHIGVsZW1lbnRzLCBzbyB3ZSBtdXN0IHdyaXRlIHRoZW0gdG8gdGhlIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLiBXZSBwb3B1bGF0ZSB0aGlzIHZhcmlhYmxlIGluIHRoZSBfcGFyc2VUcmFuc2Zvcm0oKSBtZXRob2QsIGFuZCBvbmx5IGlmL3doZW4gd2UgY29tZSBhY3Jvc3MgYW4gU1ZHIGVsZW1lbnRcblx0XHRcdFx0dmFyIGZvcmNlID0gX2llVmVycyB8fCAoL0FuZHJvaWQvaS50ZXN0KF9hZ2VudCkgJiYgIXdpbmRvdy5jaHJvbWUpLFxuXHRcdFx0XHRcdHN2ZywgcmVjdCwgd2lkdGg7XG5cdFx0XHRcdGlmIChfZG9jLmNyZWF0ZUVsZW1lbnROUyAmJiAhZm9yY2UpIHsgLy9JRTggYW5kIGVhcmxpZXIgZG9lc24ndCBzdXBwb3J0IFNWRyBhbnl3YXlcblx0XHRcdFx0XHRzdmcgPSBfY3JlYXRlU1ZHKFwic3ZnXCIsIF9kb2NFbGVtZW50KTtcblx0XHRcdFx0XHRyZWN0ID0gX2NyZWF0ZVNWRyhcInJlY3RcIiwgc3ZnLCB7d2lkdGg6MTAwLCBoZWlnaHQ6NTAsIHg6MTAwfSk7XG5cdFx0XHRcdFx0d2lkdGggPSByZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXHRcdFx0XHRcdHJlY3Quc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdID0gXCI1MCUgNTAlXCI7XG5cdFx0XHRcdFx0cmVjdC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSBcInNjYWxlWCgwLjUpXCI7XG5cdFx0XHRcdFx0Zm9yY2UgPSAod2lkdGggPT09IHJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggJiYgIShfaXNGaXJlZm94ICYmIF9zdXBwb3J0czNEKSk7IC8vbm90ZTogRmlyZWZveCBmYWlscyB0aGUgdGVzdCBldmVuIHRob3VnaCBpdCBkb2VzIHN1cHBvcnQgQ1NTIHRyYW5zZm9ybXMgaW4gM0QuIFNpbmNlIHdlIGNhbid0IHB1c2ggM0Qgc3R1ZmYgaW50byB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSwgd2UgZm9yY2UgRmlyZWZveCB0byBwYXNzIHRoZSB0ZXN0IGhlcmUgKGFzIGxvbmcgYXMgaXQgZG9lcyB0cnVseSBzdXBwb3J0IDNEKS5cblx0XHRcdFx0XHRfZG9jRWxlbWVudC5yZW1vdmVDaGlsZChzdmcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmb3JjZTtcblx0XHRcdH0pKCksXG5cdFx0XHRfcGFyc2VTVkdPcmlnaW4gPSBmdW5jdGlvbihlLCBsb2NhbCwgZGVjb3JhdGVlLCBhYnNvbHV0ZSkge1xuXHRcdFx0XHR2YXIgYmJveCwgdjtcblx0XHRcdFx0aWYgKCFhYnNvbHV0ZSB8fCAhKHYgPSBhYnNvbHV0ZS5zcGxpdChcIiBcIikpLmxlbmd0aCkge1xuXHRcdFx0XHRcdGJib3ggPSBlLmdldEJCb3goKTtcblx0XHRcdFx0XHRsb2NhbCA9IF9wYXJzZVBvc2l0aW9uKGxvY2FsKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0diA9IFsobG9jYWxbMF0uaW5kZXhPZihcIiVcIikgIT09IC0xID8gcGFyc2VGbG9hdChsb2NhbFswXSkgLyAxMDAgKiBiYm94LndpZHRoIDogcGFyc2VGbG9hdChsb2NhbFswXSkpICsgYmJveC54LFxuXHRcdFx0XHRcdFx0IChsb2NhbFsxXS5pbmRleE9mKFwiJVwiKSAhPT0gLTEgPyBwYXJzZUZsb2F0KGxvY2FsWzFdKSAvIDEwMCAqIGJib3guaGVpZ2h0IDogcGFyc2VGbG9hdChsb2NhbFsxXSkpICsgYmJveC55XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWNvcmF0ZWUueE9yaWdpbiA9IHBhcnNlRmxvYXQodlswXSk7XG5cdFx0XHRcdGRlY29yYXRlZS55T3JpZ2luID0gcGFyc2VGbG9hdCh2WzFdKTtcblx0XHRcdFx0ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIiwgdi5qb2luKFwiIFwiKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFBhcnNlcyB0aGUgdHJhbnNmb3JtIHZhbHVlcyBmb3IgYW4gZWxlbWVudCwgcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIHgsIHksIHosIHNjYWxlWCwgc2NhbGVZLCBzY2FsZVosIHJvdGF0aW9uLCByb3RhdGlvblgsIHJvdGF0aW9uWSwgc2tld1gsIGFuZCBza2V3WSBwcm9wZXJ0aWVzLiBOb3RlOiBieSBkZWZhdWx0IChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyksIGFsbCBza2V3aW5nIGlzIGNvbWJpbmVkIGludG8gc2tld1ggYW5kIHJvdGF0aW9uIGJ1dCBza2V3WSBzdGlsbCBoYXMgYSBwbGFjZSBpbiB0aGUgdHJhbnNmb3JtIG9iamVjdCBzbyB0aGF0IHdlIGNhbiByZWNvcmQgaG93IG11Y2ggb2YgdGhlIHNrZXcgaXMgYXR0cmlidXRlZCB0byBza2V3WCB2cyBza2V3WS4gUmVtZW1iZXIsIGEgc2tld1kgb2YgMTAgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBhbmQgc2tld1ggb2YgLTEwLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IHRhcmdldCBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdD19IGNzIGNvbXB1dGVkIHN0eWxlIG9iamVjdCAob3B0aW9uYWwpXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWMgaWYgdHJ1ZSwgdGhlIHRyYW5zZm9ybSB2YWx1ZXMgd2lsbCBiZSByZWNvcmRlZCB0byB0aGUgdGFyZ2V0IGVsZW1lbnQncyBfZ3NUcmFuc2Zvcm0gb2JqZWN0LCBsaWtlIHRhcmdldC5fZ3NUcmFuc2Zvcm0gPSB7eDowLCB5OjAsIHo6MCwgc2NhbGVYOjEuLi59XG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBwYXJzZSBpZiB0cnVlLCB3ZSdsbCBpZ25vcmUgYW55IF9nc1RyYW5zZm9ybSB2YWx1ZXMgdGhhdCBhbHJlYWR5IGV4aXN0IG9uIHRoZSBlbGVtZW50LCBhbmQgZm9yY2UgYSByZXBhcnNpbmcgb2YgdGhlIGNzcyAoY2FsY3VsYXRlZCBzdHlsZSlcblx0XHRcdCAqIEByZXR1cm4ge29iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcy92YWx1ZXMgbGlrZSB7eDowLCB5OjAsIHo6MCwgc2NhbGVYOjEuLi59XG5cdFx0XHQgKi9cblx0XHRcdF9nZXRUcmFuc2Zvcm0gPSBfaW50ZXJuYWxzLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHQsIGNzLCByZWMsIHBhcnNlKSB7XG5cdFx0XHRcdGlmICh0Ll9nc1RyYW5zZm9ybSAmJiByZWMgJiYgIXBhcnNlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHQuX2dzVHJhbnNmb3JtOyAvL2lmIHRoZSBlbGVtZW50IGFscmVhZHkgaGFzIGEgX2dzVHJhbnNmb3JtLCB1c2UgdGhhdC4gTm90ZTogc29tZSBicm93c2VycyBkb24ndCBhY2N1cmF0ZWx5IHJldHVybiB0aGUgY2FsY3VsYXRlZCBzdHlsZSBmb3IgdGhlIHRyYW5zZm9ybSAocGFydGljdWxhcmx5IGZvciBTVkcpLCBzbyBpdCdzIGFsbW9zdCBhbHdheXMgc2FmZXN0IHRvIGp1c3QgdXNlIHRoZSB2YWx1ZXMgd2UndmUgYWxyZWFkeSBhcHBsaWVkIHJhdGhlciB0aGFuIHJlLXBhcnNpbmcgdGhpbmdzLlxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB0bSA9IHJlYyA/IHQuX2dzVHJhbnNmb3JtIHx8IG5ldyBUcmFuc2Zvcm0oKSA6IG5ldyBUcmFuc2Zvcm0oKSxcblx0XHRcdFx0XHRpbnZYID0gKHRtLnNjYWxlWCA8IDApLCAvL2luIG9yZGVyIHRvIGludGVycHJldCB0aGluZ3MgcHJvcGVybHksIHdlIG5lZWQgdG8ga25vdyBpZiB0aGUgdXNlciBhcHBsaWVkIGEgbmVnYXRpdmUgc2NhbGVYIHByZXZpb3VzbHkgc28gdGhhdCB3ZSBjYW4gYWRqdXN0IHRoZSByb3RhdGlvbiBhbmQgc2tld1ggYWNjb3JkaW5nbHkuIE90aGVyd2lzZSwgaWYgd2UgYWx3YXlzIGludGVycHJldCBhIGZsaXBwZWQgbWF0cml4IGFzIGFmZmVjdGluZyBzY2FsZVkgYW5kIHRoZSB1c2VyIG9ubHkgd2FudHMgdG8gdHdlZW4gdGhlIHNjYWxlWCBvbiBtdWx0aXBsZSBzZXF1ZW50aWFsIHR3ZWVucywgaXQgd291bGQga2VlcCB0aGUgbmVnYXRpdmUgc2NhbGVZIHdpdGhvdXQgdGhhdCBiZWluZyB0aGUgdXNlcidzIGludGVudC5cblx0XHRcdFx0XHRtaW4gPSAwLjAwMDAyLFxuXHRcdFx0XHRcdHJuZCA9IDEwMDAwMCxcblx0XHRcdFx0XHR6T3JpZ2luID0gX3N1cHBvcnRzM0QgPyBwYXJzZUZsb2F0KF9nZXRTdHlsZSh0LCBfdHJhbnNmb3JtT3JpZ2luUHJvcCwgY3MsIGZhbHNlLCBcIjAgMCAwXCIpLnNwbGl0KFwiIFwiKVsyXSkgfHwgdG0uek9yaWdpbiAgfHwgMCA6IDAsXG5cdFx0XHRcdFx0ZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlID0gcGFyc2VGbG9hdChDU1NQbHVnaW4uZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlKSB8fCAwLFxuXHRcdFx0XHRcdGlzRGVmYXVsdCwgcywgbSwgaSwgbiwgZGVjLCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYO1xuXHRcdFx0XHRpZiAoX3RyYW5zZm9ybVByb3ApIHtcblx0XHRcdFx0XHRzID0gX2dldFN0eWxlKHQsIF90cmFuc2Zvcm1Qcm9wQ1NTLCBjcywgdHJ1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodC5jdXJyZW50U3R5bGUpIHtcblx0XHRcdFx0XHQvL2ZvciBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgd2UgbmVlZCB0byBpbnRlcnByZXQgdGhlIGZpbHRlciBwb3J0aW9uIHRoYXQgaXMgaW4gdGhlIGZvcm1hdDogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9Ni4xMjMyMzM5OTU3MzY3NjZlLTE3LCBNMTI9LTEsIE0yMT0xLCBNMjI9Ni4xMjMyMzM5OTU3MzY3NjZlLTE3LCBzaXppbmdNZXRob2Q9J2F1dG8gZXhwYW5kJykgTm90aWNlIHRoYXQgd2UgbmVlZCB0byBzd2FwIGIgYW5kIGMgY29tcGFyZWQgdG8gYSBub3JtYWwgbWF0cml4LlxuXHRcdFx0XHRcdHMgPSB0LmN1cnJlbnRTdHlsZS5maWx0ZXIubWF0Y2goX2llR2V0TWF0cml4RXhwKTtcblx0XHRcdFx0XHRzID0gKHMgJiYgcy5sZW5ndGggPT09IDQpID8gW3NbMF0uc3Vic3RyKDQpLCBOdW1iZXIoc1syXS5zdWJzdHIoNCkpLCBOdW1iZXIoc1sxXS5zdWJzdHIoNCkpLCBzWzNdLnN1YnN0cig0KSwgKHRtLnggfHwgMCksICh0bS55IHx8IDApXS5qb2luKFwiLFwiKSA6IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aXNEZWZhdWx0ID0gKCFzIHx8IHMgPT09IFwibm9uZVwiIHx8IHMgPT09IFwibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApXCIpO1xuXHRcdFx0XHR0bS5zdmcgPSAhIShfU1ZHRWxlbWVudCAmJiB0eXBlb2YodC5nZXRCQm94KSA9PT0gXCJmdW5jdGlvblwiICYmIHQuZ2V0Q1RNICYmICghdC5wYXJlbnROb2RlIHx8ICh0LnBhcmVudE5vZGUuZ2V0QkJveCAmJiB0LnBhcmVudE5vZGUuZ2V0Q1RNKSkpOyAvL2Rvbid0IGp1c3QgcmVseSBvbiBcImluc3RhbmNlb2YgX1NWR0VsZW1lbnRcIiBiZWNhdXNlIGlmIHRoZSBTVkcgaXMgZW1iZWRkZWQgdmlhIGFuIG9iamVjdCB0YWcsIGl0IHdvbid0IHdvcmsgKFNWR0VsZW1lbnQgaXMgbWFwcGVkIHRvIGEgZGlmZmVyZW50IG9iamVjdClcblx0XHRcdFx0aWYgKHRtLnN2Zykge1xuXHRcdFx0XHRcdGlmIChpc0RlZmF1bHQgJiYgKHQuc3R5bGVbX3RyYW5zZm9ybVByb3BdICsgXCJcIikuaW5kZXhPZihcIm1hdHJpeFwiKSAhPT0gLTEpIHsgLy9zb21lIGJyb3dzZXJzIChsaWtlIENocm9tZSA0MCkgZG9uJ3QgY29ycmVjdGx5IHJlcG9ydCB0cmFuc2Zvcm1zIHRoYXQgYXJlIGFwcGxpZWQgaW5saW5lIG9uIGFuIFNWRyBlbGVtZW50ICh0aGV5IGRvbid0IGdldCBpbmNsdWRlZCBpbiB0aGUgY29tcHV0ZWQgc3R5bGUpLCBzbyB3ZSBkb3VibGUtY2hlY2sgaGVyZSBhbmQgYWNjZXB0IG1hdHJpeCB2YWx1ZXNcblx0XHRcdFx0XHRcdHMgPSB0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXTtcblx0XHRcdFx0XHRcdGlzRGVmYXVsdCA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfcGFyc2VTVkdPcmlnaW4odCwgX2dldFN0eWxlKHQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wLCBfY3MsIGZhbHNlLCBcIjUwJSA1MCVcIikgKyBcIlwiLCB0bSwgdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIikpO1xuXHRcdFx0XHRcdF91c2VTVkdUcmFuc2Zvcm1BdHRyID0gQ1NTUGx1Z2luLnVzZVNWR1RyYW5zZm9ybUF0dHIgfHwgX2ZvcmNlU1ZHVHJhbnNmb3JtQXR0cjtcblx0XHRcdFx0XHRtID0gdC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG5cdFx0XHRcdFx0aWYgKGlzRGVmYXVsdCAmJiBtICYmIG0uaW5kZXhPZihcIm1hdHJpeFwiKSAhPT0gLTEpIHsgLy9qdXN0IGluIGNhc2UgdGhlcmUncyBhIFwidHJhbnNmb3JtXCIgdmFsdWUgc3BlY2lmaWVkIGFzIGFuIGF0dHJpYnV0ZSBpbnN0ZWFkIG9mIENTUyBzdHlsZS4gT25seSBhY2NlcHQgYSBtYXRyaXgsIHRob3VnaC5cblx0XHRcdFx0XHRcdHMgPSBtO1xuXHRcdFx0XHRcdFx0aXNEZWZhdWx0ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFpc0RlZmF1bHQpIHtcblx0XHRcdFx0XHQvL3NwbGl0IHRoZSBtYXRyaXggdmFsdWVzIG91dCBpbnRvIGFuIGFycmF5IChtIGZvciBtYXRyaXgpXG5cdFx0XHRcdFx0bSA9IChzIHx8IFwiXCIpLm1hdGNoKC8oPzpcXC18XFxiKVtcXGRcXC1cXC5lXStcXGIvZ2kpIHx8IFtdO1xuXHRcdFx0XHRcdGkgPSBtLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdG4gPSBOdW1iZXIobVtpXSk7XG5cdFx0XHRcdFx0XHRtW2ldID0gKGRlYyA9IG4gLSAobiB8PSAwKSkgPyAoKGRlYyAqIHJuZCArIChkZWMgPCAwID8gLTAuNSA6IDAuNSkpIHwgMCkgLyBybmQgKyBuIDogbjsgLy9jb252ZXJ0IHN0cmluZ3MgdG8gTnVtYmVycyBhbmQgcm91bmQgdG8gNSBkZWNpbWFsIHBsYWNlcyB0byBhdm9pZCBpc3N1ZXMgd2l0aCB0aW55IG51bWJlcnMuIFJvdWdobHkgMjB4IGZhc3RlciB0aGFuIE51bWJlci50b0ZpeGVkKCkuIFdlIGFsc28gbXVzdCBtYWtlIHN1cmUgdG8gcm91bmQgYmVmb3JlIGRpdmlkaW5nIHNvIHRoYXQgdmFsdWVzIGxpa2UgMC45OTk5OTk5OTk5IGJlY29tZSAxIHRvIGF2b2lkIGdsaXRjaGVzIGluIGJyb3dzZXIgcmVuZGVyaW5nIGFuZCBpbnRlcnByZXRhdGlvbiBvZiBmbGlwcGVkL3JvdGF0ZWQgM0QgbWF0cmljZXMuIEFuZCBkb24ndCBqdXN0IG11bHRpcGx5IHRoZSBudW1iZXIgYnkgcm5kLCBmbG9vciBpdCwgYW5kIHRoZW4gZGl2aWRlIGJ5IHJuZCBiZWNhdXNlIHRoZSBiaXR3aXNlIG9wZXJhdGlvbnMgbWF4IG91dCBhdCBhIDMyLWJpdCBzaWduZWQgaW50ZWdlciwgdGh1cyBpdCBjb3VsZCBnZXQgY2xpcHBlZCBhdCBhIHJlbGF0aXZlbHkgbG93IHZhbHVlIChsaWtlIDIyLDAwMC4wMDAwMCBmb3IgZXhhbXBsZSkuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtLmxlbmd0aCA9PT0gMTYpIHtcblx0XHRcdFx0XHRcdC8vd2UnbGwgb25seSBsb29rIGF0IHRoZXNlIHBvc2l0aW9uLXJlbGF0ZWQgNiB2YXJpYWJsZXMgZmlyc3QgYmVjYXVzZSBpZiB4L3kveiBhbGwgbWF0Y2gsIGl0J3MgcmVsYXRpdmVseSBzYWZlIHRvIGFzc3VtZSB3ZSBkb24ndCBuZWVkIHRvIHJlLXBhcnNlIGV2ZXJ5dGhpbmcgd2hpY2ggcmlza3MgbG9zaW5nIGltcG9ydGFudCByb3RhdGlvbmFsIGluZm9ybWF0aW9uIChsaWtlIHJvdGF0aW9uWDoxODAgcGx1cyByb3RhdGlvblk6MTgwIHdvdWxkIGxvb2sgdGhlIHNhbWUgYXMgcm90YXRpb246MTgwIC0gdGhlcmUncyBubyB3YXkgdG8ga25vdyBmb3Igc3VyZSB3aGljaCBkaXJlY3Rpb24gd2FzIHRha2VuIGJhc2VkIHNvbGVseSBvbiB0aGUgbWF0cml4M2QoKSB2YWx1ZXMpXG5cdFx0XHRcdFx0XHR2YXIgYTExID0gbVswXSwgYTIxID0gbVsxXSwgYTMxID0gbVsyXSwgYTQxID0gbVszXSxcblx0XHRcdFx0XHRcdFx0YTEyID0gbVs0XSwgYTIyID0gbVs1XSwgYTMyID0gbVs2XSwgYTQyID0gbVs3XSxcblx0XHRcdFx0XHRcdFx0YTEzID0gbVs4XSwgYTIzID0gbVs5XSwgYTMzID0gbVsxMF0sXG5cdFx0XHRcdFx0XHRcdGExNCA9IG1bMTJdLCBhMjQgPSBtWzEzXSwgYTM0ID0gbVsxNF0sXG5cdFx0XHRcdFx0XHRcdGE0MyA9IG1bMTFdLFxuXHRcdFx0XHRcdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoYTMyLCBhMzMpLFxuXHRcdFx0XHRcdFx0XHR0MSwgdDIsIHQzLCB0NCwgY29zLCBzaW47XG5cblx0XHRcdFx0XHRcdC8vd2UgbWFudWFsbHkgY29tcGVuc2F0ZSBmb3Igbm9uLXplcm8geiBjb21wb25lbnQgb2YgdHJhbnNmb3JtT3JpZ2luIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gU2FmYXJpXG5cdFx0XHRcdFx0XHRpZiAodG0uek9yaWdpbikge1xuXHRcdFx0XHRcdFx0XHRhMzQgPSAtdG0uek9yaWdpbjtcblx0XHRcdFx0XHRcdFx0YTE0ID0gYTEzKmEzNC1tWzEyXTtcblx0XHRcdFx0XHRcdFx0YTI0ID0gYTIzKmEzNC1tWzEzXTtcblx0XHRcdFx0XHRcdFx0YTM0ID0gYTMzKmEzNCt0bS56T3JpZ2luLW1bMTRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dG0ucm90YXRpb25YID0gYW5nbGUgKiBfUkFEMkRFRztcblx0XHRcdFx0XHRcdC8vcm90YXRpb25YXG5cdFx0XHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0dDEgPSBhMTIqY29zK2ExMypzaW47XG5cdFx0XHRcdFx0XHRcdHQyID0gYTIyKmNvcythMjMqc2luO1xuXHRcdFx0XHRcdFx0XHR0MyA9IGEzMipjb3MrYTMzKnNpbjtcblx0XHRcdFx0XHRcdFx0YTEzID0gYTEyKi1zaW4rYTEzKmNvcztcblx0XHRcdFx0XHRcdFx0YTIzID0gYTIyKi1zaW4rYTIzKmNvcztcblx0XHRcdFx0XHRcdFx0YTMzID0gYTMyKi1zaW4rYTMzKmNvcztcblx0XHRcdFx0XHRcdFx0YTQzID0gYTQyKi1zaW4rYTQzKmNvcztcblx0XHRcdFx0XHRcdFx0YTEyID0gdDE7XG5cdFx0XHRcdFx0XHRcdGEyMiA9IHQyO1xuXHRcdFx0XHRcdFx0XHRhMzIgPSB0Mztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vcm90YXRpb25ZXG5cdFx0XHRcdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoYTEzLCBhMzMpO1xuXHRcdFx0XHRcdFx0dG0ucm90YXRpb25ZID0gYW5nbGUgKiBfUkFEMkRFRztcblx0XHRcdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IGExMSpjb3MtYTEzKnNpbjtcblx0XHRcdFx0XHRcdFx0dDIgPSBhMjEqY29zLWEyMypzaW47XG5cdFx0XHRcdFx0XHRcdHQzID0gYTMxKmNvcy1hMzMqc2luO1xuXHRcdFx0XHRcdFx0XHRhMjMgPSBhMjEqc2luK2EyMypjb3M7XG5cdFx0XHRcdFx0XHRcdGEzMyA9IGEzMSpzaW4rYTMzKmNvcztcblx0XHRcdFx0XHRcdFx0YTQzID0gYTQxKnNpbithNDMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMTEgPSB0MTtcblx0XHRcdFx0XHRcdFx0YTIxID0gdDI7XG5cdFx0XHRcdFx0XHRcdGEzMSA9IHQzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9yb3RhdGlvblpcblx0XHRcdFx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMihhMjEsIGExMSk7XG5cdFx0XHRcdFx0XHR0bS5yb3RhdGlvbiA9IGFuZ2xlICogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0YTExID0gYTExKmNvcythMTIqc2luO1xuXHRcdFx0XHRcdFx0XHR0MiA9IGEyMSpjb3MrYTIyKnNpbjtcblx0XHRcdFx0XHRcdFx0YTIyID0gYTIxKi1zaW4rYTIyKmNvcztcblx0XHRcdFx0XHRcdFx0YTMyID0gYTMxKi1zaW4rYTMyKmNvcztcblx0XHRcdFx0XHRcdFx0YTIxID0gdDI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh0bS5yb3RhdGlvblggJiYgTWF0aC5hYnModG0ucm90YXRpb25YKSArIE1hdGguYWJzKHRtLnJvdGF0aW9uKSA+IDM1OS45KSB7IC8vd2hlbiByb3RhdGlvblkgaXMgc2V0LCBpdCB3aWxsIG9mdGVuIGJlIHBhcnNlZCBhcyAxODAgZGVncmVlcyBkaWZmZXJlbnQgdGhhbiBpdCBzaG91bGQgYmUsIGFuZCByb3RhdGlvblggYW5kIHJvdGF0aW9uIGJvdGggYmVpbmcgMTgwIChpdCBsb29rcyB0aGUgc2FtZSksIHNvIHdlIGFkanVzdCBmb3IgdGhhdCBoZXJlLlxuXHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvblggPSB0bS5yb3RhdGlvbiA9IDA7XG5cdFx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uWSArPSAxODA7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRtLnNjYWxlWCA9ICgoTWF0aC5zcXJ0KGExMSAqIGExMSArIGEyMSAqIGEyMSkgKiBybmQgKyAwLjUpIHwgMCkgLyBybmQ7XG5cdFx0XHRcdFx0XHR0bS5zY2FsZVkgPSAoKE1hdGguc3FydChhMjIgKiBhMjIgKyBhMjMgKiBhMjMpICogcm5kICsgMC41KSB8IDApIC8gcm5kO1xuXHRcdFx0XHRcdFx0dG0uc2NhbGVaID0gKChNYXRoLnNxcnQoYTMyICogYTMyICsgYTMzICogYTMzKSAqIHJuZCArIDAuNSkgfCAwKSAvIHJuZDtcblx0XHRcdFx0XHRcdHRtLnNrZXdYID0gMDtcblx0XHRcdFx0XHRcdHRtLnBlcnNwZWN0aXZlID0gYTQzID8gMSAvICgoYTQzIDwgMCkgPyAtYTQzIDogYTQzKSA6IDA7XG5cdFx0XHRcdFx0XHR0bS54ID0gYTE0O1xuXHRcdFx0XHRcdFx0dG0ueSA9IGEyNDtcblx0XHRcdFx0XHRcdHRtLnogPSBhMzQ7XG5cdFx0XHRcdFx0XHRpZiAodG0uc3ZnKSB7XG5cdFx0XHRcdFx0XHRcdHRtLnggLT0gdG0ueE9yaWdpbiAtICh0bS54T3JpZ2luICogYTExIC0gdG0ueU9yaWdpbiAqIGExMik7XG5cdFx0XHRcdFx0XHRcdHRtLnkgLT0gdG0ueU9yaWdpbiAtICh0bS55T3JpZ2luICogYTIxIC0gdG0ueE9yaWdpbiAqIGEyMik7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCghX3N1cHBvcnRzM0QgfHwgcGFyc2UgfHwgIW0ubGVuZ3RoIHx8IHRtLnggIT09IG1bNF0gfHwgdG0ueSAhPT0gbVs1XSB8fCAoIXRtLnJvdGF0aW9uWCAmJiAhdG0ucm90YXRpb25ZKSkgJiYgISh0bS54ICE9PSB1bmRlZmluZWQgJiYgX2dldFN0eWxlKHQsIFwiZGlzcGxheVwiLCBjcykgPT09IFwibm9uZVwiKSkgeyAvL3NvbWV0aW1lcyBhIDYtZWxlbWVudCBtYXRyaXggaXMgcmV0dXJuZWQgZXZlbiB3aGVuIHdlIHBlcmZvcm1lZCAzRCB0cmFuc2Zvcm1zLCBsaWtlIGlmIHJvdGF0aW9uWCBhbmQgcm90YXRpb25ZIGFyZSAxODAuIEluIGNhc2VzIGxpa2UgdGhpcywgd2Ugc3RpbGwgbmVlZCB0byBob25vciB0aGUgM0QgdHJhbnNmb3Jtcy4gSWYgd2UganVzdCByZWx5IG9uIHRoZSAyRCBpbmZvLCBpdCBjb3VsZCBhZmZlY3QgaG93IHRoZSBkYXRhIGlzIGludGVycHJldGVkLCBsaWtlIHNjYWxlWSBtaWdodCBnZXQgc2V0IHRvIC0xIG9yIHJvdGF0aW9uIGNvdWxkIGdldCBvZmZzZXQgYnkgMTgwIGRlZ3JlZXMuIEZvciBleGFtcGxlLCBkbyBhIFR3ZWVuTGl0ZS50byhlbGVtZW50LCAxLCB7Y3NzOntyb3RhdGlvblg6MTgwLCByb3RhdGlvblk6MTgwfX0pIGFuZCB0aGVuIGxhdGVyLCBUd2VlbkxpdGUudG8oZWxlbWVudCwgMSwge2Nzczp7cm90YXRpb25YOjB9fSkgYW5kIHdpdGhvdXQgdGhpcyBjb25kaXRpb25hbCBsb2dpYyBpbiBwbGFjZSwgaXQnZCBqdW1wIHRvIGEgc3RhdGUgb2YgYmVpbmcgdW5yb3RhdGVkIHdoZW4gdGhlIDJuZCB0d2VlbiBzdGFydHMuIFRoZW4gYWdhaW4sIHdlIG5lZWQgdG8gaG9ub3IgdGhlIGZhY3QgdGhhdCB0aGUgdXNlciBDT1VMRCBhbHRlciB0aGUgdHJhbnNmb3JtcyBvdXRzaWRlIG9mIENTU1BsdWdpbiwgbGlrZSBieSBtYW51YWxseSBhcHBseWluZyBuZXcgY3NzLCBzbyB3ZSB0cnkgdG8gc2Vuc2UgdGhhdCBieSBsb29raW5nIGF0IHggYW5kIHkgYmVjYXVzZSBpZiB0aG9zZSBjaGFuZ2VkLCB3ZSBrbm93IHRoZSBjaGFuZ2VzIHdlcmUgbWFkZSBvdXRzaWRlIENTU1BsdWdpbiBhbmQgd2UgZm9yY2UgYSByZWludGVycHJldGF0aW9uIG9mIHRoZSBtYXRyaXggdmFsdWVzLiBBbHNvLCBpbiBXZWJraXQgYnJvd3NlcnMsIGlmIHRoZSBlbGVtZW50J3MgXCJkaXNwbGF5XCIgaXMgXCJub25lXCIsIGl0cyBjYWxjdWxhdGVkIHN0eWxlIHZhbHVlIHdpbGwgYWx3YXlzIHJldHVybiBlbXB0eSwgc28gaWYgd2UndmUgYWxyZWFkeSByZWNvcmRlZCB0aGUgdmFsdWVzIGluIHRoZSBfZ3NUcmFuc2Zvcm0gb2JqZWN0LCB3ZSdsbCBqdXN0IHJlbHkgb24gdGhvc2UuXG5cdFx0XHRcdFx0XHR2YXIgayA9IChtLmxlbmd0aCA+PSA2KSxcblx0XHRcdFx0XHRcdFx0YSA9IGsgPyBtWzBdIDogMSxcblx0XHRcdFx0XHRcdFx0YiA9IG1bMV0gfHwgMCxcblx0XHRcdFx0XHRcdFx0YyA9IG1bMl0gfHwgMCxcblx0XHRcdFx0XHRcdFx0ZCA9IGsgPyBtWzNdIDogMTtcblx0XHRcdFx0XHRcdHRtLnggPSBtWzRdIHx8IDA7XG5cdFx0XHRcdFx0XHR0bS55ID0gbVs1XSB8fCAwO1xuXHRcdFx0XHRcdFx0c2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuXHRcdFx0XHRcdFx0c2NhbGVZID0gTWF0aC5zcXJ0KGQgKiBkICsgYyAqIGMpO1xuXHRcdFx0XHRcdFx0cm90YXRpb24gPSAoYSB8fCBiKSA/IE1hdGguYXRhbjIoYiwgYSkgKiBfUkFEMkRFRyA6IHRtLnJvdGF0aW9uIHx8IDA7IC8vbm90ZTogaWYgc2NhbGVYIGlzIDAsIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IG1lYXN1cmUgcm90YXRpb24uIFNhbWUgZm9yIHNrZXdYIHdpdGggYSBzY2FsZVkgb2YgMC4gVGhlcmVmb3JlLCB3ZSBkZWZhdWx0IHRvIHRoZSBwcmV2aW91c2x5IHJlY29yZGVkIHZhbHVlIChvciB6ZXJvIGlmIHRoYXQgZG9lc24ndCBleGlzdCkuXG5cdFx0XHRcdFx0XHRza2V3WCA9IChjIHx8IGQpID8gTWF0aC5hdGFuMihjLCBkKSAqIF9SQUQyREVHICsgcm90YXRpb24gOiB0bS5za2V3WCB8fCAwO1xuXHRcdFx0XHRcdFx0aWYgKE1hdGguYWJzKHNrZXdYKSA+IDkwICYmIE1hdGguYWJzKHNrZXdYKSA8IDI3MCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW52WCkge1xuXHRcdFx0XHRcdFx0XHRcdHNjYWxlWCAqPSAtMTtcblx0XHRcdFx0XHRcdFx0XHRza2V3WCArPSAocm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHRcdHJvdGF0aW9uICs9IChyb3RhdGlvbiA8PSAwKSA/IDE4MCA6IC0xODA7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0c2NhbGVZICo9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdHNrZXdYICs9IChza2V3WCA8PSAwKSA/IDE4MCA6IC0xODA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRtLnNjYWxlWCA9IHNjYWxlWDtcblx0XHRcdFx0XHRcdHRtLnNjYWxlWSA9IHNjYWxlWTtcblx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uID0gcm90YXRpb247XG5cdFx0XHRcdFx0XHR0bS5za2V3WCA9IHNrZXdYO1xuXHRcdFx0XHRcdFx0aWYgKF9zdXBwb3J0czNEKSB7XG5cdFx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uWCA9IHRtLnJvdGF0aW9uWSA9IHRtLnogPSAwO1xuXHRcdFx0XHRcdFx0XHR0bS5wZXJzcGVjdGl2ZSA9IGRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZTtcblx0XHRcdFx0XHRcdFx0dG0uc2NhbGVaID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0bS5zdmcpIHtcblx0XHRcdFx0XHRcdFx0dG0ueCAtPSB0bS54T3JpZ2luIC0gKHRtLnhPcmlnaW4gKiBhIC0gdG0ueU9yaWdpbiAqIGIpO1xuXHRcdFx0XHRcdFx0XHR0bS55IC09IHRtLnlPcmlnaW4gLSAodG0ueU9yaWdpbiAqIGQgLSB0bS54T3JpZ2luICogYyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRtLnpPcmlnaW4gPSB6T3JpZ2luO1xuXHRcdFx0XHRcdC8vc29tZSBicm93c2VycyBoYXZlIGEgaGFyZCB0aW1lIHdpdGggdmVyeSBzbWFsbCB2YWx1ZXMgbGlrZSAyLjQ0OTI5MzU5ODI5NDcwNjRlLTE2IChub3RpY2UgdGhlIFwiZS1cIiB0b3dhcmRzIHRoZSBlbmQpIGFuZCB3b3VsZCByZW5kZXIgdGhlIG9iamVjdCBzbGlnaHRseSBvZmYuIFNvIHdlIHJvdW5kIHRvIDAgaW4gdGhlc2UgY2FzZXMuIFRoZSBjb25kaXRpb25hbCBsb2dpYyBoZXJlIGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgTWF0aC5hYnMoKS4gQWxzbywgYnJvd3NlcnMgdGVuZCB0byByZW5kZXIgYSBTTElHSFRMWSByb3RhdGVkIG9iamVjdCBpbiBhIGZ1enp5IHdheSwgc28gd2UgbmVlZCB0byBzbmFwIHRvIGV4YWN0bHkgMCB3aGVuIGFwcHJvcHJpYXRlLlxuXHRcdFx0XHRcdGZvciAoaSBpbiB0bSkge1xuXHRcdFx0XHRcdFx0aWYgKHRtW2ldIDwgbWluKSBpZiAodG1baV0gPiAtbWluKSB7XG5cdFx0XHRcdFx0XHRcdHRtW2ldID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcInBhcnNlZCByb3RhdGlvbiBvZiBcIiArIHQuZ2V0QXR0cmlidXRlKFwiaWRcIikrXCI6IFwiKyh0bS5yb3RhdGlvblgpK1wiLCBcIisodG0ucm90YXRpb25ZKStcIiwgXCIrKHRtLnJvdGF0aW9uKStcIiwgc2NhbGU6IFwiK3RtLnNjYWxlWCtcIiwgXCIrdG0uc2NhbGVZK1wiLCBcIit0bS5zY2FsZVorXCIsIHBvc2l0aW9uOiBcIit0bS54K1wiLCBcIit0bS55K1wiLCBcIit0bS56K1wiLCBwZXJzcGVjdGl2ZTogXCIrdG0ucGVyc3BlY3RpdmUpO1xuXHRcdFx0XHRpZiAocmVjKSB7XG5cdFx0XHRcdFx0dC5fZ3NUcmFuc2Zvcm0gPSB0bTsgLy9yZWNvcmQgdG8gdGhlIG9iamVjdCdzIF9nc1RyYW5zZm9ybSB3aGljaCB3ZSB1c2Ugc28gdGhhdCB0d2VlbnMgY2FuIGNvbnRyb2wgaW5kaXZpZHVhbCBwcm9wZXJ0aWVzIGluZGVwZW5kZW50bHkgKHdlIG5lZWQgYWxsIHRoZSBwcm9wZXJ0aWVzIHRvIGFjY3VyYXRlbHkgcmVjb21wb3NlIHRoZSBtYXRyaXggaW4gdGhlIHNldFJhdGlvKCkgbWV0aG9kKVxuXHRcdFx0XHRcdGlmICh0bS5zdmcpIHsgLy9pZiB3ZSdyZSBzdXBwb3NlZCB0byBhcHBseSB0cmFuc2Zvcm1zIHRvIHRoZSBTVkcgZWxlbWVudCdzIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLCBtYWtlIHN1cmUgdGhlcmUgYXJlbid0IGFueSBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkIG9yIHRoZXknbGwgb3ZlcnJpZGUgdGhlIGF0dHJpYnV0ZSBvbmVzLiBBbHNvIGNsZWFyIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIGlmIHdlJ3JlIHVzaW5nIENTUywganVzdCB0byBiZSBjbGVhbi5cblx0XHRcdFx0XHRcdGlmIChfdXNlU1ZHVHJhbnNmb3JtQXR0ciAmJiB0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSkge1xuXHRcdFx0XHRcdFx0XHRfcmVtb3ZlUHJvcCh0LnN0eWxlLCBfdHJhbnNmb3JtUHJvcCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCFfdXNlU1ZHVHJhbnNmb3JtQXR0ciAmJiB0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSkge1xuXHRcdFx0XHRcdFx0XHR0LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRtO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly9mb3Igc2V0dGluZyAyRCB0cmFuc2Zvcm1zIGluIElFNiwgSUU3LCBhbmQgSUU4IChtdXN0IHVzZSBhIFwiZmlsdGVyXCIgdG8gZW11bGF0ZSB0aGUgYmVoYXZpb3Igb2YgbW9kZXJuIGRheSBicm93c2VyIHRyYW5zZm9ybXMpXG5cdFx0XHRfc2V0SUVUcmFuc2Zvcm1SYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dmFyIHQgPSB0aGlzLmRhdGEsIC8vcmVmZXJzIHRvIHRoZSBlbGVtZW50J3MgX2dzVHJhbnNmb3JtIG9iamVjdFxuXHRcdFx0XHRcdGFuZyA9IC10LnJvdGF0aW9uICogX0RFRzJSQUQsXG5cdFx0XHRcdFx0c2tldyA9IGFuZyArIHQuc2tld1ggKiBfREVHMlJBRCxcblx0XHRcdFx0XHRybmQgPSAxMDAwMDAsXG5cdFx0XHRcdFx0YSA9ICgoTWF0aC5jb3MoYW5nKSAqIHQuc2NhbGVYICogcm5kKSB8IDApIC8gcm5kLFxuXHRcdFx0XHRcdGIgPSAoKE1hdGguc2luKGFuZykgKiB0LnNjYWxlWCAqIHJuZCkgfCAwKSAvIHJuZCxcblx0XHRcdFx0XHRjID0gKChNYXRoLnNpbihza2V3KSAqIC10LnNjYWxlWSAqIHJuZCkgfCAwKSAvIHJuZCxcblx0XHRcdFx0XHRkID0gKChNYXRoLmNvcyhza2V3KSAqIHQuc2NhbGVZICogcm5kKSB8IDApIC8gcm5kLFxuXHRcdFx0XHRcdHN0eWxlID0gdGhpcy50LnN0eWxlLFxuXHRcdFx0XHRcdGNzID0gdGhpcy50LmN1cnJlbnRTdHlsZSxcblx0XHRcdFx0XHRmaWx0ZXJzLCB2YWw7XG5cdFx0XHRcdGlmICghY3MpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsID0gYjsgLy9qdXN0IGZvciBzd2FwcGluZyB0aGUgdmFyaWFibGVzIGFuIGludmVydGluZyB0aGVtIChyZXVzZWQgXCJ2YWxcIiB0byBhdm9pZCBjcmVhdGluZyBhbm90aGVyIHZhcmlhYmxlIGluIG1lbW9yeSkuIElFJ3MgZmlsdGVyIG1hdHJpeCB1c2VzIGEgbm9uLXN0YW5kYXJkIG1hdHJpeCBjb25maWd1cmF0aW9uIChhbmdsZSBnb2VzIHRoZSBvcHBvc2l0ZSB3YXksIGFuZCBiIGFuZCBjIGFyZSByZXZlcnNlZCBhbmQgaW52ZXJ0ZWQpXG5cdFx0XHRcdGIgPSAtYztcblx0XHRcdFx0YyA9IC12YWw7XG5cdFx0XHRcdGZpbHRlcnMgPSBjcy5maWx0ZXI7XG5cdFx0XHRcdHN0eWxlLmZpbHRlciA9IFwiXCI7IC8vcmVtb3ZlIGZpbHRlcnMgc28gdGhhdCB3ZSBjYW4gYWNjdXJhdGVseSBtZWFzdXJlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodFxuXHRcdFx0XHR2YXIgdyA9IHRoaXMudC5vZmZzZXRXaWR0aCxcblx0XHRcdFx0XHRoID0gdGhpcy50Lm9mZnNldEhlaWdodCxcblx0XHRcdFx0XHRjbGlwID0gKGNzLnBvc2l0aW9uICE9PSBcImFic29sdXRlXCIpLFxuXHRcdFx0XHRcdG0gPSBcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPVwiICsgYSArIFwiLCBNMTI9XCIgKyBiICsgXCIsIE0yMT1cIiArIGMgKyBcIiwgTTIyPVwiICsgZCxcblx0XHRcdFx0XHRveCA9IHQueCArICh3ICogdC54UGVyY2VudCAvIDEwMCksXG5cdFx0XHRcdFx0b3kgPSB0LnkgKyAoaCAqIHQueVBlcmNlbnQgLyAxMDApLFxuXHRcdFx0XHRcdGR4LCBkeTtcblxuXHRcdFx0XHQvL2lmIHRyYW5zZm9ybU9yaWdpbiBpcyBiZWluZyB1c2VkLCBhZGp1c3QgdGhlIG9mZnNldCB4IGFuZCB5XG5cdFx0XHRcdGlmICh0Lm94ICE9IG51bGwpIHtcblx0XHRcdFx0XHRkeCA9ICgodC5veHApID8gdyAqIHQub3ggKiAwLjAxIDogdC5veCkgLSB3IC8gMjtcblx0XHRcdFx0XHRkeSA9ICgodC5veXApID8gaCAqIHQub3kgKiAwLjAxIDogdC5veSkgLSBoIC8gMjtcblx0XHRcdFx0XHRveCArPSBkeCAtIChkeCAqIGEgKyBkeSAqIGIpO1xuXHRcdFx0XHRcdG95ICs9IGR5IC0gKGR4ICogYyArIGR5ICogZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWNsaXApIHtcblx0XHRcdFx0XHRtICs9IFwiLCBzaXppbmdNZXRob2Q9J2F1dG8gZXhwYW5kJylcIjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkeCA9ICh3IC8gMik7XG5cdFx0XHRcdFx0ZHkgPSAoaCAvIDIpO1xuXHRcdFx0XHRcdC8vdHJhbnNsYXRlIHRvIGVuc3VyZSB0aGF0IHRyYW5zZm9ybWF0aW9ucyBvY2N1ciBhcm91bmQgdGhlIGNvcnJlY3Qgb3JpZ2luIChkZWZhdWx0IGlzIGNlbnRlcikuXG5cdFx0XHRcdFx0bSArPSBcIiwgRHg9XCIgKyAoZHggLSAoZHggKiBhICsgZHkgKiBiKSArIG94KSArIFwiLCBEeT1cIiArIChkeSAtIChkeCAqIGMgKyBkeSAqIGQpICsgb3kpICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGZpbHRlcnMuaW5kZXhPZihcIkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0c3R5bGUuZmlsdGVyID0gZmlsdGVycy5yZXBsYWNlKF9pZVNldE1hdHJpeEV4cCwgbSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGUuZmlsdGVyID0gbSArIFwiIFwiICsgZmlsdGVyczsgLy93ZSBtdXN0IGFsd2F5cyBwdXQgdGhlIHRyYW5zZm9ybS9tYXRyaXggRklSU1QgKGJlZm9yZSBhbHBoYShvcGFjaXR5PXh4KSkgdG8gYXZvaWQgYW4gSUUgYnVnIHRoYXQgc2xpY2VzIHBhcnQgb2YgdGhlIG9iamVjdCB3aGVuIHJvdGF0aW9uIGlzIGFwcGxpZWQgd2l0aCBhbHBoYS5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vYXQgdGhlIGVuZCBvciBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuLCBpZiB0aGUgbWF0cml4IGlzIG5vcm1hbCAoMSwgMCwgMCwgMSkgYW5kIG9wYWNpdHkgaXMgMTAwIChvciBkb2Vzbid0IGV4aXN0KSwgcmVtb3ZlIHRoZSBmaWx0ZXIgdG8gaW1wcm92ZSBicm93c2VyIHBlcmZvcm1hbmNlLlxuXHRcdFx0XHRpZiAodiA9PT0gMCB8fCB2ID09PSAxKSBpZiAoYSA9PT0gMSkgaWYgKGIgPT09IDApIGlmIChjID09PSAwKSBpZiAoZCA9PT0gMSkgaWYgKCFjbGlwIHx8IG0uaW5kZXhPZihcIkR4PTAsIER5PTBcIikgIT09IC0xKSBpZiAoIV9vcGFjaXR5RXhwLnRlc3QoZmlsdGVycykgfHwgcGFyc2VGbG9hdChSZWdFeHAuJDEpID09PSAxMDApIGlmIChmaWx0ZXJzLmluZGV4T2YoXCJncmFkaWVudChcIiAmJiBmaWx0ZXJzLmluZGV4T2YoXCJBbHBoYVwiKSkgPT09IC0xKSB7XG5cdFx0XHRcdFx0c3R5bGUucmVtb3ZlQXR0cmlidXRlKFwiZmlsdGVyXCIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly93ZSBtdXN0IHNldCB0aGUgbWFyZ2lucyBBRlRFUiBhcHBseWluZyB0aGUgZmlsdGVyIGluIG9yZGVyIHRvIGF2b2lkIHNvbWUgYnVncyBpbiBJRTggdGhhdCBjb3VsZCAoaW4gcmFyZSBzY2VuYXJpb3MpIGNhdXNlIHRoZW0gdG8gYmUgaWdub3JlZCBpbnRlcm1pdHRlbnRseSAodmlicmF0aW9uKS5cblx0XHRcdFx0aWYgKCFjbGlwKSB7XG5cdFx0XHRcdFx0dmFyIG11bHQgPSAoX2llVmVycyA8IDgpID8gMSA6IC0xLCAvL2luIEludGVybmV0IEV4cGxvcmVyIDcgYW5kIGJlZm9yZSwgdGhlIGJveCBtb2RlbCBpcyBicm9rZW4sIGNhdXNpbmcgdGhlIGJyb3dzZXIgdG8gdHJlYXQgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgYWN0dWFsIHJvdGF0ZWQgZmlsdGVyZWQgaW1hZ2UgYXMgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgYm94IGl0c2VsZiwgYnV0IE1pY3Jvc29mdCBjb3JyZWN0ZWQgdGhhdCBpbiBJRTguIFdlIG11c3QgdXNlIGEgbmVnYXRpdmUgb2Zmc2V0IGluIElFOCBvbiB0aGUgcmlnaHQvYm90dG9tXG5cdFx0XHRcdFx0XHRtYXJnLCBwcm9wLCBkaWY7XG5cdFx0XHRcdFx0ZHggPSB0LmllT2Zmc2V0WCB8fCAwO1xuXHRcdFx0XHRcdGR5ID0gdC5pZU9mZnNldFkgfHwgMDtcblx0XHRcdFx0XHR0LmllT2Zmc2V0WCA9IE1hdGgucm91bmQoKHcgLSAoKGEgPCAwID8gLWEgOiBhKSAqIHcgKyAoYiA8IDAgPyAtYiA6IGIpICogaCkpIC8gMiArIG94KTtcblx0XHRcdFx0XHR0LmllT2Zmc2V0WSA9IE1hdGgucm91bmQoKGggLSAoKGQgPCAwID8gLWQgOiBkKSAqIGggKyAoYyA8IDAgPyAtYyA6IGMpICogdykpIC8gMiArIG95KTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRwcm9wID0gX21hcmdpbnNbaV07XG5cdFx0XHRcdFx0XHRtYXJnID0gY3NbcHJvcF07XG5cdFx0XHRcdFx0XHQvL3dlIG5lZWQgdG8gZ2V0IHRoZSBjdXJyZW50IG1hcmdpbiBpbiBjYXNlIGl0IGlzIGJlaW5nIHR3ZWVuZWQgc2VwYXJhdGVseSAod2Ugd2FudCB0byByZXNwZWN0IHRoYXQgdHdlZW4ncyBjaGFuZ2VzKVxuXHRcdFx0XHRcdFx0dmFsID0gKG1hcmcuaW5kZXhPZihcInB4XCIpICE9PSAtMSkgPyBwYXJzZUZsb2F0KG1hcmcpIDogX2NvbnZlcnRUb1BpeGVscyh0aGlzLnQsIHByb3AsIHBhcnNlRmxvYXQobWFyZyksIG1hcmcucmVwbGFjZShfc3VmZml4RXhwLCBcIlwiKSkgfHwgMDtcblx0XHRcdFx0XHRcdGlmICh2YWwgIT09IHRbcHJvcF0pIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKGkgPCAyKSA/IC10LmllT2Zmc2V0WCA6IC10LmllT2Zmc2V0WTsgLy9pZiBhbm90aGVyIHR3ZWVuIGlzIGNvbnRyb2xsaW5nIGEgbWFyZ2luLCB3ZSBjYW5ub3Qgb25seSBhcHBseSB0aGUgZGlmZmVyZW5jZSBpbiB0aGUgaWVPZmZzZXRzLCBzbyB3ZSBlc3NlbnRpYWxseSB6ZXJvLW91dCB0aGUgZHggYW5kIGR5IGhlcmUgaW4gdGhhdCBjYXNlLiBXZSByZWNvcmQgdGhlIG1hcmdpbihzKSBsYXRlciBzbyB0aGF0IHdlIGNhbiBrZWVwIGNvbXBhcmluZyB0aGVtLCBtYWtpbmcgdGhpcyBjb2RlIHZlcnkgZmxleGlibGUuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoaSA8IDIpID8gZHggLSB0LmllT2Zmc2V0WCA6IGR5IC0gdC5pZU9mZnNldFk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzdHlsZVtwcm9wXSA9ICh0W3Byb3BdID0gTWF0aC5yb3VuZCggdmFsIC0gZGlmICogKChpID09PSAwIHx8IGkgPT09IDIpID8gMSA6IG11bHQpICkpICsgXCJweFwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyogdHJhbnNsYXRlcyBhIHN1cGVyIHNtYWxsIGRlY2ltYWwgdG8gYSBzdHJpbmcgV0lUSE9VVCBzY2llbnRpZmljIG5vdGF0aW9uXG5cdFx0XHRfc2FmZURlY2ltYWwgPSBmdW5jdGlvbihuKSB7XG5cdFx0XHRcdHZhciBzID0gKG4gPCAwID8gLW4gOiBuKSArIFwiXCIsXG5cdFx0XHRcdFx0YSA9IHMuc3BsaXQoXCJlLVwiKTtcblx0XHRcdFx0cmV0dXJuIChuIDwgMCA/IFwiLTAuXCIgOiBcIjAuXCIpICsgbmV3IEFycmF5KHBhcnNlSW50KGFbMV0sIDEwKSB8fCAwKS5qb2luKFwiMFwiKSArIGFbMF0uc3BsaXQoXCIuXCIpLmpvaW4oXCJcIik7XG5cdFx0XHR9LFxuXHRcdFx0Ki9cblxuXHRcdFx0X3NldDNEVHJhbnNmb3JtUmF0aW8gPSBfaW50ZXJuYWxzLnNldDNEVHJhbnNmb3JtUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcy5kYXRhLCAvL3JlZmVycyB0byB0aGUgZWxlbWVudCdzIF9nc1RyYW5zZm9ybSBvYmplY3Rcblx0XHRcdFx0XHRzdHlsZSA9IHRoaXMudC5zdHlsZSxcblx0XHRcdFx0XHRhbmdsZSA9IHQucm90YXRpb24gKiBfREVHMlJBRCxcblx0XHRcdFx0XHRzeCA9IHQuc2NhbGVYLFxuXHRcdFx0XHRcdHN5ID0gdC5zY2FsZVksXG5cdFx0XHRcdFx0c3ogPSB0LnNjYWxlWixcblx0XHRcdFx0XHR4ID0gdC54LFxuXHRcdFx0XHRcdHkgPSB0LnksXG5cdFx0XHRcdFx0eiA9IHQueixcblx0XHRcdFx0XHRwZXJzcGVjdGl2ZSA9IHQucGVyc3BlY3RpdmUsXG5cdFx0XHRcdFx0YTExLCBhMTIsIGExMywgYTIxLCBhMjIsIGEyMywgYTMxLCBhMzIsIGEzMywgYTQxLCBhNDIsIGE0Myxcblx0XHRcdFx0XHR6T3JpZ2luLCBtaW4sIGNvcywgc2luLCB0MSwgdDIsIHRyYW5zZm9ybSwgY29tbWEsIHplcm87XG5cdFx0XHRcdGlmICh2ID09PSAxIHx8IHYgPT09IDAgfHwgIXQuZm9yY2UzRCkgaWYgKHQuZm9yY2UzRCAhPT0gdHJ1ZSkgaWYgKCF0LnJvdGF0aW9uWSAmJiAhdC5yb3RhdGlvblggJiYgc3ogPT09IDEgJiYgIXBlcnNwZWN0aXZlICYmICF6ICYmICh0aGlzLnR3ZWVuLl90b3RhbFRpbWUgPT09IHRoaXMudHdlZW4uX3RvdGFsRHVyYXRpb24gfHwgIXRoaXMudHdlZW4uX3RvdGFsVGltZSkpIHsgLy9vbiB0aGUgZmluYWwgcmVuZGVyICh3aGljaCBjb3VsZCBiZSAwIGZvciBhIGZyb20gdHdlZW4pLCBpZiB0aGVyZSBhcmUgbm8gM0QgYXNwZWN0cywgcmVuZGVyIGluIDJEIHRvIGZyZWUgdXAgbWVtb3J5IGFuZCBpbXByb3ZlIHBlcmZvcm1hbmNlIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZXMuIENoZWNrIHRoZSB0d2VlbidzIHRvdGFsVGltZS90b3RhbER1cmF0aW9uIHRvbyBpbiBvcmRlciB0byBtYWtlIHN1cmUgaXQgZG9lc24ndCBoYXBwZW4gYmV0d2VlbiByZXBlYXRzIGlmIGl0J3MgYSByZXBlYXRpbmcgdHdlZW4uXG5cdFx0XHRcdFx0X3NldDJEVHJhbnNmb3JtUmF0aW8uY2FsbCh0aGlzLCB2KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9pc0ZpcmVmb3gpIHtcblx0XHRcdFx0XHRtaW4gPSAwLjAwMDE7XG5cdFx0XHRcdFx0aWYgKHN4IDwgbWluICYmIHN4ID4gLW1pbikgeyAvL0ZpcmVmb3ggaGFzIGEgYnVnIChhdCBsZWFzdCBpbiB2MjUpIHRoYXQgY2F1c2VzIGl0IHRvIHJlbmRlciB0aGUgdHJhbnNwYXJlbnQgcGFydCBvZiAzMi1iaXQgUE5HIGltYWdlcyBhcyBibGFjayB3aGVuIGRpc3BsYXllZCBpbnNpZGUgYW4gaWZyYW1lIGFuZCB0aGUgM0Qgc2NhbGUgaXMgdmVyeSBzbWFsbCBhbmQgZG9lc24ndCBjaGFuZ2Ugc3VmZmljaWVudGx5IGVub3VnaCBiZXR3ZWVuIHJlbmRlcnMgKGxpa2UgaWYgeW91IHVzZSBhIFBvd2VyNC5lYXNlSW5PdXQgdG8gc2NhbGUgZnJvbSAwIHRvIDEgd2hlcmUgdGhlIGJlZ2lubmluZyB2YWx1ZXMgb25seSBjaGFuZ2UgYSB0aW55IGFtb3VudCB0byBiZWdpbiB0aGUgdHdlZW4gYmVmb3JlIGFjY2VsZXJhdGluZykuIEluIHRoaXMgY2FzZSwgd2UgZm9yY2UgdGhlIHNjYWxlIHRvIGJlIDAuMDAwMDIgaW5zdGVhZCB3aGljaCBpcyB2aXN1YWxseSB0aGUgc2FtZSBidXQgd29ya3MgYXJvdW5kIHRoZSBGaXJlZm94IGlzc3VlLlxuXHRcdFx0XHRcdFx0c3ggPSBzeiA9IDAuMDAwMDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzeSA8IG1pbiAmJiBzeSA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHN5ID0gc3ogPSAwLjAwMDAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGVyc3BlY3RpdmUgJiYgIXQueiAmJiAhdC5yb3RhdGlvblggJiYgIXQucm90YXRpb25ZKSB7IC8vRmlyZWZveCBoYXMgYSBidWcgdGhhdCBjYXVzZXMgZWxlbWVudHMgdG8gaGF2ZSBhbiBvZGQgc3VwZXItdGhpbiwgYnJva2VuL2RvdHRlZCBibGFjayBib3JkZXIgb24gZWxlbWVudHMgdGhhdCBoYXZlIGEgcGVyc3BlY3RpdmUgc2V0IGJ1dCBhcmVuJ3QgdXRpbGl6aW5nIDNEIHNwYWNlIChubyByb3RhdGlvblgsIHJvdGF0aW9uWSwgb3IgeikuXG5cdFx0XHRcdFx0XHRwZXJzcGVjdGl2ZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhbmdsZSB8fCB0LnNrZXdYKSB7XG5cdFx0XHRcdFx0Y29zID0gYTExID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0XHRcdHNpbiA9IGEyMSA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHRpZiAodC5za2V3WCkge1xuXHRcdFx0XHRcdFx0YW5nbGUgLT0gdC5za2V3WCAqIF9ERUcyUkFEO1xuXHRcdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdFx0aWYgKHQuc2tld1R5cGUgPT09IFwic2ltcGxlXCIpIHsgLy9ieSBkZWZhdWx0LCB3ZSBjb21wZW5zYXRlIHNrZXdpbmcgb24gdGhlIG90aGVyIGF4aXMgdG8gbWFrZSBpdCBsb29rIG1vcmUgbmF0dXJhbCwgYnV0IHlvdSBjYW4gc2V0IHRoZSBza2V3VHlwZSB0byBcInNpbXBsZVwiIHRvIHVzZSB0aGUgdW5jb21wZW5zYXRlZCBza2V3aW5nIHRoYXQgQ1NTIGRvZXNcblx0XHRcdFx0XHRcdFx0dDEgPSBNYXRoLnRhbih0LnNrZXdYICogX0RFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IE1hdGguc3FydCgxICsgdDEgKiB0MSk7XG5cdFx0XHRcdFx0XHRcdGNvcyAqPSB0MTtcblx0XHRcdFx0XHRcdFx0c2luICo9IHQxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhMTIgPSAtc2luO1xuXHRcdFx0XHRcdGEyMiA9IGNvcztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCF0LnJvdGF0aW9uWSAmJiAhdC5yb3RhdGlvblggJiYgc3ogPT09IDEgJiYgIXBlcnNwZWN0aXZlICYmICF0LnN2ZykgeyAvL2lmIHdlJ3JlIG9ubHkgdHJhbnNsYXRpbmcgYW5kL29yIDJEIHNjYWxpbmcsIHRoaXMgaXMgZmFzdGVyLi4uXG5cdFx0XHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gKCh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpID8gXCJ0cmFuc2xhdGUoXCIgKyB0LnhQZXJjZW50ICsgXCIlLFwiICsgdC55UGVyY2VudCArIFwiJSkgdHJhbnNsYXRlM2QoXCIgOiBcInRyYW5zbGF0ZTNkKFwiKSArIHggKyBcInB4LFwiICsgeSArIFwicHgsXCIgKyB6ICtcInB4KVwiICsgKChzeCAhPT0gMSB8fCBzeSAhPT0gMSkgPyBcIiBzY2FsZShcIiArIHN4ICsgXCIsXCIgKyBzeSArIFwiKVwiIDogXCJcIik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGExMSA9IGEyMiA9IDE7XG5cdFx0XHRcdFx0YTEyID0gYTIxID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBLRVkgIElOREVYICAgQUZGRUNUU1xuXHRcdFx0XHQvLyBhMTEgIDAgICAgICAgcm90YXRpb24sIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGEyMSAgMSAgICAgICByb3RhdGlvbiwgcm90YXRpb25ZLCBzY2FsZVhcblx0XHRcdFx0Ly8gYTMxICAyICAgICAgIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGE0MSAgMyAgICAgICByb3RhdGlvblksIHNjYWxlWFxuXHRcdFx0XHQvLyBhMTIgIDQgICAgICAgcm90YXRpb24sIHNrZXdYLCByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhMjIgIDUgICAgICAgcm90YXRpb24sIHNrZXdYLCByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhMzIgIDYgICAgICAgcm90YXRpb25YLCBzY2FsZVlcblx0XHRcdFx0Ly8gYTQyICA3ICAgICAgIHJvdGF0aW9uWCwgc2NhbGVZXG5cdFx0XHRcdC8vIGExMyAgOCAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGEyMyAgOSAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGEzMyAgMTAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGE0MyAgMTEgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgcGVyc3BlY3RpdmUsIHNjYWxlWlxuXHRcdFx0XHQvLyBhMTQgIDEyICAgICAgeCwgek9yaWdpbiwgc3ZnT3JpZ2luXG5cdFx0XHRcdC8vIGEyNCAgMTMgICAgICB5LCB6T3JpZ2luLCBzdmdPcmlnaW5cblx0XHRcdFx0Ly8gYTM0ICAxNCAgICAgIHosIHpPcmlnaW5cblx0XHRcdFx0Ly8gYTQ0ICAxNVxuXHRcdFx0XHQvLyByb3RhdGlvbjogTWF0aC5hdGFuMihhMjEsIGExMSlcblx0XHRcdFx0Ly8gcm90YXRpb25ZOiBNYXRoLmF0YW4yKGExMywgYTMzKSAob3IgTWF0aC5hdGFuMihhMTMsIGExMSkpXG5cdFx0XHRcdC8vIHJvdGF0aW9uWDogTWF0aC5hdGFuMihhMzIsIGEzMylcblx0XHRcdFx0YTMzID0gMTtcblx0XHRcdFx0YTEzID0gYTIzID0gYTMxID0gYTMyID0gYTQxID0gYTQyID0gMDtcblx0XHRcdFx0YTQzID0gKHBlcnNwZWN0aXZlKSA/IC0xIC8gcGVyc3BlY3RpdmUgOiAwO1xuXHRcdFx0XHR6T3JpZ2luID0gdC56T3JpZ2luO1xuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMTsgLy90aHJlc2hvbGQgYmVsb3cgd2hpY2ggYnJvd3NlcnMgdXNlIHNjaWVudGlmaWMgbm90YXRpb24gd2hpY2ggd29uJ3Qgd29yay5cblx0XHRcdFx0Y29tbWEgPSBcIixcIjtcblx0XHRcdFx0emVybyA9IFwiMFwiO1xuXHRcdFx0XHRhbmdsZSA9IHQucm90YXRpb25ZICogX0RFRzJSQUQ7XG5cdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0XHRcdFx0YTMxID0gLXNpbjtcblx0XHRcdFx0XHRhNDEgPSBhNDMqLXNpbjtcblx0XHRcdFx0XHRhMTMgPSBhMTEqc2luO1xuXHRcdFx0XHRcdGEyMyA9IGEyMSpzaW47XG5cdFx0XHRcdFx0YTMzID0gY29zO1xuXHRcdFx0XHRcdGE0MyAqPSBjb3M7XG5cdFx0XHRcdFx0YTExICo9IGNvcztcblx0XHRcdFx0XHRhMjEgKj0gY29zO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFuZ2xlID0gdC5yb3RhdGlvblggKiBfREVHMlJBRDtcblx0XHRcdFx0aWYgKGFuZ2xlKSB7XG5cdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHR0MSA9IGExMipjb3MrYTEzKnNpbjtcblx0XHRcdFx0XHR0MiA9IGEyMipjb3MrYTIzKnNpbjtcblx0XHRcdFx0XHRhMzIgPSBhMzMqc2luO1xuXHRcdFx0XHRcdGE0MiA9IGE0MypzaW47XG5cdFx0XHRcdFx0YTEzID0gYTEyKi1zaW4rYTEzKmNvcztcblx0XHRcdFx0XHRhMjMgPSBhMjIqLXNpbithMjMqY29zO1xuXHRcdFx0XHRcdGEzMyA9IGEzMypjb3M7XG5cdFx0XHRcdFx0YTQzID0gYTQzKmNvcztcblx0XHRcdFx0XHRhMTIgPSB0MTtcblx0XHRcdFx0XHRhMjIgPSB0Mjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc3ogIT09IDEpIHtcblx0XHRcdFx0XHRhMTMqPXN6O1xuXHRcdFx0XHRcdGEyMyo9c3o7XG5cdFx0XHRcdFx0YTMzKj1zejtcblx0XHRcdFx0XHRhNDMqPXN6O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzeSAhPT0gMSkge1xuXHRcdFx0XHRcdGExMio9c3k7XG5cdFx0XHRcdFx0YTIyKj1zeTtcblx0XHRcdFx0XHRhMzIqPXN5O1xuXHRcdFx0XHRcdGE0Mio9c3k7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN4ICE9PSAxKSB7XG5cdFx0XHRcdFx0YTExKj1zeDtcblx0XHRcdFx0XHRhMjEqPXN4O1xuXHRcdFx0XHRcdGEzMSo9c3g7XG5cdFx0XHRcdFx0YTQxKj1zeDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh6T3JpZ2luIHx8IHQuc3ZnKSB7XG5cdFx0XHRcdFx0aWYgKHpPcmlnaW4pIHtcblx0XHRcdFx0XHRcdHggKz0gYTEzKi16T3JpZ2luO1xuXHRcdFx0XHRcdFx0eSArPSBhMjMqLXpPcmlnaW47XG5cdFx0XHRcdFx0XHR6ICs9IGEzMyotek9yaWdpbit6T3JpZ2luO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodC5zdmcpIHsgLy9kdWUgdG8gYnVncyBpbiBzb21lIGJyb3dzZXJzLCB3ZSBuZWVkIHRvIG1hbmFnZSB0aGUgdHJhbnNmb3JtLW9yaWdpbiBvZiBTVkcgbWFudWFsbHlcblx0XHRcdFx0XHRcdHggKz0gdC54T3JpZ2luIC0gKHQueE9yaWdpbiAqIGExMSArIHQueU9yaWdpbiAqIGExMik7XG5cdFx0XHRcdFx0XHR5ICs9IHQueU9yaWdpbiAtICh0LnhPcmlnaW4gKiBhMjEgKyB0LnlPcmlnaW4gKiBhMjIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeCA8IG1pbiAmJiB4ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0eCA9IHplcm87XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh5IDwgbWluICYmIHkgPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR5ID0gemVybztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHogPCBtaW4gJiYgeiA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHogPSAwOyAvL2Rvbid0IHVzZSBzdHJpbmcgYmVjYXVzZSB3ZSBjYWxjdWxhdGUgcGVyc3BlY3RpdmUgbGF0ZXIgYW5kIG5lZWQgdGhlIG51bWJlci5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL29wdGltaXplZCB3YXkgb2YgY29uY2F0ZW5hdGluZyBhbGwgdGhlIHZhbHVlcyBpbnRvIGEgc3RyaW5nLiBJZiB3ZSBkbyBpdCBhbGwgaW4gb25lIHNob3QsIGl0J3Mgc2xvd2VyIGJlY2F1c2Ugb2YgdGhlIHdheSBicm93c2VycyBoYXZlIHRvIGNyZWF0ZSB0ZW1wIHN0cmluZ3MgYW5kIHRoZSB3YXkgaXQgYWZmZWN0cyBtZW1vcnkuIElmIHdlIGRvIGl0IHBpZWNlLWJ5LXBpZWNlIHdpdGggKz0sIGl0J3MgYSBiaXQgc2xvd2VyIHRvby4gV2UgZm91bmQgdGhhdCBkb2luZyBpdCBpbiB0aGVzZSBzaXplZCBjaHVua3Mgd29ya3MgYmVzdCBvdmVyYWxsOlxuXHRcdFx0XHR0cmFuc2Zvcm0gPSAoKHQueFBlcmNlbnQgfHwgdC55UGVyY2VudCkgPyBcInRyYW5zbGF0ZShcIiArIHQueFBlcmNlbnQgKyBcIiUsXCIgKyB0LnlQZXJjZW50ICsgXCIlKSBtYXRyaXgzZChcIiA6IFwibWF0cml4M2QoXCIpO1xuXHRcdFx0XHR0cmFuc2Zvcm0gKz0gKChhMTEgPCBtaW4gJiYgYTExID4gLW1pbikgPyB6ZXJvIDogYTExKSArIGNvbW1hICsgKChhMjEgPCBtaW4gJiYgYTIxID4gLW1pbikgPyB6ZXJvIDogYTIxKSArIGNvbW1hICsgKChhMzEgPCBtaW4gJiYgYTMxID4gLW1pbikgPyB6ZXJvIDogYTMxKTtcblx0XHRcdFx0dHJhbnNmb3JtICs9IGNvbW1hICsgKChhNDEgPCBtaW4gJiYgYTQxID4gLW1pbikgPyB6ZXJvIDogYTQxKSArIGNvbW1hICsgKChhMTIgPCBtaW4gJiYgYTEyID4gLW1pbikgPyB6ZXJvIDogYTEyKSArIGNvbW1hICsgKChhMjIgPCBtaW4gJiYgYTIyID4gLW1pbikgPyB6ZXJvIDogYTIyKTtcblx0XHRcdFx0aWYgKHQucm90YXRpb25YIHx8IHQucm90YXRpb25ZKSB7IC8vcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIChvZnRlbiB0aGVyZSdzIG5vIHJvdGF0aW9uWCBvciByb3RhdGlvblksIHNvIHdlIGNhbiBza2lwIHRoZXNlIGNhbGN1bGF0aW9ucylcblx0XHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGEzMiA8IG1pbiAmJiBhMzIgPiAtbWluKSA/IHplcm8gOiBhMzIpICsgY29tbWEgKyAoKGE0MiA8IG1pbiAmJiBhNDIgPiAtbWluKSA/IHplcm8gOiBhNDIpICsgY29tbWEgKyAoKGExMyA8IG1pbiAmJiBhMTMgPiAtbWluKSA/IHplcm8gOiBhMTMpO1xuXHRcdFx0XHRcdHRyYW5zZm9ybSArPSBjb21tYSArICgoYTIzIDwgbWluICYmIGEyMyA+IC1taW4pID8gemVybyA6IGEyMykgKyBjb21tYSArICgoYTMzIDwgbWluICYmIGEzMyA+IC1taW4pID8gemVybyA6IGEzMykgKyBjb21tYSArICgoYTQzIDwgbWluICYmIGE0MyA+IC1taW4pID8gemVybyA6IGE0MykgKyBjb21tYTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0cmFuc2Zvcm0gKz0gXCIsMCwwLDAsMCwxLDAsXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHJhbnNmb3JtICs9IHggKyBjb21tYSArIHkgKyBjb21tYSArIHogKyBjb21tYSArIChwZXJzcGVjdGl2ZSA/ICgxICsgKC16IC8gcGVyc3BlY3RpdmUpKSA6IDEpICsgXCIpXCI7XG5cblx0XHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXHRcdFx0fSxcblxuXHRcdFx0X3NldDJEVHJhbnNmb3JtUmF0aW8gPSBfaW50ZXJuYWxzLnNldDJEVHJhbnNmb3JtUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcy5kYXRhLCAvL3JlZmVycyB0byB0aGUgZWxlbWVudCdzIF9nc1RyYW5zZm9ybSBvYmplY3Rcblx0XHRcdFx0XHR0YXJnID0gdGhpcy50LFxuXHRcdFx0XHRcdHN0eWxlID0gdGFyZy5zdHlsZSxcblx0XHRcdFx0XHR4ID0gdC54LFxuXHRcdFx0XHRcdHkgPSB0LnksXG5cdFx0XHRcdFx0YW5nLCBza2V3LCBybmQsIHN4LCBzeSwgYSwgYiwgYywgZCwgbWF0cml4LCBtaW4sIHQxO1xuXHRcdFx0XHRpZiAoKHQucm90YXRpb25YIHx8IHQucm90YXRpb25ZIHx8IHQueiB8fCB0LmZvcmNlM0QgPT09IHRydWUgfHwgKHQuZm9yY2UzRCA9PT0gXCJhdXRvXCIgJiYgdiAhPT0gMSAmJiB2ICE9PSAwKSkgJiYgISh0LnN2ZyAmJiBfdXNlU1ZHVHJhbnNmb3JtQXR0cikgJiYgX3N1cHBvcnRzM0QpIHsgLy9pZiBhIDNEIHR3ZWVuIGJlZ2lucyB3aGlsZSBhIDJEIG9uZSBpcyBydW5uaW5nLCB3ZSBuZWVkIHRvIGtpY2sgdGhlIHJlbmRlcmluZyBvdmVyIHRvIHRoZSAzRCBtZXRob2QuIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgeW95by1pbmcsIGluZmluaXRlbHkgcmVwZWF0aW5nIHNjYWxlIHR3ZWVuIHJ1bm5pbmcsIGFuZCB0aGVuIHRoZSBvYmplY3QgZ2V0cyByb3RhdGVkIGluIDNEIHNwYWNlIHdpdGggYSBkaWZmZXJlbnQgdHdlZW4uXG5cdFx0XHRcdFx0dGhpcy5zZXRSYXRpbyA9IF9zZXQzRFRyYW5zZm9ybVJhdGlvO1xuXHRcdFx0XHRcdF9zZXQzRFRyYW5zZm9ybVJhdGlvLmNhbGwodGhpcywgdik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN4ID0gdC5zY2FsZVg7XG5cdFx0XHRcdHN5ID0gdC5zY2FsZVk7XG5cdFx0XHRcdGlmICh0LnJvdGF0aW9uIHx8IHQuc2tld1ggfHwgdC5zdmcpIHtcblx0XHRcdFx0XHRhbmcgPSB0LnJvdGF0aW9uICogX0RFRzJSQUQ7XG5cdFx0XHRcdFx0c2tldyA9IHQuc2tld1ggKiBfREVHMlJBRDtcblx0XHRcdFx0XHRybmQgPSAxMDAwMDA7XG5cdFx0XHRcdFx0YSA9IE1hdGguY29zKGFuZykgKiBzeDtcblx0XHRcdFx0XHRiID0gTWF0aC5zaW4oYW5nKSAqIHN4O1xuXHRcdFx0XHRcdGMgPSBNYXRoLnNpbihhbmcgLSBza2V3KSAqIC1zeTtcblx0XHRcdFx0XHRkID0gTWF0aC5jb3MoYW5nIC0gc2tldykgKiBzeTtcblx0XHRcdFx0XHRpZiAoc2tldyAmJiB0LnNrZXdUeXBlID09PSBcInNpbXBsZVwiKSB7IC8vYnkgZGVmYXVsdCwgd2UgY29tcGVuc2F0ZSBza2V3aW5nIG9uIHRoZSBvdGhlciBheGlzIHRvIG1ha2UgaXQgbG9vayBtb3JlIG5hdHVyYWwsIGJ1dCB5b3UgY2FuIHNldCB0aGUgc2tld1R5cGUgdG8gXCJzaW1wbGVcIiB0byB1c2UgdGhlIHVuY29tcGVuc2F0ZWQgc2tld2luZyB0aGF0IENTUyBkb2VzXG5cdFx0XHRcdFx0XHR0MSA9IE1hdGgudGFuKHNrZXcpO1xuXHRcdFx0XHRcdFx0dDEgPSBNYXRoLnNxcnQoMSArIHQxICogdDEpO1xuXHRcdFx0XHRcdFx0YyAqPSB0MTtcblx0XHRcdFx0XHRcdGQgKj0gdDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0LnN2Zykge1xuXHRcdFx0XHRcdFx0eCArPSB0LnhPcmlnaW4gLSAodC54T3JpZ2luICogYSArIHQueU9yaWdpbiAqIGMpO1xuXHRcdFx0XHRcdFx0eSArPSB0LnlPcmlnaW4gLSAodC54T3JpZ2luICogYiArIHQueU9yaWdpbiAqIGQpO1xuXHRcdFx0XHRcdFx0bWluID0gMC4wMDAwMDE7XG5cdFx0XHRcdFx0XHRpZiAoeCA8IG1pbikgaWYgKHggPiAtbWluKSB7XG5cdFx0XHRcdFx0XHRcdHggPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHkgPCBtaW4pIGlmICh5ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0XHR5ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bWF0cml4ID0gKCgoYSAqIHJuZCkgfCAwKSAvIHJuZCkgKyBcIixcIiArICgoKGIgKiBybmQpIHwgMCkgLyBybmQpICsgXCIsXCIgKyAoKChjICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgKCgoZCAqIHJuZCkgfCAwKSAvIHJuZCkgKyBcIixcIiArIHggKyBcIixcIiArIHkgKyBcIilcIjtcblx0XHRcdFx0XHRpZiAodC5zdmcgJiYgX3VzZVNWR1RyYW5zZm9ybUF0dHIpIHtcblx0XHRcdFx0XHRcdHRhcmcuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwibWF0cml4KFwiICsgbWF0cml4KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly9zb21lIGJyb3dzZXJzIGhhdmUgYSBoYXJkIHRpbWUgd2l0aCB2ZXJ5IHNtYWxsIHZhbHVlcyBsaWtlIDIuNDQ5MjkzNTk4Mjk0NzA2NGUtMTYgKG5vdGljZSB0aGUgXCJlLVwiIHRvd2FyZHMgdGhlIGVuZCkgYW5kIHdvdWxkIHJlbmRlciB0aGUgb2JqZWN0IHNsaWdodGx5IG9mZi4gU28gd2Ugcm91bmQgdG8gNSBkZWNpbWFsIHBsYWNlcy5cblx0XHRcdFx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9ICgodC54UGVyY2VudCB8fCB0LnlQZXJjZW50KSA/IFwidHJhbnNsYXRlKFwiICsgdC54UGVyY2VudCArIFwiJSxcIiArIHQueVBlcmNlbnQgKyBcIiUpIG1hdHJpeChcIiA6IFwibWF0cml4KFwiKSArIG1hdHJpeDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gKCh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpID8gXCJ0cmFuc2xhdGUoXCIgKyB0LnhQZXJjZW50ICsgXCIlLFwiICsgdC55UGVyY2VudCArIFwiJSkgbWF0cml4KFwiIDogXCJtYXRyaXgoXCIpICsgc3ggKyBcIiwwLDAsXCIgKyBzeSArIFwiLFwiICsgeCArIFwiLFwiICsgeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0cCA9IFRyYW5zZm9ybS5wcm90b3R5cGU7XG5cdFx0cC54ID0gcC55ID0gcC56ID0gcC5za2V3WCA9IHAuc2tld1kgPSBwLnJvdGF0aW9uID0gcC5yb3RhdGlvblggPSBwLnJvdGF0aW9uWSA9IHAuek9yaWdpbiA9IHAueFBlcmNlbnQgPSBwLnlQZXJjZW50ID0gMDtcblx0XHRwLnNjYWxlWCA9IHAuc2NhbGVZID0gcC5zY2FsZVogPSAxO1xuXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwidHJhbnNmb3JtLHNjYWxlLHNjYWxlWCxzY2FsZVksc2NhbGVaLHgseSx6LHJvdGF0aW9uLHJvdGF0aW9uWCxyb3RhdGlvblkscm90YXRpb25aLHNrZXdYLHNrZXdZLHNob3J0Um90YXRpb24sc2hvcnRSb3RhdGlvblgsc2hvcnRSb3RhdGlvblksc2hvcnRSb3RhdGlvblosdHJhbnNmb3JtT3JpZ2luLHN2Z09yaWdpbix0cmFuc2Zvcm1QZXJzcGVjdGl2ZSxkaXJlY3Rpb25hbFJvdGF0aW9uLHBhcnNlVHJhbnNmb3JtLGZvcmNlM0Qsc2tld1R5cGUseFBlcmNlbnQseVBlcmNlbnRcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKSB7XG5cdFx0XHRpZiAoY3NzcC5fbGFzdFBhcnNlZFRyYW5zZm9ybSA9PT0gdmFycykgeyByZXR1cm4gcHQ7IH0gLy9vbmx5IG5lZWQgdG8gcGFyc2UgdGhlIHRyYW5zZm9ybSBvbmNlLCBhbmQgb25seSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBpdC5cblx0XHRcdGNzc3AuX2xhc3RQYXJzZWRUcmFuc2Zvcm0gPSB2YXJzO1xuXHRcdFx0dmFyIG0xID0gY3NzcC5fdHJhbnNmb3JtID0gX2dldFRyYW5zZm9ybSh0LCBfY3MsIHRydWUsIHZhcnMucGFyc2VUcmFuc2Zvcm0pLFxuXHRcdFx0XHRzdHlsZSA9IHQuc3R5bGUsXG5cdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHRpID0gX3RyYW5zZm9ybVByb3BzLmxlbmd0aCxcblx0XHRcdFx0diA9IHZhcnMsXG5cdFx0XHRcdGVuZFJvdGF0aW9ucyA9IHt9LFxuXHRcdFx0XHRtMiwgc2tld1ksIGNvcHksIG9yaWcsIGhhczNELCBoYXNDaGFuZ2UsIGRyO1xuXHRcdFx0aWYgKHR5cGVvZih2LnRyYW5zZm9ybSkgPT09IFwic3RyaW5nXCIgJiYgX3RyYW5zZm9ybVByb3ApIHsgLy9mb3IgdmFsdWVzIGxpa2UgdHJhbnNmb3JtOlwicm90YXRlKDYwZGVnKSBzY2FsZSgwLjUsIDAuOClcIlxuXHRcdFx0XHRjb3B5ID0gX3RlbXBEaXYuc3R5bGU7IC8vZG9uJ3QgdXNlIHRoZSBvcmlnaW5hbCB0YXJnZXQgYmVjYXVzZSBpdCBtaWdodCBiZSBTVkcgaW4gd2hpY2ggY2FzZSBzb21lIGJyb3dzZXJzIGRvbid0IHJlcG9ydCBjb21wdXRlZCBzdHlsZSBjb3JyZWN0bHkuXG5cdFx0XHRcdGNvcHlbX3RyYW5zZm9ybVByb3BdID0gdi50cmFuc2Zvcm07XG5cdFx0XHRcdGNvcHkuZGlzcGxheSA9IFwiYmxvY2tcIjsgLy9pZiBkaXNwbGF5IGlzIFwibm9uZVwiLCB0aGUgYnJvd3NlciBvZnRlbiByZWZ1c2VzIHRvIHJlcG9ydCB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMgY29ycmVjdGx5LlxuXHRcdFx0XHRjb3B5LnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdFx0XHRfZG9jLmJvZHkuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0XHRtMiA9IF9nZXRUcmFuc2Zvcm0oX3RlbXBEaXYsIG51bGwsIGZhbHNlKTtcblx0XHRcdFx0X2RvYy5ib2R5LnJlbW92ZUNoaWxkKF90ZW1wRGl2KTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHYpID09PSBcIm9iamVjdFwiKSB7IC8vZm9yIHZhbHVlcyBsaWtlIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgeCwgeSwgc2tld1gsIGFuZCBza2V3WSBvciB0cmFuc2Zvcm06ey4uLn0gKG9iamVjdClcblx0XHRcdFx0bTIgPSB7c2NhbGVYOl9wYXJzZVZhbCgodi5zY2FsZVggIT0gbnVsbCkgPyB2LnNjYWxlWCA6IHYuc2NhbGUsIG0xLnNjYWxlWCksXG5cdFx0XHRcdFx0c2NhbGVZOl9wYXJzZVZhbCgodi5zY2FsZVkgIT0gbnVsbCkgPyB2LnNjYWxlWSA6IHYuc2NhbGUsIG0xLnNjYWxlWSksXG5cdFx0XHRcdFx0c2NhbGVaOl9wYXJzZVZhbCh2LnNjYWxlWiwgbTEuc2NhbGVaKSxcblx0XHRcdFx0XHR4Ol9wYXJzZVZhbCh2LngsIG0xLngpLFxuXHRcdFx0XHRcdHk6X3BhcnNlVmFsKHYueSwgbTEueSksXG5cdFx0XHRcdFx0ejpfcGFyc2VWYWwodi56LCBtMS56KSxcblx0XHRcdFx0XHR4UGVyY2VudDpfcGFyc2VWYWwodi54UGVyY2VudCwgbTEueFBlcmNlbnQpLFxuXHRcdFx0XHRcdHlQZXJjZW50Ol9wYXJzZVZhbCh2LnlQZXJjZW50LCBtMS55UGVyY2VudCksXG5cdFx0XHRcdFx0cGVyc3BlY3RpdmU6X3BhcnNlVmFsKHYudHJhbnNmb3JtUGVyc3BlY3RpdmUsIG0xLnBlcnNwZWN0aXZlKX07XG5cdFx0XHRcdGRyID0gdi5kaXJlY3Rpb25hbFJvdGF0aW9uO1xuXHRcdFx0XHRpZiAoZHIgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YoZHIpID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGNvcHkgaW4gZHIpIHtcblx0XHRcdFx0XHRcdFx0dltjb3B5XSA9IGRyW2NvcHldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2LnJvdGF0aW9uID0gZHI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2Yodi54KSA9PT0gXCJzdHJpbmdcIiAmJiB2LnguaW5kZXhPZihcIiVcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0bTIueCA9IDA7XG5cdFx0XHRcdFx0bTIueFBlcmNlbnQgPSBfcGFyc2VWYWwodi54LCBtMS54UGVyY2VudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZih2LnkpID09PSBcInN0cmluZ1wiICYmIHYueS5pbmRleE9mKFwiJVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRtMi55ID0gMDtcblx0XHRcdFx0XHRtMi55UGVyY2VudCA9IF9wYXJzZVZhbCh2LnksIG0xLnlQZXJjZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG0yLnJvdGF0aW9uID0gX3BhcnNlQW5nbGUoKFwicm90YXRpb25cIiBpbiB2KSA/IHYucm90YXRpb24gOiAoXCJzaG9ydFJvdGF0aW9uXCIgaW4gdikgPyB2LnNob3J0Um90YXRpb24gKyBcIl9zaG9ydFwiIDogKFwicm90YXRpb25aXCIgaW4gdikgPyB2LnJvdGF0aW9uWiA6IG0xLnJvdGF0aW9uLCBtMS5yb3RhdGlvbiwgXCJyb3RhdGlvblwiLCBlbmRSb3RhdGlvbnMpO1xuXHRcdFx0XHRpZiAoX3N1cHBvcnRzM0QpIHtcblx0XHRcdFx0XHRtMi5yb3RhdGlvblggPSBfcGFyc2VBbmdsZSgoXCJyb3RhdGlvblhcIiBpbiB2KSA/IHYucm90YXRpb25YIDogKFwic2hvcnRSb3RhdGlvblhcIiBpbiB2KSA/IHYuc2hvcnRSb3RhdGlvblggKyBcIl9zaG9ydFwiIDogbTEucm90YXRpb25YIHx8IDAsIG0xLnJvdGF0aW9uWCwgXCJyb3RhdGlvblhcIiwgZW5kUm90YXRpb25zKTtcblx0XHRcdFx0XHRtMi5yb3RhdGlvblkgPSBfcGFyc2VBbmdsZSgoXCJyb3RhdGlvbllcIiBpbiB2KSA/IHYucm90YXRpb25ZIDogKFwic2hvcnRSb3RhdGlvbllcIiBpbiB2KSA/IHYuc2hvcnRSb3RhdGlvblkgKyBcIl9zaG9ydFwiIDogbTEucm90YXRpb25ZIHx8IDAsIG0xLnJvdGF0aW9uWSwgXCJyb3RhdGlvbllcIiwgZW5kUm90YXRpb25zKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtMi5za2V3WCA9ICh2LnNrZXdYID09IG51bGwpID8gbTEuc2tld1ggOiBfcGFyc2VBbmdsZSh2LnNrZXdYLCBtMS5za2V3WCk7XG5cblx0XHRcdFx0Ly9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgY29tYmluZSBhbGwgc2tld2luZyBpbnRvIHRoZSBza2V3WCBhbmQgcm90YXRpb24gdmFsdWVzLCBpZ25vcmluZyBza2V3WSBidXQgd2UgbXVzdCBzdGlsbCByZWNvcmQgaXQgc28gdGhhdCB3ZSBjYW4gZGlzY2VybiBob3cgbXVjaCBvZiB0aGUgb3ZlcmFsbCBza2V3IGlzIGF0dHJpYnV0ZWQgdG8gc2tld1ggdnMuIHNrZXdZLiBPdGhlcndpc2UsIGlmIHRoZSBza2V3WSB3b3VsZCBhbHdheXMgYWN0IHJlbGF0aXZlICh0d2VlbiBza2V3WSB0byAxMGRlZywgZm9yIGV4YW1wbGUsIG11bHRpcGxlIHRpbWVzIGFuZCBpZiB3ZSBhbHdheXMgY29tYmluZSB0aGluZ3MgaW50byBza2V3WCwgd2UgY2FuJ3QgcmVtZW1iZXIgdGhhdCBza2V3WSB3YXMgMTAgZnJvbSBsYXN0IHRpbWUpLiBSZW1lbWJlciwgYSBza2V3WSBvZiAxMCBkZWdyZWVzIGxvb2tzIHRoZSBzYW1lIGFzIGEgcm90YXRpb24gb2YgMTAgZGVncmVlcyBwbHVzIGEgc2tld1ggb2YgLTEwIGRlZ3JlZXMuXG5cdFx0XHRcdG0yLnNrZXdZID0gKHYuc2tld1kgPT0gbnVsbCkgPyBtMS5za2V3WSA6IF9wYXJzZUFuZ2xlKHYuc2tld1ksIG0xLnNrZXdZKTtcblx0XHRcdFx0aWYgKChza2V3WSA9IG0yLnNrZXdZIC0gbTEuc2tld1kpKSB7XG5cdFx0XHRcdFx0bTIuc2tld1ggKz0gc2tld1k7XG5cdFx0XHRcdFx0bTIucm90YXRpb24gKz0gc2tld1k7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChfc3VwcG9ydHMzRCAmJiB2LmZvcmNlM0QgIT0gbnVsbCkge1xuXHRcdFx0XHRtMS5mb3JjZTNEID0gdi5mb3JjZTNEO1xuXHRcdFx0XHRoYXNDaGFuZ2UgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRtMS5za2V3VHlwZSA9IHYuc2tld1R5cGUgfHwgbTEuc2tld1R5cGUgfHwgQ1NTUGx1Z2luLmRlZmF1bHRTa2V3VHlwZTtcblxuXHRcdFx0aGFzM0QgPSAobTEuZm9yY2UzRCB8fCBtMS56IHx8IG0xLnJvdGF0aW9uWCB8fCBtMS5yb3RhdGlvblkgfHwgbTIueiB8fCBtMi5yb3RhdGlvblggfHwgbTIucm90YXRpb25ZIHx8IG0yLnBlcnNwZWN0aXZlKTtcblx0XHRcdGlmICghaGFzM0QgJiYgdi5zY2FsZSAhPSBudWxsKSB7XG5cdFx0XHRcdG0yLnNjYWxlWiA9IDE7IC8vbm8gbmVlZCB0byB0d2VlbiBzY2FsZVouXG5cdFx0XHR9XG5cblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRwID0gX3RyYW5zZm9ybVByb3BzW2ldO1xuXHRcdFx0XHRvcmlnID0gbTJbcF0gLSBtMVtwXTtcblx0XHRcdFx0aWYgKG9yaWcgPiBtaW4gfHwgb3JpZyA8IC1taW4gfHwgdltwXSAhPSBudWxsIHx8IF9mb3JjZVBUW3BdICE9IG51bGwpIHtcblx0XHRcdFx0XHRoYXNDaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihtMSwgcCwgbTFbcF0sIG9yaWcsIHB0KTtcblx0XHRcdFx0XHRpZiAocCBpbiBlbmRSb3RhdGlvbnMpIHtcblx0XHRcdFx0XHRcdHB0LmUgPSBlbmRSb3RhdGlvbnNbcF07IC8vZGlyZWN0aW9uYWwgcm90YXRpb25zIHR5cGljYWxseSBoYXZlIGNvbXBlbnNhdGVkIHZhbHVlcyBkdXJpbmcgdGhlIHR3ZWVuLCBidXQgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhleSBlbmQgYXQgZXhhY3RseSB3aGF0IHRoZSB1c2VyIHJlcXVlc3RlZFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdC54czAgPSAwOyAvL2Vuc3VyZXMgdGhlIHZhbHVlIHN0YXlzIG51bWVyaWMgaW4gc2V0UmF0aW8oKVxuXHRcdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHB0Lm4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG9yaWcgPSB2LnRyYW5zZm9ybU9yaWdpbjtcblx0XHRcdGlmIChtMS5zdmcgJiYgKG9yaWcgfHwgdi5zdmdPcmlnaW4pKSB7XG5cdFx0XHRcdF9wYXJzZVNWR09yaWdpbih0LCBfcGFyc2VQb3NpdGlvbihvcmlnKSwgbTIsIHYuc3ZnT3JpZ2luKTtcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKG0xLCBcInhPcmlnaW5cIiwgbTEueE9yaWdpbiwgbTIueE9yaWdpbiAtIG0xLnhPcmlnaW4sIHB0LCAtMSwgXCJ0cmFuc2Zvcm1PcmlnaW5cIik7XG5cdFx0XHRcdHB0LmIgPSBtMS54T3JpZ2luO1xuXHRcdFx0XHRwdC5lID0gcHQueHMwID0gbTIueE9yaWdpbjtcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKG0xLCBcInlPcmlnaW5cIiwgbTEueU9yaWdpbiwgbTIueU9yaWdpbiAtIG0xLnlPcmlnaW4sIHB0LCAtMSwgXCJ0cmFuc2Zvcm1PcmlnaW5cIik7XG5cdFx0XHRcdHB0LmIgPSBtMS55T3JpZ2luO1xuXHRcdFx0XHRwdC5lID0gcHQueHMwID0gbTIueU9yaWdpbjtcblx0XHRcdFx0b3JpZyA9IF91c2VTVkdUcmFuc2Zvcm1BdHRyID8gbnVsbCA6IFwiMHB4IDBweFwiOyAvL2NlcnRhaW4gYnJvd3NlcnMgKGxpa2UgZmlyZWZveCkgY29tcGxldGVseSBib3RjaCB0cmFuc2Zvcm0tb3JpZ2luLCBzbyB3ZSBtdXN0IHJlbW92ZSBpdCB0byBwcmV2ZW50IGl0IGZyb20gY29udGFtaW5hdGluZyB0cmFuc2Zvcm1zLiBXZSBtYW5hZ2UgaXQgb3Vyc2VsdmVzIHdpdGggeE9yaWdpbiBhbmQgeU9yaWdpblxuXHRcdFx0fVxuXHRcdFx0aWYgKG9yaWcgfHwgKF9zdXBwb3J0czNEICYmIGhhczNEICYmIG0xLnpPcmlnaW4pKSB7IC8vaWYgYW55dGhpbmcgM0QgaXMgaGFwcGVuaW5nIGFuZCB0aGVyZSdzIGEgdHJhbnNmb3JtT3JpZ2luIHdpdGggYSB6IGNvbXBvbmVudCB0aGF0J3Mgbm9uLXplcm8sIHdlIG11c3QgZW5zdXJlIHRoYXQgdGhlIHRyYW5zZm9ybU9yaWdpbidzIHotY29tcG9uZW50IGlzIHNldCB0byAwIHNvIHRoYXQgd2UgY2FuIG1hbnVhbGx5IGRvIHRob3NlIGNhbGN1bGF0aW9ucyB0byBnZXQgYXJvdW5kIFNhZmFyaSBidWdzLiBFdmVuIGlmIHRoZSB1c2VyIGRpZG4ndCBzcGVjaWZpY2FsbHkgZGVmaW5lIGEgXCJ0cmFuc2Zvcm1PcmlnaW5cIiBpbiB0aGlzIHBhcnRpY3VsYXIgdHdlZW4gKG1heWJlIHRoZXkgZGlkIGl0IHZpYSBjc3MgZGlyZWN0bHkpLlxuXHRcdFx0XHRpZiAoX3RyYW5zZm9ybVByb3ApIHtcblx0XHRcdFx0XHRoYXNDaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHRcdHAgPSBfdHJhbnNmb3JtT3JpZ2luUHJvcDtcblx0XHRcdFx0XHRvcmlnID0gKG9yaWcgfHwgX2dldFN0eWxlKHQsIHAsIF9jcywgZmFsc2UsIFwiNTAlIDUwJVwiKSkgKyBcIlwiOyAvL2Nhc3QgYXMgc3RyaW5nIHRvIGF2b2lkIGVycm9yc1xuXHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgcCwgMCwgMCwgcHQsIC0xLCBcInRyYW5zZm9ybU9yaWdpblwiKTtcblx0XHRcdFx0XHRwdC5iID0gc3R5bGVbcF07XG5cdFx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdFx0Y29weSA9IG0xLnpPcmlnaW47XG5cdFx0XHRcdFx0XHRvcmlnID0gb3JpZy5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0XHRtMS56T3JpZ2luID0gKChvcmlnLmxlbmd0aCA+IDIgJiYgIShjb3B5ICE9PSAwICYmIG9yaWdbMl0gPT09IFwiMHB4XCIpKSA/IHBhcnNlRmxvYXQob3JpZ1syXSkgOiBjb3B5KSB8fCAwOyAvL1NhZmFyaSBkb2Vzbid0IGhhbmRsZSB0aGUgeiBwYXJ0IG9mIHRyYW5zZm9ybU9yaWdpbiBjb3JyZWN0bHksIHNvIHdlJ2xsIG1hbnVhbGx5IGhhbmRsZSBpdCBpbiB0aGUgX3NldDNEVHJhbnNmb3JtUmF0aW8oKSBtZXRob2QuXG5cdFx0XHRcdFx0XHRwdC54czAgPSBwdC5lID0gb3JpZ1swXSArIFwiIFwiICsgKG9yaWdbMV0gfHwgXCI1MCVcIikgKyBcIiAwcHhcIjsgLy93ZSBtdXN0IGRlZmluZSBhIHogdmFsdWUgb2YgMHB4IHNwZWNpZmljYWxseSBvdGhlcndpc2UgaU9TIDUgU2FmYXJpIHdpbGwgc3RpY2sgd2l0aCB0aGUgb2xkIG9uZSAoaWYgb25lIHdhcyBkZWZpbmVkKSFcblx0XHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihtMSwgXCJ6T3JpZ2luXCIsIDAsIDAsIHB0LCAtMSwgcHQubik7IC8vd2UgbXVzdCBjcmVhdGUgYSBDU1NQcm9wVHdlZW4gZm9yIHRoZSBfZ3NUcmFuc2Zvcm0uek9yaWdpbiBzbyB0aGF0IGl0IGdldHMgcmVzZXQgcHJvcGVybHkgYXQgdGhlIGJlZ2lubmluZyBpZiB0aGUgdHdlZW4gcnVucyBiYWNrd2FyZCAoYXMgb3Bwb3NlZCB0byBqdXN0IHNldHRpbmcgbTEuek9yaWdpbiBoZXJlKVxuXHRcdFx0XHRcdFx0cHQuYiA9IGNvcHk7XG5cdFx0XHRcdFx0XHRwdC54czAgPSBwdC5lID0gbTEuek9yaWdpbjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQueHMwID0gcHQuZSA9IG9yaWc7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vZm9yIG9sZGVyIHZlcnNpb25zIG9mIElFICg2LTgpLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IGNhbGN1bGF0ZSB0aGluZ3MgaW5zaWRlIHRoZSBzZXRSYXRpbygpIGZ1bmN0aW9uLiBXZSByZWNvcmQgb3JpZ2luIHggYW5kIHkgKG94IGFuZCBveSkgYW5kIHdoZXRoZXIgb3Igbm90IHRoZSB2YWx1ZXMgYXJlIHBlcmNlbnRhZ2VzIChveHAgYW5kIG95cCkuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X3BhcnNlUG9zaXRpb24ob3JpZyArIFwiXCIsIG0xKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc0NoYW5nZSkge1xuXHRcdFx0XHRjc3NwLl90cmFuc2Zvcm1UeXBlID0gKCEobTEuc3ZnICYmIF91c2VTVkdUcmFuc2Zvcm1BdHRyKSAmJiAoaGFzM0QgfHwgdGhpcy5fdHJhbnNmb3JtVHlwZSA9PT0gMykpID8gMyA6IDI7IC8vcXVpY2tlciB0aGFuIGNhbGxpbmcgY3NzcC5fZW5hYmxlVHJhbnNmb3JtcygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH0sIHByZWZpeDp0cnVlfSk7XG5cblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJib3hTaGFkb3dcIiwge2RlZmF1bHRWYWx1ZTpcIjBweCAwcHggMHB4IDBweCAjOTk5XCIsIHByZWZpeDp0cnVlLCBjb2xvcjp0cnVlLCBtdWx0aTp0cnVlLCBrZXl3b3JkOlwiaW5zZXRcIn0pO1xuXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm9yZGVyUmFkaXVzXCIsIHtkZWZhdWx0VmFsdWU6XCIwcHhcIiwgcGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdGUgPSB0aGlzLmZvcm1hdChlKTtcblx0XHRcdHZhciBwcm9wcyA9IFtcImJvcmRlclRvcExlZnRSYWRpdXNcIixcImJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsXCJib3JkZXJCb3R0b21SaWdodFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiXSxcblx0XHRcdFx0c3R5bGUgPSB0LnN0eWxlLFxuXHRcdFx0XHRlYTEsIGksIGVzMiwgYnMyLCBicywgZXMsIGJuLCBlbiwgdywgaCwgZXNmeCwgYnNmeCwgcmVsLCBobiwgdm4sIGVtO1xuXHRcdFx0dyA9IHBhcnNlRmxvYXQodC5vZmZzZXRXaWR0aCk7XG5cdFx0XHRoID0gcGFyc2VGbG9hdCh0Lm9mZnNldEhlaWdodCk7XG5cdFx0XHRlYTEgPSBlLnNwbGl0KFwiIFwiKTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyAvL2lmIHdlJ3JlIGRlYWxpbmcgd2l0aCBwZXJjZW50YWdlcywgd2UgbXVzdCBjb252ZXJ0IHRoaW5ncyBzZXBhcmF0ZWx5IGZvciB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgYXhpcyFcblx0XHRcdFx0aWYgKHRoaXMucC5pbmRleE9mKFwiYm9yZGVyXCIpKSB7IC8vb2xkZXIgYnJvd3NlcnMgdXNlZCBhIHByZWZpeFxuXHRcdFx0XHRcdHByb3BzW2ldID0gX2NoZWNrUHJvcFByZWZpeChwcm9wc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnMgPSBiczIgPSBfZ2V0U3R5bGUodCwgcHJvcHNbaV0sIF9jcywgZmFsc2UsIFwiMHB4XCIpO1xuXHRcdFx0XHRpZiAoYnMuaW5kZXhPZihcIiBcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0YnMyID0gYnMuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdGJzID0gYnMyWzBdO1xuXHRcdFx0XHRcdGJzMiA9IGJzMlsxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlcyA9IGVzMiA9IGVhMVtpXTtcblx0XHRcdFx0Ym4gPSBwYXJzZUZsb2F0KGJzKTtcblx0XHRcdFx0YnNmeCA9IGJzLnN1YnN0cigoYm4gKyBcIlwiKS5sZW5ndGgpO1xuXHRcdFx0XHRyZWwgPSAoZXMuY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdGlmIChyZWwpIHtcblx0XHRcdFx0XHRlbiA9IHBhcnNlSW50KGVzLmNoYXJBdCgwKStcIjFcIiwgMTApO1xuXHRcdFx0XHRcdGVzID0gZXMuc3Vic3RyKDIpO1xuXHRcdFx0XHRcdGVuICo9IHBhcnNlRmxvYXQoZXMpO1xuXHRcdFx0XHRcdGVzZnggPSBlcy5zdWJzdHIoKGVuICsgXCJcIikubGVuZ3RoIC0gKGVuIDwgMCA/IDEgOiAwKSkgfHwgXCJcIjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbiA9IHBhcnNlRmxvYXQoZXMpO1xuXHRcdFx0XHRcdGVzZnggPSBlcy5zdWJzdHIoKGVuICsgXCJcIikubGVuZ3RoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZXNmeCA9PT0gXCJcIikge1xuXHRcdFx0XHRcdGVzZnggPSBfc3VmZml4TWFwW3BdIHx8IGJzZng7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVzZnggIT09IGJzZngpIHtcblx0XHRcdFx0XHRobiA9IF9jb252ZXJ0VG9QaXhlbHModCwgXCJib3JkZXJMZWZ0XCIsIGJuLCBic2Z4KTsgLy9ob3Jpem9udGFsIG51bWJlciAod2UgdXNlIGEgYm9ndXMgXCJib3JkZXJMZWZ0XCIgcHJvcGVydHkganVzdCBiZWNhdXNlIHRoZSBfY29udmVydFRvUGl4ZWxzKCkgbWV0aG9kIHNlYXJjaGVzIGZvciB0aGUga2V5d29yZHMgXCJMZWZ0XCIsIFwiUmlnaHRcIiwgXCJUb3BcIiwgYW5kIFwiQm90dG9tXCIgdG8gZGV0ZXJtaW5lIG9mIGl0J3MgYSBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnR5LCBhbmQgd2UgbmVlZCBcImJvcmRlclwiIGluIHRoZSBuYW1lIHNvIHRoYXQgaXQga25vd3MgaXQgc2hvdWxkIG1lYXN1cmUgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQgaXRzZWxmLCBub3QgaXRzIHBhcmVudC5cblx0XHRcdFx0XHR2biA9IF9jb252ZXJ0VG9QaXhlbHModCwgXCJib3JkZXJUb3BcIiwgYm4sIGJzZngpOyAvL3ZlcnRpY2FsIG51bWJlclxuXHRcdFx0XHRcdGlmIChlc2Z4ID09PSBcIiVcIikge1xuXHRcdFx0XHRcdFx0YnMgPSAoaG4gLyB3ICogMTAwKSArIFwiJVwiO1xuXHRcdFx0XHRcdFx0YnMyID0gKHZuIC8gaCAqIDEwMCkgKyBcIiVcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGVzZnggPT09IFwiZW1cIikge1xuXHRcdFx0XHRcdFx0ZW0gPSBfY29udmVydFRvUGl4ZWxzKHQsIFwiYm9yZGVyTGVmdFwiLCAxLCBcImVtXCIpO1xuXHRcdFx0XHRcdFx0YnMgPSAoaG4gLyBlbSkgKyBcImVtXCI7XG5cdFx0XHRcdFx0XHRiczIgPSAodm4gLyBlbSkgKyBcImVtXCI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJzID0gaG4gKyBcInB4XCI7XG5cdFx0XHRcdFx0XHRiczIgPSB2biArIFwicHhcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHJlbCkge1xuXHRcdFx0XHRcdFx0ZXMgPSAocGFyc2VGbG9hdChicykgKyBlbikgKyBlc2Z4O1xuXHRcdFx0XHRcdFx0ZXMyID0gKHBhcnNlRmxvYXQoYnMyKSArIGVuKSArIGVzZng7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gX3BhcnNlQ29tcGxleChzdHlsZSwgcHJvcHNbaV0sIGJzICsgXCIgXCIgKyBiczIsIGVzICsgXCIgXCIgKyBlczIsIGZhbHNlLCBcIjBweFwiLCBwdCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fSwgcHJlZml4OnRydWUsIGZvcm1hdHRlcjpfZ2V0Rm9ybWF0dGVyKFwiMHB4IDBweCAwcHggMHB4XCIsIGZhbHNlLCB0cnVlKX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJhY2tncm91bmRQb3NpdGlvblwiLCB7ZGVmYXVsdFZhbHVlOlwiMCAwXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgYnAgPSBcImJhY2tncm91bmQtcG9zaXRpb25cIixcblx0XHRcdFx0Y3MgPSAoX2NzIHx8IF9nZXRDb21wdXRlZFN0eWxlKHQsIG51bGwpKSxcblx0XHRcdFx0YnMgPSB0aGlzLmZvcm1hdCggKChjcykgPyBfaWVWZXJzID8gY3MuZ2V0UHJvcGVydHlWYWx1ZShicCArIFwiLXhcIikgKyBcIiBcIiArIGNzLmdldFByb3BlcnR5VmFsdWUoYnAgKyBcIi15XCIpIDogY3MuZ2V0UHJvcGVydHlWYWx1ZShicCkgOiB0LmN1cnJlbnRTdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb25YICsgXCIgXCIgKyB0LmN1cnJlbnRTdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb25ZKSB8fCBcIjAgMFwiKSwgLy9JbnRlcm5ldCBFeHBsb3JlciBkb2Vzbid0IHJlcG9ydCBiYWNrZ3JvdW5kLXBvc2l0aW9uIGNvcnJlY3RseSAtIHdlIG11c3QgcXVlcnkgYmFja2dyb3VuZC1wb3NpdGlvbi14IGFuZCBiYWNrZ3JvdW5kLXBvc2l0aW9uLXkgYW5kIGNvbWJpbmUgdGhlbSAoZXZlbiBpbiBJRTEwKS4gQmVmb3JlIElFOSwgd2UgbXVzdCBkbyB0aGUgc2FtZSB3aXRoIHRoZSBjdXJyZW50U3R5bGUgb2JqZWN0IGFuZCB1c2UgY2FtZWxDYXNlXG5cdFx0XHRcdGVzID0gdGhpcy5mb3JtYXQoZSksXG5cdFx0XHRcdGJhLCBlYSwgaSwgcGN0LCBvdmVybGFwLCBzcmM7XG5cdFx0XHRpZiAoKGJzLmluZGV4T2YoXCIlXCIpICE9PSAtMSkgIT09IChlcy5pbmRleE9mKFwiJVwiKSAhPT0gLTEpKSB7XG5cdFx0XHRcdHNyYyA9IF9nZXRTdHlsZSh0LCBcImJhY2tncm91bmRJbWFnZVwiKS5yZXBsYWNlKF91cmxFeHAsIFwiXCIpO1xuXHRcdFx0XHRpZiAoc3JjICYmIHNyYyAhPT0gXCJub25lXCIpIHtcblx0XHRcdFx0XHRiYSA9IGJzLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRlYSA9IGVzLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRfdGVtcEltZy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgc3JjKTsgLy9zZXQgdGhlIHRlbXAgSU1HJ3Mgc3JjIHRvIHRoZSBiYWNrZ3JvdW5kLWltYWdlIHNvIHRoYXQgd2UgY2FuIG1lYXN1cmUgaXRzIHdpZHRoL2hlaWdodFxuXHRcdFx0XHRcdGkgPSAyO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0YnMgPSBiYVtpXTtcblx0XHRcdFx0XHRcdHBjdCA9IChicy5pbmRleE9mKFwiJVwiKSAhPT0gLTEpO1xuXHRcdFx0XHRcdFx0aWYgKHBjdCAhPT0gKGVhW2ldLmluZGV4T2YoXCIlXCIpICE9PSAtMSkpIHtcblx0XHRcdFx0XHRcdFx0b3ZlcmxhcCA9IChpID09PSAwKSA/IHQub2Zmc2V0V2lkdGggLSBfdGVtcEltZy53aWR0aCA6IHQub2Zmc2V0SGVpZ2h0IC0gX3RlbXBJbWcuaGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHRiYVtpXSA9IHBjdCA/IChwYXJzZUZsb2F0KGJzKSAvIDEwMCAqIG92ZXJsYXApICsgXCJweFwiIDogKHBhcnNlRmxvYXQoYnMpIC8gb3ZlcmxhcCAqIDEwMCkgKyBcIiVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnMgPSBiYS5qb2luKFwiIFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsIGJzLCBlcywgcHQsIHBsdWdpbik7XG5cdFx0fSwgZm9ybWF0dGVyOl9wYXJzZVBvc2l0aW9ufSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmFja2dyb3VuZFNpemVcIiwge2RlZmF1bHRWYWx1ZTpcIjAgMFwiLCBmb3JtYXR0ZXI6X3BhcnNlUG9zaXRpb259KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJwZXJzcGVjdGl2ZVwiLCB7ZGVmYXVsdFZhbHVlOlwiMHB4XCIsIHByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwicGVyc3BlY3RpdmVPcmlnaW5cIiwge2RlZmF1bHRWYWx1ZTpcIjUwJSA1MCVcIiwgcHJlZml4OnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJ0cmFuc2Zvcm1TdHlsZVwiLCB7cHJlZml4OnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJiYWNrZmFjZVZpc2liaWxpdHlcIiwge3ByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwidXNlclNlbGVjdFwiLCB7cHJlZml4OnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJtYXJnaW5cIiwge3BhcnNlcjpfZ2V0RWRnZVBhcnNlcihcIm1hcmdpblRvcCxtYXJnaW5SaWdodCxtYXJnaW5Cb3R0b20sbWFyZ2luTGVmdFwiKX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInBhZGRpbmdcIiwge3BhcnNlcjpfZ2V0RWRnZVBhcnNlcihcInBhZGRpbmdUb3AscGFkZGluZ1JpZ2h0LHBhZGRpbmdCb3R0b20scGFkZGluZ0xlZnRcIil9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJjbGlwXCIsIHtkZWZhdWx0VmFsdWU6XCJyZWN0KDBweCwwcHgsMHB4LDBweClcIiwgcGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pe1xuXHRcdFx0dmFyIGIsIGNzLCBkZWxpbTtcblx0XHRcdGlmIChfaWVWZXJzIDwgOSkgeyAvL0lFOCBhbmQgZWFybGllciBkb24ndCByZXBvcnQgYSBcImNsaXBcIiB2YWx1ZSBpbiB0aGUgY3VycmVudFN0eWxlIC0gaW5zdGVhZCwgdGhlIHZhbHVlcyBhcmUgc3BsaXQgYXBhcnQgaW50byBjbGlwVG9wLCBjbGlwUmlnaHQsIGNsaXBCb3R0b20sIGFuZCBjbGlwTGVmdC4gQWxzbywgaW4gSUU3IGFuZCBlYXJsaWVyLCB0aGUgdmFsdWVzIGluc2lkZSByZWN0KCkgYXJlIHNwYWNlLWRlbGltaXRlZCwgbm90IGNvbW1hLWRlbGltaXRlZC5cblx0XHRcdFx0Y3MgPSB0LmN1cnJlbnRTdHlsZTtcblx0XHRcdFx0ZGVsaW0gPSBfaWVWZXJzIDwgOCA/IFwiIFwiIDogXCIsXCI7XG5cdFx0XHRcdGIgPSBcInJlY3QoXCIgKyBjcy5jbGlwVG9wICsgZGVsaW0gKyBjcy5jbGlwUmlnaHQgKyBkZWxpbSArIGNzLmNsaXBCb3R0b20gKyBkZWxpbSArIGNzLmNsaXBMZWZ0ICsgXCIpXCI7XG5cdFx0XHRcdGUgPSB0aGlzLmZvcm1hdChlKS5zcGxpdChcIixcIikuam9pbihkZWxpbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRiID0gdGhpcy5mb3JtYXQoX2dldFN0eWxlKHQsIHRoaXMucCwgX2NzLCBmYWxzZSwgdGhpcy5kZmx0KSk7XG5cdFx0XHRcdGUgPSB0aGlzLmZvcm1hdChlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnBhcnNlQ29tcGxleCh0LnN0eWxlLCBiLCBlLCBwdCwgcGx1Z2luKTtcblx0XHR9fSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwidGV4dFNoYWRvd1wiLCB7ZGVmYXVsdFZhbHVlOlwiMHB4IDBweCAwcHggIzk5OVwiLCBjb2xvcjp0cnVlLCBtdWx0aTp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYXV0b1JvdW5kLHN0cmljdFVuaXRzXCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQpIHtyZXR1cm4gcHQ7fX0pOyAvL2p1c3Qgc28gdGhhdCB3ZSBjYW4gaWdub3JlIHRoZXNlIHByb3BlcnRpZXMgKG5vdCB0d2VlbiB0aGVtKVxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJvcmRlclwiLCB7ZGVmYXVsdFZhbHVlOlwiMHB4IHNvbGlkICMwMDBcIiwgcGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsIHRoaXMuZm9ybWF0KF9nZXRTdHlsZSh0LCBcImJvcmRlclRvcFdpZHRoXCIsIF9jcywgZmFsc2UsIFwiMHB4XCIpICsgXCIgXCIgKyBfZ2V0U3R5bGUodCwgXCJib3JkZXJUb3BTdHlsZVwiLCBfY3MsIGZhbHNlLCBcInNvbGlkXCIpICsgXCIgXCIgKyBfZ2V0U3R5bGUodCwgXCJib3JkZXJUb3BDb2xvclwiLCBfY3MsIGZhbHNlLCBcIiMwMDBcIikpLCB0aGlzLmZvcm1hdChlKSwgcHQsIHBsdWdpbik7XG5cdFx0XHR9LCBjb2xvcjp0cnVlLCBmb3JtYXR0ZXI6ZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgYSA9IHYuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRyZXR1cm4gYVswXSArIFwiIFwiICsgKGFbMV0gfHwgXCJzb2xpZFwiKSArIFwiIFwiICsgKHYubWF0Y2goX2NvbG9yRXhwKSB8fCBbXCIjMDAwXCJdKVswXTtcblx0XHRcdH19KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJib3JkZXJXaWR0aFwiLCB7cGFyc2VyOl9nZXRFZGdlUGFyc2VyKFwiYm9yZGVyVG9wV2lkdGgsYm9yZGVyUmlnaHRXaWR0aCxib3JkZXJCb3R0b21XaWR0aCxib3JkZXJMZWZ0V2lkdGhcIil9KTsgLy9GaXJlZm94IGRvZXNuJ3QgcGljayB1cCBvbiBib3JkZXJXaWR0aCBzZXQgaW4gc3R5bGUgc2hlZXRzIChvbmx5IGlubGluZSkuXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiZmxvYXQsY3NzRmxvYXQsc3R5bGVGbG9hdFwiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdHZhciBzID0gdC5zdHlsZSxcblx0XHRcdFx0cHJvcCA9IChcImNzc0Zsb2F0XCIgaW4gcykgPyBcImNzc0Zsb2F0XCIgOiBcInN0eWxlRmxvYXRcIjtcblx0XHRcdHJldHVybiBuZXcgQ1NTUHJvcFR3ZWVuKHMsIHByb3AsIDAsIDAsIHB0LCAtMSwgcCwgZmFsc2UsIDAsIHNbcHJvcF0sIGUpO1xuXHRcdH19KTtcblxuXHRcdC8vb3BhY2l0eS1yZWxhdGVkXG5cdFx0dmFyIF9zZXRJRU9wYWNpdHlSYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dmFyIHQgPSB0aGlzLnQsIC8vcmVmZXJzIHRvIHRoZSBlbGVtZW50J3Mgc3R5bGUgcHJvcGVydHlcblx0XHRcdFx0XHRmaWx0ZXJzID0gdC5maWx0ZXIgfHwgX2dldFN0eWxlKHRoaXMuZGF0YSwgXCJmaWx0ZXJcIikgfHwgXCJcIixcblx0XHRcdFx0XHR2YWwgPSAodGhpcy5zICsgdGhpcy5jICogdikgfCAwLFxuXHRcdFx0XHRcdHNraXA7XG5cdFx0XHRcdGlmICh2YWwgPT09IDEwMCkgeyAvL2ZvciBvbGRlciB2ZXJzaW9ucyBvZiBJRSB0aGF0IG5lZWQgdG8gdXNlIGEgZmlsdGVyIHRvIGFwcGx5IG9wYWNpdHksIHdlIHNob3VsZCByZW1vdmUgdGhlIGZpbHRlciBpZiBvcGFjaXR5IGhpdHMgMSBpbiBvcmRlciB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLCBidXQgbWFrZSBzdXJlIHRoZXJlIGlzbid0IGEgdHJhbnNmb3JtIChtYXRyaXgpIG9yIGdyYWRpZW50IGluIHRoZSBmaWx0ZXJzLlxuXHRcdFx0XHRcdGlmIChmaWx0ZXJzLmluZGV4T2YoXCJhdHJpeChcIikgPT09IC0xICYmIGZpbHRlcnMuaW5kZXhPZihcInJhZGllbnQoXCIpID09PSAtMSAmJiBmaWx0ZXJzLmluZGV4T2YoXCJvYWRlcihcIikgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHR0LnJlbW92ZUF0dHJpYnV0ZShcImZpbHRlclwiKTtcblx0XHRcdFx0XHRcdHNraXAgPSAoIV9nZXRTdHlsZSh0aGlzLmRhdGEsIFwiZmlsdGVyXCIpKTsgLy9pZiBhIGNsYXNzIGlzIGFwcGxpZWQgdGhhdCBoYXMgYW4gYWxwaGEgZmlsdGVyLCBpdCB3aWxsIHRha2UgZWZmZWN0ICh3ZSBkb24ndCB3YW50IHRoYXQpLCBzbyByZS1hcHBseSBvdXIgYWxwaGEgZmlsdGVyIGluIHRoYXQgY2FzZS4gV2UgbXVzdCBmaXJzdCByZW1vdmUgaXQgYW5kIHRoZW4gY2hlY2suXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHQuZmlsdGVyID0gZmlsdGVycy5yZXBsYWNlKF9hbHBoYUZpbHRlckV4cCwgXCJcIik7XG5cdFx0XHRcdFx0XHRza2lwID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFza2lwKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMueG4xKSB7XG5cdFx0XHRcdFx0XHR0LmZpbHRlciA9IGZpbHRlcnMgPSBmaWx0ZXJzIHx8IChcImFscGhhKG9wYWNpdHk9XCIgKyB2YWwgKyBcIilcIik7IC8vd29ya3MgYXJvdW5kIGJ1ZyBpbiBJRTcvOCB0aGF0IHByZXZlbnRzIGNoYW5nZXMgdG8gXCJ2aXNpYmlsaXR5XCIgZnJvbSBiZWluZyBhcHBsaWVkIHByb3Blcmx5IGlmIHRoZSBmaWx0ZXIgaXMgY2hhbmdlZCB0byBhIGRpZmZlcmVudCBhbHBoYSBvbiB0aGUgc2FtZSBmcmFtZS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGZpbHRlcnMuaW5kZXhPZihcInBhY2l0eVwiKSA9PT0gLTEpIHsgLy9vbmx5IHVzZWQgaWYgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIHN0YW5kYXJkIG9wYWNpdHkgc3R5bGUgcHJvcGVydHkgKElFIDcgYW5kIDgpLiBXZSBvbWl0IHRoZSBcIk9cIiB0byBhdm9pZCBjYXNlLXNlbnNpdGl2aXR5IGlzc3Vlc1xuXHRcdFx0XHRcdFx0aWYgKHZhbCAhPT0gMCB8fCAhdGhpcy54bjEpIHsgLy9idWdzIGluIElFNy84IHdvbid0IHJlbmRlciB0aGUgZmlsdGVyIHByb3Blcmx5IGlmIG9wYWNpdHkgaXMgQURERUQgb24gdGhlIHNhbWUgZnJhbWUvcmVuZGVyIGFzIFwidmlzaWJpbGl0eVwiIGNoYW5nZXMgKHRoaXMueG4xIGlzIDEgaWYgdGhpcyB0d2VlbiBpcyBhbiBcImF1dG9BbHBoYVwiIHR3ZWVuKVxuXHRcdFx0XHRcdFx0XHR0LmZpbHRlciA9IGZpbHRlcnMgKyBcIiBhbHBoYShvcGFjaXR5PVwiICsgdmFsICsgXCIpXCI7IC8vd2Ugcm91bmQgdGhlIHZhbHVlIGJlY2F1c2Ugb3RoZXJ3aXNlLCBidWdzIGluIElFNy84IGNhbiBwcmV2ZW50IFwidmlzaWJpbGl0eVwiIGNoYW5nZXMgZnJvbSBiZWluZyBhcHBsaWVkIHByb3Blcmx5LlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0LmZpbHRlciA9IGZpbHRlcnMucmVwbGFjZShfb3BhY2l0eUV4cCwgXCJvcGFjaXR5PVwiICsgdmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwib3BhY2l0eSxhbHBoYSxhdXRvQWxwaGFcIiwge2RlZmF1bHRWYWx1ZTpcIjFcIiwgcGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdHZhciBiID0gcGFyc2VGbG9hdChfZ2V0U3R5bGUodCwgXCJvcGFjaXR5XCIsIF9jcywgZmFsc2UsIFwiMVwiKSksXG5cdFx0XHRcdHN0eWxlID0gdC5zdHlsZSxcblx0XHRcdFx0aXNBdXRvQWxwaGEgPSAocCA9PT0gXCJhdXRvQWxwaGFcIik7XG5cdFx0XHRpZiAodHlwZW9mKGUpID09PSBcInN0cmluZ1wiICYmIGUuY2hhckF0KDEpID09PSBcIj1cIikge1xuXHRcdFx0XHRlID0gKChlLmNoYXJBdCgwKSA9PT0gXCItXCIpID8gLTEgOiAxKSAqIHBhcnNlRmxvYXQoZS5zdWJzdHIoMikpICsgYjtcblx0XHRcdH1cblx0XHRcdGlmIChpc0F1dG9BbHBoYSAmJiBiID09PSAxICYmIF9nZXRTdHlsZSh0LCBcInZpc2liaWxpdHlcIiwgX2NzKSA9PT0gXCJoaWRkZW5cIiAmJiBlICE9PSAwKSB7IC8vaWYgdmlzaWJpbGl0eSBpcyBpbml0aWFsbHkgc2V0IHRvIFwiaGlkZGVuXCIsIHdlIHNob3VsZCBpbnRlcnByZXQgdGhhdCBhcyBpbnRlbnQgdG8gbWFrZSBvcGFjaXR5IDAgKGEgY29udmVuaWVuY2UpXG5cdFx0XHRcdGIgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9zdXBwb3J0c09wYWNpdHkpIHtcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBcIm9wYWNpdHlcIiwgYiwgZSAtIGIsIHB0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgXCJvcGFjaXR5XCIsIGIgKiAxMDAsIChlIC0gYikgKiAxMDAsIHB0KTtcblx0XHRcdFx0cHQueG4xID0gaXNBdXRvQWxwaGEgPyAxIDogMDsgLy93ZSBuZWVkIHRvIHJlY29yZCB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIGFuIGF1dG9BbHBoYSBzbyB0aGF0IGluIHRoZSBzZXRSYXRpbygpLCB3ZSBrbm93IHRvIGR1cGxpY2F0ZSB0aGUgc2V0dGluZyBvZiB0aGUgYWxwaGEgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgYSBidWcgaW4gSUU3IGFuZCBJRTggdGhhdCBwcmV2ZW50cyBjaGFuZ2VzIHRvIFwidmlzaWJpbGl0eVwiIGZyb20gdGFraW5nIGVmZmVjdCBpZiB0aGUgZmlsdGVyIGlzIGNoYW5nZWQgdG8gYSBkaWZmZXJlbnQgYWxwaGEob3BhY2l0eSkgYXQgdGhlIHNhbWUgdGltZS4gU2V0dGluZyBpdCB0byB0aGUgU0FNRSB2YWx1ZSBmaXJzdCwgdGhlbiB0aGUgbmV3IHZhbHVlIHdvcmtzIGFyb3VuZCB0aGUgSUU3LzggYnVnLlxuXHRcdFx0XHRzdHlsZS56b29tID0gMTsgLy9oZWxwcyBjb3JyZWN0IGFuIElFIGlzc3VlLlxuXHRcdFx0XHRwdC50eXBlID0gMjtcblx0XHRcdFx0cHQuYiA9IFwiYWxwaGEob3BhY2l0eT1cIiArIHB0LnMgKyBcIilcIjtcblx0XHRcdFx0cHQuZSA9IFwiYWxwaGEob3BhY2l0eT1cIiArIChwdC5zICsgcHQuYykgKyBcIilcIjtcblx0XHRcdFx0cHQuZGF0YSA9IHQ7XG5cdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0cHQuc2V0UmF0aW8gPSBfc2V0SUVPcGFjaXR5UmF0aW87XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNBdXRvQWxwaGEpIHsgLy93ZSBoYXZlIHRvIGNyZWF0ZSB0aGUgXCJ2aXNpYmlsaXR5XCIgUHJvcFR3ZWVuIGFmdGVyIHRoZSBvcGFjaXR5IG9uZSBpbiB0aGUgbGlua2VkIGxpc3Qgc28gdGhhdCB0aGV5IHJ1biBpbiB0aGUgb3JkZXIgdGhhdCB3b3JrcyBwcm9wZXJseSBpbiBJRTggYW5kIGVhcmxpZXJcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBcInZpc2liaWxpdHlcIiwgMCwgMCwgcHQsIC0xLCBudWxsLCBmYWxzZSwgMCwgKChiICE9PSAwKSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiksICgoZSA9PT0gMCkgPyBcImhpZGRlblwiIDogXCJpbmhlcml0XCIpKTtcblx0XHRcdFx0cHQueHMwID0gXCJpbmhlcml0XCI7XG5cdFx0XHRcdGNzc3AuX292ZXJ3cml0ZVByb3BzLnB1c2gocHQubik7XG5cdFx0XHRcdGNzc3AuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fX0pO1xuXG5cblx0XHR2YXIgX3JlbW92ZVByb3AgPSBmdW5jdGlvbihzLCBwKSB7XG5cdFx0XHRcdGlmIChwKSB7XG5cdFx0XHRcdFx0aWYgKHMucmVtb3ZlUHJvcGVydHkpIHtcblx0XHRcdFx0XHRcdGlmIChwLnN1YnN0cigwLDIpID09PSBcIm1zXCIgfHwgcC5zdWJzdHIoMCw2KSA9PT0gXCJ3ZWJraXRcIikgeyAvL01pY3Jvc29mdCBhbmQgc29tZSBXZWJraXQgYnJvd3NlcnMgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3RhbmRhcmQgb2YgY2FwaXRhbGl6aW5nIHRoZSBmaXJzdCBwcmVmaXggY2hhcmFjdGVyLCBzbyB3ZSBhZGp1c3Qgc28gdGhhdCB3aGVuIHdlIHByZWZpeCB0aGUgY2FwcyB3aXRoIGEgZGFzaCwgaXQncyBjb3JyZWN0IChvdGhlcndpc2UgaXQnZCBiZSBcIm1zLXRyYW5zZm9ybVwiIGluc3RlYWQgb2YgXCItbXMtdHJhbnNmb3JtXCIgZm9yIElFOSwgZm9yIGV4YW1wbGUpXG5cdFx0XHRcdFx0XHRcdHAgPSBcIi1cIiArIHA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzLnJlbW92ZVByb3BlcnR5KHAucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHsgLy9ub3RlOiBvbGQgdmVyc2lvbnMgb2YgSUUgdXNlIFwicmVtb3ZlQXR0cmlidXRlKClcIiBpbnN0ZWFkIG9mIFwicmVtb3ZlUHJvcGVydHkoKVwiXG5cdFx0XHRcdFx0XHRzLnJlbW92ZUF0dHJpYnV0ZShwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfc2V0Q2xhc3NOYW1lUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHRoaXMudC5fZ3NDbGFzc1BUID0gdGhpcztcblx0XHRcdFx0aWYgKHYgPT09IDEgfHwgdiA9PT0gMCkge1xuXHRcdFx0XHRcdHRoaXMudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCAodiA9PT0gMCkgPyB0aGlzLmIgOiB0aGlzLmUpO1xuXHRcdFx0XHRcdHZhciBtcHQgPSB0aGlzLmRhdGEsIC8vZmlyc3QgTWluaVByb3BUd2VlblxuXHRcdFx0XHRcdFx0cyA9IHRoaXMudC5zdHlsZTtcblx0XHRcdFx0XHR3aGlsZSAobXB0KSB7XG5cdFx0XHRcdFx0XHRpZiAoIW1wdC52KSB7XG5cdFx0XHRcdFx0XHRcdF9yZW1vdmVQcm9wKHMsIG1wdC5wKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNbbXB0LnBdID0gbXB0LnY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtcHQgPSBtcHQuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh2ID09PSAxICYmIHRoaXMudC5fZ3NDbGFzc1BUID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnQuX2dzQ2xhc3NQVCA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMudC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSAhPT0gdGhpcy5lKSB7XG5cdFx0XHRcdFx0dGhpcy50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiY2xhc3NOYW1lXCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0dmFyIGIgPSB0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIsIC8vZG9uJ3QgdXNlIHQuY2xhc3NOYW1lIGJlY2F1c2UgaXQgZG9lc24ndCB3b3JrIGNvbnNpc3RlbnRseSBvbiBTVkcgZWxlbWVudHM7IGdldEF0dHJpYnV0ZShcImNsYXNzXCIpIGFuZCBzZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB2YWx1ZVwiKSBpcyBtb3JlIHJlbGlhYmxlLlxuXHRcdFx0XHRjc3NUZXh0ID0gdC5zdHlsZS5jc3NUZXh0LFxuXHRcdFx0XHRkaWZEYXRhLCBicywgY25wdCwgY25wdExvb2t1cCwgbXB0O1xuXHRcdFx0cHQgPSBjc3NwLl9jbGFzc05hbWVQVCA9IG5ldyBDU1NQcm9wVHdlZW4odCwgcCwgMCwgMCwgcHQsIDIpO1xuXHRcdFx0cHQuc2V0UmF0aW8gPSBfc2V0Q2xhc3NOYW1lUmF0aW87XG5cdFx0XHRwdC5wciA9IC0xMTtcblx0XHRcdF9oYXNQcmlvcml0eSA9IHRydWU7XG5cdFx0XHRwdC5iID0gYjtcblx0XHRcdGJzID0gX2dldEFsbFN0eWxlcyh0LCBfY3MpO1xuXHRcdFx0Ly9pZiB0aGVyZSdzIGEgY2xhc3NOYW1lIHR3ZWVuIGFscmVhZHkgb3BlcmF0aW5nIG9uIHRoZSB0YXJnZXQsIGZvcmNlIGl0IHRvIGl0cyBlbmQgc28gdGhhdCB0aGUgbmVjZXNzYXJ5IGlubGluZSBzdHlsZXMgYXJlIHJlbW92ZWQgYW5kIHRoZSBjbGFzcyBuYW1lIGlzIGFwcGxpZWQgYmVmb3JlIHdlIGRldGVybWluZSB0aGUgZW5kIHN0YXRlICh3ZSBkb24ndCB3YW50IGlubGluZSBzdHlsZXMgaW50ZXJmZXJpbmcgdGhhdCB3ZXJlIHRoZXJlIGp1c3QgZm9yIGNsYXNzLXNwZWNpZmljIHZhbHVlcylcblx0XHRcdGNucHQgPSB0Ll9nc0NsYXNzUFQ7XG5cdFx0XHRpZiAoY25wdCkge1xuXHRcdFx0XHRjbnB0TG9va3VwID0ge307XG5cdFx0XHRcdG1wdCA9IGNucHQuZGF0YTsgLy9maXJzdCBNaW5pUHJvcFR3ZWVuIHdoaWNoIHN0b3JlcyB0aGUgaW5saW5lIHN0eWxlcyAtIHdlIG5lZWQgdG8gZm9yY2UgdGhlc2Ugc28gdGhhdCB0aGUgaW5saW5lIHN0eWxlcyBkb24ndCBjb250YW1pbmF0ZSB0aGluZ3MuIE90aGVyd2lzZSwgdGhlcmUncyBhIHNtYWxsIGNoYW5jZSB0aGF0IGEgdHdlZW4gY291bGQgc3RhcnQgYW5kIHRoZSBpbmxpbmUgdmFsdWVzIG1hdGNoIHRoZSBkZXN0aW5hdGlvbiB2YWx1ZXMgYW5kIHRoZXkgbmV2ZXIgZ2V0IGNsZWFuZWQuXG5cdFx0XHRcdHdoaWxlIChtcHQpIHtcblx0XHRcdFx0XHRjbnB0TG9va3VwW21wdC5wXSA9IDE7XG5cdFx0XHRcdFx0bXB0ID0gbXB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNucHQuc2V0UmF0aW8oMSk7XG5cdFx0XHR9XG5cdFx0XHR0Ll9nc0NsYXNzUFQgPSBwdDtcblx0XHRcdHB0LmUgPSAoZS5jaGFyQXQoMSkgIT09IFwiPVwiKSA/IGUgOiBiLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFxzKlxcXFxiXCIgKyBlLnN1YnN0cigyKSArIFwiXFxcXGJcIiksIFwiXCIpICsgKChlLmNoYXJBdCgwKSA9PT0gXCIrXCIpID8gXCIgXCIgKyBlLnN1YnN0cigyKSA6IFwiXCIpO1xuXHRcdFx0aWYgKGNzc3AuX3R3ZWVuLl9kdXJhdGlvbikgeyAvL2lmIGl0J3MgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB0aGVyZSdzIG5vIG5lZWQgdG8gdHdlZW4gYW55dGhpbmcgb3IgcGFyc2UgdGhlIGRhdGEuIEluIGZhY3QsIGlmIHdlIHN3aXRjaCBjbGFzc2VzIHRlbXBvcmFyaWx5ICh3aGljaCB3ZSBtdXN0IGRvIGZvciBwcm9wZXIgcGFyc2luZykgYW5kIHRoZSBjbGFzcyBoYXMgYSB0cmFuc2l0aW9uIGFwcGxpZWQsIGl0IGNvdWxkIGNhdXNlIGEgcXVpY2sgZmxhc2ggdG8gdGhlIGVuZCBzdGF0ZSBhbmQgYmFjayBhZ2FpbiBpbml0aWFsbHkgaW4gc29tZSBicm93c2Vycy5cblx0XHRcdFx0dC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBwdC5lKTtcblx0XHRcdFx0ZGlmRGF0YSA9IF9jc3NEaWYodCwgYnMsIF9nZXRBbGxTdHlsZXModCksIHZhcnMsIGNucHRMb29rdXApO1xuXHRcdFx0XHR0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGIpO1xuXHRcdFx0XHRwdC5kYXRhID0gZGlmRGF0YS5maXJzdE1QVDtcblx0XHRcdFx0dC5zdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDsgLy93ZSByZWNvcmRlZCBjc3NUZXh0IGJlZm9yZSB3ZSBzd2FwcGVkIGNsYXNzZXMgYW5kIHJhbiBfZ2V0QWxsU3R5bGVzKCkgYmVjYXVzZSBpbiBjYXNlcyB3aGVuIGEgY2xhc3NOYW1lIHR3ZWVuIGlzIG92ZXJ3cml0dGVuLCB3ZSByZW1vdmUgYWxsIHRoZSByZWxhdGVkIHR3ZWVuaW5nIHByb3BlcnRpZXMgZnJvbSB0aGF0IGNsYXNzIGNoYW5nZSAob3RoZXJ3aXNlIGNsYXNzLXNwZWNpZmljIHN0dWZmIGNhbid0IG92ZXJyaWRlIHByb3BlcnRpZXMgd2UndmUgZGlyZWN0bHkgc2V0IG9uIHRoZSB0YXJnZXQncyBzdHlsZSBvYmplY3QgZHVlIHRvIHNwZWNpZmljaXR5KS5cblx0XHRcdFx0cHQgPSBwdC54Zmlyc3QgPSBjc3NwLnBhcnNlKHQsIGRpZkRhdGEuZGlmcywgcHQsIHBsdWdpbik7IC8vd2UgcmVjb3JkIHRoZSBDU1NQcm9wVHdlZW4gYXMgdGhlIHhmaXJzdCBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgb3ZlcndyaXRpbmcgcHJvcGVydGx5IChpZiBcImNsYXNzTmFtZVwiIGdldHMgb3ZlcndyaXR0ZW4sIHdlIG11c3Qga2lsbCBhbGwgdGhlIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjbGFzc05hbWUgcGFydCBvZiB0aGUgdHdlZW4sIHNvIHdlIGNhbiBsb29wIHRocm91Z2ggZnJvbSB4Zmlyc3QgdG8gdGhlIHB0IGl0c2VsZilcblx0XHRcdH1cblx0XHRcdHJldHVybiBwdDtcblx0XHR9fSk7XG5cblxuXHRcdHZhciBfc2V0Q2xlYXJQcm9wc1JhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0aWYgKHYgPT09IDEgfHwgdiA9PT0gMCkgaWYgKHRoaXMuZGF0YS5fdG90YWxUaW1lID09PSB0aGlzLmRhdGEuX3RvdGFsRHVyYXRpb24gJiYgdGhpcy5kYXRhLmRhdGEgIT09IFwiaXNGcm9tU3RhcnRcIikgeyAvL3RoaXMuZGF0YSByZWZlcnMgdG8gdGhlIHR3ZWVuLiBPbmx5IGNsZWFyIGF0IHRoZSBFTkQgb2YgdGhlIHR3ZWVuIChyZW1lbWJlciwgZnJvbSgpIHR3ZWVucyBtYWtlIHRoZSByYXRpbyBnbyBmcm9tIDEgdG8gMCwgc28gd2UgY2FuJ3QganVzdCBjaGVjayB0aGF0IGFuZCBpZiB0aGUgdHdlZW4gaXMgdGhlIHplcm8tZHVyYXRpb24gb25lIHRoYXQncyBjcmVhdGVkIGludGVybmFsbHkgdG8gcmVuZGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgaW4gYSBmcm9tKCkgdHdlZW4sIGlnbm9yZSB0aGF0IGJlY2F1c2Ugb3RoZXJ3aXNlLCBmb3IgZXhhbXBsZSwgZnJvbSguLi57aGVpZ2h0OjEwMCwgY2xlYXJQcm9wczpcImhlaWdodFwiLCBkZWxheToxfSkgd291bGQgd2lwZSB0aGUgaGVpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIGFuZCBhZnRlciAxIHNlY29uZCwgaXQnZCBraWNrIGJhY2sgaW4pLlxuXHRcdFx0XHR2YXIgcyA9IHRoaXMudC5zdHlsZSxcblx0XHRcdFx0XHR0cmFuc2Zvcm1QYXJzZSA9IF9zcGVjaWFsUHJvcHMudHJhbnNmb3JtLnBhcnNlLFxuXHRcdFx0XHRcdGEsIHAsIGksIGNsZWFyVHJhbnNmb3JtO1xuXHRcdFx0XHRpZiAodGhpcy5lID09PSBcImFsbFwiKSB7XG5cdFx0XHRcdFx0cy5jc3NUZXh0ID0gXCJcIjtcblx0XHRcdFx0XHRjbGVhclRyYW5zZm9ybSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YSA9IHRoaXMuZS5zcGxpdChcIiBcIikuam9pbihcIlwiKS5zcGxpdChcIixcIik7XG5cdFx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0cCA9IGFbaV07XG5cdFx0XHRcdFx0XHRpZiAoX3NwZWNpYWxQcm9wc1twXSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoX3NwZWNpYWxQcm9wc1twXS5wYXJzZSA9PT0gdHJhbnNmb3JtUGFyc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRjbGVhclRyYW5zZm9ybSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IChwID09PSBcInRyYW5zZm9ybU9yaWdpblwiKSA/IF90cmFuc2Zvcm1PcmlnaW5Qcm9wIDogX3NwZWNpYWxQcm9wc1twXS5wOyAvL2Vuc3VyZXMgdGhhdCBzcGVjaWFsIHByb3BlcnRpZXMgdXNlIHRoZSBwcm9wZXIgYnJvd3Nlci1zcGVjaWZpYyBwcm9wZXJ0eSBuYW1lLCBsaWtlIFwic2NhbGVYXCIgbWlnaHQgYmUgXCItd2Via2l0LXRyYW5zZm9ybVwiIG9yIFwiYm94U2hhZG93XCIgbWlnaHQgYmUgXCItbW96LWJveC1zaGFkb3dcIlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRfcmVtb3ZlUHJvcChzLCBwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNsZWFyVHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0X3JlbW92ZVByb3AocywgX3RyYW5zZm9ybVByb3ApO1xuXHRcdFx0XHRcdGlmICh0aGlzLnQuX2dzVHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpcy50Ll9nc1RyYW5zZm9ybTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH07XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiY2xlYXJQcm9wc1wiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0KSB7XG5cdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4odCwgcCwgMCwgMCwgcHQsIDIpO1xuXHRcdFx0cHQuc2V0UmF0aW8gPSBfc2V0Q2xlYXJQcm9wc1JhdGlvO1xuXHRcdFx0cHQuZSA9IGU7XG5cdFx0XHRwdC5wciA9IC0xMDtcblx0XHRcdHB0LmRhdGEgPSBjc3NwLl90d2Vlbjtcblx0XHRcdF9oYXNQcmlvcml0eSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fX0pO1xuXG5cdFx0cCA9IFwiYmV6aWVyLHRocm93UHJvcHMscGh5c2ljc1Byb3BzLHBoeXNpY3MyRFwiLnNwbGl0KFwiLFwiKTtcblx0XHRpID0gcC5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0X3JlZ2lzdGVyUGx1Z2luUHJvcChwW2ldKTtcblx0XHR9XG5cblxuXG5cblxuXG5cblxuXHRcdHAgPSBDU1NQbHVnaW4ucHJvdG90eXBlO1xuXHRcdHAuX2ZpcnN0UFQgPSBwLl9sYXN0UGFyc2VkVHJhbnNmb3JtID0gcC5fdHJhbnNmb3JtID0gbnVsbDtcblxuXHRcdC8vZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdHdlZW4gcmVuZGVycyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMga2lja3MgZXZlcnl0aGluZyBvZmYsIHJlY29yZGluZyBzdGFydC9lbmQgdmFsdWVzLCBldGMuXG5cdFx0cC5fb25Jbml0VHdlZW4gPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMsIHR3ZWVuKSB7XG5cdFx0XHRpZiAoIXRhcmdldC5ub2RlVHlwZSkgeyAvL2NzcyBpcyBvbmx5IGZvciBkb20gZWxlbWVudHNcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0dGhpcy5fdHdlZW4gPSB0d2Vlbjtcblx0XHRcdHRoaXMuX3ZhcnMgPSB2YXJzO1xuXHRcdFx0X2F1dG9Sb3VuZCA9IHZhcnMuYXV0b1JvdW5kO1xuXHRcdFx0X2hhc1ByaW9yaXR5ID0gZmFsc2U7XG5cdFx0XHRfc3VmZml4TWFwID0gdmFycy5zdWZmaXhNYXAgfHwgQ1NTUGx1Z2luLnN1ZmZpeE1hcDtcblx0XHRcdF9jcyA9IF9nZXRDb21wdXRlZFN0eWxlKHRhcmdldCwgXCJcIik7XG5cdFx0XHRfb3ZlcndyaXRlUHJvcHMgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcztcblx0XHRcdHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcblx0XHRcdFx0diwgcHQsIHB0MiwgZmlyc3QsIGxhc3QsIG5leHQsIHpJbmRleCwgdHB0LCB0aHJlZUQ7XG5cdFx0XHRpZiAoX3JlcVNhZmFyaUZpeCkgaWYgKHN0eWxlLnpJbmRleCA9PT0gXCJcIikge1xuXHRcdFx0XHR2ID0gX2dldFN0eWxlKHRhcmdldCwgXCJ6SW5kZXhcIiwgX2NzKTtcblx0XHRcdFx0aWYgKHYgPT09IFwiYXV0b1wiIHx8IHYgPT09IFwiXCIpIHtcblx0XHRcdFx0XHQvL2NvcnJlY3RzIGEgYnVnIGluIFtub24tQW5kcm9pZF0gU2FmYXJpIHRoYXQgcHJldmVudHMgaXQgZnJvbSByZXBhaW50aW5nIGVsZW1lbnRzIGluIHRoZWlyIG5ldyBwb3NpdGlvbnMgaWYgdGhleSBkb24ndCBoYXZlIGEgekluZGV4IHNldC4gV2UgYWxzbyBjYW4ndCBqdXN0IGFwcGx5IHRoaXMgaW5zaWRlIF9wYXJzZVRyYW5zZm9ybSgpIGJlY2F1c2UgYW55dGhpbmcgdGhhdCdzIG1vdmVkIGluIGFueSB3YXkgKGxpa2UgdXNpbmcgXCJsZWZ0XCIgb3IgXCJ0b3BcIiBpbnN0ZWFkIG9mIHRyYW5zZm9ybXMgbGlrZSBcInhcIiBhbmQgXCJ5XCIpIGNhbiBiZSBhZmZlY3RlZCwgc28gaXQgaXMgYmVzdCB0byBlbnN1cmUgdGhhdCBhbnl0aGluZyB0aGF0J3MgdHdlZW5pbmcgaGFzIGEgei1pbmRleC4gU2V0dGluZyBcIldlYmtpdFBlcnNwZWN0aXZlXCIgdG8gYSBub24temVybyB2YWx1ZSB3b3JrZWQgdG9vIGV4Y2VwdCB0aGF0IG9uIGlPUyBTYWZhcmkgdGhpbmdzIHdvdWxkIGZsaWNrZXIgcmFuZG9tbHkuIFBsdXMgekluZGV4IGlzIGxlc3MgbWVtb3J5LWludGVuc2l2ZS5cblx0XHRcdFx0XHR0aGlzLl9hZGRMYXp5U2V0KHN0eWxlLCBcInpJbmRleFwiLCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mKHZhcnMpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGZpcnN0ID0gc3R5bGUuY3NzVGV4dDtcblx0XHRcdFx0diA9IF9nZXRBbGxTdHlsZXModGFyZ2V0LCBfY3MpO1xuXHRcdFx0XHRzdHlsZS5jc3NUZXh0ID0gZmlyc3QgKyBcIjtcIiArIHZhcnM7XG5cdFx0XHRcdHYgPSBfY3NzRGlmKHRhcmdldCwgdiwgX2dldEFsbFN0eWxlcyh0YXJnZXQpKS5kaWZzO1xuXHRcdFx0XHRpZiAoIV9zdXBwb3J0c09wYWNpdHkgJiYgX29wYWNpdHlWYWxFeHAudGVzdCh2YXJzKSkge1xuXHRcdFx0XHRcdHYub3BhY2l0eSA9IHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhcnMgPSB2O1xuXHRcdFx0XHRzdHlsZS5jc3NUZXh0ID0gZmlyc3Q7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9maXJzdFBUID0gcHQgPSB0aGlzLnBhcnNlKHRhcmdldCwgdmFycywgbnVsbCk7XG5cblx0XHRcdGlmICh0aGlzLl90cmFuc2Zvcm1UeXBlKSB7XG5cdFx0XHRcdHRocmVlRCA9ICh0aGlzLl90cmFuc2Zvcm1UeXBlID09PSAzKTtcblx0XHRcdFx0aWYgKCFfdHJhbnNmb3JtUHJvcCkge1xuXHRcdFx0XHRcdHN0eWxlLnpvb20gPSAxOyAvL2hlbHBzIGNvcnJlY3QgYW4gSUUgaXNzdWUuXG5cdFx0XHRcdH0gZWxzZSBpZiAoX2lzU2FmYXJpKSB7XG5cdFx0XHRcdFx0X3JlcVNhZmFyaUZpeCA9IHRydWU7XG5cdFx0XHRcdFx0Ly9pZiB6SW5kZXggaXNuJ3Qgc2V0LCBpT1MgU2FmYXJpIGRvZXNuJ3QgcmVwYWludCB0aGluZ3MgY29ycmVjdGx5IHNvbWV0aW1lcyAoc2VlbWluZ2x5IGF0IHJhbmRvbSkuXG5cdFx0XHRcdFx0aWYgKHN0eWxlLnpJbmRleCA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0ekluZGV4ID0gX2dldFN0eWxlKHRhcmdldCwgXCJ6SW5kZXhcIiwgX2NzKTtcblx0XHRcdFx0XHRcdGlmICh6SW5kZXggPT09IFwiYXV0b1wiIHx8IHpJbmRleCA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9hZGRMYXp5U2V0KHN0eWxlLCBcInpJbmRleFwiLCAwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9TZXR0aW5nIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSBjb3JyZWN0cyAzIGJ1Z3M6XG5cdFx0XHRcdFx0Ly8gMSkgW25vbi1BbmRyb2lkXSBTYWZhcmkgc2tpcHMgcmVuZGVyaW5nIGNoYW5nZXMgdG8gXCJ0b3BcIiBhbmQgXCJsZWZ0XCIgdGhhdCBhcmUgbWFkZSBvbiB0aGUgc2FtZSBmcmFtZS9yZW5kZXIgYXMgYSB0cmFuc2Zvcm0gdXBkYXRlLlxuXHRcdFx0XHRcdC8vIDIpIGlPUyBTYWZhcmkgc29tZXRpbWVzIG5lZ2xlY3RzIHRvIHJlcGFpbnQgZWxlbWVudHMgaW4gdGhlaXIgbmV3IHBvc2l0aW9ucy4gU2V0dGluZyBcIldlYmtpdFBlcnNwZWN0aXZlXCIgdG8gYSBub24temVybyB2YWx1ZSB3b3JrZWQgdG9vIGV4Y2VwdCB0aGF0IG9uIGlPUyBTYWZhcmkgdGhpbmdzIHdvdWxkIGZsaWNrZXIgcmFuZG9tbHkuXG5cdFx0XHRcdFx0Ly8gMykgU2FmYXJpIHNvbWV0aW1lcyBkaXNwbGF5ZWQgb2RkIGFydGlmYWN0cyB3aGVuIHR3ZWVuaW5nIHRoZSB0cmFuc2Zvcm0gKG9yIFdlYmtpdFRyYW5zZm9ybSkgcHJvcGVydHksIGxpa2UgZ2hvc3RzIG9mIHRoZSBlZGdlcyBvZiB0aGUgZWxlbWVudCByZW1haW5lZC4gRGVmaW5pdGVseSBhIGJyb3dzZXIgYnVnLlxuXHRcdFx0XHRcdC8vTm90ZTogd2UgYWxsb3cgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgdGhlIGF1dG8tc2V0dGluZyBieSBkZWZpbmluZyBXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgaW4gdGhlIHZhcnMgb2YgdGhlIHR3ZWVuLlxuXHRcdFx0XHRcdGlmIChfaXNTYWZhcmlMVDYpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FkZExhenlTZXQoc3R5bGUsIFwiV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5XCIsIHRoaXMuX3ZhcnMuV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5IHx8ICh0aHJlZUQgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQyID0gcHQ7XG5cdFx0XHRcdHdoaWxlIChwdDIgJiYgcHQyLl9uZXh0KSB7XG5cdFx0XHRcdFx0cHQyID0gcHQyLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4odGFyZ2V0LCBcInRyYW5zZm9ybVwiLCAwLCAwLCBudWxsLCAyKTtcblx0XHRcdFx0dGhpcy5fbGlua0NTU1AodHB0LCBudWxsLCBwdDIpO1xuXHRcdFx0XHR0cHQuc2V0UmF0aW8gPSAodGhyZWVEICYmIF9zdXBwb3J0czNEKSA/IF9zZXQzRFRyYW5zZm9ybVJhdGlvIDogX3RyYW5zZm9ybVByb3AgPyBfc2V0MkRUcmFuc2Zvcm1SYXRpbyA6IF9zZXRJRVRyYW5zZm9ybVJhdGlvO1xuXHRcdFx0XHR0cHQuZGF0YSA9IHRoaXMuX3RyYW5zZm9ybSB8fCBfZ2V0VHJhbnNmb3JtKHRhcmdldCwgX2NzLCB0cnVlKTtcblx0XHRcdFx0dHB0LnR3ZWVuID0gdHdlZW47XG5cdFx0XHRcdF9vdmVyd3JpdGVQcm9wcy5wb3AoKTsgLy93ZSBkb24ndCB3YW50IHRvIGZvcmNlIHRoZSBvdmVyd3JpdGUgb2YgYWxsIFwidHJhbnNmb3JtXCIgdHdlZW5zIG9mIHRoZSB0YXJnZXQgLSB3ZSBvbmx5IGNhcmUgYWJvdXQgaW5kaXZpZHVhbCB0cmFuc2Zvcm0gcHJvcGVydGllcyBsaWtlIHNjYWxlWCwgcm90YXRpb24sIGV0Yy4gVGhlIENTU1Byb3BUd2VlbiBjb25zdHJ1Y3RvciBhdXRvbWF0aWNhbGx5IGFkZHMgdGhlIHByb3BlcnR5IHRvIF9vdmVyd3JpdGVQcm9wcyB3aGljaCBpcyB3aHkgd2UgbmVlZCB0byBwb3AoKSBoZXJlLlxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2hhc1ByaW9yaXR5KSB7XG5cdFx0XHRcdC8vcmVvcmRlcnMgdGhlIGxpbmtlZCBsaXN0IGluIG9yZGVyIG9mIHByIChwcmlvcml0eSlcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0bmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdHB0MiA9IGZpcnN0O1xuXHRcdFx0XHRcdHdoaWxlIChwdDIgJiYgcHQyLnByID4gcHQucHIpIHtcblx0XHRcdFx0XHRcdHB0MiA9IHB0Mi5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fcHJldiA9IHB0MiA/IHB0Mi5fcHJldiA6IGxhc3QpKSB7XG5cdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmaXJzdCA9IHB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHB0Ll9uZXh0ID0gcHQyKSkge1xuXHRcdFx0XHRcdFx0cHQyLl9wcmV2ID0gcHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxhc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBmaXJzdDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblxuXHRcdHAucGFyc2UgPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMsIHB0LCBwbHVnaW4pIHtcblx0XHRcdHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcblx0XHRcdFx0cCwgc3AsIGJuLCBlbiwgYnMsIGVzLCBic2Z4LCBlc2Z4LCBpc1N0ciwgcmVsO1xuXHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0ZXMgPSB2YXJzW3BdOyAvL2VuZGluZyB2YWx1ZSBzdHJpbmdcblx0XHRcdFx0c3AgPSBfc3BlY2lhbFByb3BzW3BdOyAvL1NwZWNpYWxQcm9wIGxvb2t1cC5cblx0XHRcdFx0aWYgKHNwKSB7XG5cdFx0XHRcdFx0cHQgPSBzcC5wYXJzZSh0YXJnZXQsIGVzLCBwLCB0aGlzLCBwdCwgcGx1Z2luLCB2YXJzKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJzID0gX2dldFN0eWxlKHRhcmdldCwgcCwgX2NzKSArIFwiXCI7XG5cdFx0XHRcdFx0aXNTdHIgPSAodHlwZW9mKGVzKSA9PT0gXCJzdHJpbmdcIik7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFwiY29sb3JcIiB8fCBwID09PSBcImZpbGxcIiB8fCBwID09PSBcInN0cm9rZVwiIHx8IHAuaW5kZXhPZihcIkNvbG9yXCIpICE9PSAtMSB8fCAoaXNTdHIgJiYgX3JnYmhzbEV4cC50ZXN0KGVzKSkpIHsgLy9PcGVyYSB1c2VzIGJhY2tncm91bmQ6IHRvIGRlZmluZSBjb2xvciBzb21ldGltZXMgaW4gYWRkaXRpb24gdG8gYmFja2dyb3VuZENvbG9yOlxuXHRcdFx0XHRcdFx0aWYgKCFpc1N0cikge1xuXHRcdFx0XHRcdFx0XHRlcyA9IF9wYXJzZUNvbG9yKGVzKTtcblx0XHRcdFx0XHRcdFx0ZXMgPSAoKGVzLmxlbmd0aCA+IDMpID8gXCJyZ2JhKFwiIDogXCJyZ2IoXCIpICsgZXMuam9pbihcIixcIikgKyBcIilcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHB0ID0gX3BhcnNlQ29tcGxleChzdHlsZSwgcCwgYnMsIGVzLCB0cnVlLCBcInRyYW5zcGFyZW50XCIsIHB0LCAwLCBwbHVnaW4pO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpc1N0ciAmJiAoZXMuaW5kZXhPZihcIiBcIikgIT09IC0xIHx8IGVzLmluZGV4T2YoXCIsXCIpICE9PSAtMSkpIHtcblx0XHRcdFx0XHRcdHB0ID0gX3BhcnNlQ29tcGxleChzdHlsZSwgcCwgYnMsIGVzLCB0cnVlLCBudWxsLCBwdCwgMCwgcGx1Z2luKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRibiA9IHBhcnNlRmxvYXQoYnMpO1xuXHRcdFx0XHRcdFx0YnNmeCA9IChibiB8fCBibiA9PT0gMCkgPyBicy5zdWJzdHIoKGJuICsgXCJcIikubGVuZ3RoKSA6IFwiXCI7IC8vcmVtZW1iZXIsIGJzIGNvdWxkIGJlIG5vbi1udW1lcmljIGxpa2UgXCJub3JtYWxcIiBmb3IgZm9udFdlaWdodCwgc28gd2Ugc2hvdWxkIGRlZmF1bHQgdG8gYSBibGFuayBzdWZmaXggaW4gdGhhdCBjYXNlLlxuXG5cdFx0XHRcdFx0XHRpZiAoYnMgPT09IFwiXCIgfHwgYnMgPT09IFwiYXV0b1wiKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwID09PSBcIndpZHRoXCIgfHwgcCA9PT0gXCJoZWlnaHRcIikge1xuXHRcdFx0XHRcdFx0XHRcdGJuID0gX2dldERpbWVuc2lvbih0YXJnZXQsIHAsIF9jcyk7XG5cdFx0XHRcdFx0XHRcdFx0YnNmeCA9IFwicHhcIjtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwID09PSBcImxlZnRcIiB8fCBwID09PSBcInRvcFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gPSBfY2FsY3VsYXRlT2Zmc2V0KHRhcmdldCwgcCwgX2NzKTtcblx0XHRcdFx0XHRcdFx0XHRic2Z4ID0gXCJweFwiO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGJuID0gKHAgIT09IFwib3BhY2l0eVwiKSA/IDAgOiAxO1xuXHRcdFx0XHRcdFx0XHRcdGJzZnggPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJlbCA9IChpc1N0ciAmJiBlcy5jaGFyQXQoMSkgPT09IFwiPVwiKTtcblx0XHRcdFx0XHRcdGlmIChyZWwpIHtcblx0XHRcdFx0XHRcdFx0ZW4gPSBwYXJzZUludChlcy5jaGFyQXQoMCkgKyBcIjFcIiwgMTApO1xuXHRcdFx0XHRcdFx0XHRlcyA9IGVzLnN1YnN0cigyKTtcblx0XHRcdFx0XHRcdFx0ZW4gKj0gcGFyc2VGbG9hdChlcyk7XG5cdFx0XHRcdFx0XHRcdGVzZnggPSBlcy5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZW4gPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRcdFx0ZXNmeCA9IGlzU3RyID8gZXMucmVwbGFjZShfc3VmZml4RXhwLCBcIlwiKSA6IFwiXCI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChlc2Z4ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRcdGVzZnggPSAocCBpbiBfc3VmZml4TWFwKSA/IF9zdWZmaXhNYXBbcF0gOiBic2Z4OyAvL3BvcHVsYXRlIHRoZSBlbmQgc3VmZml4LCBwcmlvcml0aXppbmcgdGhlIG1hcCwgdGhlbiBpZiBub25lIGlzIGZvdW5kLCB1c2UgdGhlIGJlZ2lubmluZyBzdWZmaXguXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGVzID0gKGVuIHx8IGVuID09PSAwKSA/IChyZWwgPyBlbiArIGJuIDogZW4pICsgZXNmeCA6IHZhcnNbcF07IC8vZW5zdXJlcyB0aGF0IGFueSArPSBvciAtPSBwcmVmaXhlcyBhcmUgdGFrZW4gY2FyZSBvZi4gUmVjb3JkIHRoZSBlbmQgdmFsdWUgYmVmb3JlIG5vcm1hbGl6aW5nIHRoZSBzdWZmaXggYmVjYXVzZSB3ZSBhbHdheXMgd2FudCB0byBlbmQgdGhlIHR3ZWVuIG9uIGV4YWN0bHkgd2hhdCB0aGV5IGludGVuZGVkIGV2ZW4gaWYgaXQgZG9lc24ndCBtYXRjaCB0aGUgYmVnaW5uaW5nIHZhbHVlJ3Mgc3VmZml4LlxuXG5cdFx0XHRcdFx0XHQvL2lmIHRoZSBiZWdpbm5pbmcvZW5kaW5nIHN1ZmZpeGVzIGRvbid0IG1hdGNoLCBub3JtYWxpemUgdGhlbS4uLlxuXHRcdFx0XHRcdFx0aWYgKGJzZnggIT09IGVzZngpIGlmIChlc2Z4ICE9PSBcIlwiKSBpZiAoZW4gfHwgZW4gPT09IDApIGlmIChibikgeyAvL25vdGU6IGlmIHRoZSBiZWdpbm5pbmcgdmFsdWUgKGJuKSBpcyAwLCB3ZSBkb24ndCBuZWVkIHRvIGNvbnZlcnQgdW5pdHMhXG5cdFx0XHRcdFx0XHRcdGJuID0gX2NvbnZlcnRUb1BpeGVscyh0YXJnZXQsIHAsIGJuLCBic2Z4KTtcblx0XHRcdFx0XHRcdFx0aWYgKGVzZnggPT09IFwiJVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gLz0gX2NvbnZlcnRUb1BpeGVscyh0YXJnZXQsIHAsIDEwMCwgXCIlXCIpIC8gMTAwO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh2YXJzLnN0cmljdFVuaXRzICE9PSB0cnVlKSB7IC8vc29tZSBicm93c2VycyByZXBvcnQgb25seSBcInB4XCIgdmFsdWVzIGluc3RlYWQgb2YgYWxsb3dpbmcgXCIlXCIgd2l0aCBnZXRDb21wdXRlZFN0eWxlKCksIHNvIHdlIGFzc3VtZSB0aGF0IGlmIHdlJ3JlIHR3ZWVuaW5nIHRvIGEgJSwgd2Ugc2hvdWxkIHN0YXJ0IHRoZXJlIHRvbyB1bmxlc3Mgc3RyaWN0VW5pdHM6dHJ1ZSBpcyBkZWZpbmVkLiBUaGlzIGFwcHJvYWNoIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHJlc3BvbnNpdmUgZGVzaWducyB0aGF0IHVzZSBmcm9tKCkgdHdlZW5zLlxuXHRcdFx0XHRcdFx0XHRcdFx0YnMgPSBibiArIFwiJVwiO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGVzZnggPT09IFwiZW1cIikge1xuXHRcdFx0XHRcdFx0XHRcdGJuIC89IF9jb252ZXJ0VG9QaXhlbHModGFyZ2V0LCBwLCAxLCBcImVtXCIpO1xuXG5cdFx0XHRcdFx0XHRcdC8vb3RoZXJ3aXNlIGNvbnZlcnQgdG8gcGl4ZWxzLlxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGVzZnggIT09IFwicHhcIikge1xuXHRcdFx0XHRcdFx0XHRcdGVuID0gX2NvbnZlcnRUb1BpeGVscyh0YXJnZXQsIHAsIGVuLCBlc2Z4KTtcblx0XHRcdFx0XHRcdFx0XHRlc2Z4ID0gXCJweFwiOyAvL3dlIGRvbid0IHVzZSBic2Z4IGFmdGVyIHRoaXMsIHNvIHdlIGRvbid0IG5lZWQgdG8gc2V0IGl0IHRvIHB4IHRvby5cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAocmVsKSBpZiAoZW4gfHwgZW4gPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRlcyA9IChlbiArIGJuKSArIGVzZng7IC8vdGhlIGNoYW5nZXMgd2UgbWFkZSBhZmZlY3QgcmVsYXRpdmUgY2FsY3VsYXRpb25zLCBzbyBhZGp1c3QgdGhlIGVuZCB2YWx1ZSBoZXJlLlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChyZWwpIHtcblx0XHRcdFx0XHRcdFx0ZW4gKz0gYm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICgoYm4gfHwgYm4gPT09IDApICYmIChlbiB8fCBlbiA9PT0gMCkpIHsgLy9mYXN0ZXIgdGhhbiBpc05hTigpLiBBbHNvLCBwcmV2aW91c2x5IHdlIHJlcXVpcmVkIGVuICE9PSBibiBidXQgdGhhdCBkb2Vzbid0IHJlYWxseSBnYWluIG11Y2ggcGVyZm9ybWFuY2UgYW5kIGl0IHByZXZlbnRzIF9wYXJzZVRvUHJveHkoKSBmcm9tIHdvcmtpbmcgcHJvcGVybHkgaWYgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIG1hdGNoIGJ1dCBuZWVkIHRvIGdldCB0d2VlbmVkIGJ5IGFuIGV4dGVybmFsIHBsdWdpbiBhbnl3YXkuIEZvciBleGFtcGxlLCBhIGJlemllciB0d2VlbiB3aGVyZSB0aGUgdGFyZ2V0IHN0YXJ0cyBhdCBsZWZ0OjAgYW5kIGhhcyB0aGVzZSBwb2ludHM6IFt7bGVmdDo1MH0se2xlZnQ6MH1dIHdvdWxkbid0IHdvcmsgcHJvcGVybHkgYmVjYXVzZSB3aGVuIHBhcnNpbmcgdGhlIGxhc3QgcG9pbnQsIGl0J2QgbWF0Y2ggdGhlIGZpcnN0IChjdXJyZW50KSBvbmUgYW5kIGEgbm9uLXR3ZWVuaW5nIENTU1Byb3BUd2VlbiB3b3VsZCBiZSByZWNvcmRlZCB3aGVuIHdlIGFjdHVhbGx5IG5lZWQgYSBub3JtYWwgdHdlZW4gKHR5cGU6MCkgc28gdGhhdCB0aGluZ3MgZ2V0IHVwZGF0ZWQgZHVyaW5nIHRoZSB0d2VlbiBwcm9wZXJseS5cblx0XHRcdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBwLCBibiwgZW4gLSBibiwgcHQsIDAsIHAsIChfYXV0b1JvdW5kICE9PSBmYWxzZSAmJiAoZXNmeCA9PT0gXCJweFwiIHx8IHAgPT09IFwiekluZGV4XCIpKSwgMCwgYnMsIGVzKTtcblx0XHRcdFx0XHRcdFx0cHQueHMwID0gZXNmeDtcblx0XHRcdFx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcInR3ZWVuIFwiK3ArXCIgZnJvbSBcIitwdC5iK1wiIChcIitibitlc2Z4K1wiKSB0byBcIitwdC5lK1wiIHdpdGggc3VmZml4OiBcIitwdC54czApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzdHlsZVtwXSA9PT0gdW5kZWZpbmVkIHx8ICFlcyAmJiAoZXMgKyBcIlwiID09PSBcIk5hTlwiIHx8IGVzID09IG51bGwpKSB7XG5cdFx0XHRcdFx0XHRcdF9sb2coXCJpbnZhbGlkIFwiICsgcCArIFwiIHR3ZWVuIHZhbHVlOiBcIiArIHZhcnNbcF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBwLCBlbiB8fCBibiB8fCAwLCAwLCBwdCwgLTEsIHAsIGZhbHNlLCAwLCBicywgZXMpO1xuXHRcdFx0XHRcdFx0XHRwdC54czAgPSAoZXMgPT09IFwibm9uZVwiICYmIChwID09PSBcImRpc3BsYXlcIiB8fCBwLmluZGV4T2YoXCJTdHlsZVwiKSAhPT0gLTEpKSA/IGJzIDogZXM7IC8vaW50ZXJtZWRpYXRlIHZhbHVlIHNob3VsZCB0eXBpY2FsbHkgYmUgc2V0IGltbWVkaWF0ZWx5IChlbmQgdmFsdWUpIGV4Y2VwdCBmb3IgXCJkaXNwbGF5XCIgb3IgdGhpbmdzIGxpa2UgYm9yZGVyVG9wU3R5bGUsIGJvcmRlckJvdHRvbVN0eWxlLCBldGMuIHdoaWNoIHNob3VsZCB1c2UgdGhlIGJlZ2lubmluZyB2YWx1ZSBkdXJpbmcgdGhlIHR3ZWVuLlxuXHRcdFx0XHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwibm9uLXR3ZWVuaW5nIHZhbHVlIFwiK3ArXCI6IFwiK3B0LnhzMCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwbHVnaW4pIGlmIChwdCAmJiAhcHQucGx1Z2luKSB7XG5cdFx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fTtcblxuXG5cdFx0Ly9nZXRzIGNhbGxlZCBldmVyeSB0aW1lIHRoZSB0d2VlbiB1cGRhdGVzLCBwYXNzaW5nIHRoZSBuZXcgcmF0aW8gKHR5cGljYWxseSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgYnV0IG5vdCBhbHdheXMgKGZvciBleGFtcGxlLCBpZiBhbiBFbGFzdGljLmVhc2VPdXQgaXMgdXNlZCwgdGhlIHZhbHVlIGNhbiBqdW1wIGFib3ZlIDEgbWlkLXR3ZWVuKS4gSXQgd2lsbCBhbHdheXMgc3RhcnQgYW5kIDAgYW5kIGVuZCBhdCAxLlxuXHRcdHAuc2V0UmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLl9maXJzdFBULFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0dmFsLCBzdHIsIGk7XG5cdFx0XHQvL2F0IHRoZSBlbmQgb2YgdGhlIHR3ZWVuLCB3ZSBzZXQgdGhlIHZhbHVlcyB0byBleGFjdGx5IHdoYXQgd2UgcmVjZWl2ZWQgaW4gb3JkZXIgdG8gbWFrZSBzdXJlIG5vbi10d2VlbmluZyB2YWx1ZXMgKGxpa2UgXCJwb3NpdGlvblwiIG9yIFwiZmxvYXRcIiBvciB3aGF0ZXZlcikgYXJlIHNldCBhbmQgc28gdGhhdCBpZiB0aGUgYmVnaW5uaW5nL2VuZGluZyBzdWZmaXhlcyAodW5pdHMpIGRpZG4ndCBtYXRjaCBhbmQgd2Ugbm9ybWFsaXplZCB0byBweCwgdGhlIHZhbHVlIHRoYXQgdGhlIHVzZXIgcGFzc2VkIGluIGlzIHVzZWQgaGVyZS4gV2UgY2hlY2sgdG8gc2VlIGlmIHRoZSB0d2VlbiBpcyBhdCBpdHMgYmVnaW5uaW5nIGluIGNhc2UgaXQncyBhIGZyb20oKSB0d2VlbiBpbiB3aGljaCBjYXNlIHRoZSByYXRpbyB3aWxsIGFjdHVhbGx5IGdvIGZyb20gMSB0byAwIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgdHdlZW4gKGJhY2t3YXJkcykuXG5cdFx0XHRpZiAodiA9PT0gMSAmJiAodGhpcy5fdHdlZW4uX3RpbWUgPT09IHRoaXMuX3R3ZWVuLl9kdXJhdGlvbiB8fCB0aGlzLl90d2Vlbi5fdGltZSA9PT0gMCkpIHtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0aWYgKHB0LnR5cGUgIT09IDIpIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC5lO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC5zZXRSYXRpbyh2KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKHYgfHwgISh0aGlzLl90d2Vlbi5fdGltZSA9PT0gdGhpcy5fdHdlZW4uX2R1cmF0aW9uIHx8IHRoaXMuX3R3ZWVuLl90aW1lID09PSAwKSB8fCB0aGlzLl90d2Vlbi5fcmF3UHJldlRpbWUgPT09IC0wLjAwMDAwMSkge1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHR2YWwgPSBwdC5jICogdiArIHB0LnM7XG5cdFx0XHRcdFx0aWYgKHB0LnIpIHtcblx0XHRcdFx0XHRcdHZhbCA9IE1hdGgucm91bmQodmFsKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbCA8IG1pbikgaWYgKHZhbCA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHZhbCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghcHQudHlwZSkge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHZhbCArIHB0LnhzMDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnR5cGUgPT09IDEpIHsgLy9jb21wbGV4IHZhbHVlIChvbmUgdGhhdCB0eXBpY2FsbHkgaGFzIG11bHRpcGxlIG51bWJlcnMgaW5zaWRlIGEgc3RyaW5nLCBsaWtlIFwicmVjdCg1cHgsMTBweCwyMHB4LDI1cHgpXCJcblx0XHRcdFx0XHRcdGkgPSBwdC5sO1xuXHRcdFx0XHRcdFx0aWYgKGkgPT09IDIpIHtcblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMCArIHZhbCArIHB0LnhzMSArIHB0LnhuMSArIHB0LnhzMjtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gMykge1xuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwICsgdmFsICsgcHQueHMxICsgcHQueG4xICsgcHQueHMyICsgcHQueG4yICsgcHQueHMzO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpID09PSA0KSB7XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czAgKyB2YWwgKyBwdC54czEgKyBwdC54bjEgKyBwdC54czIgKyBwdC54bjIgKyBwdC54czMgKyBwdC54bjMgKyBwdC54czQ7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgPT09IDUpIHtcblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMCArIHZhbCArIHB0LnhzMSArIHB0LnhuMSArIHB0LnhzMiArIHB0LnhuMiArIHB0LnhzMyArIHB0LnhuMyArIHB0LnhzNCArIHB0LnhuNCArIHB0LnhzNTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN0ciA9IHB0LnhzMCArIHZhbCArIHB0LnhzMTtcblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8IHB0Lmw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHN0ciArPSBwdFtcInhuXCIraV0gKyBwdFtcInhzXCIrKGkrMSldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBzdHI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnR5cGUgPT09IC0xKSB7IC8vbm9uLXR3ZWVuaW5nIHZhbHVlXG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC5zZXRSYXRpbykgeyAvL2N1c3RvbSBzZXRSYXRpbygpIGZvciB0aGluZ3MgbGlrZSBTcGVjaWFsUHJvcHMsIGV4dGVybmFsIHBsdWdpbnMsIGV0Yy5cblx0XHRcdFx0XHRcdHB0LnNldFJhdGlvKHYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vaWYgdGhlIHR3ZWVuIGlzIHJldmVyc2VkIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZywgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCB2YWx1ZXMgd2hpY2ggbWF5IGhhdmUgZGlmZmVyZW50IHVuaXRzIChsaWtlICUgaW5zdGVhZCBvZiBweCBvciBlbSBvciB3aGF0ZXZlcikuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRpZiAocHQudHlwZSAhPT0gMikge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LmI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0LnNldFJhdGlvKHYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogRm9yY2VzIHJlbmRlcmluZyBvZiB0aGUgdGFyZ2V0J3MgdHJhbnNmb3JtcyAocm90YXRpb24sIHNjYWxlLCBldGMuKSB3aGVuZXZlciB0aGUgQ1NTUGx1Z2luJ3Mgc2V0UmF0aW8oKSBpcyBjYWxsZWQuXG5cdFx0ICogQmFzaWNhbGx5LCB0aGlzIHRlbGxzIHRoZSBDU1NQbHVnaW4gdG8gY3JlYXRlIGEgQ1NTUHJvcFR3ZWVuICh0eXBlIDIpIGFmdGVyIGluc3RhbnRpYXRpb24gdGhhdCBydW5zIGxhc3QgaW4gdGhlIGxpbmtlZFxuXHRcdCAqIGxpc3QgYW5kIGNhbGxzIHRoZSBhcHByb3ByaWF0ZSAoM0Qgb3IgMkQpIHJlbmRlcmluZyBmdW5jdGlvbi4gV2Ugc2VwYXJhdGUgdGhpcyBpbnRvIGl0cyBvd24gbWV0aG9kIHNvIHRoYXQgd2UgY2FuIGNhbGxcblx0XHQgKiBpdCBmcm9tIG90aGVyIHBsdWdpbnMgbGlrZSBCZXppZXJQbHVnaW4gaWYsIGZvciBleGFtcGxlLCBpdCBuZWVkcyB0byBhcHBseSBhbiBhdXRvUm90YXRpb24gYW5kIHRoaXMgQ1NTUGx1Z2luXG5cdFx0ICogZG9lc24ndCBoYXZlIGFueSB0cmFuc2Zvcm0tcmVsYXRlZCBwcm9wZXJ0aWVzIG9mIGl0cyBvd24uIFlvdSBjYW4gY2FsbCB0aGlzIG1ldGhvZCBhcyBtYW55IHRpbWVzIGFzIHlvdVxuXHRcdCAqIHdhbnQgYW5kIGl0IHdvbid0IGNyZWF0ZSBkdXBsaWNhdGUgQ1NTUHJvcFR3ZWVucy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdGhyZWVEIGlmIHRydWUsIGl0IHNob3VsZCBhcHBseSAzRCB0d2VlbnMgKG90aGVyd2lzZSwganVzdCAyRCBvbmVzIGFyZSBmaW5lIGFuZCB0eXBpY2FsbHkgZmFzdGVyKVxuXHRcdCAqL1xuXHRcdHAuX2VuYWJsZVRyYW5zZm9ybXMgPSBmdW5jdGlvbih0aHJlZUQpIHtcblx0XHRcdHRoaXMuX3RyYW5zZm9ybSA9IHRoaXMuX3RyYW5zZm9ybSB8fCBfZ2V0VHJhbnNmb3JtKHRoaXMuX3RhcmdldCwgX2NzLCB0cnVlKTsgLy9lbnN1cmVzIHRoYXQgdGhlIGVsZW1lbnQgaGFzIGEgX2dzVHJhbnNmb3JtIHByb3BlcnR5IHdpdGggdGhlIGFwcHJvcHJpYXRlIHZhbHVlcy5cblx0XHRcdHRoaXMuX3RyYW5zZm9ybVR5cGUgPSAoISh0aGlzLl90cmFuc2Zvcm0uc3ZnICYmIF91c2VTVkdUcmFuc2Zvcm1BdHRyKSAmJiAodGhyZWVEIHx8IHRoaXMuX3RyYW5zZm9ybVR5cGUgPT09IDMpKSA/IDMgOiAyO1xuXHRcdH07XG5cblx0XHR2YXIgbGF6eVNldCA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdHRoaXMudFt0aGlzLnBdID0gdGhpcy5lO1xuXHRcdFx0dGhpcy5kYXRhLl9saW5rQ1NTUCh0aGlzLCB0aGlzLl9uZXh0LCBudWxsLCB0cnVlKTsgLy93ZSBwdXJwb3NlZnVsbHkga2VlcCB0aGlzLl9uZXh0IGV2ZW4gdGhvdWdoIGl0J2QgbWFrZSBzZW5zZSB0byBudWxsIGl0LCBidXQgdGhpcyBpcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiwgYXMgdGhpcyBoYXBwZW5zIGR1cmluZyB0aGUgd2hpbGUgKHB0KSB7fSBsb29wIGluIHNldFJhdGlvKCkgYXQgdGhlIGJvdHRvbSBvZiB3aGljaCBpdCBzZXRzIHB0ID0gcHQuX25leHQsIHNvIGlmIHdlIG51bGwgaXQsIHRoZSBsaW5rZWQgbGlzdCB3aWxsIGJlIGJyb2tlbiBpbiB0aGF0IGxvb3AuXG5cdFx0fTtcblx0XHQvKiogQHByaXZhdGUgR2l2ZXMgdXMgYSB3YXkgdG8gc2V0IGEgdmFsdWUgb24gdGhlIGZpcnN0IHJlbmRlciAoYW5kIG9ubHkgdGhlIGZpcnN0IHJlbmRlcikuICoqL1xuXHRcdHAuX2FkZExhenlTZXQgPSBmdW5jdGlvbih0LCBwLCB2KSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLl9maXJzdFBUID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCB0aGlzLl9maXJzdFBULCAyKTtcblx0XHRcdHB0LmUgPSB2O1xuXHRcdFx0cHQuc2V0UmF0aW8gPSBsYXp5U2V0O1xuXHRcdFx0cHQuZGF0YSA9IHRoaXM7XG5cdFx0fTtcblxuXHRcdC8qKiBAcHJpdmF0ZSAqKi9cblx0XHRwLl9saW5rQ1NTUCA9IGZ1bmN0aW9uKHB0LCBuZXh0LCBwcmV2LCByZW1vdmUpIHtcblx0XHRcdGlmIChwdCkge1xuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdG5leHQuX3ByZXYgPSBwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0Ll9wcmV2O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdC5fcHJldikge1xuXHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZmlyc3RQVCA9PT0gcHQpIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0cmVtb3ZlID0gdHJ1ZTsgLy9qdXN0IHRvIHByZXZlbnQgcmVzZXR0aW5nIHRoaXMuX2ZpcnN0UFQgNSBsaW5lcyBkb3duIGluIGNhc2UgcHQuX25leHQgaXMgbnVsbC4gKG9wdGltaXplZCBmb3Igc3BlZWQpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByZXYpIHtcblx0XHRcdFx0XHRwcmV2Ll9uZXh0ID0gcHQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXJlbW92ZSAmJiB0aGlzLl9maXJzdFBUID09PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0Ll9uZXh0ID0gbmV4dDtcblx0XHRcdFx0cHQuX3ByZXYgPSBwcmV2O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH07XG5cblx0XHQvL3dlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgaWYgYWxwaGEgb3IgYXV0b0FscGhhIGlzIGtpbGxlZCwgb3BhY2l0eSBpcyB0b28uIEFuZCBhdXRvQWxwaGEgYWZmZWN0cyB0aGUgXCJ2aXNpYmlsaXR5XCIgcHJvcGVydHkuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIGNvcHkgPSBsb29rdXAsXG5cdFx0XHRcdHB0LCBwLCB4Zmlyc3Q7XG5cdFx0XHRpZiAobG9va3VwLmF1dG9BbHBoYSB8fCBsb29rdXAuYWxwaGEpIHtcblx0XHRcdFx0Y29weSA9IHt9O1xuXHRcdFx0XHRmb3IgKHAgaW4gbG9va3VwKSB7IC8vY29weSB0aGUgbG9va3VwIHNvIHRoYXQgd2UncmUgbm90IGNoYW5naW5nIHRoZSBvcmlnaW5hbCB3aGljaCBtYXkgYmUgcGFzc2VkIGVsc2V3aGVyZS5cblx0XHRcdFx0XHRjb3B5W3BdID0gbG9va3VwW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvcHkub3BhY2l0eSA9IDE7XG5cdFx0XHRcdGlmIChjb3B5LmF1dG9BbHBoYSkge1xuXHRcdFx0XHRcdGNvcHkudmlzaWJpbGl0eSA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChsb29rdXAuY2xhc3NOYW1lICYmIChwdCA9IHRoaXMuX2NsYXNzTmFtZVBUKSkgeyAvL2ZvciBjbGFzc05hbWUgdHdlZW5zLCB3ZSBuZWVkIHRvIGtpbGwgYW55IGFzc29jaWF0ZWQgQ1NTUHJvcFR3ZWVucyB0b287IGEgbGlua2VkIGxpc3Qgc3RhcnRzIGF0IHRoZSBjbGFzc05hbWUncyBcInhmaXJzdFwiLlxuXHRcdFx0XHR4Zmlyc3QgPSBwdC54Zmlyc3Q7XG5cdFx0XHRcdGlmICh4Zmlyc3QgJiYgeGZpcnN0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0dGhpcy5fbGlua0NTU1AoeGZpcnN0Ll9wcmV2LCBwdC5fbmV4dCwgeGZpcnN0Ll9wcmV2Ll9wcmV2KTsgLy9icmVhayBvZmYgdGhlIHByZXZcblx0XHRcdFx0fSBlbHNlIGlmICh4Zmlyc3QgPT09IHRoaXMuX2ZpcnN0UFQpIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0dGhpcy5fbGlua0NTU1AocHQuX25leHQsIHB0Ll9uZXh0Ll9uZXh0LCB4Zmlyc3QuX3ByZXYpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NsYXNzTmFtZVBUID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBUd2VlblBsdWdpbi5wcm90b3R5cGUuX2tpbGwuY2FsbCh0aGlzLCBjb3B5KTtcblx0XHR9O1xuXG5cblxuXHRcdC8vdXNlZCBieSBjYXNjYWRlVG8oKSBmb3IgZ2F0aGVyaW5nIGFsbCB0aGUgc3R5bGUgcHJvcGVydGllcyBvZiBlYWNoIGNoaWxkIGVsZW1lbnQgaW50byBhbiBhcnJheSBmb3IgY29tcGFyaXNvbi5cblx0XHR2YXIgX2dldENoaWxkU3R5bGVzID0gZnVuY3Rpb24oZSwgcHJvcHMsIHRhcmdldHMpIHtcblx0XHRcdFx0dmFyIGNoaWxkcmVuLCBpLCBjaGlsZCwgdHlwZTtcblx0XHRcdFx0aWYgKGUuc2xpY2UpIHtcblx0XHRcdFx0XHRpID0gZS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRfZ2V0Q2hpbGRTdHlsZXMoZVtpXSwgcHJvcHMsIHRhcmdldHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hpbGRyZW4gPSBlLmNoaWxkTm9kZXM7XG5cdFx0XHRcdGkgPSBjaGlsZHJlbi5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHRcdFx0dHlwZSA9IGNoaWxkLnR5cGU7XG5cdFx0XHRcdFx0aWYgKGNoaWxkLnN0eWxlKSB7XG5cdFx0XHRcdFx0XHRwcm9wcy5wdXNoKF9nZXRBbGxTdHlsZXMoY2hpbGQpKTtcblx0XHRcdFx0XHRcdGlmICh0YXJnZXRzKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldHMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgodHlwZSA9PT0gMSB8fCB0eXBlID09PSA5IHx8IHR5cGUgPT09IDExKSAmJiBjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0X2dldENoaWxkU3R5bGVzKGNoaWxkLCBwcm9wcywgdGFyZ2V0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVHlwaWNhbGx5IG9ubHkgdXNlZnVsIGZvciBjbGFzc05hbWUgdHdlZW5zIHRoYXQgbWF5IGFmZmVjdCBjaGlsZCBlbGVtZW50cywgdGhpcyBtZXRob2QgY3JlYXRlcyBhIFR3ZWVuTGl0ZVxuXHRcdCAqIGFuZCB0aGVuIGNvbXBhcmVzIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIG9mIGFsbCB0aGUgdGFyZ2V0J3MgY2hpbGQgZWxlbWVudHMgYXQgdGhlIHR3ZWVuJ3Mgc3RhcnQgYW5kIGVuZCwgYW5kXG5cdFx0ICogaWYgYW55IGFyZSBkaWZmZXJlbnQsIGl0IGFsc28gY3JlYXRlcyB0d2VlbnMgZm9yIHRob3NlIGFuZCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgQUxMIG9mIHRoZSByZXN1bHRpbmdcblx0XHQgKiB0d2VlbnMgKHNvIHRoYXQgeW91IGNhbiBlYXNpbHkgYWRkKCkgdGhlbSB0byBhIFRpbWVsaW5lTGl0ZSwgZm9yIGV4YW1wbGUpLiBUaGUgcmVhc29uIHRoaXMgZnVuY3Rpb25hbGl0eSBpc1xuXHRcdCAqIHdyYXBwZWQgaW50byBhIHNlcGFyYXRlIHN0YXRpYyBtZXRob2Qgb2YgQ1NTUGx1Z2luIGluc3RlYWQgb2YgYmVpbmcgaW50ZWdyYXRlZCBpbnRvIGFsbCByZWd1bGFyIGNsYXNzTmFtZSB0d2VlbnNcblx0XHQgKiBpcyBiZWNhdXNlIGl0IGNyZWF0ZXMgZW50aXJlbHkgbmV3IHR3ZWVucyB0aGF0IG1heSBoYXZlIGNvbXBsZXRlbHkgZGlmZmVyZW50IHRhcmdldHMgdGhhbiB0aGUgb3JpZ2luYWwgdHdlZW4sXG5cdFx0ICogc28gaWYgdGhleSB3ZXJlIGFsbCBsdW1wZWQgaW50byB0aGUgb3JpZ2luYWwgdHdlZW4gaW5zdGFuY2UsIGl0IHdvdWxkIGJlIGluY29uc2lzdGVudCB3aXRoIHRoZSByZXN0IG9mIHRoZSBBUElcblx0XHQgKiBhbmQgaXQgd291bGQgY3JlYXRlIG90aGVyIHByb2JsZW1zLiBGb3IgZXhhbXBsZTpcblx0XHQgKiAgLSBJZiBJIGNyZWF0ZSBhIHR3ZWVuIG9mIGVsZW1lbnRBLCB0aGF0IHR3ZWVuIGluc3RhbmNlIG1heSBzdWRkZW5seSBjaGFuZ2UgaXRzIHRhcmdldCB0byBpbmNsdWRlIDUwIG90aGVyIGVsZW1lbnRzICh1bmludHVpdGl2ZSBpZiBJIHNwZWNpZmljYWxseSBkZWZpbmVkIHRoZSB0YXJnZXQgSSB3YW50ZWQpXG5cdFx0ICogIC0gV2UgY2FuJ3QganVzdCBjcmVhdGUgbmV3IGluZGVwZW5kZW50IHR3ZWVucyBiZWNhdXNlIG90aGVyd2lzZSwgd2hhdCBoYXBwZW5zIGlmIHRoZSBvcmlnaW5hbC9wYXJlbnQgdHdlZW4gaXMgcmV2ZXJzZWQgb3IgcGF1c2Ugb3IgZHJvcHBlZCBpbnRvIGEgVGltZWxpbmVMaXRlIGZvciB0aWdodCBjb250cm9sPyBZb3UnZCBleHBlY3QgdGhhdCB0d2VlbidzIGJlaGF2aW9yIHRvIGFmZmVjdCBhbGwgdGhlIG90aGVycy5cblx0XHQgKiAgLSBBbmFseXppbmcgZXZlcnkgc3R5bGUgcHJvcGVydHkgb2YgZXZlcnkgY2hpbGQgYmVmb3JlIGFuZCBhZnRlciB0aGUgdHdlZW4gaXMgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbiB3aGVuIHRoZXJlIGFyZSBtYW55IGNoaWxkcmVuLCBzbyB0aGlzIGJlaGF2aW9yIHNob3VsZG4ndCBiZSBpbXBvc2VkIG9uIGFsbCBjbGFzc05hbWUgdHdlZW5zIGJ5IGRlZmF1bHQsIGVzcGVjaWFsbHkgc2luY2UgaXQncyBwcm9iYWJseSByYXJlIHRoYXQgdGhpcyBleHRyYSBmdW5jdGlvbmFsaXR5IGlzIG5lZWRlZC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgb2JqZWN0IHRvIGJlIHR3ZWVuZWRcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gRHVyYXRpb24gaW4gc2Vjb25kcyAob3IgZnJhbWVzIGZvciBmcmFtZXMtYmFzZWQgdHdlZW5zKVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgZW5kIHZhbHVlcywgbGlrZSB7Y2xhc3NOYW1lOlwibmV3Q2xhc3NcIiwgZWFzZTpMaW5lYXIuZWFzZU5vbmV9XG5cdFx0ICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIFR3ZWVuTGl0ZSBpbnN0YW5jZXNcblx0XHQgKi9cblx0XHRDU1NQbHVnaW4uY2FzY2FkZVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0dmFyIHR3ZWVuID0gVHdlZW5MaXRlLnRvKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpLFxuXHRcdFx0XHRyZXN1bHRzID0gW3R3ZWVuXSxcblx0XHRcdFx0YiA9IFtdLFxuXHRcdFx0XHRlID0gW10sXG5cdFx0XHRcdHRhcmdldHMgPSBbXSxcblx0XHRcdFx0X3Jlc2VydmVkUHJvcHMgPSBUd2VlbkxpdGUuX2ludGVybmFscy5yZXNlcnZlZFByb3BzLFxuXHRcdFx0XHRpLCBkaWZzLCBwLCBmcm9tO1xuXHRcdFx0dGFyZ2V0ID0gdHdlZW4uX3RhcmdldHMgfHwgdHdlZW4udGFyZ2V0O1xuXHRcdFx0X2dldENoaWxkU3R5bGVzKHRhcmdldCwgYiwgdGFyZ2V0cyk7XG5cdFx0XHR0d2Vlbi5yZW5kZXIoZHVyYXRpb24sIHRydWUsIHRydWUpO1xuXHRcdFx0X2dldENoaWxkU3R5bGVzKHRhcmdldCwgZSk7XG5cdFx0XHR0d2Vlbi5yZW5kZXIoMCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHR0d2Vlbi5fZW5hYmxlZCh0cnVlKTtcblx0XHRcdGkgPSB0YXJnZXRzLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRkaWZzID0gX2Nzc0RpZih0YXJnZXRzW2ldLCBiW2ldLCBlW2ldKTtcblx0XHRcdFx0aWYgKGRpZnMuZmlyc3RNUFQpIHtcblx0XHRcdFx0XHRkaWZzID0gZGlmcy5kaWZzO1xuXHRcdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdFx0XHRpZiAoX3Jlc2VydmVkUHJvcHNbcF0pIHtcblx0XHRcdFx0XHRcdFx0ZGlmc1twXSA9IHZhcnNbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZyb20gPSB7fTtcblx0XHRcdFx0XHRmb3IgKHAgaW4gZGlmcykge1xuXHRcdFx0XHRcdFx0ZnJvbVtwXSA9IGJbaV1bcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdHMucHVzaChUd2VlbkxpdGUuZnJvbVRvKHRhcmdldHNbaV0sIGR1cmF0aW9uLCBmcm9tLCBkaWZzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0XHRUd2VlblBsdWdpbi5hY3RpdmF0ZShbQ1NTUGx1Z2luXSk7XG5cdFx0cmV0dXJuIENTU1BsdWdpbjtcblxuXHR9LCB0cnVlKTtcblxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBSb3VuZFByb3BzUGx1Z2luXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0KGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIFJvdW5kUHJvcHNQbHVnaW4gPSBfZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtcblx0XHRcdFx0cHJvcE5hbWU6IFwicm91bmRQcm9wc1wiLFxuXHRcdFx0XHRwcmlvcml0eTogLTEsXG5cdFx0XHRcdEFQSTogMixcblxuXHRcdFx0XHQvL2NhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBpcyB3aGVyZSBpbml0aWFsIHZhbHVlcyBzaG91bGQgYmUgcmVjb3JkZWQgYW5kIGFueSBzZXR1cCByb3V0aW5lcyBzaG91bGQgcnVuLlxuXHRcdFx0XHRpbml0OiBmdW5jdGlvbih0YXJnZXQsIHZhbHVlLCB0d2Vlbikge1xuXHRcdFx0XHRcdHRoaXMuX3R3ZWVuID0gdHdlZW47XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSksXG5cdFx0XHRwID0gUm91bmRQcm9wc1BsdWdpbi5wcm90b3R5cGU7XG5cblx0XHRwLl9vbkluaXRBbGxQcm9wcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fdHdlZW4sXG5cdFx0XHRcdHJwID0gKHR3ZWVuLnZhcnMucm91bmRQcm9wcyBpbnN0YW5jZW9mIEFycmF5KSA/IHR3ZWVuLnZhcnMucm91bmRQcm9wcyA6IHR3ZWVuLnZhcnMucm91bmRQcm9wcy5zcGxpdChcIixcIiksXG5cdFx0XHRcdGkgPSBycC5sZW5ndGgsXG5cdFx0XHRcdGxvb2t1cCA9IHt9LFxuXHRcdFx0XHRycHQgPSB0d2Vlbi5fcHJvcExvb2t1cC5yb3VuZFByb3BzLFxuXHRcdFx0XHRwcm9wLCBwdCwgbmV4dDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRsb29rdXBbcnBbaV1dID0gMTtcblx0XHRcdH1cblx0XHRcdGkgPSBycC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0cHJvcCA9IHJwW2ldO1xuXHRcdFx0XHRwdCA9IHR3ZWVuLl9maXJzdFBUO1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRuZXh0ID0gcHQuX25leHQ7IC8vcmVjb3JkIGhlcmUsIGJlY2F1c2UgaXQgbWF5IGdldCByZW1vdmVkXG5cdFx0XHRcdFx0aWYgKHB0LnBnKSB7XG5cdFx0XHRcdFx0XHRwdC50Ll9yb3VuZFByb3BzKGxvb2t1cCwgdHJ1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC5uID09PSBwcm9wKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGQocHQudCwgcHJvcCwgcHQucywgcHQuYyk7XG5cdFx0XHRcdFx0XHQvL3JlbW92ZSBmcm9tIGxpbmtlZCBsaXN0XG5cdFx0XHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdFx0XHRuZXh0Ll9wcmV2ID0gcHQuX3ByZXY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAocHQuX3ByZXYpIHtcblx0XHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBuZXh0O1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fZmlyc3RQVCA9PT0gcHQpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4uX2ZpcnN0UFQgPSBuZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cHQuX25leHQgPSBwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0XHR0d2Vlbi5fcHJvcExvb2t1cFtwcm9wXSA9IHJwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdHAuX2FkZCA9IGZ1bmN0aW9uKHRhcmdldCwgcCwgcywgYykge1xuXHRcdFx0dGhpcy5fYWRkVHdlZW4odGFyZ2V0LCBwLCBzLCBzICsgYywgcCwgdHJ1ZSk7XG5cdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdH07XG5cblx0fSgpKTtcblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEF0dHJQbHVnaW5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtcblx0XHRwcm9wTmFtZTogXCJhdHRyXCIsXG5cdFx0QVBJOiAyLFxuXHRcdHZlcnNpb246IFwiMC4zLjNcIixcblxuXHRcdC8vY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSwgdHdlZW4pIHtcblx0XHRcdHZhciBwLCBzdGFydCwgZW5kO1xuXHRcdFx0aWYgKHR5cGVvZih0YXJnZXQuc2V0QXR0cmlidXRlKSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblx0XHRcdHRoaXMuX3Byb3h5ID0ge307XG5cdFx0XHR0aGlzLl9zdGFydCA9IHt9OyAvLyB3ZSByZWNvcmQgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgZXhhY3RseSBhcyB0aGV5IGFyZSBpbiBjYXNlIHRoZXkncmUgc3RyaW5ncyAobm90IG51bWJlcnMpIC0gd2UgbmVlZCB0byBiZSBhYmxlIHRvIHJldmVydCB0byB0aGVtIGNsZWFubHkuXG5cdFx0XHR0aGlzLl9lbmQgPSB7fTtcblx0XHRcdGZvciAocCBpbiB2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLl9zdGFydFtwXSA9IHRoaXMuX3Byb3h5W3BdID0gc3RhcnQgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKHApO1xuXHRcdFx0XHRlbmQgPSB0aGlzLl9hZGRUd2Vlbih0aGlzLl9wcm94eSwgcCwgcGFyc2VGbG9hdChzdGFydCksIHZhbHVlW3BdLCBwKTtcblx0XHRcdFx0dGhpcy5fZW5kW3BdID0gZW5kID8gZW5kLnMgKyBlbmQuYyA6IHZhbHVlW3BdO1xuXHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8vY2FsbGVkIGVhY2ggdGltZSB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkLCBhbmQgdGhlIHJhdGlvIGdldHMgcGFzc2VkIGFzIHRoZSBvbmx5IHBhcmFtZXRlciAodHlwaWNhbGx5IGl0J3MgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIGJ1dCBpdCBjYW4gZXhjZWVkIHRob3NlIHdoZW4gdXNpbmcgYW4gZWFzZSBsaWtlIEVsYXN0aWMuZWFzZU91dCBvciBCYWNrLmVhc2VPdXQsIGV0Yy4pXG5cdFx0c2V0OiBmdW5jdGlvbihyYXRpbykge1xuXHRcdFx0dGhpcy5fc3VwZXIuc2V0UmF0aW8uY2FsbCh0aGlzLCByYXRpbyk7XG5cdFx0XHR2YXIgcHJvcHMgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aCxcblx0XHRcdFx0bG9va3VwID0gKHJhdGlvID09PSAxKSA/IHRoaXMuX2VuZCA6IHJhdGlvID8gdGhpcy5fcHJveHkgOiB0aGlzLl9zdGFydCxcblx0XHRcdFx0cDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdHRoaXMuX3RhcmdldC5zZXRBdHRyaWJ1dGUocCwgbG9va3VwW3BdICsgXCJcIik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0pO1xuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGlyZWN0aW9uYWxSb3RhdGlvblBsdWdpblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe1xuXHRcdHByb3BOYW1lOiBcImRpcmVjdGlvbmFsUm90YXRpb25cIixcblx0XHR2ZXJzaW9uOiBcIjAuMi4xXCIsXG5cdFx0QVBJOiAyLFxuXG5cdFx0Ly9jYWxsZWQgd2hlbiB0aGUgdHdlZW4gcmVuZGVycyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMgaXMgd2hlcmUgaW5pdGlhbCB2YWx1ZXMgc2hvdWxkIGJlIHJlY29yZGVkIGFuZCBhbnkgc2V0dXAgcm91dGluZXMgc2hvdWxkIHJ1bi5cblx0XHRpbml0OiBmdW5jdGlvbih0YXJnZXQsIHZhbHVlLCB0d2Vlbikge1xuXHRcdFx0aWYgKHR5cGVvZih2YWx1ZSkgIT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0dmFsdWUgPSB7cm90YXRpb246dmFsdWV9O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5maW5hbHMgPSB7fTtcblx0XHRcdHZhciBjYXAgPSAodmFsdWUudXNlUmFkaWFucyA9PT0gdHJ1ZSkgPyBNYXRoLlBJICogMiA6IDM2MCxcblx0XHRcdFx0bWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdHAsIHYsIHN0YXJ0LCBlbmQsIGRpZiwgc3BsaXQ7XG5cdFx0XHRmb3IgKHAgaW4gdmFsdWUpIHtcblx0XHRcdFx0aWYgKHAgIT09IFwidXNlUmFkaWFuc1wiKSB7XG5cdFx0XHRcdFx0c3BsaXQgPSAodmFsdWVbcF0gKyBcIlwiKS5zcGxpdChcIl9cIik7XG5cdFx0XHRcdFx0diA9IHNwbGl0WzBdO1xuXHRcdFx0XHRcdHN0YXJ0ID0gcGFyc2VGbG9hdCggKHR5cGVvZih0YXJnZXRbcF0pICE9PSBcImZ1bmN0aW9uXCIpID8gdGFyZ2V0W3BdIDogdGFyZ2V0WyAoKHAuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKSkgXSgpICk7XG5cdFx0XHRcdFx0ZW5kID0gdGhpcy5maW5hbHNbcF0gPSAodHlwZW9mKHYpID09PSBcInN0cmluZ1wiICYmIHYuY2hhckF0KDEpID09PSBcIj1cIikgPyBzdGFydCArIHBhcnNlSW50KHYuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIE51bWJlcih2LnN1YnN0cigyKSkgOiBOdW1iZXIodikgfHwgMDtcblx0XHRcdFx0XHRkaWYgPSBlbmQgLSBzdGFydDtcblx0XHRcdFx0XHRpZiAoc3BsaXQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR2ID0gc3BsaXQuam9pbihcIl9cIik7XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwic2hvcnRcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IGRpZiAlIGNhcDtcblx0XHRcdFx0XHRcdFx0aWYgKGRpZiAhPT0gZGlmICUgKGNhcCAvIDIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlmID0gKGRpZiA8IDApID8gZGlmICsgY2FwIDogZGlmIC0gY2FwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwiX2N3XCIpICE9PSAtMSAmJiBkaWYgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9ICgoZGlmICsgY2FwICogOTk5OTk5OTk5OSkgJSBjYXApIC0gKChkaWYgLyBjYXApIHwgMCkgKiBjYXA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYuaW5kZXhPZihcImNjd1wiKSAhPT0gLTEgJiYgZGlmID4gMCkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoKGRpZiAtIGNhcCAqIDk5OTk5OTk5OTkpICUgY2FwKSAtICgoZGlmIC8gY2FwKSB8IDApICogY2FwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZGlmID4gbWluIHx8IGRpZiA8IC1taW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FkZFR3ZWVuKHRhcmdldCwgcCwgc3RhcnQsIHN0YXJ0ICsgZGlmLCBwKTtcblx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly9jYWxsZWQgZWFjaCB0aW1lIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQsIGFuZCB0aGUgcmF0aW8gZ2V0cyBwYXNzZWQgYXMgdGhlIG9ubHkgcGFyYW1ldGVyICh0eXBpY2FsbHkgaXQncyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgYnV0IGl0IGNhbiBleGNlZWQgdGhvc2Ugd2hlbiB1c2luZyBhbiBlYXNlIGxpa2UgRWxhc3RpYy5lYXNlT3V0IG9yIEJhY2suZWFzZU91dCwgZXRjLilcblx0XHRzZXQ6IGZ1bmN0aW9uKHJhdGlvKSB7XG5cdFx0XHR2YXIgcHQ7XG5cdFx0XHRpZiAocmF0aW8gIT09IDEpIHtcblx0XHRcdFx0dGhpcy5fc3VwZXIuc2V0UmF0aW8uY2FsbCh0aGlzLCByYXRpbyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdGlmIChwdC5mKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdKHRoaXMuZmluYWxzW3B0LnBdKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHRoaXMuZmluYWxzW3B0LnBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0pLl9hdXRvQ1NTID0gdHJ1ZTtcblxuXG5cblxuXG5cblxuXHRcblx0XG5cdFxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBFYXNlUGFja1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcImVhc2luZy5CYWNrXCIsIFtcImVhc2luZy5FYXNlXCJdLCBmdW5jdGlvbihFYXNlKSB7XG5cdFx0XG5cdFx0dmFyIHcgPSAoX2dzU2NvcGUuR3JlZW5Tb2NrR2xvYmFscyB8fCBfZ3NTY29wZSksXG5cdFx0XHRncyA9IHcuY29tLmdyZWVuc29jayxcblx0XHRcdF8yUEkgPSBNYXRoLlBJICogMixcblx0XHRcdF9IQUxGX1BJID0gTWF0aC5QSSAvIDIsXG5cdFx0XHRfY2xhc3MgPSBncy5fY2xhc3MsXG5cdFx0XHRfY3JlYXRlID0gZnVuY3Rpb24obiwgZikge1xuXHRcdFx0XHR2YXIgQyA9IF9jbGFzcyhcImVhc2luZy5cIiArIG4sIGZ1bmN0aW9uKCl7fSwgdHJ1ZSksXG5cdFx0XHRcdFx0cCA9IEMucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRcdFx0cC5jb25zdHJ1Y3RvciA9IEM7XG5cdFx0XHRcdHAuZ2V0UmF0aW8gPSBmO1xuXHRcdFx0XHRyZXR1cm4gQztcblx0XHRcdH0sXG5cdFx0XHRfZWFzZVJlZyA9IEVhc2UucmVnaXN0ZXIgfHwgZnVuY3Rpb24oKXt9LCAvL3B1dCBhbiBlbXB0eSBmdW5jdGlvbiBpbiBwbGFjZSBqdXN0IGFzIGEgc2FmZXR5IG1lYXN1cmUgaW4gY2FzZSBzb21lb25lIGxvYWRzIGFuIE9MRCB2ZXJzaW9uIG9mIFR3ZWVuTGl0ZS5qcyB3aGVyZSBFYXNlLnJlZ2lzdGVyIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRfd3JhcCA9IGZ1bmN0aW9uKG5hbWUsIEVhc2VPdXQsIEVhc2VJbiwgRWFzZUluT3V0LCBhbGlhc2VzKSB7XG5cdFx0XHRcdHZhciBDID0gX2NsYXNzKFwiZWFzaW5nLlwiK25hbWUsIHtcblx0XHRcdFx0XHRlYXNlT3V0Om5ldyBFYXNlT3V0KCksXG5cdFx0XHRcdFx0ZWFzZUluOm5ldyBFYXNlSW4oKSxcblx0XHRcdFx0XHRlYXNlSW5PdXQ6bmV3IEVhc2VJbk91dCgpXG5cdFx0XHRcdH0sIHRydWUpO1xuXHRcdFx0XHRfZWFzZVJlZyhDLCBuYW1lKTtcblx0XHRcdFx0cmV0dXJuIEM7XG5cdFx0XHR9LFxuXHRcdFx0RWFzZVBvaW50ID0gZnVuY3Rpb24odGltZSwgdmFsdWUsIG5leHQpIHtcblx0XHRcdFx0dGhpcy50ID0gdGltZTtcblx0XHRcdFx0dGhpcy52ID0gdmFsdWU7XG5cdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0dGhpcy5uZXh0ID0gbmV4dDtcblx0XHRcdFx0XHRuZXh0LnByZXYgPSB0aGlzO1xuXHRcdFx0XHRcdHRoaXMuYyA9IG5leHQudiAtIHZhbHVlO1xuXHRcdFx0XHRcdHRoaXMuZ2FwID0gbmV4dC50IC0gdGltZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly9CYWNrXG5cdFx0XHRfY3JlYXRlQmFjayA9IGZ1bmN0aW9uKG4sIGYpIHtcblx0XHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIgKyBuLCBmdW5jdGlvbihvdmVyc2hvb3QpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3AxID0gKG92ZXJzaG9vdCB8fCBvdmVyc2hvb3QgPT09IDApID8gb3ZlcnNob290IDogMS43MDE1ODtcblx0XHRcdFx0XHRcdHRoaXMuX3AyID0gdGhpcy5fcDEgKiAxLjUyNTtcblx0XHRcdFx0XHR9LCB0cnVlKSxcblx0XHRcdFx0XHRwID0gQy5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdFx0XHRwLmNvbnN0cnVjdG9yID0gQztcblx0XHRcdFx0cC5nZXRSYXRpbyA9IGY7XG5cdFx0XHRcdHAuY29uZmlnID0gZnVuY3Rpb24ob3ZlcnNob290KSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBDKG92ZXJzaG9vdCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBDO1xuXHRcdFx0fSxcblxuXHRcdFx0QmFjayA9IF93cmFwKFwiQmFja1wiLFxuXHRcdFx0XHRfY3JlYXRlQmFjayhcIkJhY2tPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRcdHJldHVybiAoKHAgPSBwIC0gMSkgKiBwICogKCh0aGlzLl9wMSArIDEpICogcCArIHRoaXMuX3AxKSArIDEpO1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0X2NyZWF0ZUJhY2soXCJCYWNrSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRcdHJldHVybiBwICogcCAqICgodGhpcy5fcDEgKyAxKSAqIHAgLSB0aGlzLl9wMSk7XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRfY3JlYXRlQmFjayhcIkJhY2tJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdFx0cmV0dXJuICgocCAqPSAyKSA8IDEpID8gMC41ICogcCAqIHAgKiAoKHRoaXMuX3AyICsgMSkgKiBwIC0gdGhpcy5fcDIpIDogMC41ICogKChwIC09IDIpICogcCAqICgodGhpcy5fcDIgKyAxKSAqIHAgKyB0aGlzLl9wMikgKyAyKTtcblx0XHRcdFx0fSlcblx0XHRcdCksXG5cblxuXHRcdFx0Ly9TbG93TW9cblx0XHRcdFNsb3dNbyA9IF9jbGFzcyhcImVhc2luZy5TbG93TW9cIiwgZnVuY3Rpb24obGluZWFyUmF0aW8sIHBvd2VyLCB5b3lvTW9kZSkge1xuXHRcdFx0XHRwb3dlciA9IChwb3dlciB8fCBwb3dlciA9PT0gMCkgPyBwb3dlciA6IDAuNztcblx0XHRcdFx0aWYgKGxpbmVhclJhdGlvID09IG51bGwpIHtcblx0XHRcdFx0XHRsaW5lYXJSYXRpbyA9IDAuNztcblx0XHRcdFx0fSBlbHNlIGlmIChsaW5lYXJSYXRpbyA+IDEpIHtcblx0XHRcdFx0XHRsaW5lYXJSYXRpbyA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcCA9IChsaW5lYXJSYXRpbyAhPT0gMSkgPyBwb3dlciA6IDA7XG5cdFx0XHRcdHRoaXMuX3AxID0gKDEgLSBsaW5lYXJSYXRpbykgLyAyO1xuXHRcdFx0XHR0aGlzLl9wMiA9IGxpbmVhclJhdGlvO1xuXHRcdFx0XHR0aGlzLl9wMyA9IHRoaXMuX3AxICsgdGhpcy5fcDI7XG5cdFx0XHRcdHRoaXMuX2NhbGNFbmQgPSAoeW95b01vZGUgPT09IHRydWUpO1xuXHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRwID0gU2xvd01vLnByb3RvdHlwZSA9IG5ldyBFYXNlKCksXG5cdFx0XHRTdGVwcGVkRWFzZSwgUm91Z2hFYXNlLCBfY3JlYXRlRWxhc3RpYztcblxuXHRcdHAuY29uc3RydWN0b3IgPSBTbG93TW87XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdHZhciByID0gcCArICgwLjUgLSBwKSAqIHRoaXMuX3A7XG5cdFx0XHRpZiAocCA8IHRoaXMuX3AxKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYWxjRW5kID8gMSAtICgocCA9IDEgLSAocCAvIHRoaXMuX3AxKSkgKiBwKSA6IHIgLSAoKHAgPSAxIC0gKHAgLyB0aGlzLl9wMSkpICogcCAqIHAgKiBwICogcik7XG5cdFx0XHR9IGVsc2UgaWYgKHAgPiB0aGlzLl9wMykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FsY0VuZCA/IDEgLSAocCA9IChwIC0gdGhpcy5fcDMpIC8gdGhpcy5fcDEpICogcCA6IHIgKyAoKHAgLSByKSAqIChwID0gKHAgLSB0aGlzLl9wMykgLyB0aGlzLl9wMSkgKiBwICogcCAqIHApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGNFbmQgPyAxIDogcjtcblx0XHR9O1xuXHRcdFNsb3dNby5lYXNlID0gbmV3IFNsb3dNbygwLjcsIDAuNyk7XG5cblx0XHRwLmNvbmZpZyA9IFNsb3dNby5jb25maWcgPSBmdW5jdGlvbihsaW5lYXJSYXRpbywgcG93ZXIsIHlveW9Nb2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNsb3dNbyhsaW5lYXJSYXRpbywgcG93ZXIsIHlveW9Nb2RlKTtcblx0XHR9O1xuXG5cblx0XHQvL1N0ZXBwZWRFYXNlXG5cdFx0U3RlcHBlZEVhc2UgPSBfY2xhc3MoXCJlYXNpbmcuU3RlcHBlZEVhc2VcIiwgZnVuY3Rpb24oc3RlcHMpIHtcblx0XHRcdFx0c3RlcHMgPSBzdGVwcyB8fCAxO1xuXHRcdFx0XHR0aGlzLl9wMSA9IDEgLyBzdGVwcztcblx0XHRcdFx0dGhpcy5fcDIgPSBzdGVwcyArIDE7XG5cdFx0XHR9LCB0cnVlKTtcblx0XHRwID0gU3RlcHBlZEVhc2UucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRwLmNvbnN0cnVjdG9yID0gU3RlcHBlZEVhc2U7XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdGlmIChwIDwgMCkge1xuXHRcdFx0XHRwID0gMDtcblx0XHRcdH0gZWxzZSBpZiAocCA+PSAxKSB7XG5cdFx0XHRcdHAgPSAwLjk5OTk5OTk5OTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAoKHRoaXMuX3AyICogcCkgPj4gMCkgKiB0aGlzLl9wMTtcblx0XHR9O1xuXHRcdHAuY29uZmlnID0gU3RlcHBlZEVhc2UuY29uZmlnID0gZnVuY3Rpb24oc3RlcHMpIHtcblx0XHRcdHJldHVybiBuZXcgU3RlcHBlZEVhc2Uoc3RlcHMpO1xuXHRcdH07XG5cblxuXHRcdC8vUm91Z2hFYXNlXG5cdFx0Um91Z2hFYXNlID0gX2NsYXNzKFwiZWFzaW5nLlJvdWdoRWFzZVwiLCBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHR2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdHZhciB0YXBlciA9IHZhcnMudGFwZXIgfHwgXCJub25lXCIsXG5cdFx0XHRcdGEgPSBbXSxcblx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0cG9pbnRzID0gKHZhcnMucG9pbnRzIHx8IDIwKSB8IDAsXG5cdFx0XHRcdGkgPSBwb2ludHMsXG5cdFx0XHRcdHJhbmRvbWl6ZSA9ICh2YXJzLnJhbmRvbWl6ZSAhPT0gZmFsc2UpLFxuXHRcdFx0XHRjbGFtcCA9ICh2YXJzLmNsYW1wID09PSB0cnVlKSxcblx0XHRcdFx0dGVtcGxhdGUgPSAodmFycy50ZW1wbGF0ZSBpbnN0YW5jZW9mIEVhc2UpID8gdmFycy50ZW1wbGF0ZSA6IG51bGwsXG5cdFx0XHRcdHN0cmVuZ3RoID0gKHR5cGVvZih2YXJzLnN0cmVuZ3RoKSA9PT0gXCJudW1iZXJcIikgPyB2YXJzLnN0cmVuZ3RoICogMC40IDogMC40LFxuXHRcdFx0XHR4LCB5LCBidW1wLCBpbnZYLCBvYmosIHBudDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHR4ID0gcmFuZG9taXplID8gTWF0aC5yYW5kb20oKSA6ICgxIC8gcG9pbnRzKSAqIGk7XG5cdFx0XHRcdHkgPSB0ZW1wbGF0ZSA/IHRlbXBsYXRlLmdldFJhdGlvKHgpIDogeDtcblx0XHRcdFx0aWYgKHRhcGVyID09PSBcIm5vbmVcIikge1xuXHRcdFx0XHRcdGJ1bXAgPSBzdHJlbmd0aDtcblx0XHRcdFx0fSBlbHNlIGlmICh0YXBlciA9PT0gXCJvdXRcIikge1xuXHRcdFx0XHRcdGludlggPSAxIC0geDtcblx0XHRcdFx0XHRidW1wID0gaW52WCAqIGludlggKiBzdHJlbmd0aDtcblx0XHRcdFx0fSBlbHNlIGlmICh0YXBlciA9PT0gXCJpblwiKSB7XG5cdFx0XHRcdFx0YnVtcCA9IHggKiB4ICogc3RyZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSBpZiAoeCA8IDAuNSkgeyAgLy9cImJvdGhcIiAoc3RhcnQpXG5cdFx0XHRcdFx0aW52WCA9IHggKiAyO1xuXHRcdFx0XHRcdGJ1bXAgPSBpbnZYICogaW52WCAqIDAuNSAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2Uge1x0XHRcdFx0Ly9cImJvdGhcIiAoZW5kKVxuXHRcdFx0XHRcdGludlggPSAoMSAtIHgpICogMjtcblx0XHRcdFx0XHRidW1wID0gaW52WCAqIGludlggKiAwLjUgKiBzdHJlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmFuZG9taXplKSB7XG5cdFx0XHRcdFx0eSArPSAoTWF0aC5yYW5kb20oKSAqIGJ1bXApIC0gKGJ1bXAgKiAwLjUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGkgJSAyKSB7XG5cdFx0XHRcdFx0eSArPSBidW1wICogMC41O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHkgLT0gYnVtcCAqIDAuNTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2xhbXApIHtcblx0XHRcdFx0XHRpZiAoeSA+IDEpIHtcblx0XHRcdFx0XHRcdHkgPSAxO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoeSA8IDApIHtcblx0XHRcdFx0XHRcdHkgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRhW2NudCsrXSA9IHt4OngsIHk6eX07XG5cdFx0XHR9XG5cdFx0XHRhLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYS54IC0gYi54O1xuXHRcdFx0fSk7XG5cblx0XHRcdHBudCA9IG5ldyBFYXNlUG9pbnQoMSwgMSwgbnVsbCk7XG5cdFx0XHRpID0gcG9pbnRzO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdG9iaiA9IGFbaV07XG5cdFx0XHRcdHBudCA9IG5ldyBFYXNlUG9pbnQob2JqLngsIG9iai55LCBwbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9wcmV2ID0gbmV3IEVhc2VQb2ludCgwLCAwLCAocG50LnQgIT09IDApID8gcG50IDogcG50Lm5leHQpO1xuXHRcdH0sIHRydWUpO1xuXHRcdHAgPSBSb3VnaEVhc2UucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRwLmNvbnN0cnVjdG9yID0gUm91Z2hFYXNlO1xuXHRcdHAuZ2V0UmF0aW8gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHR2YXIgcG50ID0gdGhpcy5fcHJldjtcblx0XHRcdGlmIChwID4gcG50LnQpIHtcblx0XHRcdFx0d2hpbGUgKHBudC5uZXh0ICYmIHAgPj0gcG50LnQpIHtcblx0XHRcdFx0XHRwbnQgPSBwbnQubmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwbnQgPSBwbnQucHJldjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlIChwbnQucHJldiAmJiBwIDw9IHBudC50KSB7XG5cdFx0XHRcdFx0cG50ID0gcG50LnByZXY7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX3ByZXYgPSBwbnQ7XG5cdFx0XHRyZXR1cm4gKHBudC52ICsgKChwIC0gcG50LnQpIC8gcG50LmdhcCkgKiBwbnQuYyk7XG5cdFx0fTtcblx0XHRwLmNvbmZpZyA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgUm91Z2hFYXNlKHZhcnMpO1xuXHRcdH07XG5cdFx0Um91Z2hFYXNlLmVhc2UgPSBuZXcgUm91Z2hFYXNlKCk7XG5cblxuXHRcdC8vQm91bmNlXG5cdFx0X3dyYXAoXCJCb3VuY2VcIixcblx0XHRcdF9jcmVhdGUoXCJCb3VuY2VPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRpZiAocCA8IDEgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIHAgKiBwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyIC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAocCAtPSAxLjUgLyAyLjc1KSAqIHAgKyAwLjc1O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyLjUgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChwIC09IDIuMjUgLyAyLjc1KSAqIHAgKyAwLjkzNzU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChwIC09IDIuNjI1IC8gMi43NSkgKiBwICsgMC45ODQzNzU7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJCb3VuY2VJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdGlmICgocCA9IDEgLSBwKSA8IDEgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDEgLSAoNy41NjI1ICogcCAqIHApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyIC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiAxIC0gKDcuNTYyNSAqIChwIC09IDEuNSAvIDIuNzUpICogcCArIDAuNzUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyLjUgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDEgLSAoNy41NjI1ICogKHAgLT0gMi4yNSAvIDIuNzUpICogcCArIDAuOTM3NSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIDEgLSAoNy41NjI1ICogKHAgLT0gMi42MjUgLyAyLjc1KSAqIHAgKyAwLjk4NDM3NSk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJCb3VuY2VJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHZhciBpbnZlcnQgPSAocCA8IDAuNSk7XG5cdFx0XHRcdGlmIChpbnZlcnQpIHtcblx0XHRcdFx0XHRwID0gMSAtIChwICogMik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cCA9IChwICogMikgLSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwIDwgMSAvIDIuNzUpIHtcblx0XHRcdFx0XHRwID0gNy41NjI1ICogcCAqIHA7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cCA9IDcuNTYyNSAqIChwIC09IDEuNSAvIDIuNzUpICogcCArIDAuNzU7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIuNSAvIDIuNzUpIHtcblx0XHRcdFx0XHRwID0gNy41NjI1ICogKHAgLT0gMi4yNSAvIDIuNzUpICogcCArIDAuOTM3NTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwID0gNy41NjI1ICogKHAgLT0gMi42MjUgLyAyLjc1KSAqIHAgKyAwLjk4NDM3NTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gaW52ZXJ0ID8gKDEgLSBwKSAqIDAuNSA6IHAgKiAwLjUgKyAwLjU7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblxuXHRcdC8vQ0lSQ1xuXHRcdF93cmFwKFwiQ2lyY1wiLFxuXHRcdFx0X2NyZWF0ZShcIkNpcmNPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAocCA9IHAgLSAxKSAqIHApO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiQ2lyY0luXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIC0oTWF0aC5zcXJ0KDEgLSAocCAqIHApKSAtIDEpO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiQ2lyY0luT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuICgocCo9MikgPCAxKSA/IC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBwICogcCkgLSAxKSA6IDAuNSAqIChNYXRoLnNxcnQoMSAtIChwIC09IDIpICogcCkgKyAxKTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXG5cdFx0Ly9FbGFzdGljXG5cdFx0X2NyZWF0ZUVsYXN0aWMgPSBmdW5jdGlvbihuLCBmLCBkZWYpIHtcblx0XHRcdHZhciBDID0gX2NsYXNzKFwiZWFzaW5nLlwiICsgbiwgZnVuY3Rpb24oYW1wbGl0dWRlLCBwZXJpb2QpIHtcblx0XHRcdFx0XHR0aGlzLl9wMSA9IChhbXBsaXR1ZGUgPj0gMSkgPyBhbXBsaXR1ZGUgOiAxOyAvL25vdGU6IGlmIGFtcGxpdHVkZSBpcyA8IDEsIHdlIHNpbXBseSBhZGp1c3QgdGhlIHBlcmlvZCBmb3IgYSBtb3JlIG5hdHVyYWwgZmVlbC4gT3RoZXJ3aXNlIHRoZSBtYXRoIGRvZXNuJ3Qgd29yayByaWdodCBhbmQgdGhlIGN1cnZlIHN0YXJ0cyBhdCAxLlxuXHRcdFx0XHRcdHRoaXMuX3AyID0gKHBlcmlvZCB8fCBkZWYpIC8gKGFtcGxpdHVkZSA8IDEgPyBhbXBsaXR1ZGUgOiAxKTtcblx0XHRcdFx0XHR0aGlzLl9wMyA9IHRoaXMuX3AyIC8gXzJQSSAqIChNYXRoLmFzaW4oMSAvIHRoaXMuX3AxKSB8fCAwKTtcblx0XHRcdFx0XHR0aGlzLl9wMiA9IF8yUEkgLyB0aGlzLl9wMjsgLy9wcmVjYWxjdWxhdGUgdG8gb3B0aW1pemVcblx0XHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRcdHAgPSBDLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0XHRwLmNvbnN0cnVjdG9yID0gQztcblx0XHRcdHAuZ2V0UmF0aW8gPSBmO1xuXHRcdFx0cC5jb25maWcgPSBmdW5jdGlvbihhbXBsaXR1ZGUsIHBlcmlvZCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEMoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBDO1xuXHRcdH07XG5cdFx0X3dyYXAoXCJFbGFzdGljXCIsXG5cdFx0XHRfY3JlYXRlRWxhc3RpYyhcIkVsYXN0aWNPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcDEgKiBNYXRoLnBvdygyLCAtMTAgKiBwKSAqIE1hdGguc2luKCAocCAtIHRoaXMuX3AzKSAqIHRoaXMuX3AyICkgKyAxO1xuXHRcdFx0fSwgMC4zKSxcblx0XHRcdF9jcmVhdGVFbGFzdGljKFwiRWxhc3RpY0luXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIC0odGhpcy5fcDEgKiBNYXRoLnBvdygyLCAxMCAqIChwIC09IDEpKSAqIE1hdGguc2luKCAocCAtIHRoaXMuX3AzKSAqIHRoaXMuX3AyICkpO1xuXHRcdFx0fSwgMC4zKSxcblx0XHRcdF9jcmVhdGVFbGFzdGljKFwiRWxhc3RpY0luT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuICgocCAqPSAyKSA8IDEpID8gLTAuNSAqICh0aGlzLl9wMSAqIE1hdGgucG93KDIsIDEwICogKHAgLT0gMSkpICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIpKSA6IHRoaXMuX3AxICogTWF0aC5wb3coMiwgLTEwICoocCAtPSAxKSkgKiBNYXRoLnNpbiggKHAgLSB0aGlzLl9wMykgKiB0aGlzLl9wMiApICogMC41ICsgMTtcblx0XHRcdH0sIDAuNDUpXG5cdFx0KTtcblxuXG5cdFx0Ly9FeHBvXG5cdFx0X3dyYXAoXCJFeHBvXCIsXG5cdFx0XHRfY3JlYXRlKFwiRXhwb091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAxIC0gTWF0aC5wb3coMiwgLTEwICogcCk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJFeHBvSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5wb3coMiwgMTAgKiAocCAtIDEpKSAtIDAuMDAxO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiRXhwb0luT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuICgocCAqPSAyKSA8IDEpID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAocCAtIDEpKSA6IDAuNSAqICgyIC0gTWF0aC5wb3coMiwgLTEwICogKHAgLSAxKSkpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cblx0XHQvL1NpbmVcblx0XHRfd3JhcChcIlNpbmVcIixcblx0XHRcdF9jcmVhdGUoXCJTaW5lT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIE1hdGguc2luKHAgKiBfSEFMRl9QSSk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJTaW5lSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLU1hdGguY29zKHAgKiBfSEFMRl9QSSkgKyAxO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiU2luZUluT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHApIC0gMSk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblx0XHRfY2xhc3MoXCJlYXNpbmcuRWFzZUxvb2t1cFwiLCB7XG5cdFx0XHRcdGZpbmQ6ZnVuY3Rpb24ocykge1xuXHRcdFx0XHRcdHJldHVybiBFYXNlLm1hcFtzXTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdHJ1ZSk7XG5cblx0XHQvL3JlZ2lzdGVyIHRoZSBub24tc3RhbmRhcmQgZWFzZXNcblx0XHRfZWFzZVJlZyh3LlNsb3dNbywgXCJTbG93TW9cIiwgXCJlYXNlLFwiKTtcblx0XHRfZWFzZVJlZyhSb3VnaEVhc2UsIFwiUm91Z2hFYXNlXCIsIFwiZWFzZSxcIik7XG5cdFx0X2Vhc2VSZWcoU3RlcHBlZEVhc2UsIFwiU3RlcHBlZEVhc2VcIiwgXCJlYXNlLFwiKTtcblxuXHRcdHJldHVybiBCYWNrO1xuXHRcdFxuXHR9LCB0cnVlKTtcblxuXG59KTtcblxuaWYgKF9nc1Njb3BlLl9nc0RlZmluZSkgeyBfZ3NTY29wZS5fZ3NRdWV1ZS5wb3AoKSgpOyB9IC8vbmVjZXNzYXJ5IGluIGNhc2UgVHdlZW5MaXRlIHdhcyBhbHJlYWR5IGxvYWRlZCBzZXBhcmF0ZWx5LlxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCYXNlIGNsYXNzZXMgbGlrZSBUd2VlbkxpdGUsIFNpbXBsZVRpbWVsaW5lLCBFYXNlLCBUaWNrZXIsIGV0Yy5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgbW9kdWxlTmFtZSkge1xuXG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9nbG9iYWxzID0gd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyB8fCB3aW5kb3c7XG5cdFx0aWYgKF9nbG9iYWxzLlR3ZWVuTGl0ZSkge1xuXHRcdFx0cmV0dXJuOyAvL2luIGNhc2UgdGhlIGNvcmUgc2V0IG9mIGNsYXNzZXMgaXMgYWxyZWFkeSBsb2FkZWQsIGRvbid0IGluc3RhbnRpYXRlIHR3aWNlLlxuXHRcdH1cblx0XHR2YXIgX25hbWVzcGFjZSA9IGZ1bmN0aW9uKG5zKSB7XG5cdFx0XHRcdHZhciBhID0gbnMuc3BsaXQoXCIuXCIpLFxuXHRcdFx0XHRcdHAgPSBfZ2xvYmFscywgaTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRwW2FbaV1dID0gcCA9IHBbYVtpXV0gfHwge307XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHA7XG5cdFx0XHR9LFxuXHRcdFx0Z3MgPSBfbmFtZXNwYWNlKFwiY29tLmdyZWVuc29ja1wiKSxcblx0XHRcdF90aW55TnVtID0gMC4wMDAwMDAwMDAxLFxuXHRcdFx0X3NsaWNlID0gZnVuY3Rpb24oYSkgeyAvL2Rvbid0IHVzZSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0YXJnZXQsIDApIGJlY2F1c2UgdGhhdCBkb2Vzbid0IHdvcmsgaW4gSUU4IHdpdGggYSBOb2RlTGlzdCB0aGF0J3MgcmV0dXJuZWQgYnkgcXVlcnlTZWxlY3RvckFsbCgpXG5cdFx0XHRcdHZhciBiID0gW10sXG5cdFx0XHRcdFx0bCA9IGEubGVuZ3RoLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgIT09IGw7IGIucHVzaChhW2krK10pKTtcblx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHR9LFxuXHRcdFx0X2VtcHR5RnVuYyA9IGZ1bmN0aW9uKCkge30sXG5cdFx0XHRfaXNBcnJheSA9IChmdW5jdGlvbigpIHsgLy93b3JrcyBhcm91bmQgaXNzdWVzIGluIGlmcmFtZSBlbnZpcm9ubWVudHMgd2hlcmUgdGhlIEFycmF5IGdsb2JhbCBpc24ndCBzaGFyZWQsIHRodXMgaWYgdGhlIG9iamVjdCBvcmlnaW5hdGVzIGluIGEgZGlmZmVyZW50IHdpbmRvdy9pZnJhbWUsIFwiKG9iaiBpbnN0YW5jZW9mIEFycmF5KVwiIHdpbGwgZXZhbHVhdGUgZmFsc2UuIFdlIGFkZGVkIHNvbWUgc3BlZWQgb3B0aW1pemF0aW9ucyB0byBhdm9pZCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoKSB1bmxlc3MgaXQncyBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSBiZWNhdXNlIGl0J3MgVkVSWSBzbG93IChsaWtlIDIweCBzbG93ZXIpXG5cdFx0XHRcdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdFx0XHRcdFx0YXJyYXkgPSB0b1N0cmluZy5jYWxsKFtdKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiAob2JqIGluc3RhbmNlb2YgQXJyYXkgfHwgKHR5cGVvZihvYmopID09PSBcIm9iamVjdFwiICYmICEhb2JqLnB1c2ggJiYgdG9TdHJpbmcuY2FsbChvYmopID09PSBhcnJheSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSgpKSxcblx0XHRcdGEsIGksIHAsIF90aWNrZXIsIF90aWNrZXJBY3RpdmUsXG5cdFx0XHRfZGVmTG9va3VwID0ge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0XHQgKiBEZWZpbmVzIGEgR3JlZW5Tb2NrIGNsYXNzLCBvcHRpb25hbGx5IHdpdGggYW4gYXJyYXkgb2YgZGVwZW5kZW5jaWVzIHRoYXQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgZmlyc3QgYW5kIHBhc3NlZCBpbnRvIHRoZSBkZWZpbml0aW9uLlxuXHRcdFx0ICogVGhpcyBhbGxvd3MgdXNlcnMgdG8gbG9hZCBHcmVlblNvY2sgSlMgZmlsZXMgaW4gYW55IG9yZGVyIGV2ZW4gaWYgdGhleSBoYXZlIGludGVyZGVwZW5kZW5jaWVzIChsaWtlIENTU1BsdWdpbiBleHRlbmRzIFR3ZWVuUGx1Z2luIHdoaWNoIGlzXG5cdFx0XHQgKiBpbnNpZGUgVHdlZW5MaXRlLmpzLCBidXQgaWYgQ1NTUGx1Z2luIGlzIGxvYWRlZCBmaXJzdCwgaXQgc2hvdWxkIHdhaXQgdG8gcnVuIGl0cyBjb2RlIHVudGlsIFR3ZWVuTGl0ZS5qcyBsb2FkcyBhbmQgaW5zdGFudGlhdGVzIFR3ZWVuUGx1Z2luXG5cdFx0XHQgKiBhbmQgdGhlbiBwYXNzIFR3ZWVuUGx1Z2luIHRvIENTU1BsdWdpbidzIGRlZmluaXRpb24pLiBUaGlzIGlzIGFsbCBkb25lIGF1dG9tYXRpY2FsbHkgYW5kIGludGVybmFsbHkuXG5cdFx0XHQgKlxuXHRcdFx0ICogRXZlcnkgZGVmaW5pdGlvbiB3aWxsIGJlIGFkZGVkIHRvIGEgXCJjb20uZ3JlZW5zb2NrXCIgZ2xvYmFsIG9iamVjdCAodHlwaWNhbGx5IHdpbmRvdywgYnV0IGlmIGEgd2luZG93LkdyZWVuU29ja0dsb2JhbHMgb2JqZWN0IGlzIGZvdW5kLFxuXHRcdFx0ICogaXQgd2lsbCBnbyB0aGVyZSBhcyBvZiB2MS43KS4gRm9yIGV4YW1wbGUsIFR3ZWVuTGl0ZSB3aWxsIGJlIGZvdW5kIGF0IHdpbmRvdy5jb20uZ3JlZW5zb2NrLlR3ZWVuTGl0ZSBhbmQgc2luY2UgaXQncyBhIGdsb2JhbCBjbGFzcyB0aGF0IHNob3VsZCBiZSBhdmFpbGFibGUgYW55d2hlcmUsXG5cdFx0XHQgKiBpdCBpcyBBTFNPIHJlZmVyZW5jZWQgYXQgd2luZG93LlR3ZWVuTGl0ZS4gSG93ZXZlciBzb21lIGNsYXNzZXMgYXJlbid0IGNvbnNpZGVyZWQgZ2xvYmFsLCBsaWtlIHRoZSBiYXNlIGNvbS5ncmVlbnNvY2suY29yZS5BbmltYXRpb24gY2xhc3MsIHNvXG5cdFx0XHQgKiB0aG9zZSB3aWxsIG9ubHkgYmUgYXQgdGhlIHBhY2thZ2UgbGlrZSB3aW5kb3cuY29tLmdyZWVuc29jay5jb3JlLkFuaW1hdGlvbi4gQWdhaW4sIGlmIHlvdSBkZWZpbmUgYSBHcmVlblNvY2tHbG9iYWxzIG9iamVjdCBvbiB0aGUgd2luZG93LCBldmVyeXRoaW5nXG5cdFx0XHQgKiBnZXRzIHR1Y2tlZCBuZWF0bHkgaW5zaWRlIHRoZXJlIGluc3RlYWQgb2Ygb24gdGhlIHdpbmRvdyBkaXJlY3RseS4gVGhpcyBhbGxvd3MgeW91IHRvIGRvIGFkdmFuY2VkIHRoaW5ncyBsaWtlIGxvYWQgbXVsdGlwbGUgdmVyc2lvbnMgb2YgR3JlZW5Tb2NrXG5cdFx0XHQgKiBmaWxlcyBhbmQgcHV0IHRoZW0gaW50byBkaXN0aW5jdCBvYmplY3RzIChpbWFnaW5lIGEgYmFubmVyIGFkIHVzZXMgYSBuZXdlciB2ZXJzaW9uIGJ1dCB0aGUgbWFpbiBzaXRlIHVzZXMgYW4gb2xkZXIgb25lKS4gSW4gdGhhdCBjYXNlLCB5b3UgY291bGRcblx0XHRcdCAqIHNhbmRib3ggdGhlIGJhbm5lciBvbmUgbGlrZTpcblx0XHRcdCAqXG5cdFx0XHQgKiA8c2NyaXB0PlxuXHRcdFx0ICogICAgIHZhciBncyA9IHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0ge307IC8vdGhlIG5ld2VyIHZlcnNpb24gd2UncmUgYWJvdXQgdG8gbG9hZCBjb3VsZCBub3cgYmUgcmVmZXJlbmNlZCBpbiBhIFwiZ3NcIiBvYmplY3QsIGxpa2UgZ3MuVHdlZW5MaXRlLnRvKC4uLikuIFVzZSB3aGF0ZXZlciBhbGlhcyB5b3Ugd2FudCBhcyBsb25nIGFzIGl0J3MgdW5pcXVlLCBcImdzXCIgb3IgXCJiYW5uZXJcIiBvciB3aGF0ZXZlci5cblx0XHRcdCAqIDwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdCBzcmM9XCJqcy9ncmVlbnNvY2svdjEuNy9Ud2Vlbk1heC5qc1wiPjwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdD5cblx0XHRcdCAqICAgICB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHdpbmRvdy5fZ3NRdWV1ZSA9IHdpbmRvdy5fZ3NEZWZpbmUgPSBudWxsOyAvL3Jlc2V0IGl0IGJhY2sgdG8gbnVsbCAoYWxvbmcgd2l0aCB0aGUgc3BlY2lhbCBfZ3NRdWV1ZSB2YXJpYWJsZSkgc28gdGhhdCB0aGUgbmV4dCBsb2FkIG9mIFR3ZWVuTWF4IGFmZmVjdHMgdGhlIHdpbmRvdyBhbmQgd2UgY2FuIHJlZmVyZW5jZSB0aGluZ3MgZGlyZWN0bHkgbGlrZSBUd2VlbkxpdGUudG8oLi4uKVxuXHRcdFx0ICogPC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0IHNyYz1cImpzL2dyZWVuc29jay92MS42L1R3ZWVuTWF4LmpzXCI+PC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0PlxuXHRcdFx0ICogICAgIGdzLlR3ZWVuTGl0ZS50byguLi4pOyAvL3dvdWxkIHVzZSB2MS43XG5cdFx0XHQgKiAgICAgVHdlZW5MaXRlLnRvKC4uLik7IC8vd291bGQgdXNlIHYxLjZcblx0XHRcdCAqIDwvc2NyaXB0PlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gbnMgVGhlIG5hbWVzcGFjZSBvZiB0aGUgY2xhc3MgZGVmaW5pdGlvbiwgbGVhdmluZyBvZmYgXCJjb20uZ3JlZW5zb2NrLlwiIGFzIHRoYXQncyBhc3N1bWVkLiBGb3IgZXhhbXBsZSwgXCJUd2VlbkxpdGVcIiBvciBcInBsdWdpbnMuQ1NTUGx1Z2luXCIgb3IgXCJlYXNpbmcuQmFja1wiLlxuXHRcdFx0ICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGRlcGVuZGVuY2llcyBBbiBhcnJheSBvZiBkZXBlbmRlbmNpZXMgKGRlc2NyaWJlZCBhcyB0aGVpciBuYW1lc3BhY2VzIG1pbnVzIFwiY29tLmdyZWVuc29jay5cIiBwcmVmaXgpLiBGb3IgZXhhbXBsZSBbXCJUd2VlbkxpdGVcIixcInBsdWdpbnMuVHdlZW5QbHVnaW5cIixcImNvcmUuQW5pbWF0aW9uXCJdXG5cdFx0XHQgKiBAcGFyYW0geyFmdW5jdGlvbigpOk9iamVjdH0gZnVuYyBUaGUgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIGFuZCBwYXNzZWQgdGhlIHJlc29sdmVkIGRlcGVuZGVuY2llcyB3aGljaCB3aWxsIHJldHVybiB0aGUgYWN0dWFsIGNsYXNzIGZvciB0aGlzIGRlZmluaXRpb24uXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBnbG9iYWwgSWYgdHJ1ZSwgdGhlIGNsYXNzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGdsb2JhbCBzY29wZSAodHlwaWNhbGx5IHdpbmRvdyB1bmxlc3MgeW91IGRlZmluZSBhIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzIG9iamVjdClcblx0XHRcdCAqL1xuXHRcdFx0RGVmaW5pdGlvbiA9IGZ1bmN0aW9uKG5zLCBkZXBlbmRlbmNpZXMsIGZ1bmMsIGdsb2JhbCkge1xuXHRcdFx0XHR0aGlzLnNjID0gKF9kZWZMb29rdXBbbnNdKSA/IF9kZWZMb29rdXBbbnNdLnNjIDogW107IC8vc3ViY2xhc3Nlc1xuXHRcdFx0XHRfZGVmTG9va3VwW25zXSA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuZ3NDbGFzcyA9IG51bGw7XG5cdFx0XHRcdHRoaXMuZnVuYyA9IGZ1bmM7XG5cdFx0XHRcdHZhciBfY2xhc3NlcyA9IFtdO1xuXHRcdFx0XHR0aGlzLmNoZWNrID0gZnVuY3Rpb24oaW5pdCkge1xuXHRcdFx0XHRcdHZhciBpID0gZGVwZW5kZW5jaWVzLmxlbmd0aCxcblx0XHRcdFx0XHRcdG1pc3NpbmcgPSBpLFxuXHRcdFx0XHRcdFx0Y3VyLCBhLCBuLCBjbDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICgoY3VyID0gX2RlZkxvb2t1cFtkZXBlbmRlbmNpZXNbaV1dIHx8IG5ldyBEZWZpbml0aW9uKGRlcGVuZGVuY2llc1tpXSwgW10pKS5nc0NsYXNzKSB7XG5cdFx0XHRcdFx0XHRcdF9jbGFzc2VzW2ldID0gY3VyLmdzQ2xhc3M7XG5cdFx0XHRcdFx0XHRcdG1pc3NpbmctLTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaW5pdCkge1xuXHRcdFx0XHRcdFx0XHRjdXIuc2MucHVzaCh0aGlzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1pc3NpbmcgPT09IDAgJiYgZnVuYykge1xuXHRcdFx0XHRcdFx0YSA9IChcImNvbS5ncmVlbnNvY2suXCIgKyBucykuc3BsaXQoXCIuXCIpO1xuXHRcdFx0XHRcdFx0biA9IGEucG9wKCk7XG5cdFx0XHRcdFx0XHRjbCA9IF9uYW1lc3BhY2UoYS5qb2luKFwiLlwiKSlbbl0gPSB0aGlzLmdzQ2xhc3MgPSBmdW5jLmFwcGx5KGZ1bmMsIF9jbGFzc2VzKTtcblxuXHRcdFx0XHRcdFx0Ly9leHBvcnRzIHRvIG11bHRpcGxlIGVudmlyb25tZW50c1xuXHRcdFx0XHRcdFx0aWYgKGdsb2JhbCkge1xuXHRcdFx0XHRcdFx0XHRfZ2xvYmFsc1tuXSA9IGNsOyAvL3Byb3ZpZGVzIGEgd2F5IHRvIGF2b2lkIGdsb2JhbCBuYW1lc3BhY2UgcG9sbHV0aW9uLiBCeSBkZWZhdWx0LCB0aGUgbWFpbiBjbGFzc2VzIGxpa2UgVHdlZW5MaXRlLCBQb3dlcjEsIFN0cm9uZywgZXRjLiBhcmUgYWRkZWQgdG8gd2luZG93IHVubGVzcyBhIEdyZWVuU29ja0dsb2JhbHMgaXMgZGVmaW5lZC4gU28gaWYgeW91IHdhbnQgdG8gaGF2ZSB0aGluZ3MgYWRkZWQgdG8gYSBjdXN0b20gb2JqZWN0IGluc3RlYWQsIGp1c3QgZG8gc29tZXRoaW5nIGxpa2Ugd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB7fSBiZWZvcmUgbG9hZGluZyBhbnkgR3JlZW5Tb2NrIGZpbGVzLiBZb3UgY2FuIGV2ZW4gc2V0IHVwIGFuIGFsaWFzIGxpa2Ugd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB3aW5kb3dzLmdzID0ge30gc28gdGhhdCB5b3UgY2FuIGFjY2VzcyBldmVyeXRoaW5nIGxpa2UgZ3MuVHdlZW5MaXRlLiBBbHNvIHJlbWVtYmVyIHRoYXQgQUxMIGNsYXNzZXMgYXJlIGFkZGVkIHRvIHRoZSB3aW5kb3cuY29tLmdyZWVuc29jayBvYmplY3QgKGluIHRoZWlyIHJlc3BlY3RpdmUgcGFja2FnZXMsIGxpa2UgY29tLmdyZWVuc29jay5lYXNpbmcuUG93ZXIxLCBjb20uZ3JlZW5zb2NrLlR3ZWVuTGl0ZSwgZXRjLilcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZihkZWZpbmUpID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCl7IC8vQU1EXG5cdFx0XHRcdFx0XHRcdFx0ZGVmaW5lKCh3aW5kb3cuR3JlZW5Tb2NrQU1EUGF0aCA/IHdpbmRvdy5HcmVlblNvY2tBTURQYXRoICsgXCIvXCIgOiBcIlwiKSArIG5zLnNwbGl0KFwiLlwiKS5wb3AoKSwgW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2w7IH0pO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG5zID09PSBtb2R1bGVOYW1lICYmIHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKXsgLy9ub2RlXG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlLmV4cG9ydHMgPSBjbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuc2MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zY1tpXS5jaGVjaygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5jaGVjayh0cnVlKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vdXNlZCB0byBjcmVhdGUgRGVmaW5pdGlvbiBpbnN0YW5jZXMgKHdoaWNoIGJhc2ljYWxseSByZWdpc3RlcnMgYSBjbGFzcyB0aGF0IGhhcyBkZXBlbmRlbmNpZXMpLlxuXHRcdFx0X2dzRGVmaW5lID0gd2luZG93Ll9nc0RlZmluZSA9IGZ1bmN0aW9uKG5zLCBkZXBlbmRlbmNpZXMsIGZ1bmMsIGdsb2JhbCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IERlZmluaXRpb24obnMsIGRlcGVuZGVuY2llcywgZnVuYywgZ2xvYmFsKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vYSBxdWljayB3YXkgdG8gY3JlYXRlIGEgY2xhc3MgdGhhdCBkb2Vzbid0IGhhdmUgYW55IGRlcGVuZGVuY2llcy4gUmV0dXJucyB0aGUgY2xhc3MsIGJ1dCBmaXJzdCByZWdpc3RlcnMgaXQgaW4gdGhlIEdyZWVuU29jayBuYW1lc3BhY2Ugc28gdGhhdCBvdGhlciBjbGFzc2VzIGNhbiBncmFiIGl0IChvdGhlciBjbGFzc2VzIG1pZ2h0IGJlIGRlcGVuZGVudCBvbiB0aGUgY2xhc3MpLlxuXHRcdFx0X2NsYXNzID0gZ3MuX2NsYXNzID0gZnVuY3Rpb24obnMsIGZ1bmMsIGdsb2JhbCkge1xuXHRcdFx0XHRmdW5jID0gZnVuYyB8fCBmdW5jdGlvbigpIHt9O1xuXHRcdFx0XHRfZ3NEZWZpbmUobnMsIFtdLCBmdW5jdGlvbigpeyByZXR1cm4gZnVuYzsgfSwgZ2xvYmFsKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmM7XG5cdFx0XHR9O1xuXG5cdFx0X2dzRGVmaW5lLmdsb2JhbHMgPSBfZ2xvYmFscztcblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBFYXNlXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgX2Jhc2VQYXJhbXMgPSBbMCwgMCwgMSwgMV0sXG5cdFx0XHRfYmxhbmtBcnJheSA9IFtdLFxuXHRcdFx0RWFzZSA9IF9jbGFzcyhcImVhc2luZy5FYXNlXCIsIGZ1bmN0aW9uKGZ1bmMsIGV4dHJhUGFyYW1zLCB0eXBlLCBwb3dlcikge1xuXHRcdFx0XHR0aGlzLl9mdW5jID0gZnVuYztcblx0XHRcdFx0dGhpcy5fdHlwZSA9IHR5cGUgfHwgMDtcblx0XHRcdFx0dGhpcy5fcG93ZXIgPSBwb3dlciB8fCAwO1xuXHRcdFx0XHR0aGlzLl9wYXJhbXMgPSBleHRyYVBhcmFtcyA/IF9iYXNlUGFyYW1zLmNvbmNhdChleHRyYVBhcmFtcykgOiBfYmFzZVBhcmFtcztcblx0XHRcdH0sIHRydWUpLFxuXHRcdFx0X2Vhc2VNYXAgPSBFYXNlLm1hcCA9IHt9LFxuXHRcdFx0X2Vhc2VSZWcgPSBFYXNlLnJlZ2lzdGVyID0gZnVuY3Rpb24oZWFzZSwgbmFtZXMsIHR5cGVzLCBjcmVhdGUpIHtcblx0XHRcdFx0dmFyIG5hID0gbmFtZXMuc3BsaXQoXCIsXCIpLFxuXHRcdFx0XHRcdGkgPSBuYS5sZW5ndGgsXG5cdFx0XHRcdFx0dGEgPSAodHlwZXMgfHwgXCJlYXNlSW4sZWFzZU91dCxlYXNlSW5PdXRcIikuc3BsaXQoXCIsXCIpLFxuXHRcdFx0XHRcdGUsIG5hbWUsIGosIHR5cGU7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdG5hbWUgPSBuYVtpXTtcblx0XHRcdFx0XHRlID0gY3JlYXRlID8gX2NsYXNzKFwiZWFzaW5nLlwiK25hbWUsIG51bGwsIHRydWUpIDogZ3MuZWFzaW5nW25hbWVdIHx8IHt9O1xuXHRcdFx0XHRcdGogPSB0YS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gdGFbal07XG5cdFx0XHRcdFx0XHRfZWFzZU1hcFtuYW1lICsgXCIuXCIgKyB0eXBlXSA9IF9lYXNlTWFwW3R5cGUgKyBuYW1lXSA9IGVbdHlwZV0gPSBlYXNlLmdldFJhdGlvID8gZWFzZSA6IGVhc2VbdHlwZV0gfHwgbmV3IGVhc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRwID0gRWFzZS5wcm90b3R5cGU7XG5cdFx0cC5fY2FsY0VuZCA9IGZhbHNlO1xuXHRcdHAuZ2V0UmF0aW8gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHRpZiAodGhpcy5fZnVuYykge1xuXHRcdFx0XHR0aGlzLl9wYXJhbXNbMF0gPSBwO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZnVuYy5hcHBseShudWxsLCB0aGlzLl9wYXJhbXMpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHQgPSB0aGlzLl90eXBlLFxuXHRcdFx0XHRwdyA9IHRoaXMuX3Bvd2VyLFxuXHRcdFx0XHRyID0gKHQgPT09IDEpID8gMSAtIHAgOiAodCA9PT0gMikgPyBwIDogKHAgPCAwLjUpID8gcCAqIDIgOiAoMSAtIHApICogMjtcblx0XHRcdGlmIChwdyA9PT0gMSkge1xuXHRcdFx0XHRyICo9IHI7XG5cdFx0XHR9IGVsc2UgaWYgKHB3ID09PSAyKSB7XG5cdFx0XHRcdHIgKj0gciAqIHI7XG5cdFx0XHR9IGVsc2UgaWYgKHB3ID09PSAzKSB7XG5cdFx0XHRcdHIgKj0gciAqIHIgKiByO1xuXHRcdFx0fSBlbHNlIGlmIChwdyA9PT0gNCkge1xuXHRcdFx0XHRyICo9IHIgKiByICogciAqIHI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHQgPT09IDEpID8gMSAtIHIgOiAodCA9PT0gMikgPyByIDogKHAgPCAwLjUpID8gciAvIDIgOiAxIC0gKHIgLyAyKTtcblx0XHR9O1xuXG5cdFx0Ly9jcmVhdGUgYWxsIHRoZSBzdGFuZGFyZCBlYXNlcyBsaWtlIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIGFuZCBQb3dlcjQgKGVhY2ggd2l0aCBlYXNlSW4sIGVhc2VPdXQsIGFuZCBlYXNlSW5PdXQpXG5cdFx0YSA9IFtcIkxpbmVhclwiLFwiUXVhZFwiLFwiQ3ViaWNcIixcIlF1YXJ0XCIsXCJRdWludCxTdHJvbmdcIl07XG5cdFx0aSA9IGEubGVuZ3RoO1xuXHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0cCA9IGFbaV0rXCIsUG93ZXJcIitpO1xuXHRcdFx0X2Vhc2VSZWcobmV3IEVhc2UobnVsbCxudWxsLDEsaSksIHAsIFwiZWFzZU91dFwiLCB0cnVlKTtcblx0XHRcdF9lYXNlUmVnKG5ldyBFYXNlKG51bGwsbnVsbCwyLGkpLCBwLCBcImVhc2VJblwiICsgKChpID09PSAwKSA/IFwiLGVhc2VOb25lXCIgOiBcIlwiKSk7XG5cdFx0XHRfZWFzZVJlZyhuZXcgRWFzZShudWxsLG51bGwsMyxpKSwgcCwgXCJlYXNlSW5PdXRcIik7XG5cdFx0fVxuXHRcdF9lYXNlTWFwLmxpbmVhciA9IGdzLmVhc2luZy5MaW5lYXIuZWFzZUluO1xuXHRcdF9lYXNlTWFwLnN3aW5nID0gZ3MuZWFzaW5nLlF1YWQuZWFzZUluT3V0OyAvL2ZvciBqUXVlcnkgZm9sa3NcblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRXZlbnREaXNwYXRjaGVyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgRXZlbnREaXNwYXRjaGVyID0gX2NsYXNzKFwiZXZlbnRzLkV2ZW50RGlzcGF0Y2hlclwiLCBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRcdHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXHRcdFx0dGhpcy5fZXZlbnRUYXJnZXQgPSB0YXJnZXQgfHwgdGhpcztcblx0XHR9KTtcblx0XHRwID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZTtcblxuXHRcdHAuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBzY29wZSwgdXNlUGFyYW0sIHByaW9yaXR5KSB7XG5cdFx0XHRwcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cdFx0XHR2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsaXN0ZW5lciwgaTtcblx0XHRcdGlmIChsaXN0ID09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gbGlzdCA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGxpc3RlbmVyID0gbGlzdFtpXTtcblx0XHRcdFx0aWYgKGxpc3RlbmVyLmMgPT09IGNhbGxiYWNrICYmIGxpc3RlbmVyLnMgPT09IHNjb3BlKSB7XG5cdFx0XHRcdFx0bGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggPT09IDAgJiYgbGlzdGVuZXIucHIgPCBwcmlvcml0eSkge1xuXHRcdFx0XHRcdGluZGV4ID0gaSArIDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxpc3Quc3BsaWNlKGluZGV4LCAwLCB7YzpjYWxsYmFjaywgczpzY29wZSwgdXA6dXNlUGFyYW0sIHByOnByaW9yaXR5fSk7XG5cdFx0XHRpZiAodGhpcyA9PT0gX3RpY2tlciAmJiAhX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLCBpO1xuXHRcdFx0aWYgKGxpc3QpIHtcblx0XHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAobGlzdFtpXS5jID09PSBjYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLFxuXHRcdFx0XHRpLCB0LCBsaXN0ZW5lcjtcblx0XHRcdGlmIChsaXN0KSB7XG5cdFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0dCA9IHRoaXMuX2V2ZW50VGFyZ2V0O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRsaXN0ZW5lciA9IGxpc3RbaV07XG5cdFx0XHRcdFx0aWYgKGxpc3RlbmVyKSB7XG5cdFx0XHRcdFx0XHRpZiAobGlzdGVuZXIudXApIHtcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXIuYy5jYWxsKGxpc3RlbmVyLnMgfHwgdCwge3R5cGU6dHlwZSwgdGFyZ2V0OnR9KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLmMuY2FsbChsaXN0ZW5lci5zIHx8IHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRpY2tlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4gXHRcdHZhciBfcmVxQW5pbUZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSxcblx0XHRcdF9jYW5jZWxBbmltRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUsXG5cdFx0XHRfZ2V0VGltZSA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge3JldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTt9LFxuXHRcdFx0X2xhc3RVcGRhdGUgPSBfZ2V0VGltZSgpO1xuXG5cdFx0Ly9ub3cgdHJ5IHRvIGRldGVybWluZSB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGFuZCBjYW5jZWxBbmltYXRpb25GcmFtZSBmdW5jdGlvbnMgYW5kIGlmIG5vbmUgYXJlIGZvdW5kLCB3ZSdsbCB1c2UgYSBzZXRUaW1lb3V0KCkvY2xlYXJUaW1lb3V0KCkgcG9seWZpbGwuXG5cdFx0YSA9IFtcIm1zXCIsXCJtb3pcIixcIndlYmtpdFwiLFwib1wiXTtcblx0XHRpID0gYS5sZW5ndGg7XG5cdFx0d2hpbGUgKC0taSA+IC0xICYmICFfcmVxQW5pbUZyYW1lKSB7XG5cdFx0XHRfcmVxQW5pbUZyYW1lID0gd2luZG93W2FbaV0gKyBcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcblx0XHRcdF9jYW5jZWxBbmltRnJhbWUgPSB3aW5kb3dbYVtpXSArIFwiQ2FuY2VsQW5pbWF0aW9uRnJhbWVcIl0gfHwgd2luZG93W2FbaV0gKyBcIkNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcblx0XHR9XG5cblx0XHRfY2xhc3MoXCJUaWNrZXJcIiwgZnVuY3Rpb24oZnBzLCB1c2VSQUYpIHtcblx0XHRcdHZhciBfc2VsZiA9IHRoaXMsXG5cdFx0XHRcdF9zdGFydFRpbWUgPSBfZ2V0VGltZSgpLFxuXHRcdFx0XHRfdXNlUkFGID0gKHVzZVJBRiAhPT0gZmFsc2UgJiYgX3JlcUFuaW1GcmFtZSksXG5cdFx0XHRcdF9sYWdUaHJlc2hvbGQgPSA1MDAsXG5cdFx0XHRcdF9hZGp1c3RlZExhZyA9IDMzLFxuXHRcdFx0XHRfdGlja1dvcmQgPSBcInRpY2tcIiwgLy9oZWxwcyByZWR1Y2UgZ2MgYnVyZGVuXG5cdFx0XHRcdF9mcHMsIF9yZXEsIF9pZCwgX2dhcCwgX25leHRUaW1lLFxuXHRcdFx0XHRfdGljayA9IGZ1bmN0aW9uKG1hbnVhbCkge1xuXHRcdFx0XHRcdHZhciBlbGFwc2VkID0gX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlLFxuXHRcdFx0XHRcdFx0b3ZlcmxhcCwgZGlzcGF0Y2g7XG5cdFx0XHRcdFx0aWYgKGVsYXBzZWQgPiBfbGFnVGhyZXNob2xkKSB7XG5cdFx0XHRcdFx0XHRfc3RhcnRUaW1lICs9IGVsYXBzZWQgLSBfYWRqdXN0ZWRMYWc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9sYXN0VXBkYXRlICs9IGVsYXBzZWQ7XG5cdFx0XHRcdFx0X3NlbGYudGltZSA9IChfbGFzdFVwZGF0ZSAtIF9zdGFydFRpbWUpIC8gMTAwMDtcblx0XHRcdFx0XHRvdmVybGFwID0gX3NlbGYudGltZSAtIF9uZXh0VGltZTtcblx0XHRcdFx0XHRpZiAoIV9mcHMgfHwgb3ZlcmxhcCA+IDAgfHwgbWFudWFsID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRfc2VsZi5mcmFtZSsrO1xuXHRcdFx0XHRcdFx0X25leHRUaW1lICs9IG92ZXJsYXAgKyAob3ZlcmxhcCA+PSBfZ2FwID8gMC4wMDQgOiBfZ2FwIC0gb3ZlcmxhcCk7XG5cdFx0XHRcdFx0XHRkaXNwYXRjaCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtYW51YWwgIT09IHRydWUpIHsgLy9tYWtlIHN1cmUgdGhlIHJlcXVlc3QgaXMgbWFkZSBiZWZvcmUgd2UgZGlzcGF0Y2ggdGhlIFwidGlja1wiIGV2ZW50IHNvIHRoYXQgdGltaW5nIGlzIG1haW50YWluZWQuIE90aGVyd2lzZSwgaWYgcHJvY2Vzc2luZyB0aGUgXCJ0aWNrXCIgcmVxdWlyZXMgYSBidW5jaCBvZiB0aW1lIChsaWtlIDE1bXMpIGFuZCB3ZSdyZSB1c2luZyBhIHNldFRpbWVvdXQoKSB0aGF0J3MgYmFzZWQgb24gMTYuN21zLCBpdCdkIHRlY2huaWNhbGx5IHRha2UgMzEuN21zIGJldHdlZW4gZnJhbWVzIG90aGVyd2lzZS5cblx0XHRcdFx0XHRcdF9pZCA9IF9yZXEoX3RpY2spO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZGlzcGF0Y2gpIHtcblx0XHRcdFx0XHRcdF9zZWxmLmRpc3BhdGNoRXZlbnQoX3RpY2tXb3JkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdEV2ZW50RGlzcGF0Y2hlci5jYWxsKF9zZWxmKTtcblx0XHRcdF9zZWxmLnRpbWUgPSBfc2VsZi5mcmFtZSA9IDA7XG5cdFx0XHRfc2VsZi50aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF90aWNrKHRydWUpO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYubGFnU21vb3RoaW5nID0gZnVuY3Rpb24odGhyZXNob2xkLCBhZGp1c3RlZExhZykge1xuXHRcdFx0XHRfbGFnVGhyZXNob2xkID0gdGhyZXNob2xkIHx8ICgxIC8gX3RpbnlOdW0pOyAvL3plcm8gc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGJhc2ljYWxseSB1bmxpbWl0ZWRcblx0XHRcdFx0X2FkanVzdGVkTGFnID0gTWF0aC5taW4oYWRqdXN0ZWRMYWcsIF9sYWdUaHJlc2hvbGQsIDApO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYuc2xlZXAgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF9pZCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghX3VzZVJBRiB8fCAhX2NhbmNlbEFuaW1GcmFtZSkge1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dChfaWQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9jYW5jZWxBbmltRnJhbWUoX2lkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcmVxID0gX2VtcHR5RnVuYztcblx0XHRcdFx0X2lkID0gbnVsbDtcblx0XHRcdFx0aWYgKF9zZWxmID09PSBfdGlja2VyKSB7XG5cdFx0XHRcdFx0X3RpY2tlckFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi53YWtlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChfaWQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRfc2VsZi5zbGVlcCgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKF9zZWxmLmZyYW1lID4gMTApIHsgLy9kb24ndCB0cmlnZ2VyIGxhZ1Ntb290aGluZyBpZiB3ZSdyZSBqdXN0IHdha2luZyB1cCwgYW5kIG1ha2Ugc3VyZSB0aGF0IGF0IGxlYXN0IDEwIGZyYW1lcyBoYXZlIGVsYXBzZWQgYmVjYXVzZSBvZiB0aGUgaU9TIGJ1ZyB0aGF0IHdlIHdvcmsgYXJvdW5kIGJlbG93IHdpdGggdGhlIDEuNS1zZWNvbmQgc2V0VGltb3V0KCkuXG5cdFx0XHRcdFx0X2xhc3RVcGRhdGUgPSBfZ2V0VGltZSgpIC0gX2xhZ1RocmVzaG9sZCArIDU7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3JlcSA9IChfZnBzID09PSAwKSA/IF9lbXB0eUZ1bmMgOiAoIV91c2VSQUYgfHwgIV9yZXFBbmltRnJhbWUpID8gZnVuY3Rpb24oZikgeyByZXR1cm4gc2V0VGltZW91dChmLCAoKF9uZXh0VGltZSAtIF9zZWxmLnRpbWUpICogMTAwMCArIDEpIHwgMCk7IH0gOiBfcmVxQW5pbUZyYW1lO1xuXHRcdFx0XHRpZiAoX3NlbGYgPT09IF90aWNrZXIpIHtcblx0XHRcdFx0XHRfdGlja2VyQWN0aXZlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdGljaygyKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLmZwcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBfZnBzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9mcHMgPSB2YWx1ZTtcblx0XHRcdFx0X2dhcCA9IDEgLyAoX2ZwcyB8fCA2MCk7XG5cdFx0XHRcdF9uZXh0VGltZSA9IHRoaXMudGltZSArIF9nYXA7XG5cdFx0XHRcdF9zZWxmLndha2UoKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLnVzZVJBRiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBfdXNlUkFGO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9zZWxmLnNsZWVwKCk7XG5cdFx0XHRcdF91c2VSQUYgPSB2YWx1ZTtcblx0XHRcdFx0X3NlbGYuZnBzKF9mcHMpO1xuXHRcdFx0fTtcblx0XHRcdF9zZWxmLmZwcyhmcHMpO1xuXG5cdFx0XHQvL2EgYnVnIGluIGlPUyA2IFNhZmFyaSBvY2Nhc2lvbmFsbHkgcHJldmVudHMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tIHdvcmtpbmcgaW5pdGlhbGx5LCBzbyB3ZSB1c2UgYSAxLjUtc2Vjb25kIHRpbWVvdXQgdGhhdCBhdXRvbWF0aWNhbGx5IGZhbGxzIGJhY2sgdG8gc2V0VGltZW91dCgpIGlmIGl0IHNlbnNlcyB0aGlzIGNvbmRpdGlvbi5cblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChfdXNlUkFGICYmICghX2lkIHx8IF9zZWxmLmZyYW1lIDwgNSkpIHtcblx0XHRcdFx0XHRfc2VsZi51c2VSQUYoZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAxNTAwKTtcblx0XHR9KTtcblxuXHRcdHAgPSBncy5UaWNrZXIucHJvdG90eXBlID0gbmV3IGdzLmV2ZW50cy5FdmVudERpc3BhdGNoZXIoKTtcblx0XHRwLmNvbnN0cnVjdG9yID0gZ3MuVGlja2VyO1xuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBbmltYXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBBbmltYXRpb24gPSBfY2xhc3MoXCJjb3JlLkFuaW1hdGlvblwiLCBmdW5jdGlvbihkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0XHR0aGlzLnZhcnMgPSB2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdFx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gZHVyYXRpb24gfHwgMDtcblx0XHRcdFx0dGhpcy5fZGVsYXkgPSBOdW1iZXIodmFycy5kZWxheSkgfHwgMDtcblx0XHRcdFx0dGhpcy5fdGltZVNjYWxlID0gMTtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5kYXRhID0gdmFycy5kYXRhO1xuXHRcdFx0XHR0aGlzLl9yZXZlcnNlZCA9ICh2YXJzLnJldmVyc2VkID09PSB0cnVlKTtcblxuXHRcdFx0XHRpZiAoIV9yb290VGltZWxpbmUpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7IC8vc29tZSBicm93c2VycyAobGlrZSBpT1MgNiBTYWZhcmkpIHNodXQgZG93biBKYXZhU2NyaXB0IGV4ZWN1dGlvbiB3aGVuIHRoZSB0YWIgaXMgZGlzYWJsZWQgYW5kIHRoZXkgW29jY2FzaW9uYWxseV0gbmVnbGVjdCB0byBzdGFydCB1cCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYWdhaW4gd2hlbiByZXR1cm5pbmcgLSB0aGlzIGNvZGUgZW5zdXJlcyB0aGF0IHRoZSBlbmdpbmUgc3RhcnRzIHVwIGFnYWluIHByb3Blcmx5LlxuXHRcdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHRsID0gdGhpcy52YXJzLnVzZUZyYW1lcyA/IF9yb290RnJhbWVzVGltZWxpbmUgOiBfcm9vdFRpbWVsaW5lO1xuXHRcdFx0XHR0bC5hZGQodGhpcywgdGwuX3RpbWUpO1xuXG5cdFx0XHRcdGlmICh0aGlzLnZhcnMucGF1c2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXVzZWQodHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0X3RpY2tlciA9IEFuaW1hdGlvbi50aWNrZXIgPSBuZXcgZ3MuVGlja2VyKCk7XG5cdFx0cCA9IEFuaW1hdGlvbi5wcm90b3R5cGU7XG5cdFx0cC5fZGlydHkgPSBwLl9nYyA9IHAuX2luaXR0ZWQgPSBwLl9wYXVzZWQgPSBmYWxzZTtcblx0XHRwLl90b3RhbFRpbWUgPSBwLl90aW1lID0gMDtcblx0XHRwLl9yYXdQcmV2VGltZSA9IC0xO1xuXHRcdHAuX25leHQgPSBwLl9sYXN0ID0gcC5fb25VcGRhdGUgPSBwLl90aW1lbGluZSA9IHAudGltZWxpbmUgPSBudWxsO1xuXHRcdHAuX3BhdXNlZCA9IGZhbHNlO1xuXG5cblx0XHQvL3NvbWUgYnJvd3NlcnMgKGxpa2UgaU9TKSBvY2Nhc2lvbmFsbHkgZHJvcCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGV2ZW50IHdoZW4gdGhlIHVzZXIgc3dpdGNoZXMgdG8gYSBkaWZmZXJlbnQgdGFiIGFuZCB0aGVuIGNvbWVzIGJhY2sgYWdhaW4sIHNvIHdlIHVzZSBhIDItc2Vjb25kIHNldFRpbWVvdXQoKSB0byBzZW5zZSBpZi93aGVuIHRoYXQgY29uZGl0aW9uIG9jY3VycyBhbmQgdGhlbiB3YWtlKCkgdGhlIHRpY2tlci5cblx0XHR2YXIgX2NoZWNrVGltZW91dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX3RpY2tlckFjdGl2ZSAmJiBfZ2V0VGltZSgpIC0gX2xhc3RVcGRhdGUgPiAyMDAwKSB7XG5cdFx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0VGltZW91dChfY2hlY2tUaW1lb3V0LCAyMDAwKTtcblx0XHRcdH07XG5cdFx0X2NoZWNrVGltZW91dCgpO1xuXG5cblx0XHRwLnBsYXkgPSBmdW5jdGlvbihmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGZyb20gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNlZWsoZnJvbSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucmV2ZXJzZWQoZmFsc2UpLnBhdXNlZChmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucGF1c2UgPSBmdW5jdGlvbihhdFRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoYXRUaW1lICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2VkKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLnJlc3VtZSA9IGZ1bmN0aW9uKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoZnJvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2Vlayhmcm9tLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXVzZWQoZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnNlZWsgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKE51bWJlcih0aW1lKSwgc3VwcHJlc3NFdmVudHMgIT09IGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXN0YXJ0ID0gZnVuY3Rpb24oaW5jbHVkZURlbGF5LCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMucmV2ZXJzZWQoZmFsc2UpLnBhdXNlZChmYWxzZSkudG90YWxUaW1lKGluY2x1ZGVEZWxheSA/IC10aGlzLl9kZWxheSA6IDAsIChzdXBwcmVzc0V2ZW50cyAhPT0gZmFsc2UpLCB0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXZlcnNlID0gZnVuY3Rpb24oZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmIChmcm9tICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKChmcm9tIHx8IHRoaXMudG90YWxEdXJhdGlvbigpKSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucmV2ZXJzZWQodHJ1ZSkucGF1c2VkKGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdC8vc3R1YiAtIHdlIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGluIHN1YmNsYXNzZXMuXG5cdFx0fTtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IDA7XG5cdFx0XHR0aGlzLl9pbml0dGVkID0gdGhpcy5fZ2MgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gLTE7XG5cdFx0XHRpZiAodGhpcy5fZ2MgfHwgIXRoaXMudGltZWxpbmUpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGwgPSB0aGlzLl90aW1lbGluZSwgLy90aGUgMiByb290IHRpbWVsaW5lcyB3b24ndCBoYXZlIGEgX3RpbWVsaW5lOyB0aGV5J3JlIGFsd2F5cyBhY3RpdmUuXG5cdFx0XHRcdHN0YXJ0VGltZSA9IHRoaXMuX3N0YXJ0VGltZSxcblx0XHRcdFx0cmF3VGltZTtcblx0XHRcdHJldHVybiAoIXRsIHx8ICghdGhpcy5fZ2MgJiYgIXRoaXMuX3BhdXNlZCAmJiB0bC5pc0FjdGl2ZSgpICYmIChyYXdUaW1lID0gdGwucmF3VGltZSgpKSA+PSBzdGFydFRpbWUgJiYgcmF3VGltZSA8IHN0YXJ0VGltZSArIHRoaXMudG90YWxEdXJhdGlvbigpIC8gdGhpcy5fdGltZVNjYWxlKSk7XG5cdFx0fTtcblxuXHRcdHAuX2VuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpIHtcblx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2djID0gIWVuYWJsZWQ7XG5cdFx0XHR0aGlzLl9hY3RpdmUgPSB0aGlzLmlzQWN0aXZlKCk7XG5cdFx0XHRpZiAoaWdub3JlVGltZWxpbmUgIT09IHRydWUpIHtcblx0XHRcdFx0aWYgKGVuYWJsZWQgJiYgIXRoaXMudGltZWxpbmUpIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lbGluZS5hZGQodGhpcywgdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fZGVsYXkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFlbmFibGVkICYmIHRoaXMudGltZWxpbmUpIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lbGluZS5fcmVtb3ZlKHRoaXMsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9raWxsKHZhcnMsIHRhcmdldCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fdW5jYWNoZSA9IGZ1bmN0aW9uKGluY2x1ZGVTZWxmKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSBpbmNsdWRlU2VsZiA/IHRoaXMgOiB0aGlzLnRpbWVsaW5lO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdHR3ZWVuLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4udGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fc3dhcFNlbGZJblBhcmFtcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXHRcdFx0dmFyIGkgPSBwYXJhbXMubGVuZ3RoLFxuXHRcdFx0XHRjb3B5ID0gcGFyYW1zLmNvbmNhdCgpO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChwYXJhbXNbaV0gPT09IFwie3NlbGZ9XCIpIHtcblx0XHRcdFx0XHRjb3B5W2ldID0gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvcHk7XG5cdFx0fTtcblxuLy8tLS0tQW5pbWF0aW9uIGdldHRlcnMvc2V0dGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5ldmVudENhbGxiYWNrID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcblx0XHRcdGlmICgodHlwZSB8fCBcIlwiKS5zdWJzdHIoMCwyKSA9PT0gXCJvblwiKSB7XG5cdFx0XHRcdHZhciB2ID0gdGhpcy52YXJzO1xuXHRcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdHJldHVybiB2W3R5cGVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHZbdHlwZV07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dlt0eXBlXSA9IGNhbGxiYWNrO1xuXHRcdFx0XHRcdHZbdHlwZSArIFwiUGFyYW1zXCJdID0gKF9pc0FycmF5KHBhcmFtcykgJiYgcGFyYW1zLmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKSAhPT0gLTEpID8gdGhpcy5fc3dhcFNlbGZJblBhcmFtcyhwYXJhbXMpIDogcGFyYW1zO1xuXHRcdFx0XHRcdHZbdHlwZSArIFwiU2NvcGVcIl0gPSBzY29wZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZSA9PT0gXCJvblVwZGF0ZVwiKSB7XG5cdFx0XHRcdFx0dGhpcy5fb25VcGRhdGUgPSBjYWxsYmFjaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZGVsYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kZWxheTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHR0aGlzLnN0YXJ0VGltZSggdGhpcy5fc3RhcnRUaW1lICsgdmFsdWUgLSB0aGlzLl9kZWxheSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGVsYXkgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmR1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24gPSB2YWx1ZTtcblx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7IC8vdHJ1ZSBpbiBjYXNlIGl0J3MgYSBUd2Vlbk1heCBvciBUaW1lbGluZU1heCB0aGF0IGhhcyBhIHJlcGVhdCAtIHdlJ2xsIG5lZWQgdG8gcmVmcmVzaCB0aGUgdG90YWxEdXJhdGlvbi5cblx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykgaWYgKHRoaXMuX3RpbWUgPiAwKSBpZiAodGhpcy5fdGltZSA8IHRoaXMuX2R1cmF0aW9uKSBpZiAodmFsdWUgIT09IDApIHtcblx0XHRcdFx0dGhpcy50b3RhbFRpbWUodGhpcy5fdG90YWxUaW1lICogKHZhbHVlIC8gdGhpcy5fZHVyYXRpb24pLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdG90YWxEdXJhdGlvbiA6IHRoaXMuZHVyYXRpb24odmFsdWUpO1xuXHRcdH07XG5cblx0XHRwLnRpbWUgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZSgodmFsdWUgPiB0aGlzLl9kdXJhdGlvbikgPyB0aGlzLl9kdXJhdGlvbiA6IHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxUaW1lID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIHVuY2FwcGVkKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsVGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl90aW1lbGluZSkge1xuXHRcdFx0XHRpZiAodGltZSA8IDAgJiYgIXVuY2FwcGVkKSB7XG5cdFx0XHRcdFx0dGltZSArPSB0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgdG90YWxEdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24sXG5cdFx0XHRcdFx0XHR0bCA9IHRoaXMuX3RpbWVsaW5lO1xuXHRcdFx0XHRcdGlmICh0aW1lID4gdG90YWxEdXJhdGlvbiAmJiAhdW5jYXBwZWQpIHtcblx0XHRcdFx0XHRcdHRpbWUgPSB0b3RhbER1cmF0aW9uO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSAodGhpcy5fcGF1c2VkID8gdGhpcy5fcGF1c2VUaW1lIDogdGwuX3RpbWUpIC0gKCghdGhpcy5fcmV2ZXJzZWQgPyB0aW1lIDogdG90YWxEdXJhdGlvbiAtIHRpbWUpIC8gdGhpcy5fdGltZVNjYWxlKTtcblx0XHRcdFx0XHRpZiAoIXRsLl9kaXJ0eSkgeyAvL2ZvciBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudC4gSWYgdGhlIHBhcmVudCdzIGNhY2hlIGlzIGFscmVhZHkgZGlydHksIGl0IGFscmVhZHkgdG9vayBjYXJlIG9mIG1hcmtpbmcgdGhlIGFuY2VzdG9ycyBhcyBkaXJ0eSB0b28sIHNvIHNraXAgdGhlIGZ1bmN0aW9uIGNhbGwgaGVyZS5cblx0XHRcdFx0XHRcdHRoaXMuX3VuY2FjaGUoZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvciB0aW1lbGluZXMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLCB3ZSBzaG91bGQgcmVzZXQgdGhlaXIgdG90YWxUaW1lKCkgd2hpY2ggd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZXkncmUgbGluZWQgdXAgcHJvcGVybHkgYW5kIGVuYWJsZWQuIFNraXAgZm9yIGFuaW1hdGlvbnMgdGhhdCBhcmUgb24gdGhlIHJvb3QgKHdhc3RlZnVsKS4gRXhhbXBsZTogYSBUaW1lbGluZUxpdGUuZXhwb3J0Um9vdCgpIGlzIHBlcmZvcm1lZCB3aGVuIHRoZXJlJ3MgYSBwYXVzZWQgdHdlZW4gb24gdGhlIHJvb3QsIHRoZSBleHBvcnQgd2lsbCBub3QgY29tcGxldGUgdW50aWwgdGhhdCB0d2VlbiBpcyB1bnBhdXNlZCwgYnV0IGltYWdpbmUgYSBjaGlsZCBnZXRzIHJlc3RhcnRlZCBsYXRlciwgYWZ0ZXIgYWxsIFt1bnBhdXNlZF0gdHdlZW5zIGhhdmUgY29tcGxldGVkLiBUaGUgc3RhcnRUaW1lIG9mIHRoYXQgY2hpbGQgd291bGQgZ2V0IHB1c2hlZCBvdXQsIGJ1dCBvbmUgb2YgdGhlIGFuY2VzdG9ycyBtYXkgaGF2ZSBjb21wbGV0ZWQuXG5cdFx0XHRcdFx0aWYgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAodGwuX3RpbWVsaW5lLl90aW1lICE9PSAodGwuX3N0YXJ0VGltZSArIHRsLl90b3RhbFRpbWUpIC8gdGwuX3RpbWVTY2FsZSkge1xuXHRcdFx0XHRcdFx0XHRcdHRsLnRvdGFsVGltZSh0bC5fdG90YWxUaW1lLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3RvdGFsVGltZSAhPT0gdGltZSB8fCB0aGlzLl9kdXJhdGlvbiA9PT0gMCkge1xuXHRcdFx0XHRcdHRoaXMucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmYWxzZSk7XG5cdFx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gc29tZW9uZSBjYWxscyBzZWVrKCkgb3IgdGltZSgpIG9yIHByb2dyZXNzKCksIHRoZXkgZXhwZWN0IGFuIGltbWVkaWF0ZSByZW5kZXIuXG5cdFx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucHJvZ3Jlc3MgPSBwLnRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdGltZSAvIHRoaXMuZHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKHRoaXMuZHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAuc3RhcnRUaW1lID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc3RhcnRUaW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlICE9PSB0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gdmFsdWU7XG5cdFx0XHRcdGlmICh0aGlzLnRpbWVsaW5lKSBpZiAodGhpcy50aW1lbGluZS5fc29ydENoaWxkcmVuKSB7XG5cdFx0XHRcdFx0dGhpcy50aW1lbGluZS5hZGQodGhpcywgdmFsdWUgLSB0aGlzLl9kZWxheSk7IC8vZW5zdXJlcyB0aGF0IGFueSBuZWNlc3NhcnkgcmUtc2VxdWVuY2luZyBvZiBBbmltYXRpb25zIGluIHRoZSB0aW1lbGluZSBvY2N1cnMgdG8gbWFrZSBzdXJlIHRoZSByZW5kZXJpbmcgb3JkZXIgaXMgY29ycmVjdC5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZW5kVGltZSA9IGZ1bmN0aW9uKGluY2x1ZGVSZXBlYXRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3RhcnRUaW1lICsgKChpbmNsdWRlUmVwZWF0cyAhPSBmYWxzZSkgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMuZHVyYXRpb24oKSkgLyB0aGlzLl90aW1lU2NhbGU7XG5cdFx0fTtcblxuXHRcdHAudGltZVNjYWxlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGltZVNjYWxlO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSB2YWx1ZSB8fCBfdGlueU51bTsgLy9jYW4ndCBhbGxvdyB6ZXJvIGJlY2F1c2UgaXQnbGwgdGhyb3cgdGhlIG1hdGggb2ZmXG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUgJiYgdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0dmFyIHBhdXNlVGltZSA9IHRoaXMuX3BhdXNlVGltZSxcblx0XHRcdFx0XHR0ID0gKHBhdXNlVGltZSB8fCBwYXVzZVRpbWUgPT09IDApID8gcGF1c2VUaW1lIDogdGhpcy5fdGltZWxpbmUudG90YWxUaW1lKCk7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHQgLSAoKHQgLSB0aGlzLl9zdGFydFRpbWUpICogdGhpcy5fdGltZVNjYWxlIC8gdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdGltZVNjYWxlID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZShmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucmV2ZXJzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzLl9yZXZlcnNlZCkge1xuXHRcdFx0XHR0aGlzLl9yZXZlcnNlZCA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLnRvdGFsVGltZSgoKHRoaXMuX3RpbWVsaW5lICYmICF0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSAtIHRoaXMuX3RvdGFsVGltZSA6IHRoaXMuX3RvdGFsVGltZSksIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucGF1c2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGF1c2VkO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRsID0gdGhpcy5fdGltZWxpbmUsXG5cdFx0XHRcdHJhdywgZWxhcHNlZDtcblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzLl9wYXVzZWQpIGlmICh0bCkge1xuXHRcdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUgJiYgIXZhbHVlKSB7XG5cdFx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmF3ID0gdGwucmF3VGltZSgpO1xuXHRcdFx0XHRlbGFwc2VkID0gcmF3IC0gdGhpcy5fcGF1c2VUaW1lO1xuXHRcdFx0XHRpZiAoIXZhbHVlICYmIHRsLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lICs9IGVsYXBzZWQ7XG5cdFx0XHRcdFx0dGhpcy5fdW5jYWNoZShmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcGF1c2VUaW1lID0gdmFsdWUgPyByYXcgOiBudWxsO1xuXHRcdFx0XHR0aGlzLl9wYXVzZWQgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdGhpcy5pc0FjdGl2ZSgpO1xuXHRcdFx0XHRpZiAoIXZhbHVlICYmIGVsYXBzZWQgIT09IDAgJiYgdGhpcy5faW5pdHRlZCAmJiB0aGlzLmR1cmF0aW9uKCkpIHtcblx0XHRcdFx0XHR0aGlzLnJlbmRlcigodGwuc21vb3RoQ2hpbGRUaW1pbmcgPyB0aGlzLl90b3RhbFRpbWUgOiAocmF3IC0gdGhpcy5fc3RhcnRUaW1lKSAvIHRoaXMuX3RpbWVTY2FsZSksIHRydWUsIHRydWUpOyAvL2luIGNhc2UgdGhlIHRhcmdldCdzIHByb3BlcnRpZXMgY2hhbmdlZCB2aWEgc29tZSBvdGhlciB0d2VlbiBvciBtYW51YWwgdXBkYXRlIGJ5IHRoZSB1c2VyLCB3ZSBzaG91bGQgZm9yY2UgYSByZW5kZXIuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9nYyAmJiAhdmFsdWUpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBTaW1wbGVUaW1lbGluZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIFNpbXBsZVRpbWVsaW5lID0gX2NsYXNzKFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLCBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRBbmltYXRpb24uY2FsbCh0aGlzLCAwLCB2YXJzKTtcblx0XHRcdHRoaXMuYXV0b1JlbW92ZUNoaWxkcmVuID0gdGhpcy5zbW9vdGhDaGlsZFRpbWluZyA9IHRydWU7XG5cdFx0fSk7XG5cblx0XHRwID0gU2ltcGxlVGltZWxpbmUucHJvdG90eXBlID0gbmV3IEFuaW1hdGlvbigpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBTaW1wbGVUaW1lbGluZTtcblx0XHRwLmtpbGwoKS5fZ2MgPSBmYWxzZTtcblx0XHRwLl9maXJzdCA9IHAuX2xhc3QgPSBwLl9yZWNlbnQgPSBudWxsO1xuXHRcdHAuX3NvcnRDaGlsZHJlbiA9IGZhbHNlO1xuXG5cdFx0cC5hZGQgPSBwLmluc2VydCA9IGZ1bmN0aW9uKGNoaWxkLCBwb3NpdGlvbiwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHZhciBwcmV2VHdlZW4sIHN0O1xuXHRcdFx0Y2hpbGQuX3N0YXJ0VGltZSA9IE51bWJlcihwb3NpdGlvbiB8fCAwKSArIGNoaWxkLl9kZWxheTtcblx0XHRcdGlmIChjaGlsZC5fcGF1c2VkKSBpZiAodGhpcyAhPT0gY2hpbGQuX3RpbWVsaW5lKSB7IC8vd2Ugb25seSBhZGp1c3QgdGhlIF9wYXVzZVRpbWUgaWYgaXQgd2Fzbid0IGluIHRoaXMgdGltZWxpbmUgYWxyZWFkeS4gUmVtZW1iZXIsIHNvbWV0aW1lcyBhIHR3ZWVuIHdpbGwgYmUgaW5zZXJ0ZWQgYWdhaW4gaW50byB0aGUgc2FtZSB0aW1lbGluZSB3aGVuIGl0cyBzdGFydFRpbWUgaXMgY2hhbmdlZCBzbyB0aGF0IHRoZSB0d2VlbnMgaW4gdGhlIFRpbWVsaW5lTGl0ZS9NYXggYXJlIHJlLW9yZGVyZWQgcHJvcGVybHkgaW4gdGhlIGxpbmtlZCBsaXN0IChzbyBldmVyeXRoaW5nIHJlbmRlcnMgaW4gdGhlIHByb3BlciBvcmRlcikuXG5cdFx0XHRcdGNoaWxkLl9wYXVzZVRpbWUgPSBjaGlsZC5fc3RhcnRUaW1lICsgKCh0aGlzLnJhd1RpbWUoKSAtIGNoaWxkLl9zdGFydFRpbWUpIC8gY2hpbGQuX3RpbWVTY2FsZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2hpbGQudGltZWxpbmUpIHtcblx0XHRcdFx0Y2hpbGQudGltZWxpbmUuX3JlbW92ZShjaGlsZCwgdHJ1ZSk7IC8vcmVtb3ZlcyBmcm9tIGV4aXN0aW5nIHRpbWVsaW5lIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IGFkZGVkIHRvIHRoaXMgb25lLlxuXHRcdFx0fVxuXHRcdFx0Y2hpbGQudGltZWxpbmUgPSBjaGlsZC5fdGltZWxpbmUgPSB0aGlzO1xuXHRcdFx0aWYgKGNoaWxkLl9nYykge1xuXHRcdFx0XHRjaGlsZC5fZW5hYmxlZCh0cnVlLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHByZXZUd2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRpZiAodGhpcy5fc29ydENoaWxkcmVuKSB7XG5cdFx0XHRcdHN0ID0gY2hpbGQuX3N0YXJ0VGltZTtcblx0XHRcdFx0d2hpbGUgKHByZXZUd2VlbiAmJiBwcmV2VHdlZW4uX3N0YXJ0VGltZSA+IHN0KSB7XG5cdFx0XHRcdFx0cHJldlR3ZWVuID0gcHJldlR3ZWVuLl9wcmV2O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJldlR3ZWVuKSB7XG5cdFx0XHRcdGNoaWxkLl9uZXh0ID0gcHJldlR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRwcmV2VHdlZW4uX25leHQgPSBjaGlsZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoaWxkLl9uZXh0ID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHRoaXMuX2ZpcnN0ID0gY2hpbGQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2hpbGQuX25leHQpIHtcblx0XHRcdFx0Y2hpbGQuX25leHQuX3ByZXYgPSBjaGlsZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2xhc3QgPSBjaGlsZDtcblx0XHRcdH1cblx0XHRcdGNoaWxkLl9wcmV2ID0gcHJldlR3ZWVuO1xuXHRcdFx0dGhpcy5fcmVjZW50ID0gY2hpbGQ7XG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUpIHtcblx0XHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLl9yZW1vdmUgPSBmdW5jdGlvbih0d2Vlbiwgc2tpcERpc2FibGUpIHtcblx0XHRcdGlmICh0d2Vlbi50aW1lbGluZSA9PT0gdGhpcykge1xuXHRcdFx0XHRpZiAoIXNraXBEaXNhYmxlKSB7XG5cdFx0XHRcdFx0dHdlZW4uX2VuYWJsZWQoZmFsc2UsIHRydWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHR3ZWVuLl9wcmV2KSB7XG5cdFx0XHRcdFx0dHdlZW4uX3ByZXYuX25leHQgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9maXJzdCA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdCA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0d2Vlbi5fbmV4dCkge1xuXHRcdFx0XHRcdHR3ZWVuLl9uZXh0Ll9wcmV2ID0gdHdlZW4uX3ByZXY7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fbGFzdCA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHR0aGlzLl9sYXN0ID0gdHdlZW4uX3ByZXY7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4uX25leHQgPSB0d2Vlbi5fcHJldiA9IHR3ZWVuLnRpbWVsaW5lID0gbnVsbDtcblx0XHRcdFx0aWYgKHR3ZWVuID09PSB0aGlzLl9yZWNlbnQpIHtcblx0XHRcdFx0XHR0aGlzLl9yZWNlbnQgPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdCxcblx0XHRcdFx0bmV4dDtcblx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9uZXh0OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0aWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHRpbWUgPj0gdHdlZW4uX3N0YXJ0VGltZSAmJiAhdHdlZW4uX3BhdXNlZCkpIHtcblx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5yYXdUaW1lID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxUaW1lO1xuXHRcdH07XG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUd2VlbkxpdGVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBUd2VlbkxpdGUgPSBfY2xhc3MoXCJUd2VlbkxpdGVcIiwgZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0XHRBbmltYXRpb24uY2FsbCh0aGlzLCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0XHRcdHRoaXMucmVuZGVyID0gVHdlZW5MaXRlLnByb3RvdHlwZS5yZW5kZXI7IC8vc3BlZWQgb3B0aW1pemF0aW9uIChhdm9pZCBwcm90b3R5cGUgbG9va3VwIG9uIHRoaXMgXCJob3RcIiBtZXRob2QpXG5cblx0XHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhyb3cgXCJDYW5ub3QgdHdlZW4gYSBudWxsIHRhcmdldC5cIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0ID0gKHR5cGVvZih0YXJnZXQpICE9PSBcInN0cmluZ1wiKSA/IHRhcmdldCA6IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnZXQpIHx8IHRhcmdldDtcblxuXHRcdFx0XHR2YXIgaXNTZWxlY3RvciA9ICh0YXJnZXQuanF1ZXJ5IHx8ICh0YXJnZXQubGVuZ3RoICYmIHRhcmdldCAhPT0gd2luZG93ICYmIHRhcmdldFswXSAmJiAodGFyZ2V0WzBdID09PSB3aW5kb3cgfHwgKHRhcmdldFswXS5ub2RlVHlwZSAmJiB0YXJnZXRbMF0uc3R5bGUgJiYgIXRhcmdldC5ub2RlVHlwZSkpKSksXG5cdFx0XHRcdFx0b3ZlcndyaXRlID0gdGhpcy52YXJzLm92ZXJ3cml0ZSxcblx0XHRcdFx0XHRpLCB0YXJnLCB0YXJnZXRzO1xuXG5cdFx0XHRcdHRoaXMuX292ZXJ3cml0ZSA9IG92ZXJ3cml0ZSA9IChvdmVyd3JpdGUgPT0gbnVsbCkgPyBfb3ZlcndyaXRlTG9va3VwW1R3ZWVuTGl0ZS5kZWZhdWx0T3ZlcndyaXRlXSA6ICh0eXBlb2Yob3ZlcndyaXRlKSA9PT0gXCJudW1iZXJcIikgPyBvdmVyd3JpdGUgPj4gMCA6IF9vdmVyd3JpdGVMb29rdXBbb3ZlcndyaXRlXTtcblxuXHRcdFx0XHRpZiAoKGlzU2VsZWN0b3IgfHwgdGFyZ2V0IGluc3RhbmNlb2YgQXJyYXkgfHwgKHRhcmdldC5wdXNoICYmIF9pc0FycmF5KHRhcmdldCkpKSAmJiB0eXBlb2YodGFyZ2V0WzBdKSAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdHRoaXMuX3RhcmdldHMgPSB0YXJnZXRzID0gX3NsaWNlKHRhcmdldCk7ICAvL2Rvbid0IHVzZSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0YXJnZXQsIDApIGJlY2F1c2UgdGhhdCBkb2Vzbid0IHdvcmsgaW4gSUU4IHdpdGggYSBOb2RlTGlzdCB0aGF0J3MgcmV0dXJuZWQgYnkgcXVlcnlTZWxlY3RvckFsbCgpXG5cdFx0XHRcdFx0dGhpcy5fcHJvcExvb2t1cCA9IFtdO1xuXHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzID0gW107XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHRhcmcgPSB0YXJnZXRzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKCF0YXJnKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGktLSwgMSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodGFyZykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdFx0dGFyZyA9IHRhcmdldHNbaS0tXSA9IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnKTsgLy9pbiBjYXNlIGl0J3MgYW4gYXJyYXkgb2Ygc3RyaW5nc1xuXHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mKHRhcmcpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaSsxLCAxKTsgLy90byBhdm9pZCBhbiBlbmRsZXNzIGxvb3AgKGNhbid0IGltYWdpbmUgd2h5IHRoZSBzZWxlY3RvciB3b3VsZCByZXR1cm4gYSBzdHJpbmcsIGJ1dCBqdXN0IGluIGNhc2UpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRhcmcubGVuZ3RoICYmIHRhcmcgIT09IHdpbmRvdyAmJiB0YXJnWzBdICYmICh0YXJnWzBdID09PSB3aW5kb3cgfHwgKHRhcmdbMF0ubm9kZVR5cGUgJiYgdGFyZ1swXS5zdHlsZSAmJiAhdGFyZy5ub2RlVHlwZSkpKSB7IC8vaW4gY2FzZSB0aGUgdXNlciBpcyBwYXNzaW5nIGluIGFuIGFycmF5IG9mIHNlbGVjdG9yIG9iamVjdHMgKGxpa2UgalF1ZXJ5IG9iamVjdHMpLCB3ZSBuZWVkIHRvIGNoZWNrIG9uZSBtb3JlIGxldmVsIGFuZCBwdWxsIHRoaW5ncyBvdXQgaWYgbmVjZXNzYXJ5LiBBbHNvIG5vdGUgdGhhdCA8c2VsZWN0PiBlbGVtZW50cyBwYXNzIGFsbCB0aGUgY3JpdGVyaWEgcmVnYXJkaW5nIGxlbmd0aCBhbmQgdGhlIGZpcnN0IGNoaWxkIGhhdmluZyBzdHlsZSwgc28gd2UgbXVzdCBhbHNvIGNoZWNrIHRvIGVuc3VyZSB0aGUgdGFyZ2V0IGlzbid0IGFuIEhUTUwgbm9kZSBpdHNlbGYuXG5cdFx0XHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGktLSwgMSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3RhcmdldHMgPSB0YXJnZXRzID0gdGFyZ2V0cy5jb25jYXQoX3NsaWNlKHRhcmcpKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9zaWJsaW5nc1tpXSA9IF9yZWdpc3Rlcih0YXJnLCB0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRpZiAob3ZlcndyaXRlID09PSAxKSBpZiAodGhpcy5fc2libGluZ3NbaV0ubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdFx0XHRfYXBwbHlPdmVyd3JpdGUodGFyZywgdGhpcywgbnVsbCwgMSwgdGhpcy5fc2libGluZ3NbaV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Byb3BMb29rdXAgPSB7fTtcblx0XHRcdFx0XHR0aGlzLl9zaWJsaW5ncyA9IF9yZWdpc3Rlcih0YXJnZXQsIHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0XHRpZiAob3ZlcndyaXRlID09PSAxKSBpZiAodGhpcy5fc2libGluZ3MubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdFx0X2FwcGx5T3ZlcndyaXRlKHRhcmdldCwgdGhpcywgbnVsbCwgMSwgdGhpcy5fc2libGluZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciB8fCAoZHVyYXRpb24gPT09IDAgJiYgdGhpcy5fZGVsYXkgPT09IDAgJiYgdGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UpKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IC1fdGlueU51bTsgLy9mb3JjZXMgYSByZW5kZXIgd2l0aG91dCBoYXZpbmcgdG8gc2V0IHRoZSByZW5kZXIoKSBcImZvcmNlXCIgcGFyYW1ldGVyIHRvIHRydWUgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IGxhenlpbmcgYnkgZGVmYXVsdCAodXNpbmcgdGhlIFwiZm9yY2VcIiBwYXJhbWV0ZXIgYWx3YXlzIGZvcmNlcyBhbiBpbW1lZGlhdGUgZnVsbCByZW5kZXIpXG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIoLXRoaXMuX2RlbGF5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRfaXNTZWxlY3RvciA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0cmV0dXJuICh2ICYmIHYubGVuZ3RoICYmIHYgIT09IHdpbmRvdyAmJiB2WzBdICYmICh2WzBdID09PSB3aW5kb3cgfHwgKHZbMF0ubm9kZVR5cGUgJiYgdlswXS5zdHlsZSAmJiAhdi5ub2RlVHlwZSkpKTsgLy93ZSBjYW5ub3QgY2hlY2sgXCJub2RlVHlwZVwiIGlmIHRoZSB0YXJnZXQgaXMgd2luZG93IGZyb20gd2l0aGluIGFuIGlmcmFtZSwgb3RoZXJ3aXNlIGl0IHdpbGwgdHJpZ2dlciBhIHNlY3VyaXR5IGVycm9yIGluIHNvbWUgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxuXHRcdFx0fSxcblx0XHRcdF9hdXRvQ1NTID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHRcdHZhciBjc3MgPSB7fSxcblx0XHRcdFx0XHRwO1xuXHRcdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRcdGlmICghX3Jlc2VydmVkUHJvcHNbcF0gJiYgKCEocCBpbiB0YXJnZXQpIHx8IHAgPT09IFwidHJhbnNmb3JtXCIgfHwgcCA9PT0gXCJ4XCIgfHwgcCA9PT0gXCJ5XCIgfHwgcCA9PT0gXCJ3aWR0aFwiIHx8IHAgPT09IFwiaGVpZ2h0XCIgfHwgcCA9PT0gXCJjbGFzc05hbWVcIiB8fCBwID09PSBcImJvcmRlclwiKSAmJiAoIV9wbHVnaW5zW3BdIHx8IChfcGx1Z2luc1twXSAmJiBfcGx1Z2luc1twXS5fYXV0b0NTUykpKSB7IC8vbm90ZTogPGltZz4gZWxlbWVudHMgY29udGFpbiByZWFkLW9ubHkgXCJ4XCIgYW5kIFwieVwiIHByb3BlcnRpZXMuIFdlIHNob3VsZCBhbHNvIHByaW9yaXRpemUgZWRpdGluZyBjc3Mgd2lkdGgvaGVpZ2h0IHJhdGhlciB0aGFuIHRoZSBlbGVtZW50J3MgcHJvcGVydGllcy5cblx0XHRcdFx0XHRcdGNzc1twXSA9IHZhcnNbcF07XG5cdFx0XHRcdFx0XHRkZWxldGUgdmFyc1twXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFycy5jc3MgPSBjc3M7XG5cdFx0XHR9O1xuXG5cdFx0cCA9IFR3ZWVuTGl0ZS5wcm90b3R5cGUgPSBuZXcgQW5pbWF0aW9uKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFR3ZWVuTGl0ZTtcblx0XHRwLmtpbGwoKS5fZ2MgPSBmYWxzZTtcblxuLy8tLS0tVHdlZW5MaXRlIGRlZmF1bHRzLCBvdmVyd3JpdGUgbWFuYWdlbWVudCwgYW5kIHJvb3QgdXBkYXRlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRwLnJhdGlvID0gMDtcblx0XHRwLl9maXJzdFBUID0gcC5fdGFyZ2V0cyA9IHAuX292ZXJ3cml0dGVuUHJvcHMgPSBwLl9zdGFydEF0ID0gbnVsbDtcblx0XHRwLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkID0gcC5fbGF6eSA9IGZhbHNlO1xuXG5cdFx0VHdlZW5MaXRlLnZlcnNpb24gPSBcIjEuMTYuMFwiO1xuXHRcdFR3ZWVuTGl0ZS5kZWZhdWx0RWFzZSA9IHAuX2Vhc2UgPSBuZXcgRWFzZShudWxsLCBudWxsLCAxLCAxKTtcblx0XHRUd2VlbkxpdGUuZGVmYXVsdE92ZXJ3cml0ZSA9IFwiYXV0b1wiO1xuXHRcdFR3ZWVuTGl0ZS50aWNrZXIgPSBfdGlja2VyO1xuXHRcdFR3ZWVuTGl0ZS5hdXRvU2xlZXAgPSAxMjA7XG5cdFx0VHdlZW5MaXRlLmxhZ1Ntb290aGluZyA9IGZ1bmN0aW9uKHRocmVzaG9sZCwgYWRqdXN0ZWRMYWcpIHtcblx0XHRcdF90aWNrZXIubGFnU21vb3RoaW5nKHRocmVzaG9sZCwgYWRqdXN0ZWRMYWcpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuc2VsZWN0b3IgPSB3aW5kb3cuJCB8fCB3aW5kb3cualF1ZXJ5IHx8IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBzZWxlY3RvciA9IHdpbmRvdy4kIHx8IHdpbmRvdy5qUXVlcnk7XG5cdFx0XHRpZiAoc2VsZWN0b3IpIHtcblx0XHRcdFx0VHdlZW5MaXRlLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdHJldHVybiBzZWxlY3RvcihlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodHlwZW9mKGRvY3VtZW50KSA9PT0gXCJ1bmRlZmluZWRcIikgPyBlIDogKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGUpIDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoKGUuY2hhckF0KDApID09PSBcIiNcIikgPyBlLnN1YnN0cigxKSA6IGUpKTtcblx0XHR9O1xuXG5cdFx0dmFyIF9sYXp5VHdlZW5zID0gW10sXG5cdFx0XHRfbGF6eUxvb2t1cCA9IHt9LFxuXHRcdFx0X2ludGVybmFscyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzID0ge2lzQXJyYXk6X2lzQXJyYXksIGlzU2VsZWN0b3I6X2lzU2VsZWN0b3IsIGxhenlUd2VlbnM6X2xhenlUd2VlbnN9LCAvL2dpdmVzIHVzIGEgd2F5IHRvIGV4cG9zZSBjZXJ0YWluIHByaXZhdGUgdmFsdWVzIHRvIG90aGVyIEdyZWVuU29jayBjbGFzc2VzIHdpdGhvdXQgY29udGFtaW5hdGluZyB0aGEgbWFpbiBUd2VlbkxpdGUgb2JqZWN0LlxuXHRcdFx0X3BsdWdpbnMgPSBUd2VlbkxpdGUuX3BsdWdpbnMgPSB7fSxcblx0XHRcdF90d2Vlbkxvb2t1cCA9IF9pbnRlcm5hbHMudHdlZW5Mb29rdXAgPSB7fSxcblx0XHRcdF90d2Vlbkxvb2t1cE51bSA9IDAsXG5cdFx0XHRfcmVzZXJ2ZWRQcm9wcyA9IF9pbnRlcm5hbHMucmVzZXJ2ZWRQcm9wcyA9IHtlYXNlOjEsIGRlbGF5OjEsIG92ZXJ3cml0ZToxLCBvbkNvbXBsZXRlOjEsIG9uQ29tcGxldGVQYXJhbXM6MSwgb25Db21wbGV0ZVNjb3BlOjEsIHVzZUZyYW1lczoxLCBydW5CYWNrd2FyZHM6MSwgc3RhcnRBdDoxLCBvblVwZGF0ZToxLCBvblVwZGF0ZVBhcmFtczoxLCBvblVwZGF0ZVNjb3BlOjEsIG9uU3RhcnQ6MSwgb25TdGFydFBhcmFtczoxLCBvblN0YXJ0U2NvcGU6MSwgb25SZXZlcnNlQ29tcGxldGU6MSwgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6MSwgb25SZXZlcnNlQ29tcGxldGVTY29wZToxLCBvblJlcGVhdDoxLCBvblJlcGVhdFBhcmFtczoxLCBvblJlcGVhdFNjb3BlOjEsIGVhc2VQYXJhbXM6MSwgeW95bzoxLCBpbW1lZGlhdGVSZW5kZXI6MSwgcmVwZWF0OjEsIHJlcGVhdERlbGF5OjEsIGRhdGE6MSwgcGF1c2VkOjEsIHJldmVyc2VkOjEsIGF1dG9DU1M6MSwgbGF6eToxLCBvbk92ZXJ3cml0ZToxfSxcblx0XHRcdF9vdmVyd3JpdGVMb29rdXAgPSB7bm9uZTowLCBhbGw6MSwgYXV0bzoyLCBjb25jdXJyZW50OjMsIGFsbE9uU3RhcnQ6NCwgcHJlZXhpc3Rpbmc6NSwgXCJ0cnVlXCI6MSwgXCJmYWxzZVwiOjB9LFxuXHRcdFx0X3Jvb3RGcmFtZXNUaW1lbGluZSA9IEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lID0gbmV3IFNpbXBsZVRpbWVsaW5lKCksXG5cdFx0XHRfcm9vdFRpbWVsaW5lID0gQW5pbWF0aW9uLl9yb290VGltZWxpbmUgPSBuZXcgU2ltcGxlVGltZWxpbmUoKSxcblx0XHRcdF9uZXh0R0NGcmFtZSA9IDMwLFxuXHRcdFx0X2xhenlSZW5kZXIgPSBfaW50ZXJuYWxzLmxhenlSZW5kZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGkgPSBfbGF6eVR3ZWVucy5sZW5ndGgsXG5cdFx0XHRcdFx0dHdlZW47XG5cdFx0XHRcdF9sYXp5TG9va3VwID0ge307XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHR3ZWVuID0gX2xhenlUd2VlbnNbaV07XG5cdFx0XHRcdFx0aWYgKHR3ZWVuICYmIHR3ZWVuLl9sYXp5ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR0d2Vlbi5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRfbGF6eVR3ZWVucy5sZW5ndGggPSAwO1xuXHRcdFx0fTtcblxuXHRcdF9yb290VGltZWxpbmUuX3N0YXJ0VGltZSA9IF90aWNrZXIudGltZTtcblx0XHRfcm9vdEZyYW1lc1RpbWVsaW5lLl9zdGFydFRpbWUgPSBfdGlja2VyLmZyYW1lO1xuXHRcdF9yb290VGltZWxpbmUuX2FjdGl2ZSA9IF9yb290RnJhbWVzVGltZWxpbmUuX2FjdGl2ZSA9IHRydWU7XG5cdFx0c2V0VGltZW91dChfbGF6eVJlbmRlciwgMSk7IC8vb24gc29tZSBtb2JpbGUgZGV2aWNlcywgdGhlcmUgaXNuJ3QgYSBcInRpY2tcIiBiZWZvcmUgY29kZSBydW5zIHdoaWNoIG1lYW5zIGFueSBsYXp5IHJlbmRlcnMgd291bGRuJ3QgcnVuIGJlZm9yZSB0aGUgbmV4dCBvZmZpY2lhbCBcInRpY2tcIi5cblxuXHRcdEFuaW1hdGlvbi5fdXBkYXRlUm9vdCA9IFR3ZWVuTGl0ZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGksIGEsIHA7XG5cdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pZiBjb2RlIGlzIHJ1biBvdXRzaWRlIG9mIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbG9vcCwgdGhlcmUgbWF5IGJlIHR3ZWVucyBxdWV1ZWQgQUZURVIgdGhlIGVuZ2luZSByZWZyZXNoZWQsIHNvIHdlIG5lZWQgdG8gZW5zdXJlIGFueSBwZW5kaW5nIHJlbmRlcnMgb2NjdXIgYmVmb3JlIHdlIHJlZnJlc2ggYWdhaW4uXG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcm9vdFRpbWVsaW5lLnJlbmRlcigoX3RpY2tlci50aW1lIC0gX3Jvb3RUaW1lbGluZS5fc3RhcnRUaW1lKSAqIF9yb290VGltZWxpbmUuX3RpbWVTY2FsZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0X3Jvb3RGcmFtZXNUaW1lbGluZS5yZW5kZXIoKF90aWNrZXIuZnJhbWUgLSBfcm9vdEZyYW1lc1RpbWVsaW5lLl9zdGFydFRpbWUpICogX3Jvb3RGcmFtZXNUaW1lbGluZS5fdGltZVNjYWxlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX3RpY2tlci5mcmFtZSA+PSBfbmV4dEdDRnJhbWUpIHsgLy9kdW1wIGdhcmJhZ2UgZXZlcnkgMTIwIGZyYW1lcyBvciB3aGF0ZXZlciB0aGUgdXNlciBzZXRzIFR3ZWVuTGl0ZS5hdXRvU2xlZXAgdG9cblx0XHRcdFx0XHRfbmV4dEdDRnJhbWUgPSBfdGlja2VyLmZyYW1lICsgKHBhcnNlSW50KFR3ZWVuTGl0ZS5hdXRvU2xlZXAsIDEwKSB8fCAxMjApO1xuXHRcdFx0XHRcdGZvciAocCBpbiBfdHdlZW5Mb29rdXApIHtcblx0XHRcdFx0XHRcdGEgPSBfdHdlZW5Mb29rdXBbcF0udHdlZW5zO1xuXHRcdFx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhW2ldLl9nYykge1xuXHRcdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoYS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIF90d2Vlbkxvb2t1cFtwXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9pZiB0aGVyZSBhcmUgbm8gbW9yZSB0d2VlbnMgaW4gdGhlIHJvb3QgdGltZWxpbmVzLCBvciBpZiB0aGV5J3JlIGFsbCBwYXVzZWQsIG1ha2UgdGhlIF90aW1lciBzbGVlcCB0byByZWR1Y2UgbG9hZCBvbiB0aGUgQ1BVIHNsaWdodGx5XG5cdFx0XHRcdFx0cCA9IF9yb290VGltZWxpbmUuX2ZpcnN0O1xuXHRcdFx0XHRcdGlmICghcCB8fCBwLl9wYXVzZWQpIGlmIChUd2VlbkxpdGUuYXV0b1NsZWVwICYmICFfcm9vdEZyYW1lc1RpbWVsaW5lLl9maXJzdCAmJiBfdGlja2VyLl9saXN0ZW5lcnMudGljay5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRcdHdoaWxlIChwICYmIHAuX3BhdXNlZCkge1xuXHRcdFx0XHRcdFx0XHRwID0gcC5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghcCkge1xuXHRcdFx0XHRcdFx0XHRfdGlja2VyLnNsZWVwKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0X3RpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBBbmltYXRpb24uX3VwZGF0ZVJvb3QpO1xuXG5cdFx0dmFyIF9yZWdpc3RlciA9IGZ1bmN0aW9uKHRhcmdldCwgdHdlZW4sIHNjcnViKSB7XG5cdFx0XHRcdHZhciBpZCA9IHRhcmdldC5fZ3NUd2VlbklELCBhLCBpO1xuXHRcdFx0XHRpZiAoIV90d2Vlbkxvb2t1cFtpZCB8fCAodGFyZ2V0Ll9nc1R3ZWVuSUQgPSBpZCA9IFwidFwiICsgKF90d2Vlbkxvb2t1cE51bSsrKSldKSB7XG5cdFx0XHRcdFx0X3R3ZWVuTG9va3VwW2lkXSA9IHt0YXJnZXQ6dGFyZ2V0LCB0d2VlbnM6W119O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0d2Vlbikge1xuXHRcdFx0XHRcdGEgPSBfdHdlZW5Mb29rdXBbaWRdLnR3ZWVucztcblx0XHRcdFx0XHRhWyhpID0gYS5sZW5ndGgpXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdGlmIChzY3J1Yikge1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhW2ldID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBfdHdlZW5Mb29rdXBbaWRdLnR3ZWVucztcblx0XHRcdH0sXG5cblx0XHRcdF9vbk92ZXJ3cml0ZSA9IGZ1bmN0aW9uKG92ZXJ3cml0dGVuVHdlZW4sIG92ZXJ3cml0aW5nVHdlZW4sIHRhcmdldCwga2lsbGVkUHJvcHMpIHtcblx0XHRcdFx0dmFyIGZ1bmMgPSBvdmVyd3JpdHRlblR3ZWVuLnZhcnMub25PdmVyd3JpdGUsIHIxLCByMjtcblx0XHRcdFx0aWYgKGZ1bmMpIHtcblx0XHRcdFx0XHRyMSA9IGZ1bmMob3ZlcndyaXR0ZW5Ud2Vlbiwgb3ZlcndyaXRpbmdUd2VlbiwgdGFyZ2V0LCBraWxsZWRQcm9wcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuYyA9IFR3ZWVuTGl0ZS5vbk92ZXJ3cml0ZTtcblx0XHRcdFx0aWYgKGZ1bmMpIHtcblx0XHRcdFx0XHRyMiA9IGZ1bmMob3ZlcndyaXR0ZW5Ud2Vlbiwgb3ZlcndyaXRpbmdUd2VlbiwgdGFyZ2V0LCBraWxsZWRQcm9wcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIChyMSAhPT0gZmFsc2UgJiYgcjIgIT09IGZhbHNlKTtcblx0XHRcdH0sXG5cdFx0XHRfYXBwbHlPdmVyd3JpdGUgPSBmdW5jdGlvbih0YXJnZXQsIHR3ZWVuLCBwcm9wcywgbW9kZSwgc2libGluZ3MpIHtcblx0XHRcdFx0dmFyIGksIGNoYW5nZWQsIGN1clR3ZWVuLCBsO1xuXHRcdFx0XHRpZiAobW9kZSA9PT0gMSB8fCBtb2RlID49IDQpIHtcblx0XHRcdFx0XHRsID0gc2libGluZ3MubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmICgoY3VyVHdlZW4gPSBzaWJsaW5nc1tpXSkgIT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghY3VyVHdlZW4uX2djKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKF9vbk92ZXJ3cml0ZShjdXJUd2VlbiwgdHdlZW4pICYmIGN1clR3ZWVuLl9lbmFibGVkKGZhbHNlLCBmYWxzZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChtb2RlID09PSA1KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL05PVEU6IEFkZCAwLjAwMDAwMDAwMDEgdG8gb3ZlcmNvbWUgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIHRoYXQgY2FuIGNhdXNlIHRoZSBzdGFydFRpbWUgdG8gYmUgVkVSWSBzbGlnaHRseSBvZmYgKHdoZW4gYSB0d2VlbidzIHRpbWUoKSBpcyBzZXQgZm9yIGV4YW1wbGUpXG5cdFx0XHRcdHZhciBzdGFydFRpbWUgPSB0d2Vlbi5fc3RhcnRUaW1lICsgX3RpbnlOdW0sXG5cdFx0XHRcdFx0b3ZlcmxhcHMgPSBbXSxcblx0XHRcdFx0XHRvQ291bnQgPSAwLFxuXHRcdFx0XHRcdHplcm9EdXIgPSAodHdlZW4uX2R1cmF0aW9uID09PSAwKSxcblx0XHRcdFx0XHRnbG9iYWxTdGFydDtcblx0XHRcdFx0aSA9IHNpYmxpbmdzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKChjdXJUd2VlbiA9IHNpYmxpbmdzW2ldKSA9PT0gdHdlZW4gfHwgY3VyVHdlZW4uX2djIHx8IGN1clR3ZWVuLl9wYXVzZWQpIHtcblx0XHRcdFx0XHRcdC8vaWdub3JlXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjdXJUd2Vlbi5fdGltZWxpbmUgIT09IHR3ZWVuLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdFx0Z2xvYmFsU3RhcnQgPSBnbG9iYWxTdGFydCB8fCBfY2hlY2tPdmVybGFwKHR3ZWVuLCAwLCB6ZXJvRHVyKTtcblx0XHRcdFx0XHRcdGlmIChfY2hlY2tPdmVybGFwKGN1clR3ZWVuLCBnbG9iYWxTdGFydCwgemVyb0R1cikgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0b3ZlcmxhcHNbb0NvdW50KytdID0gY3VyVHdlZW47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjdXJUd2Vlbi5fc3RhcnRUaW1lIDw9IHN0YXJ0VGltZSkgaWYgKGN1clR3ZWVuLl9zdGFydFRpbWUgKyBjdXJUd2Vlbi50b3RhbER1cmF0aW9uKCkgLyBjdXJUd2Vlbi5fdGltZVNjYWxlID4gc3RhcnRUaW1lKSBpZiAoISgoemVyb0R1ciB8fCAhY3VyVHdlZW4uX2luaXR0ZWQpICYmIHN0YXJ0VGltZSAtIGN1clR3ZWVuLl9zdGFydFRpbWUgPD0gMC4wMDAwMDAwMDAyKSkge1xuXHRcdFx0XHRcdFx0b3ZlcmxhcHNbb0NvdW50KytdID0gY3VyVHdlZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSA9IG9Db3VudDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0Y3VyVHdlZW4gPSBvdmVybGFwc1tpXTtcblx0XHRcdFx0XHRpZiAobW9kZSA9PT0gMikgaWYgKGN1clR3ZWVuLl9raWxsKHByb3BzLCB0YXJnZXQsIHR3ZWVuKSkge1xuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtb2RlICE9PSAyIHx8ICghY3VyVHdlZW4uX2ZpcnN0UFQgJiYgY3VyVHdlZW4uX2luaXR0ZWQpKSB7XG5cdFx0XHRcdFx0XHRpZiAobW9kZSAhPT0gMiAmJiAhX29uT3ZlcndyaXRlKGN1clR3ZWVuLCB0d2VlbikpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoY3VyVHdlZW4uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKSkgeyAvL2lmIGFsbCBwcm9wZXJ0eSB0d2VlbnMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuLCBraWxsIHRoZSB0d2Vlbi5cblx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0X2NoZWNrT3ZlcmxhcCA9IGZ1bmN0aW9uKHR3ZWVuLCByZWZlcmVuY2UsIHplcm9EdXIpIHtcblx0XHRcdFx0dmFyIHRsID0gdHdlZW4uX3RpbWVsaW5lLFxuXHRcdFx0XHRcdHRzID0gdGwuX3RpbWVTY2FsZSxcblx0XHRcdFx0XHR0ID0gdHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdHQgKz0gdGwuX3N0YXJ0VGltZTtcblx0XHRcdFx0XHR0cyAqPSB0bC5fdGltZVNjYWxlO1xuXHRcdFx0XHRcdGlmICh0bC5fcGF1c2VkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gLTEwMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGwgPSB0bC5fdGltZWxpbmU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dCAvPSB0cztcblx0XHRcdFx0cmV0dXJuICh0ID4gcmVmZXJlbmNlKSA/IHQgLSByZWZlcmVuY2UgOiAoKHplcm9EdXIgJiYgdCA9PT0gcmVmZXJlbmNlKSB8fCAoIXR3ZWVuLl9pbml0dGVkICYmIHQgLSByZWZlcmVuY2UgPCAyICogX3RpbnlOdW0pKSA/IF90aW55TnVtIDogKCh0ICs9IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSAvIHR3ZWVuLl90aW1lU2NhbGUgLyB0cykgPiByZWZlcmVuY2UgKyBfdGlueU51bSkgPyAwIDogdCAtIHJlZmVyZW5jZSAtIF90aW55TnVtO1xuXHRcdFx0fTtcblxuXG4vLy0tLS0gVHdlZW5MaXRlIGluc3RhbmNlIG1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdHAuX2luaXQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB2ID0gdGhpcy52YXJzLFxuXHRcdFx0XHRvcCA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMsXG5cdFx0XHRcdGR1ciA9IHRoaXMuX2R1cmF0aW9uLFxuXHRcdFx0XHRpbW1lZGlhdGUgPSAhIXYuaW1tZWRpYXRlUmVuZGVyLFxuXHRcdFx0XHRlYXNlID0gdi5lYXNlLFxuXHRcdFx0XHRpLCBpbml0UGx1Z2lucywgcHQsIHAsIHN0YXJ0VmFycztcblx0XHRcdGlmICh2LnN0YXJ0QXQpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSk7IC8vaWYgd2UndmUgcnVuIGEgc3RhcnRBdCBwcmV2aW91c2x5ICh3aGVuIHRoZSB0d2VlbiBpbnN0YW50aWF0ZWQpLCB3ZSBzaG91bGQgcmV2ZXJ0IGl0IHNvIHRoYXQgdGhlIHZhbHVlcyByZS1pbnN0YW50aWF0ZSBjb3JyZWN0bHkgcGFydGljdWxhcmx5IGZvciByZWxhdGl2ZSB0d2VlbnMuIFdpdGhvdXQgdGhpcywgYSBUd2VlbkxpdGUuZnJvbVRvKG9iaiwgMSwge3g6XCIrPTEwMFwifSwge3g6XCItPTEwMFwifSksIGZvciBleGFtcGxlLCB3b3VsZCBhY3R1YWxseSBqdW1wIHRvICs9MjAwIGJlY2F1c2UgdGhlIHN0YXJ0QXQgd291bGQgcnVuIHR3aWNlLCBkb3VibGluZyB0aGUgcmVsYXRpdmUgY2hhbmdlLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQua2lsbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJ0VmFycyA9IHt9O1xuXHRcdFx0XHRmb3IgKHAgaW4gdi5zdGFydEF0KSB7IC8vY29weSB0aGUgcHJvcGVydGllcy92YWx1ZXMgaW50byBhIG5ldyBvYmplY3QgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSB2YXIgdG8gPSB7eDowfSwgZnJvbSA9IHt4OjUwMH07IHRpbWVsaW5lLmZyb21UbyhlLCAxLCBmcm9tLCB0bykuZnJvbVRvKGUsIDEsIHRvLCBmcm9tKTtcblx0XHRcdFx0XHRzdGFydFZhcnNbcF0gPSB2LnN0YXJ0QXRbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhcnRWYXJzLm92ZXJ3cml0ZSA9IGZhbHNlO1xuXHRcdFx0XHRzdGFydFZhcnMuaW1tZWRpYXRlUmVuZGVyID0gdHJ1ZTtcblx0XHRcdFx0c3RhcnRWYXJzLmxhenkgPSAoaW1tZWRpYXRlICYmIHYubGF6eSAhPT0gZmFsc2UpO1xuXHRcdFx0XHRzdGFydFZhcnMuc3RhcnRBdCA9IHN0YXJ0VmFycy5kZWxheSA9IG51bGw7IC8vbm8gbmVzdGluZyBvZiBzdGFydEF0IG9iamVjdHMgYWxsb3dlZCAob3RoZXJ3aXNlIGl0IGNvdWxkIGNhdXNlIGFuIGluZmluaXRlIGxvb3ApLlxuXHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gVHdlZW5MaXRlLnRvKHRoaXMudGFyZ2V0LCAwLCBzdGFydFZhcnMpO1xuXHRcdFx0XHRpZiAoaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgPiAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gbnVsbDsgLy90d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgKGxpa2UgbW9zdCBmcm9tKCkgYW5kIGZyb21UbygpIHR3ZWVucykgc2hvdWxkbid0IHJldmVydCB3aGVuIHRoZWlyIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgc3RhcnRUaW1lIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIGNvdWxkIGhhdmUgaGFwcGVuZWQgYW55dGltZSBhbmQgaXQgc2hvdWxkbid0IGJlIGRpcmVjdGx5IGNvcnJlbGF0ZWQgdG8gdGhpcyB0d2VlbidzIHN0YXJ0VGltZS4gSW1hZ2luZSBzZXR0aW5nIHVwIGEgY29tcGxleCBhbmltYXRpb24gd2hlcmUgdGhlIGJlZ2lubmluZyBzdGF0ZXMgb2YgdmFyaW91cyBvYmplY3RzIGFyZSByZW5kZXJlZCBpbW1lZGlhdGVseSBidXQgdGhlIHR3ZWVuIGRvZXNuJ3QgaGFwcGVuIGZvciBxdWl0ZSBzb21lIHRpbWUgLSBpZiB3ZSByZXZlcnQgdG8gdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcyBzb29uIGFzIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHR3ZWVuJ3Mgc3RhcnRUaW1lLCBpdCB3aWxsIHRocm93IHRoaW5ncyBvZmYgdmlzdWFsbHkuIFJldmVyc2lvbiBzaG91bGQgb25seSBoYXBwZW4gaW4gVGltZWxpbmVMaXRlL01heCBpbnN0YW5jZXMgd2hlcmUgaW1tZWRpYXRlUmVuZGVyIHdhcyBmYWxzZSAod2hpY2ggaXMgdGhlIGRlZmF1bHQgaW4gdGhlIGNvbnZlbmllbmNlIG1ldGhvZHMgbGlrZSBmcm9tKCkpLlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZHVyICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47IC8vd2Ugc2tpcCBpbml0aWFsaXphdGlvbiBoZXJlIHNvIHRoYXQgb3ZlcndyaXRpbmcgZG9lc24ndCBvY2N1ciB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zLiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgc2V2ZXJhbCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZSB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0L3Byb3BlcnRpZXMgdG8gZHJvcCBpbnRvIGEgVGltZWxpbmVMaXRlIG9yIFRpbWVsaW5lTWF4LCB0aGUgbGFzdCBvbmUgY3JlYXRlZCB3b3VsZCBvdmVyd3JpdGUgdGhlIGZpcnN0IG9uZXMgYmVjYXVzZSB0aGV5IGRpZG4ndCBnZXQgcGxhY2VkIGludG8gdGhlIHRpbWVsaW5lIHlldCBiZWZvcmUgdGhlIGZpcnN0IHJlbmRlciBvY2N1cnMgYW5kIGtpY2tzIGluIG92ZXJ3cml0aW5nLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh2LnJ1bkJhY2t3YXJkcyAmJiBkdXIgIT09IDApIHtcblx0XHRcdFx0Ly9mcm9tKCkgdHdlZW5zIG11c3QgYmUgaGFuZGxlZCB1bmlxdWVseTogdGhlaXIgYmVnaW5uaW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkIGJ1dCB3ZSBkb24ndCB3YW50IG92ZXJ3cml0aW5nIHRvIG9jY3VyIHlldCAod2hlbiB0aW1lIGlzIHN0aWxsIDApLiBXYWl0IHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMgYmVmb3JlIGRvaW5nIGFsbCB0aGUgcm91dGluZXMgbGlrZSBvdmVyd3JpdGluZy4gQXQgdGhhdCB0aW1lLCB3ZSBzaG91bGQgcmVuZGVyIGF0IHRoZSBFTkQgb2YgdGhlIHR3ZWVuIHRvIGVuc3VyZSB0aGF0IHRoaW5ncyBpbml0aWFsaXplIGNvcnJlY3RseSAocmVtZW1iZXIsIGZyb20oKSB0d2VlbnMgZ28gYmFja3dhcmRzKVxuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKTtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LmtpbGwoKTtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSAhPT0gMCkgeyAvL2luIHJhcmUgY2FzZXMgKGxpa2UgaWYgYSBmcm9tKCkgdHdlZW4gcnVucyBhbmQgdGhlbiBpcyBpbnZhbGlkYXRlKCktZWQpLCBpbW1lZGlhdGVSZW5kZXIgY291bGQgYmUgdHJ1ZSBidXQgdGhlIGluaXRpYWwgZm9yY2VkLXJlbmRlciBnZXRzIHNraXBwZWQsIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSB0aGUgcmVuZGVyIGluIHRoaXMgY29udGV4dCB3aGVuIHRoZSBfdGltZSBpcyBncmVhdGVyIHRoYW4gMFxuXHRcdFx0XHRcdFx0aW1tZWRpYXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0ge307XG5cdFx0XHRcdFx0Zm9yIChwIGluIHYpIHsgLy9jb3B5IHByb3BzIGludG8gYSBuZXcgb2JqZWN0IGFuZCBza2lwIGFueSByZXNlcnZlZCBwcm9wcywgb3RoZXJ3aXNlIG9uQ29tcGxldGUgb3Igb25VcGRhdGUgb3Igb25TdGFydCBjb3VsZCBmaXJlLiBXZSBzaG91bGQsIGhvd2V2ZXIsIHBlcm1pdCBhdXRvQ1NTIHRvIGdvIHRocm91Z2guXG5cdFx0XHRcdFx0XHRpZiAoIV9yZXNlcnZlZFByb3BzW3BdIHx8IHAgPT09IFwiYXV0b0NTU1wiKSB7XG5cdFx0XHRcdFx0XHRcdHB0W3BdID0gdltwXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQub3ZlcndyaXRlID0gMDtcblx0XHRcdFx0XHRwdC5kYXRhID0gXCJpc0Zyb21TdGFydFwiOyAvL3dlIHRhZyB0aGUgdHdlZW4gd2l0aCBhcyBcImlzRnJvbVN0YXJ0XCIgc28gdGhhdCBpZiBbaW5zaWRlIGEgcGx1Z2luXSB3ZSBuZWVkIHRvIG9ubHkgZG8gc29tZXRoaW5nIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuLCB3ZSBoYXZlIGEgd2F5IG9mIGlkZW50aWZ5aW5nIHRoaXMgdHdlZW4gYXMgbWVyZWx5IHRoZSBvbmUgdGhhdCdzIHNldHRpbmcgdGhlIGJlZ2lubmluZyB2YWx1ZXMgZm9yIGEgXCJmcm9tKClcIiB0d2Vlbi4gRm9yIGV4YW1wbGUsIGNsZWFyUHJvcHMgaW4gQ1NTUGx1Z2luIHNob3VsZCBvbmx5IGdldCBhcHBsaWVkIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuIGFuZCB3aXRob3V0IHRoaXMgdGFnLCBmcm9tKC4uLntoZWlnaHQ6MTAwLCBjbGVhclByb3BzOlwiaGVpZ2h0XCIsIGRlbGF5OjF9KSB3b3VsZCB3aXBlIHRoZSBoZWlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gYW5kIGFmdGVyIDEgc2Vjb25kLCBpdCdkIGtpY2sgYmFjayBpbi5cblx0XHRcdFx0XHRwdC5sYXp5ID0gKGltbWVkaWF0ZSAmJiB2LmxhenkgIT09IGZhbHNlKTtcblx0XHRcdFx0XHRwdC5pbW1lZGlhdGVSZW5kZXIgPSBpbW1lZGlhdGU7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgcmVuZGVyIGltbWVkaWF0ZWx5IGJ5IGRlZmF1bHQsIGJ1dCBpZiB3ZSdyZSBub3Qgc3BlY2lmaWNhbGx5IGluc3RydWN0ZWQgdG8gcmVuZGVyIHRoaXMgdHdlZW4gaW1tZWRpYXRlbHksIHdlIHNob3VsZCBza2lwIHRoaXMgYW5kIG1lcmVseSBfaW5pdCgpIHRvIHJlY29yZCB0aGUgc3RhcnRpbmcgdmFsdWVzIChyZW5kZXJpbmcgdGhlbSBpbW1lZGlhdGVseSB3b3VsZCBwdXNoIHRoZW0gdG8gY29tcGxldGlvbiB3aGljaCBpcyB3YXN0ZWZ1bCBpbiB0aGF0IGNhc2UgLSB3ZSdkIGhhdmUgdG8gcmVuZGVyKC0xKSBpbW1lZGlhdGVseSBhZnRlcilcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gVHdlZW5MaXRlLnRvKHRoaXMudGFyZ2V0LCAwLCBwdCk7XG5cdFx0XHRcdFx0aWYgKCFpbW1lZGlhdGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQuX2luaXQoKTsgLy9lbnN1cmVzIHRoYXQgdGhlIGluaXRpYWwgdmFsdWVzIGFyZSByZWNvcmRlZFxuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5fZW5hYmxlZChmYWxzZSk7IC8vbm8gbmVlZCB0byBoYXZlIHRoZSB0d2VlbiByZW5kZXIgb24gdGhlIG5leHQgY3ljbGUuIERpc2FibGUgaXQgYmVjYXVzZSB3ZSdsbCBhbHdheXMgbWFudWFsbHkgY29udHJvbCB0aGUgcmVuZGVycyBvZiB0aGUgX3N0YXJ0QXQgdHdlZW4uXG5cdFx0XHRcdFx0XHRpZiAodGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlcikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPT09IDApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2Vhc2UgPSBlYXNlID0gKCFlYXNlKSA/IFR3ZWVuTGl0ZS5kZWZhdWx0RWFzZSA6IChlYXNlIGluc3RhbmNlb2YgRWFzZSkgPyBlYXNlIDogKHR5cGVvZihlYXNlKSA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyBFYXNlKGVhc2UsIHYuZWFzZVBhcmFtcykgOiBfZWFzZU1hcFtlYXNlXSB8fCBUd2VlbkxpdGUuZGVmYXVsdEVhc2U7XG5cdFx0XHRpZiAodi5lYXNlUGFyYW1zIGluc3RhbmNlb2YgQXJyYXkgJiYgZWFzZS5jb25maWcpIHtcblx0XHRcdFx0dGhpcy5fZWFzZSA9IGVhc2UuY29uZmlnLmFwcGx5KGVhc2UsIHYuZWFzZVBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9lYXNlVHlwZSA9IHRoaXMuX2Vhc2UuX3R5cGU7XG5cdFx0XHR0aGlzLl9lYXNlUG93ZXIgPSB0aGlzLl9lYXNlLl9wb3dlcjtcblx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBudWxsO1xuXG5cdFx0XHRpZiAodGhpcy5fdGFyZ2V0cykge1xuXHRcdFx0XHRpID0gdGhpcy5fdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5faW5pdFByb3BzKCB0aGlzLl90YXJnZXRzW2ldLCAodGhpcy5fcHJvcExvb2t1cFtpXSA9IHt9KSwgdGhpcy5fc2libGluZ3NbaV0sIChvcCA/IG9wW2ldIDogbnVsbCkpICkge1xuXHRcdFx0XHRcdFx0aW5pdFBsdWdpbnMgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5pdFBsdWdpbnMgPSB0aGlzLl9pbml0UHJvcHModGhpcy50YXJnZXQsIHRoaXMuX3Byb3BMb29rdXAsIHRoaXMuX3NpYmxpbmdzLCBvcCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpbml0UGx1Z2lucykge1xuXHRcdFx0XHRUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoXCJfb25Jbml0QWxsUHJvcHNcIiwgdGhpcyk7IC8vcmVvcmRlcnMgdGhlIGFycmF5IGluIG9yZGVyIG9mIHByaW9yaXR5LiBVc2VzIGEgc3RhdGljIFR3ZWVuUGx1Z2luIG1ldGhvZCBpbiBvcmRlciB0byBtaW5pbWl6ZSBmaWxlIHNpemUgaW4gVHdlZW5MaXRlXG5cdFx0XHR9XG5cdFx0XHRpZiAob3ApIGlmICghdGhpcy5fZmlyc3RQVCkgaWYgKHR5cGVvZih0aGlzLnRhcmdldCkgIT09IFwiZnVuY3Rpb25cIikgeyAvL2lmIGFsbCB0d2VlbmluZyBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiwga2lsbCB0aGUgdHdlZW4uIElmIHRoZSB0YXJnZXQgaXMgYSBmdW5jdGlvbiwgaXQncyBwcm9iYWJseSBhIGRlbGF5ZWRDYWxsIHNvIGxldCBpdCBsaXZlLlxuXHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodi5ydW5CYWNrd2FyZHMpIHtcblx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRwdC5zICs9IHB0LmM7XG5cdFx0XHRcdFx0cHQuYyA9IC1wdC5jO1xuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX29uVXBkYXRlID0gdi5vblVwZGF0ZTtcblx0XHRcdHRoaXMuX2luaXR0ZWQgPSB0cnVlO1xuXHRcdH07XG5cblx0XHRwLl9pbml0UHJvcHMgPSBmdW5jdGlvbih0YXJnZXQsIHByb3BMb29rdXAsIHNpYmxpbmdzLCBvdmVyd3JpdHRlblByb3BzKSB7XG5cdFx0XHR2YXIgcCwgaSwgaW5pdFBsdWdpbnMsIHBsdWdpbiwgcHQsIHY7XG5cdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2xhenlMb29rdXBbdGFyZ2V0Ll9nc1R3ZWVuSURdKSB7XG5cdFx0XHRcdF9sYXp5UmVuZGVyKCk7IC8vaWYgb3RoZXIgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldCBoYXZlIHJlY2VudGx5IGluaXR0ZWQgYnV0IGhhdmVuJ3QgcmVuZGVyZWQgeWV0LCB3ZSd2ZSBnb3QgdG8gZm9yY2UgdGhlIHJlbmRlciBzbyB0aGF0IHRoZSBzdGFydGluZyB2YWx1ZXMgYXJlIGNvcnJlY3QgKGltYWdpbmUgcG9wdWxhdGluZyBhIHRpbWVsaW5lIHdpdGggYSBidW5jaCBvZiBzZXF1ZW50aWFsIHR3ZWVucyBhbmQgdGhlbiBqdW1waW5nIHRvIHRoZSBlbmQpXG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy52YXJzLmNzcykgaWYgKHRhcmdldC5zdHlsZSkgaWYgKHRhcmdldCAhPT0gd2luZG93ICYmIHRhcmdldC5ub2RlVHlwZSkgaWYgKF9wbHVnaW5zLmNzcykgaWYgKHRoaXMudmFycy5hdXRvQ1NTICE9PSBmYWxzZSkgeyAvL2l0J3Mgc28gY29tbW9uIHRvIHVzZSBUd2VlbkxpdGUvTWF4IHRvIGFuaW1hdGUgdGhlIGNzcyBvZiBET00gZWxlbWVudHMsIHdlIGFzc3VtZSB0aGF0IGlmIHRoZSB0YXJnZXQgaXMgYSBET00gZWxlbWVudCwgdGhhdCdzIHdoYXQgaXMgaW50ZW5kZWQgKGEgY29udmVuaWVuY2Ugc28gdGhhdCB1c2VycyBkb24ndCBoYXZlIHRvIHdyYXAgdGhpbmdzIGluIGNzczp7fSwgYWx0aG91Z2ggd2Ugc3RpbGwgcmVjb21tZW5kIGl0IGZvciBhIHNsaWdodCBwZXJmb3JtYW5jZSBib29zdCBhbmQgYmV0dGVyIHNwZWNpZmljaXR5KS4gTm90ZTogd2UgY2Fubm90IGNoZWNrIFwibm9kZVR5cGVcIiBvbiB0aGUgd2luZG93IGluc2lkZSBhbiBpZnJhbWUuXG5cdFx0XHRcdF9hdXRvQ1NTKHRoaXMudmFycywgdGFyZ2V0KTtcblx0XHRcdH1cblx0XHRcdGZvciAocCBpbiB0aGlzLnZhcnMpIHtcblx0XHRcdFx0diA9IHRoaXMudmFyc1twXTtcblx0XHRcdFx0aWYgKF9yZXNlcnZlZFByb3BzW3BdKSB7XG5cdFx0XHRcdFx0aWYgKHYpIGlmICgodiBpbnN0YW5jZW9mIEFycmF5KSB8fCAodi5wdXNoICYmIF9pc0FycmF5KHYpKSkgaWYgKHYuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0dGhpcy52YXJzW3BdID0gdiA9IHRoaXMuX3N3YXBTZWxmSW5QYXJhbXModiwgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoX3BsdWdpbnNbcF0gJiYgKHBsdWdpbiA9IG5ldyBfcGx1Z2luc1twXSgpKS5fb25Jbml0VHdlZW4odGFyZ2V0LCB0aGlzLnZhcnNbcF0sIHRoaXMpKSB7XG5cblx0XHRcdFx0XHQvL3QgLSB0YXJnZXQgXHRcdFtvYmplY3RdXG5cdFx0XHRcdFx0Ly9wIC0gcHJvcGVydHkgXHRcdFtzdHJpbmddXG5cdFx0XHRcdFx0Ly9zIC0gc3RhcnRcdFx0XHRbbnVtYmVyXVxuXHRcdFx0XHRcdC8vYyAtIGNoYW5nZVx0XHRbbnVtYmVyXVxuXHRcdFx0XHRcdC8vZiAtIGlzRnVuY3Rpb25cdFtib29sZWFuXVxuXHRcdFx0XHRcdC8vbiAtIG5hbWVcdFx0XHRbc3RyaW5nXVxuXHRcdFx0XHRcdC8vcGcgLSBpc1BsdWdpbiBcdFtib29sZWFuXVxuXHRcdFx0XHRcdC8vcHIgLSBwcmlvcml0eVx0XHRbbnVtYmVyXVxuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdCA9IHtfbmV4dDp0aGlzLl9maXJzdFBULCB0OnBsdWdpbiwgcDpcInNldFJhdGlvXCIsIHM6MCwgYzoxLCBmOnRydWUsIG46cCwgcGc6dHJ1ZSwgcHI6cGx1Z2luLl9wcmlvcml0eX07XG5cdFx0XHRcdFx0aSA9IHBsdWdpbi5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0cHJvcExvb2t1cFtwbHVnaW4uX292ZXJ3cml0ZVByb3BzW2ldXSA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwbHVnaW4uX3ByaW9yaXR5IHx8IHBsdWdpbi5fb25Jbml0QWxsUHJvcHMpIHtcblx0XHRcdFx0XHRcdGluaXRQbHVnaW5zID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBsdWdpbi5fb25EaXNhYmxlIHx8IHBsdWdpbi5fb25FbmFibGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwcm9wTG9va3VwW3BdID0gcHQgPSB7X25leHQ6dGhpcy5fZmlyc3RQVCwgdDp0YXJnZXQsIHA6cCwgZjoodHlwZW9mKHRhcmdldFtwXSkgPT09IFwiZnVuY3Rpb25cIiksIG46cCwgcGc6ZmFsc2UsIHByOjB9O1xuXHRcdFx0XHRcdHB0LnMgPSAoIXB0LmYpID8gcGFyc2VGbG9hdCh0YXJnZXRbcF0pIDogdGFyZ2V0WyAoKHAuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKSkgXSgpO1xuXHRcdFx0XHRcdHB0LmMgPSAodHlwZW9mKHYpID09PSBcInN0cmluZ1wiICYmIHYuY2hhckF0KDEpID09PSBcIj1cIikgPyBwYXJzZUludCh2LmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBOdW1iZXIodi5zdWJzdHIoMikpIDogKE51bWJlcih2KSAtIHB0LnMpIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHB0KSBpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvdmVyd3JpdHRlblByb3BzKSBpZiAodGhpcy5fa2lsbChvdmVyd3JpdHRlblByb3BzLCB0YXJnZXQpKSB7IC8vYW5vdGhlciB0d2VlbiBtYXkgaGF2ZSB0cmllZCB0byBvdmVyd3JpdGUgcHJvcGVydGllcyBvZiB0aGlzIHR3ZWVuIGJlZm9yZSBpbml0KCkgd2FzIGNhbGxlZCAobGlrZSBpZiB0d28gdHdlZW5zIHN0YXJ0IGF0IHRoZSBzYW1lIHRpbWUsIHRoZSBvbmUgY3JlYXRlZCBzZWNvbmQgd2lsbCBydW4gZmlyc3QpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9pbml0UHJvcHModGFyZ2V0LCBwcm9wTG9va3VwLCBzaWJsaW5ncywgb3ZlcndyaXR0ZW5Qcm9wcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fb3ZlcndyaXRlID4gMSkgaWYgKHRoaXMuX2ZpcnN0UFQpIGlmIChzaWJsaW5ncy5sZW5ndGggPiAxKSBpZiAoX2FwcGx5T3ZlcndyaXRlKHRhcmdldCwgdGhpcywgcHJvcExvb2t1cCwgdGhpcy5fb3ZlcndyaXRlLCBzaWJsaW5ncykpIHtcblx0XHRcdFx0dGhpcy5fa2lsbChwcm9wTG9va3VwLCB0YXJnZXQpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5faW5pdFByb3BzKHRhcmdldCwgcHJvcExvb2t1cCwgc2libGluZ3MsIG92ZXJ3cml0dGVuUHJvcHMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2ZpcnN0UFQpIGlmICgodGhpcy52YXJzLmxhenkgIT09IGZhbHNlICYmIHRoaXMuX2R1cmF0aW9uKSB8fCAodGhpcy52YXJzLmxhenkgJiYgIXRoaXMuX2R1cmF0aW9uKSkgeyAvL3plcm8gZHVyYXRpb24gdHdlZW5zIGRvbid0IGxhenkgcmVuZGVyIGJ5IGRlZmF1bHQ7IGV2ZXJ5dGhpbmcgZWxzZSBkb2VzLlxuXHRcdFx0XHRfbGF6eUxvb2t1cFt0YXJnZXQuX2dzVHdlZW5JRF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluaXRQbHVnaW5zO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0dmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcblx0XHRcdFx0ZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbixcblx0XHRcdFx0cHJldlJhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdGlzQ29tcGxldGUsIGNhbGxiYWNrLCBwdCwgcmF3UHJldlRpbWU7XG5cdFx0XHRpZiAodGltZSA+PSBkdXJhdGlvbikge1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gZHVyYXRpb247XG5cdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLl9jYWxjRW5kID8gdGhpcy5fZWFzZS5nZXRSYXRpbygxKSA6IDE7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQgKSB7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uQ29tcGxldGVcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDApIGlmICh0aGlzLl9pbml0dGVkIHx8ICF0aGlzLnZhcnMubGF6eSB8fCBmb3JjZSkgeyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIGFyZSB0cmlja3kgYmVjYXVzZSB3ZSBtdXN0IGRpc2Nlcm4gdGhlIG1vbWVudHVtL2RpcmVjdGlvbiBvZiB0aW1lIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkIG9yIHRoZSBlbmRpbmcgdmFsdWVzLiBJZiB0aGUgXCJwbGF5aGVhZFwiIG9mIGl0cyB0aW1lbGluZSBnb2VzIHBhc3QgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uIG9yIGxhbmRzIGRpcmVjdGx5IG9uIGl0LCB0aGUgZW5kIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQsIGJ1dCBpZiB0aGUgdGltZWxpbmUncyBcInBsYXloZWFkXCIgbW92ZXMgcGFzdCBpdCBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uIChmcm9tIGEgcG9zdGl0aXZlIHRpbWUgdG8gYSBuZWdhdGl2ZSB0aW1lKSwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9zdGFydFRpbWUgPT09IHRoaXMuX3RpbWVsaW5lLl9kdXJhdGlvbikgeyAvL2lmIGEgemVyby1kdXJhdGlvbiB0d2VlbiBpcyBhdCB0aGUgVkVSWSBlbmQgb2YgYSB0aW1lbGluZSBhbmQgdGhhdCB0aW1lbGluZSByZW5kZXJzIGF0IGl0cyBlbmQsIGl0IHdpbGwgdHlwaWNhbGx5IGFkZCBhIHRpbnkgYml0IG9mIGN1c2hpb24gdG8gdGhlIHJlbmRlciB0aW1lIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzIGZyb20gZ2V0dGluZyBpbiB0aGUgd2F5IG9mIHR3ZWVucyByZW5kZXJpbmcgdGhlaXIgVkVSWSBlbmQuIElmIHdlIHRoZW4gcmV2ZXJzZSgpIHRoYXQgdGltZWxpbmUsIHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIHdpbGwgdHJpZ2dlciBpdHMgb25SZXZlcnNlQ29tcGxldGUgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHkgdGhlIHBsYXloZWFkIGRpZG4ndCBwYXNzIG92ZXIgaXQgYWdhaW4uIEl0J3MgYSB2ZXJ5IHNwZWNpZmljIGVkZ2UgY2FzZSB3ZSBtdXN0IGFjY29tbW9kYXRlLlxuXHRcdFx0XHRcdFx0dGltZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aW1lID09PSAwIHx8IHByZXZSYXdQcmV2VGltZSA8IDAgfHwgKHByZXZSYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgdGhpcy5kYXRhICE9PSBcImlzUGF1c2VcIikpIGlmIChwcmV2UmF3UHJldlRpbWUgIT09IHRpbWUpIHsgLy9ub3RlOiB3aGVuIHRoaXMuZGF0YSBpcyBcImlzUGF1c2VcIiwgaXQncyBhIGNhbGxiYWNrIGFkZGVkIGJ5IGFkZFBhdXNlKCkgb24gYSB0aW1lbGluZSB0aGF0IHdlIHNob3VsZCBub3QgYmUgdHJpZ2dlcmVkIHdoZW4gTEVBVklORyBpdHMgZXhhY3Qgc3RhcnQgdGltZS4gSW4gb3RoZXIgd29yZHMsIHRsLmFkZFBhdXNlKDEpLnBsYXkoMSkgc2hvdWxkbid0IHBhdXNlLlxuXHRcdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJhd1ByZXZUaW1lID0gKCFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMCkgOiAwO1xuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IDAgfHwgKGR1cmF0aW9uID09PSAwICYmIHByZXZSYXdQcmV2VGltZSA+IDApKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCkgaWYgKHRoaXMuX2luaXR0ZWQgfHwgIXRoaXMudmFycy5sYXp5IHx8IGZvcmNlKSB7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgYXJlIHRyaWNreSBiZWNhdXNlIHdlIG11c3QgZGlzY2VybiB0aGUgbW9tZW50dW0vZGlyZWN0aW9uIG9mIHRpbWUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN0YXJ0aW5nIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQgb3IgdGhlIGVuZGluZyB2YWx1ZXMuIElmIHRoZSBcInBsYXloZWFkXCIgb2YgaXRzIHRpbWVsaW5lIGdvZXMgcGFzdCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24gb3IgbGFuZHMgZGlyZWN0bHkgb24gaXQsIHRoZSBlbmQgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCwgYnV0IGlmIHRoZSB0aW1lbGluZSdzIFwicGxheWhlYWRcIiBtb3ZlcyBwYXN0IGl0IGluIHRoZSBiYWNrd2FyZCBkaXJlY3Rpb24gKGZyb20gYSBwb3N0aXRpdmUgdGltZSB0byBhIG5lZ2F0aXZlIHRpbWUpLCB0aGUgc3RhcnRpbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQuXG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID49IDAgJiYgIShwcmV2UmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHRoaXMuZGF0YSA9PT0gXCJpc1BhdXNlXCIpKSB7XG5cdFx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmF3UHJldlRpbWUgPSAoIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgcHJldlJhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7IC8vaWYgd2UgcmVuZGVyIHRoZSB2ZXJ5IGJlZ2lubmluZyAodGltZSA9PSAwKSBvZiBhIGZyb21UbygpLCB3ZSBtdXN0IGZvcmNlIHRoZSByZW5kZXIgKG5vcm1hbCB0d2VlbnMgd291bGRuJ3QgbmVlZCB0byByZW5kZXIgYXQgYSB0aW1lIG9mIDAgd2hlbiB0aGUgcHJldlRpbWUgd2FzIGFsc28gMCkuIFRoaXMgaXMgYWxzbyBtYW5kYXRvcnkgdG8gbWFrZSBzdXJlIG92ZXJ3cml0aW5nIGtpY2tzIGluIGltbWVkaWF0ZWx5LlxuXHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRpbWU7XG5cblx0XHRcdFx0aWYgKHRoaXMuX2Vhc2VUeXBlKSB7XG5cdFx0XHRcdFx0dmFyIHIgPSB0aW1lIC8gZHVyYXRpb24sIHR5cGUgPSB0aGlzLl9lYXNlVHlwZSwgcG93ID0gdGhpcy5fZWFzZVBvd2VyO1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSAxIHx8ICh0eXBlID09PSAzICYmIHIgPj0gMC41KSkge1xuXHRcdFx0XHRcdFx0ciA9IDEgLSByO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMykge1xuXHRcdFx0XHRcdFx0ciAqPSAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocG93ID09PSAxKSB7XG5cdFx0XHRcdFx0XHRyICo9IHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDIpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDMpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHIgKiByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSA0KSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByICogciAqIHI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSAxIC0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IDIpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGltZSAvIGR1cmF0aW9uIDwgMC41KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gciAvIDI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSAxIC0gKHIgLyAyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbyh0aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl90aW1lID09PSBwcmV2VGltZSAmJiAhZm9yY2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0KCk7XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCB8fCB0aGlzLl9nYykgeyAvL2ltbWVkaWF0ZVJlbmRlciB0d2VlbnMgdHlwaWNhbGx5IHdvbid0IGluaXRpYWxpemUgdW50aWwgdGhlIHBsYXloZWFkIGFkdmFuY2VzIChfdGltZSBpcyBncmVhdGVyIHRoYW4gMCkgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgb3ZlcndyaXRpbmcgb2NjdXJzIHByb3Blcmx5LiBBbHNvLCBpZiBhbGwgb2YgdGhlIHR3ZWVuaW5nIHByb3BlcnRpZXMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuICh3aGljaCB3b3VsZCBjYXVzZSBfZ2MgdG8gYmUgdHJ1ZSwgYXMgc2V0IGluIF9pbml0KCkpLCB3ZSBzaG91bGRuJ3QgY29udGludWUgb3RoZXJ3aXNlIGFuIG9uU3RhcnQgY2FsbGJhY2sgY291bGQgYmUgY2FsbGVkIGZvciBleGFtcGxlLlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIGlmICghZm9yY2UgJiYgdGhpcy5fZmlyc3RQVCAmJiAoKHRoaXMudmFycy5sYXp5ICE9PSBmYWxzZSAmJiB0aGlzLl9kdXJhdGlvbikgfHwgKHRoaXMudmFycy5sYXp5ICYmICF0aGlzLl9kdXJhdGlvbikpKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IHByZXZUaW1lO1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcHJldlJhd1ByZXZUaW1lO1xuXHRcdFx0XHRcdF9sYXp5VHdlZW5zLnB1c2godGhpcyk7XG5cdFx0XHRcdFx0dGhpcy5fbGF6eSA9IFt0aW1lLCBzdXBwcmVzc0V2ZW50c107XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vX2Vhc2UgaXMgaW5pdGlhbGx5IHNldCB0byBkZWZhdWx0RWFzZSwgc28gbm93IHRoYXQgaW5pdCgpIGhhcyBydW4sIF9lYXNlIGlzIHNldCBwcm9wZXJseSBhbmQgd2UgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgcmF0aW8uIE92ZXJhbGwgdGhpcyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBjb25kaXRpb25hbCBsb2dpYyBlYXJsaWVyIGluIHRoZSBtZXRob2QgdG8gYXZvaWQgaGF2aW5nIHRvIHNldCByYXRpbyB0d2ljZSBiZWNhdXNlIHdlIG9ubHkgaW5pdCgpIG9uY2UgYnV0IHJlbmRlclRpbWUoKSBnZXRzIGNhbGxlZCBWRVJZIGZyZXF1ZW50bHkuXG5cdFx0XHRcdGlmICh0aGlzLl90aW1lICYmICFpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8odGhpcy5fdGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc0NvbXBsZXRlICYmIHRoaXMuX2Vhc2UuX2NhbGNFbmQpIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbygodGhpcy5fdGltZSA9PT0gMCkgPyAwIDogMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9sYXp5ICE9PSBmYWxzZSkgeyAvL2luIGNhc2UgYSBsYXp5IHJlbmRlciBpcyBwZW5kaW5nLCB3ZSBzaG91bGQgZmx1c2ggaXQgYmVjYXVzZSB0aGUgbmV3IHJlbmRlciBpcyBvY2N1cnJpbmcgbm93IChpbWFnaW5lIGEgbGF6eSB0d2VlbiBpbnN0YW50aWF0aW5nIGFuZCB0aGVuIGltbWVkaWF0ZWx5IHRoZSB1c2VyIGNhbGxzIHR3ZWVuLnNlZWsodHdlZW4uZHVyYXRpb24oKSksIHNraXBwaW5nIHRvIHRoZSBlbmQgLSB0aGUgZW5kIHJlbmRlciB3b3VsZCBiZSBmb3JjZWQsIGFuZCB0aGVuIGlmIHdlIGRpZG4ndCBmbHVzaCB0aGUgbGF6eSByZW5kZXIsIGl0J2QgZmlyZSBBRlRFUiB0aGUgc2VlaygpLCByZW5kZXJpbmcgaXQgYXQgdGhlIHdyb25nIHRpbWUuXG5cdFx0XHRcdHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICghdGhpcy5fYWN0aXZlKSBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl90aW1lICE9PSBwcmV2VGltZSAmJiB0aW1lID49IDApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTsgIC8vc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGEgdHdlZW4gKGFzIG9wcG9zZWQgdG8gdGhlIHRpbWVsaW5lIHJlbmRlcmluZyBpdCksIHRoZSB0aW1lbGluZSBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0d2VlbiBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZS5cblx0XHRcdH1cblx0XHRcdGlmIChwcmV2VGltZSA9PT0gMCkge1xuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdGlmICh0aW1lID49IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJfZHVtbXlHU1wiOyAvL2lmIG5vIGNhbGxiYWNrIGlzIGRlZmluZWQsIHVzZSBhIGR1bW15IHZhbHVlIGp1c3Qgc28gdGhhdCB0aGUgY29uZGl0aW9uIGF0IHRoZSBlbmQgZXZhbHVhdGVzIGFzIHRydWUgYmVjYXVzZSBfc3RhcnRBdCBzaG91bGQgcmVuZGVyIEFGVEVSIHRoZSBub3JtYWwgcmVuZGVyIGxvb3Agd2hlbiB0aGUgdGltZSBpcyBuZWdhdGl2ZS4gV2UgY291bGQgaGFuZGxlIHRoaXMgaW4gYSBtb3JlIGludHVpdGl2ZSB3YXksIG9mIGNvdXJzZSwgYnV0IHRoZSByZW5kZXIgbG9vcCBpcyB0aGUgTU9TVCBpbXBvcnRhbnQgdGhpbmcgdG8gb3B0aW1pemUsIHNvIHRoaXMgdGVjaG5pcXVlIGFsbG93cyB1cyB0byBhdm9pZCBhZGRpbmcgZXh0cmEgY29uZGl0aW9uYWwgbG9naWMgaW4gYSBoaWdoLWZyZXF1ZW5jeSBhcmVhLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy52YXJzLm9uU3RhcnQpIGlmICh0aGlzLl90aW1lICE9PSAwIHx8IGR1cmF0aW9uID09PSAwKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFx0dGhpcy52YXJzLm9uU3RhcnQuYXBwbHkodGhpcy52YXJzLm9uU3RhcnRTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25TdGFydFBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0ocHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSkge1xuXHRcdFx0XHRpZiAodGltZSA8IDApIGlmICh0aGlzLl9zdGFydEF0ICYmIHRpbWUgIT09IC0wLjAwMDEpIHsgLy9pZiB0aGUgdHdlZW4gaXMgcG9zaXRpb25lZCBhdCB0aGUgVkVSWSBiZWdpbm5pbmcgKF9zdGFydFRpbWUgMCkgb2YgaXRzIHBhcmVudCB0aW1lbGluZSwgaXQncyBpbGxlZ2FsIGZvciB0aGUgcGxheWhlYWQgdG8gZ28gYmFjayBmdXJ0aGVyLCBzbyB3ZSBzaG91bGQgbm90IHJlbmRlciB0aGUgcmVjb3JkZWQgc3RhcnRBdCB2YWx1ZXMuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTsgLy9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgdHVjayB0aGlzIGNvbmRpdGlvbmFsIGxvZ2ljIGluc2lkZSBsZXNzIHRyYXZlbGVkIGFyZWFzIChtb3N0IHR3ZWVucyBkb24ndCBoYXZlIGFuIG9uVXBkYXRlKS4gV2UnZCBqdXN0IGhhdmUgaXQgYXQgdGhlIGVuZCBiZWZvcmUgdGhlIG9uQ29tcGxldGUsIGJ1dCB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkIGJlZm9yZSBhbnkgb25VcGRhdGUgaXMgY2FsbGVkLCBzbyB3ZSBBTFNPIHB1dCBpdCBoZXJlIGFuZCB0aGVuIGlmIGl0J3Mgbm90IGNhbGxlZCwgd2UgZG8gc28gbGF0ZXIgbmVhciB0aGUgb25Db21wbGV0ZS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzKSBpZiAodGhpcy5fdGltZSAhPT0gcHJldlRpbWUgfHwgaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdHRoaXMuX29uVXBkYXRlLmFwcGx5KHRoaXMudmFycy5vblVwZGF0ZVNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblVwZGF0ZVBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjYWxsYmFjaykgaWYgKCF0aGlzLl9nYyB8fCBmb3JjZSkgeyAvL2NoZWNrIF9nYyBiZWNhdXNlIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBraWxsKCkgY291bGQgYmUgY2FsbGVkIGluIGFuIG9uVXBkYXRlXG5cdFx0XHRcdGlmICh0aW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmICF0aGlzLl9vblVwZGF0ZSAmJiB0aW1lICE9PSAtMC4wMDAxKSB7IC8vLTAuMDAwMSBpcyBhIHNwZWNpYWwgdmFsdWUgdGhhdCB3ZSB1c2Ugd2hlbiBsb29waW5nIGJhY2sgdG8gdGhlIGJlZ2lubmluZyBvZiBhIHJlcGVhdGVkIFRpbWVsaW5lTWF4LCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZG4ndCByZW5kZXIgdGhlIF9zdGFydEF0IHZhbHVlcy5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzICYmIHRoaXMudmFyc1tjYWxsYmFja10pIHtcblx0XHRcdFx0XHR0aGlzLnZhcnNbY2FsbGJhY2tdLmFwcGx5KHRoaXMudmFyc1tjYWxsYmFjayArIFwiU2NvcGVcIl0gfHwgdGhpcywgdGhpcy52YXJzW2NhbGxiYWNrICsgXCJQYXJhbXNcIl0gfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgcmF3UHJldlRpbWUgIT09IF90aW55TnVtKSB7IC8vdGhlIG9uQ29tcGxldGUgb3Igb25SZXZlcnNlQ29tcGxldGUgY291bGQgdHJpZ2dlciBtb3ZlbWVudCBvZiB0aGUgcGxheWhlYWQgYW5kIGZvciB6ZXJvLWR1cmF0aW9uIHR3ZWVucyAod2hpY2ggbXVzdCBkaXNjZXJuIGRpcmVjdGlvbikgdGhhdCBsYW5kIGRpcmVjdGx5IGJhY2sgb24gdGhlaXIgc3RhcnQgdGltZSwgd2UgZG9uJ3Qgd2FudCB0byBmaXJlIGFnYWluIG9uIHRoZSBuZXh0IHJlbmRlci4gVGhpbmsgb2Ygc2V2ZXJhbCBhZGRQYXVzZSgpJ3MgaW4gYSB0aW1lbGluZSB0aGF0IGZvcmNlcyB0aGUgcGxheWhlYWQgdG8gYSBjZXJ0YWluIHNwb3QsIGJ1dCB3aGF0IGlmIGl0J3MgYWxyZWFkeSBwYXVzZWQgYW5kIGFub3RoZXIgdHdlZW4gaXMgdHdlZW5pbmcgdGhlIFwidGltZVwiIG9mIHRoZSB0aW1lbGluZT8gRWFjaCB0aW1lIGl0IG1vdmVzIFtmb3J3YXJkXSBwYXN0IHRoYXQgc3BvdCwgaXQgd291bGQgbW92ZSBiYWNrLCBhbmQgc2luY2Ugc3VwcHJlc3NFdmVudHMgaXMgdHJ1ZSwgaXQnZCByZXNldCBfcmF3UHJldlRpbWUgdG8gX3RpbnlOdW0gc28gdGhhdCB3aGVuIGl0IGJlZ2lucyBhZ2FpbiwgdGhlIGNhbGxiYWNrIHdvdWxkIGZpcmUgKHNvIHVsdGltYXRlbHkgaXQgY291bGQgYm91bmNlIGJhY2sgYW5kIGZvcnRoIGR1cmluZyB0aGF0IHR3ZWVuKS4gQWdhaW4sIHRoaXMgaXMgYSB2ZXJ5IHVuY29tbW9uIHNjZW5hcmlvLCBidXQgcG9zc2libGUgbm9uZXRoZWxlc3MuXG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQsIG92ZXJ3cml0aW5nVHdlZW4pIHtcblx0XHRcdGlmICh2YXJzID09PSBcImFsbFwiKSB7XG5cdFx0XHRcdHZhcnMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhcnMgPT0gbnVsbCkgaWYgKHRhcmdldCA9PSBudWxsIHx8IHRhcmdldCA9PT0gdGhpcy50YXJnZXQpIHtcblx0XHRcdFx0dGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0ID0gKHR5cGVvZih0YXJnZXQpICE9PSBcInN0cmluZ1wiKSA/ICh0YXJnZXQgfHwgdGhpcy5fdGFyZ2V0cyB8fCB0aGlzLnRhcmdldCkgOiBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0KSB8fCB0YXJnZXQ7XG5cdFx0XHR2YXIgaSwgb3ZlcndyaXR0ZW5Qcm9wcywgcCwgcHQsIHByb3BMb29rdXAsIGNoYW5nZWQsIGtpbGxQcm9wcywgcmVjb3JkLCBraWxsZWQ7XG5cdFx0XHRpZiAoKF9pc0FycmF5KHRhcmdldCkgfHwgX2lzU2VsZWN0b3IodGFyZ2V0KSkgJiYgdHlwZW9mKHRhcmdldFswXSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0aSA9IHRhcmdldC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9raWxsKHZhcnMsIHRhcmdldFtpXSkpIHtcblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX3RhcmdldHMpIHtcblx0XHRcdFx0XHRpID0gdGhpcy5fdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0ID09PSB0aGlzLl90YXJnZXRzW2ldKSB7XG5cdFx0XHRcdFx0XHRcdHByb3BMb29rdXAgPSB0aGlzLl9wcm9wTG9va3VwW2ldIHx8IHt9O1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyB8fCBbXTtcblx0XHRcdFx0XHRcdFx0b3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHNbaV0gPSB2YXJzID8gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wc1tpXSB8fCB7fSA6IFwiYWxsXCI7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh0YXJnZXQgIT09IHRoaXMudGFyZ2V0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByb3BMb29rdXAgPSB0aGlzLl9wcm9wTG9va3VwO1xuXHRcdFx0XHRcdG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzID0gdmFycyA/IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgfHwge30gOiBcImFsbFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHByb3BMb29rdXApIHtcblx0XHRcdFx0XHRraWxsUHJvcHMgPSB2YXJzIHx8IHByb3BMb29rdXA7XG5cdFx0XHRcdFx0cmVjb3JkID0gKHZhcnMgIT09IG92ZXJ3cml0dGVuUHJvcHMgJiYgb3ZlcndyaXR0ZW5Qcm9wcyAhPT0gXCJhbGxcIiAmJiB2YXJzICE9PSBwcm9wTG9va3VwICYmICh0eXBlb2YodmFycykgIT09IFwib2JqZWN0XCIgfHwgIXZhcnMuX3RlbXBLaWxsKSk7IC8vX3RlbXBLaWxsIGlzIGEgc3VwZXItc2VjcmV0IHdheSB0byBkZWxldGUgYSBwYXJ0aWN1bGFyIHR3ZWVuaW5nIHByb3BlcnR5IGJ1dCBOT1QgaGF2ZSBpdCByZW1lbWJlcmVkIGFzIGFuIG9mZmljaWFsIG92ZXJ3cml0dGVuIHByb3BlcnR5IChsaWtlIGluIEJlemllclBsdWdpbilcblx0XHRcdFx0XHRpZiAob3ZlcndyaXRpbmdUd2VlbiAmJiAoVHdlZW5MaXRlLm9uT3ZlcndyaXRlIHx8IHRoaXMudmFycy5vbk92ZXJ3cml0ZSkpIHtcblx0XHRcdFx0XHRcdGZvciAocCBpbiBraWxsUHJvcHMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHByb3BMb29rdXBbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIWtpbGxlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0a2lsbGVkID0gW107XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGtpbGxlZC5wdXNoKHApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIV9vbk92ZXJ3cml0ZSh0aGlzLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZCkpIHsgLy9pZiB0aGUgb25PdmVyd3JpdGUgcmV0dXJuZWQgZmFsc2UsIHRoYXQgbWVhbnMgdGhlIHVzZXIgd2FudHMgdG8gb3ZlcnJpZGUgdGhlIG92ZXJ3cml0aW5nIChjYW5jZWwgaXQpLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yIChwIGluIGtpbGxQcm9wcykge1xuXHRcdFx0XHRcdFx0aWYgKChwdCA9IHByb3BMb29rdXBbcF0pKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwdC5wZyAmJiBwdC50Ll9raWxsKGtpbGxQcm9wcykpIHtcblx0XHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTsgLy9zb21lIHBsdWdpbnMgbmVlZCB0byBiZSBub3RpZmllZCBzbyB0aGV5IGNhbiBwZXJmb3JtIGNsZWFudXAgdGFza3MgZmlyc3Rcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIXB0LnBnIHx8IHB0LnQuX292ZXJ3cml0ZVByb3BzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChwdC5fcHJldikge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0ID09PSB0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cHQuX25leHQgPSBwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHByb3BMb29rdXBbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAocmVjb3JkKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJ3cml0dGVuUHJvcHNbcF0gPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXRoaXMuX2ZpcnN0UFQgJiYgdGhpcy5faW5pdHRlZCkgeyAvL2lmIGFsbCB0d2VlbmluZyBwcm9wZXJ0aWVzIGFyZSBraWxsZWQsIGtpbGwgdGhlIHR3ZWVuLiBXaXRob3V0IHRoaXMgbGluZSwgaWYgdGhlcmUncyBhIHR3ZWVuIHdpdGggbXVsdGlwbGUgdGFyZ2V0cyBhbmQgdGhlbiB5b3Uga2lsbFR3ZWVuc09mKCkgZWFjaCB0YXJnZXQgaW5kaXZpZHVhbGx5LCB0aGUgdHdlZW4gd291bGQgdGVjaG5pY2FsbHkgc3RpbGwgcmVtYWluIGFjdGl2ZSBhbmQgZmlyZSBpdHMgb25Db21wbGV0ZSBldmVuIHRob3VnaCB0aGVyZSBhcmVuJ3QgYW55IG1vcmUgcHJvcGVydGllcyB0d2VlbmluZy5cblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH07XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudChcIl9vbkRpc2FibGVcIiwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9maXJzdFBUID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX3N0YXJ0QXQgPSB0aGlzLl9vblVwZGF0ZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkID0gdGhpcy5fYWN0aXZlID0gdGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fcHJvcExvb2t1cCA9ICh0aGlzLl90YXJnZXRzKSA/IHt9IDogW107XG5cdFx0XHRBbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcblx0XHRcdGlmICh0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyKSB7XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSAtX3RpbnlOdW07IC8vZm9yY2VzIGEgcmVuZGVyIHdpdGhvdXQgaGF2aW5nIHRvIHNldCB0aGUgcmVuZGVyKCkgXCJmb3JjZVwiIHBhcmFtZXRlciB0byB0cnVlIGJlY2F1c2Ugd2Ugd2FudCB0byBhbGxvdyBsYXp5aW5nIGJ5IGRlZmF1bHQgKHVzaW5nIHRoZSBcImZvcmNlXCIgcGFyYW1ldGVyIGFsd2F5cyBmb3JjZXMgYW4gaW1tZWRpYXRlIGZ1bGwgcmVuZGVyKVxuXHRcdFx0XHR0aGlzLnJlbmRlcigtdGhpcy5fZGVsYXkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX2VuYWJsZWQgPSBmdW5jdGlvbihlbmFibGVkLCBpZ25vcmVUaW1lbGluZSkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVuYWJsZWQgJiYgdGhpcy5fZ2MpIHtcblx0XHRcdFx0dmFyIHRhcmdldHMgPSB0aGlzLl90YXJnZXRzLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGlmICh0YXJnZXRzKSB7XG5cdFx0XHRcdFx0aSA9IHRhcmdldHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc2libGluZ3NbaV0gPSBfcmVnaXN0ZXIodGFyZ2V0c1tpXSwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzID0gX3JlZ2lzdGVyKHRoaXMudGFyZ2V0LCB0aGlzLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0QW5pbWF0aW9uLnByb3RvdHlwZS5fZW5hYmxlZC5jYWxsKHRoaXMsIGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKTtcblx0XHRcdGlmICh0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkKSBpZiAodGhpcy5fZmlyc3RQVCkge1xuXHRcdFx0XHRyZXR1cm4gVHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50KChlbmFibGVkID8gXCJfb25FbmFibGVcIiA6IFwiX29uRGlzYWJsZVwiKSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXG4vLy0tLS1Ud2VlbkxpdGUgc3RhdGljIG1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdFR3ZWVuTGl0ZS50byA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuZnJvbSA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHZhcnMucnVuQmFja3dhcmRzID0gdHJ1ZTtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuZnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycykge1xuXHRcdFx0dG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcblx0XHRcdHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodG9WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSAmJiBmcm9tVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCBkdXJhdGlvbiwgdG9WYXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24oZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlLCB1c2VGcmFtZXMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKGNhbGxiYWNrLCAwLCB7ZGVsYXk6ZGVsYXksIG9uQ29tcGxldGU6Y2FsbGJhY2ssIG9uQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBvbkNvbXBsZXRlU2NvcGU6c2NvcGUsIG9uUmV2ZXJzZUNvbXBsZXRlOmNhbGxiYWNrLCBvblJldmVyc2VDb21wbGV0ZVBhcmFtczpwYXJhbXMsIG9uUmV2ZXJzZUNvbXBsZXRlU2NvcGU6c2NvcGUsIGltbWVkaWF0ZVJlbmRlcjpmYWxzZSwgbGF6eTpmYWxzZSwgdXNlRnJhbWVzOnVzZUZyYW1lcywgb3ZlcndyaXRlOjB9KTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLnNldCA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCAwLCB2YXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmdldFR3ZWVuc09mID0gZnVuY3Rpb24odGFyZ2V0LCBvbmx5QWN0aXZlKSB7XG5cdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHsgcmV0dXJuIFtdOyB9XG5cdFx0XHR0YXJnZXQgPSAodHlwZW9mKHRhcmdldCkgIT09IFwic3RyaW5nXCIpID8gdGFyZ2V0IDogVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldCkgfHwgdGFyZ2V0O1xuXHRcdFx0dmFyIGksIGEsIGosIHQ7XG5cdFx0XHRpZiAoKF9pc0FycmF5KHRhcmdldCkgfHwgX2lzU2VsZWN0b3IodGFyZ2V0KSkgJiYgdHlwZW9mKHRhcmdldFswXSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0aSA9IHRhcmdldC5sZW5ndGg7XG5cdFx0XHRcdGEgPSBbXTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0YSA9IGEuY29uY2F0KFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXRbaV0sIG9ubHlBY3RpdmUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdC8vbm93IGdldCByaWQgb2YgYW55IGR1cGxpY2F0ZXMgKHR3ZWVucyBvZiBhcnJheXMgb2Ygb2JqZWN0cyBjb3VsZCBjYXVzZSBkdXBsaWNhdGVzKVxuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR0ID0gYVtpXTtcblx0XHRcdFx0XHRqID0gaTtcblx0XHRcdFx0XHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICh0ID09PSBhW2pdKSB7XG5cdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YSA9IF9yZWdpc3Rlcih0YXJnZXQpLmNvbmNhdCgpO1xuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChhW2ldLl9nYyB8fCAob25seUFjdGl2ZSAmJiAhYVtpXS5pc0FjdGl2ZSgpKSkge1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmtpbGxUd2VlbnNPZiA9IFR3ZWVuTGl0ZS5raWxsRGVsYXllZENhbGxzVG8gPSBmdW5jdGlvbih0YXJnZXQsIG9ubHlBY3RpdmUsIHZhcnMpIHtcblx0XHRcdGlmICh0eXBlb2Yob25seUFjdGl2ZSkgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0dmFycyA9IG9ubHlBY3RpdmU7IC8vZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChiZWZvcmUgXCJvbmx5QWN0aXZlXCIgcGFyYW1ldGVyIHdhcyBpbnNlcnRlZClcblx0XHRcdFx0b25seUFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGEgPSBUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0LCBvbmx5QWN0aXZlKSxcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGFbaV0uX2tpbGwodmFycywgdGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFR3ZWVuUGx1Z2luICAgKGNvdWxkIGVhc2lseSBiZSBzcGxpdCBvdXQgYXMgYSBzZXBhcmF0ZSBmaWxlL2NsYXNzLCBidXQgaW5jbHVkZWQgZm9yIGVhc2Ugb2YgdXNlIChzbyB0aGF0IHBlb3BsZSBkb24ndCBuZWVkIHRvIGluY2x1ZGUgYW5vdGhlciBzY3JpcHQgY2FsbCBiZWZvcmUgbG9hZGluZyBwbHVnaW5zIHdoaWNoIGlzIGVhc3kgdG8gZm9yZ2V0KVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIFR3ZWVuUGx1Z2luID0gX2NsYXNzKFwicGx1Z2lucy5Ud2VlblBsdWdpblwiLCBmdW5jdGlvbihwcm9wcywgcHJpb3JpdHkpIHtcblx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcyA9IChwcm9wcyB8fCBcIlwiKS5zcGxpdChcIixcIik7XG5cdFx0XHRcdFx0dGhpcy5fcHJvcE5hbWUgPSB0aGlzLl9vdmVyd3JpdGVQcm9wc1swXTtcblx0XHRcdFx0XHR0aGlzLl9wcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBUd2VlblBsdWdpbi5wcm90b3R5cGU7XG5cdFx0XHRcdH0sIHRydWUpO1xuXG5cdFx0cCA9IFR3ZWVuUGx1Z2luLnByb3RvdHlwZTtcblx0XHRUd2VlblBsdWdpbi52ZXJzaW9uID0gXCIxLjEwLjFcIjtcblx0XHRUd2VlblBsdWdpbi5BUEkgPSAyO1xuXHRcdHAuX2ZpcnN0UFQgPSBudWxsO1xuXG5cdFx0cC5fYWRkVHdlZW4gPSBmdW5jdGlvbih0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQsIG92ZXJ3cml0ZVByb3AsIHJvdW5kKSB7XG5cdFx0XHR2YXIgYywgcHQ7XG5cdFx0XHRpZiAoZW5kICE9IG51bGwgJiYgKGMgPSAodHlwZW9mKGVuZCkgPT09IFwibnVtYmVyXCIgfHwgZW5kLmNoYXJBdCgxKSAhPT0gXCI9XCIpID8gTnVtYmVyKGVuZCkgLSBzdGFydCA6IHBhcnNlSW50KGVuZC5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogTnVtYmVyKGVuZC5zdWJzdHIoMikpKSkge1xuXHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQgPSB7X25leHQ6dGhpcy5fZmlyc3RQVCwgdDp0YXJnZXQsIHA6cHJvcCwgczpzdGFydCwgYzpjLCBmOih0eXBlb2YodGFyZ2V0W3Byb3BdKSA9PT0gXCJmdW5jdGlvblwiKSwgbjpvdmVyd3JpdGVQcm9wIHx8IHByb3AsIHI6cm91bmR9O1xuXHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5zZXRSYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQsXG5cdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHR2YWw7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0dmFsID0gcHQuYyAqIHYgKyBwdC5zO1xuXHRcdFx0XHRpZiAocHQucikge1xuXHRcdFx0XHRcdHZhbCA9IE1hdGgucm91bmQodmFsKTtcblx0XHRcdFx0fSBlbHNlIGlmICh2YWwgPCBtaW4pIGlmICh2YWwgPiAtbWluKSB7IC8vcHJldmVudHMgaXNzdWVzIHdpdGggY29udmVydGluZyB2ZXJ5IHNtYWxsIG51bWJlcnMgdG8gc3RyaW5ncyBpbiB0aGUgYnJvd3NlclxuXHRcdFx0XHRcdHZhbCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdKHZhbCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24obG9va3VwKSB7XG5cdFx0XHR2YXIgYSA9IHRoaXMuX292ZXJ3cml0ZVByb3BzLFxuXHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQsXG5cdFx0XHRcdGk7XG5cdFx0XHRpZiAobG9va3VwW3RoaXMuX3Byb3BOYW1lXSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzID0gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChsb29rdXBbYVtpXV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKGxvb2t1cFtwdC5uXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0Ll9wcmV2O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocHQuX3ByZXYpIHtcblx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9maXJzdFBUID09PSBwdCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRwLl9yb3VuZFByb3BzID0gZnVuY3Rpb24obG9va3VwLCB2YWx1ZSkge1xuXHRcdFx0dmFyIHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAobG9va3VwW3RoaXMuX3Byb3BOYW1lXSB8fCAocHQubiAhPSBudWxsICYmIGxvb2t1cFsgcHQubi5zcGxpdCh0aGlzLl9wcm9wTmFtZSArIFwiX1wiKS5qb2luKFwiXCIpIF0pKSB7IC8vc29tZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHZlcnkgcGx1Z2luLXNwZWNpZmljIGFkZCBhIHByZWZpeCBuYW1lZCBhZnRlciB0aGUgX3Byb3BOYW1lIHBsdXMgYW4gdW5kZXJzY29yZSwgc28gd2UgbmVlZCB0byBpZ25vcmUgdGhhdCBleHRyYSBzdHVmZiBoZXJlLlxuXHRcdFx0XHRcdHB0LnIgPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQgPSBmdW5jdGlvbih0eXBlLCB0d2Vlbikge1xuXHRcdFx0dmFyIHB0ID0gdHdlZW4uX2ZpcnN0UFQsXG5cdFx0XHRcdGNoYW5nZWQsIHB0MiwgZmlyc3QsIGxhc3QsIG5leHQ7XG5cdFx0XHRpZiAodHlwZSA9PT0gXCJfb25Jbml0QWxsUHJvcHNcIikge1xuXHRcdFx0XHQvL3NvcnRzIHRoZSBQcm9wVHdlZW4gbGlua2VkIGxpc3QgaW4gb3JkZXIgb2YgcHJpb3JpdHkgYmVjYXVzZSBzb21lIHBsdWdpbnMgbmVlZCB0byByZW5kZXIgZWFybGllci9sYXRlciB0aGFuIG90aGVycywgbGlrZSBNb3Rpb25CbHVyUGx1Z2luIGFwcGxpZXMgaXRzIGVmZmVjdHMgYWZ0ZXIgYWxsIHgveS9hbHBoYSB0d2VlbnMgaGF2ZSByZW5kZXJlZCBvbiBlYWNoIGZyYW1lLlxuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRuZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0cHQyID0gZmlyc3Q7XG5cdFx0XHRcdFx0d2hpbGUgKHB0MiAmJiBwdDIucHIgPiBwdC5wcikge1xuXHRcdFx0XHRcdFx0cHQyID0gcHQyLl9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHB0Ll9wcmV2ID0gcHQyID8gcHQyLl9wcmV2IDogbGFzdCkpIHtcblx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZpcnN0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgocHQuX25leHQgPSBwdDIpKSB7XG5cdFx0XHRcdFx0XHRwdDIuX3ByZXYgPSBwdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bGFzdCA9IHB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSB0d2Vlbi5fZmlyc3RQVCA9IGZpcnN0O1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChwdC5wZykgaWYgKHR5cGVvZihwdC50W3R5cGVdKSA9PT0gXCJmdW5jdGlvblwiKSBpZiAocHQudFt0eXBlXSgpKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH07XG5cblx0XHRUd2VlblBsdWdpbi5hY3RpdmF0ZSA9IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHRcdHZhciBpID0gcGx1Z2lucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKHBsdWdpbnNbaV0uQVBJID09PSBUd2VlblBsdWdpbi5BUEkpIHtcblx0XHRcdFx0XHRfcGx1Z2luc1sobmV3IHBsdWdpbnNbaV0oKSkuX3Byb3BOYW1lXSA9IHBsdWdpbnNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvL3Byb3ZpZGVzIGEgbW9yZSBjb25jaXNlIHdheSB0byBkZWZpbmUgcGx1Z2lucyB0aGF0IGhhdmUgbm8gZGVwZW5kZW5jaWVzIGJlc2lkZXMgVHdlZW5QbHVnaW4gYW5kIFR3ZWVuTGl0ZSwgd3JhcHBpbmcgY29tbW9uIGJvaWxlcnBsYXRlIHN0dWZmIGludG8gb25lIGZ1bmN0aW9uIChhZGRlZCBpbiAxLjkuMCkuIFlvdSBkb24ndCBORUVEIHRvIHVzZSB0aGlzIHRvIGRlZmluZSBhIHBsdWdpbiAtIHRoZSBvbGQgd2F5IHN0aWxsIHdvcmtzIGFuZCBjYW4gYmUgdXNlZnVsIGluIGNlcnRhaW4gKHJhcmUpIHNpdHVhdGlvbnMuXG5cdFx0X2dzRGVmaW5lLnBsdWdpbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdFx0aWYgKCFjb25maWcgfHwgIWNvbmZpZy5wcm9wTmFtZSB8fCAhY29uZmlnLmluaXQgfHwgIWNvbmZpZy5BUEkpIHsgdGhyb3cgXCJpbGxlZ2FsIHBsdWdpbiBkZWZpbml0aW9uLlwiOyB9XG5cdFx0XHR2YXIgcHJvcE5hbWUgPSBjb25maWcucHJvcE5hbWUsXG5cdFx0XHRcdHByaW9yaXR5ID0gY29uZmlnLnByaW9yaXR5IHx8IDAsXG5cdFx0XHRcdG92ZXJ3cml0ZVByb3BzID0gY29uZmlnLm92ZXJ3cml0ZVByb3BzLFxuXHRcdFx0XHRtYXAgPSB7aW5pdDpcIl9vbkluaXRUd2VlblwiLCBzZXQ6XCJzZXRSYXRpb1wiLCBraWxsOlwiX2tpbGxcIiwgcm91bmQ6XCJfcm91bmRQcm9wc1wiLCBpbml0QWxsOlwiX29uSW5pdEFsbFByb3BzXCJ9LFxuXHRcdFx0XHRQbHVnaW4gPSBfY2xhc3MoXCJwbHVnaW5zLlwiICsgcHJvcE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wTmFtZS5zdWJzdHIoMSkgKyBcIlBsdWdpblwiLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0VHdlZW5QbHVnaW4uY2FsbCh0aGlzLCBwcm9wTmFtZSwgcHJpb3JpdHkpO1xuXHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMgPSBvdmVyd3JpdGVQcm9wcyB8fCBbXTtcblx0XHRcdFx0XHR9LCAoY29uZmlnLmdsb2JhbCA9PT0gdHJ1ZSkpLFxuXHRcdFx0XHRwID0gUGx1Z2luLnByb3RvdHlwZSA9IG5ldyBUd2VlblBsdWdpbihwcm9wTmFtZSksXG5cdFx0XHRcdHByb3A7XG5cdFx0XHRwLmNvbnN0cnVjdG9yID0gUGx1Z2luO1xuXHRcdFx0UGx1Z2luLkFQSSA9IGNvbmZpZy5BUEk7XG5cdFx0XHRmb3IgKHByb3AgaW4gbWFwKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YoY29uZmlnW3Byb3BdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0cFttYXBbcHJvcF1dID0gY29uZmlnW3Byb3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRQbHVnaW4udmVyc2lvbiA9IGNvbmZpZy52ZXJzaW9uO1xuXHRcdFx0VHdlZW5QbHVnaW4uYWN0aXZhdGUoW1BsdWdpbl0pO1xuXHRcdFx0cmV0dXJuIFBsdWdpbjtcblx0XHR9O1xuXG5cblx0XHQvL25vdyBydW4gdGhyb3VnaCBhbGwgdGhlIGRlcGVuZGVuY2llcyBkaXNjb3ZlcmVkIGFuZCBpZiBhbnkgYXJlIG1pc3NpbmcsIGxvZyB0aGF0IHRvIHRoZSBjb25zb2xlIGFzIGEgd2FybmluZy4gVGhpcyBpcyB3aHkgaXQncyBiZXN0IHRvIGhhdmUgVHdlZW5MaXRlIGxvYWQgbGFzdCAtIGl0IGNhbiBjaGVjayBhbGwgdGhlIGRlcGVuZGVuY2llcyBmb3IgeW91LlxuXHRcdGEgPSB3aW5kb3cuX2dzUXVldWU7XG5cdFx0aWYgKGEpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGFbaV0oKTtcblx0XHRcdH1cblx0XHRcdGZvciAocCBpbiBfZGVmTG9va3VwKSB7XG5cdFx0XHRcdGlmICghX2RlZkxvb2t1cFtwXS5mdW5jKSB7XG5cdFx0XHRcdFx0d2luZG93LmNvbnNvbGUubG9nKFwiR1NBUCBlbmNvdW50ZXJlZCBtaXNzaW5nIGRlcGVuZGVuY3k6IGNvbS5ncmVlbnNvY2suXCIgKyBwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF90aWNrZXJBY3RpdmUgPSBmYWxzZTsgLy9lbnN1cmVzIHRoYXQgdGhlIGZpcnN0IG9mZmljaWFsIGFuaW1hdGlvbiBmb3JjZXMgYSB0aWNrZXIudGljaygpIHRvIHVwZGF0ZSB0aGUgdGltZSB3aGVuIGl0IGlzIGluc3RhbnRpYXRlZFxuXG59KSgodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mKGdsb2JhbCkgIT09IFwidW5kZWZpbmVkXCIpID8gZ2xvYmFsIDogdGhpcyB8fCB3aW5kb3csIFwiVHdlZW5NYXhcIik7IiwiLyohIEhhbW1lci5KUyAtIHYyLjAuNCAtIDIwMTQtMDktMjhcbiAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IEpvcmlrIFRhbmdlbGRlcjtcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbnZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnbW96JywgJ01TJywgJ21zJywgJ28nXTtcbnZhciBURVNUX0VMRU1FTlQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxudmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIG5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIHNldCBhIHRpbWVvdXQgd2l0aCBhIGdpdmVuIHNjb3BlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzZXRUaW1lb3V0Q29udGV4dChmbiwgdGltZW91dCwgY29udGV4dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmRGbihmbiwgY29udGV4dCksIHRpbWVvdXQpO1xufVxuXG4vKipcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XG4gKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIGVhY2goYXJnLCBjb250ZXh0W2ZuXSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZV1cbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFtZXJnZSB8fCAobWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuXG4vKipcbiAqIG1lcmdlIHRoZSB2YWx1ZXMgZnJvbSBzcmMgaW4gdGhlIGRlc3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBkZXN0IHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuIGJ5IHNyY1xuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XG4gICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xufVxuXG4vKipcbiAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAqL1xuZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xuICAgIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlLFxuICAgICAgICBjaGlsZFA7XG5cbiAgICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICBleHRlbmQoY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG59XG5cbi8qKlxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gVFlQRV9GVU5DVElPTikge1xuICAgICAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogdXNlIHRoZSB2YWwyIHdoZW4gdmFsMSBpcyB1bmRlZmluZWRcbiAqIEBwYXJhbSB7Kn0gdmFsMVxuICogQHBhcmFtIHsqfSB2YWwyXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gaWZVbmRlZmluZWQodmFsMSwgdmFsMikge1xuICAgIHJldHVybiAodmFsMSA9PT0gdW5kZWZpbmVkKSA/IHZhbDIgOiB2YWwxO1xufVxuXG4vKipcbiAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICogQG1ldGhvZCBoYXNQYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YoZmluZCkgPiAtMTtcbn1cblxuLyoqXG4gKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICovXG5mdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cblxuLyoqXG4gKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xuICAgICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQpIHx8ICghZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufVxuXG4vKipcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG59XG5cbi8qKlxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAqL1xuZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuICAgICAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiBzb3J0VW5pcXVlQXJyYXkoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cbmZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgICB2YXIgcHJlZml4LCBwcm9wO1xuICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XG4gICAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICAgICAgcHJvcCA9IChwcmVmaXgpID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogZ2V0IGEgdW5pcXVlIGlkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICovXG52YXIgX3VuaXF1ZUlkID0gMTtcbmZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBfdW5pcXVlSWQrKztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIChkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyk7XG59XG5cbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG5cbnZhciBTVVBQT1JUX1RPVUNIID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbmRvdywgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG52YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxudmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xudmFyIElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG52YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XG52YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcblxudmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcblxudmFyIElOUFVUX1NUQVJUID0gMTtcbnZhciBJTlBVVF9NT1ZFID0gMjtcbnZhciBJTlBVVF9FTkQgPSA0O1xudmFyIElOUFVUX0NBTkNFTCA9IDg7XG5cbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG52YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XG52YXIgRElSRUNUSU9OX1VQID0gODtcbnZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xuXG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbnZhciBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVVAgfCBESVJFQ1RJT05fRE9XTjtcbnZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG5cbnZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG52YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0lucHV0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDtcblxuICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVyKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmluaXQoKTtcblxufVxuXG5JbnB1dC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIHRoZSBldmVudHNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2V2luICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICAgIHZhciBUeXBlO1xuICAgIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgICBpZiAoaW5wdXRDbGFzcykge1xuICAgICAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICAgIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaElucHV0O1xuICAgIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICAgICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoVHlwZSkobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICAgIHZhciBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgY2hhbmdlZFBvaW50ZXJzTGVuID0gaW5wdXQuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aDtcbiAgICB2YXIgaXNGaXJzdCA9IChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcbiAgICB2YXIgaXNGaW5hbCA9IChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcblxuICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICAgIH1cblxuICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gICAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG4gICAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuXG4gICAgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG4gICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XG5cbiAgICAvLyBlbWl0IHNlY3JldCBldmVudFxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuXG4gICAgbWFuYWdlci5yZWNvZ25pemUoaW5wdXQpO1xuICAgIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcbn1cblxuLyoqXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG4gICAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH1cblxuICAgIC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XG4gICAgdmFyIGZpcnN0TXVsdGlwbGUgPSBzZXNzaW9uLmZpcnN0TXVsdGlwbGU7XG4gICAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuXG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlciA9IGdldENlbnRlcihwb2ludGVycyk7XG4gICAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XG5cbiAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcblxuICAgIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuXG4gICAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xuXG4gICAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTtcblxuICAgIC8vIGZpbmQgdGhlIGNvcnJlY3QgdGFyZ2V0XG4gICAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoaGFzUGFyZW50KGlucHV0LnNyY0V2ZW50LnRhcmdldCwgdGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQgPSBpbnB1dC5zcmNFdmVudC50YXJnZXQ7XG4gICAgfVxuICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyO1xuICAgIHZhciBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xuICAgIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldklucHV0ID0gc2Vzc2lvbi5wcmV2SW5wdXQgfHwge307XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICAgICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICAgICAgfTtcblxuICAgICAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgICAgICB5OiBjZW50ZXIueVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICAgIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xufVxuXG4vKipcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgICB2YXIgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0LFxuICAgICAgICBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcCxcbiAgICAgICAgdmVsb2NpdHksIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBkaXJlY3Rpb247XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHZhciBkZWx0YVggPSBsYXN0LmRlbHRhWCAtIGlucHV0LmRlbHRhWDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IGxhc3QuZGVsdGFZIC0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICAgICAgdmVsb2NpdHlZID0gdi55O1xuICAgICAgICB2ZWxvY2l0eSA9IChhYnModi54KSA+IGFicyh2LnkpKSA/IHYueCA6IHYueTtcbiAgICAgICAgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKTtcblxuICAgICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcbiAgICAgICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgICAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICAgICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG59XG5cbi8qKlxuICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcbiAqL1xuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBpbnB1dC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICAgICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgICAgICAgIGNsaWVudFk6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFkpXG4gICAgICAgIH07XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICAgICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciB4ID0gMCwgeSA9IDAsIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgICAgICB5ICs9IHBvaW50ZXJzW2ldLmNsaWVudFk7XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxuICAgICAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAqL1xuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxuICAgICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgICB9O1xufVxuXG4vKipcbiAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxuICovXG5mdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xuICAgICAgICByZXR1cm4geCA+IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIHkgPiAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gcDFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICovXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xuICAgIH1cbiAgICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXSxcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0sIFBST1BTX0NMSUVOVF9YWSkgLSBnZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICovXG5mdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICAgIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIG1vdXNldXA6IElOUFVUX0VORFxufTtcblxudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG52YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG5cbi8qKlxuICogTW91c2UgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG5cbiAgICB0aGlzLmFsbG93ID0gdHJ1ZTsgLy8gdXNlZCBieSBJbnB1dC5Ub3VjaE1vdXNlIHRvIGRpc2FibGUgbW91c2UgZXZlbnRzXG4gICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7IC8vIG1vdXNlZG93biBzdGF0ZVxuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNRWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgICAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9NT1ZFICYmIGV2LndoaWNoICE9PSAxKSB7XG4gICAgICAgICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3VzZSBtdXN0IGJlIGRvd24sIGFuZCBtb3VzZSBldmVudHMgYXJlIGFsbG93ZWQgKHNlZSB0aGUgVG91Y2hNb3VzZSBpbnB1dClcbiAgICAgICAgaWYgKCF0aGlzLnByZXNzZWQgfHwgIXRoaXMuYWxsb3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIFBPSU5URVJfSU5QVVRfTUFQID0ge1xuICAgIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcbiAgICBwb2ludGVybW92ZTogSU5QVVRfTU9WRSxcbiAgICBwb2ludGVydXA6IElOUFVUX0VORCxcbiAgICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXG4gICAgcG9pbnRlcm91dDogSU5QVVRfQ0FOQ0VMXG59O1xuXG4vLyBpbiBJRTEwIHRoZSBwb2ludGVyIHR5cGVzIGlzIGRlZmluZWQgYXMgYW4gZW51bVxudmFyIElFMTBfUE9JTlRFUl9UWVBFX0VOVU0gPSB7XG4gICAgMjogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAzOiBJTlBVVF9UWVBFX1BFTixcbiAgICA0OiBJTlBVVF9UWVBFX01PVVNFLFxuICAgIDU6IElOUFVUX1RZUEVfS0lORUNUIC8vIHNlZSBodHRwczovL3R3aXR0ZXIuY29tL2phY29icm9zc2kvc3RhdHVzLzQ4MDU5NjQzODQ4OTg5MDgxNlxufTtcblxudmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xudmFyIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdwb2ludGVybW92ZSBwb2ludGVydXAgcG9pbnRlcmNhbmNlbCc7XG5cbi8vIElFMTAgaGFzIHByZWZpeGVkIHN1cHBvcnQsIGFuZCBjYXNlLXNlbnNpdGl2ZVxuaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCkge1xuICAgIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbn1cblxuLyoqXG4gKiBQb2ludGVyIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcbiAgICB0aGlzLmV2RWwgPSBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBQT0lOVEVSX1dJTkRPV19FVkVOVFM7XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5zdG9yZSA9ICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wb2ludGVyRXZlbnRzID0gW10pO1xufVxuXG5pbmhlcml0KFBvaW50ZXJFdmVudElucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBQRWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcblxuICAgICAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xuICAgICAgICB2YXIgcG9pbnRlclR5cGUgPSBJRTEwX1BPSU5URVJfVFlQRV9FTlVNW2V2LnBvaW50ZXJUeXBlXSB8fCBldi5wb2ludGVyVHlwZTtcblxuICAgICAgICB2YXIgaXNUb3VjaCA9IChwb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKTtcblxuICAgICAgICAvLyBnZXQgaW5kZXggb2YgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpO1xuXG4gICAgICAgIC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChldi5idXR0b24gPT09IDAgfHwgaXNUb3VjaCkpIHtcbiAgICAgICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgICAgICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxuICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHN0b3JlLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSB0aGUgc3RvcmVcbiAgICAgICAgICAgIHN0b3JlLnNwbGljZShzdG9yZUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgU0lOR0xFX1RPVUNIX0lOUFVUX01BUCA9IHtcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG52YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG52YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIFRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBTaW5nbGVUb3VjaElucHV0KCkge1xuICAgIHRoaXMuZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFM7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFNpbmdsZVRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgICAvLyBzaG91bGQgd2UgaGFuZGxlIHRoZSB0b3VjaCBldmVudHM/XG4gICAgICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG91Y2hlcyA9IG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICAgICAgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHRvdWNoZXNbMF0ubGVuZ3RoIC0gdG91Y2hlc1sxXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgY2hhbmdlZCA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpO1xuXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBhbGwgPSB1bmlxdWVBcnJheShhbGwuY29uY2F0KGNoYW5nZWQpLCAnaWRlbnRpZmllcicsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBbYWxsLCBjaGFuZ2VkXTtcbn1cblxudmFyIFRPVUNIX0lOUFVUX01BUCA9IHtcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG52YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogTXVsdGktdXNlciB0b3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLnRhcmdldElkcyA9IHt9O1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1URWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgICAgIHZhciB0b3VjaGVzID0gZ2V0VG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcbiAgICAgICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7XG5cbiAgICAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRvdWNoLCB0aGUgcHJvY2VzcyBjYW4gYmUgc2ltcGxpZmllZFxuICAgIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGFyZ2V0SWRzW2FsbFRvdWNoZXNbMF0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gW2FsbFRvdWNoZXMsIGFsbFRvdWNoZXNdO1xuICAgIH1cblxuICAgIHZhciBpLFxuICAgICAgICB0YXJnZXRUb3VjaGVzLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpLFxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdLFxuICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldDtcblxuICAgIC8vIGdldCB0YXJnZXQgdG91Y2hlcyBmcm9tIHRvdWNoZXNcbiAgICB0YXJnZXRUb3VjaGVzID0gYWxsVG91Y2hlcy5maWx0ZXIoZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gICAgfSk7XG5cbiAgICAvLyBjb2xsZWN0IHRvdWNoZXNcbiAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRhcmdldElkc1t0YXJnZXRUb3VjaGVzW2ldLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFudXAgcmVtb3ZlZCB0b3VjaGVzXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgICAvLyBtZXJnZSB0YXJnZXRUb3VjaGVzIHdpdGggY2hhbmdlZFRhcmdldFRvdWNoZXMgc28gaXQgY29udGFpbnMgQUxMIHRvdWNoZXMsIGluY2x1ZGluZyAnZW5kJyBhbmQgJ2NhbmNlbCdcbiAgICAgICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLFxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlc1xuICAgIF07XG59XG5cbi8qKlxuICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XG4gKlxuICogVG91Y2ggaGFzIGEgaGlnaGVyIHByaW9yaXR5IHRoZW4gbW91c2UsIGFuZCB3aGlsZSB0b3VjaGluZyBubyBtb3VzZSBldmVudHMgYXJlIGFsbG93ZWQuXG4gKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBUb3VjaE1vdXNlSW5wdXQoKSB7XG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHZhciBoYW5kbGVyID0gYmluZEZuKHRoaXMuaGFuZGxlciwgdGhpcyk7XG4gICAgdGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG59XG5cbmluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBUTUVoYW5kbGVyKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgaXNUb3VjaCA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCksXG4gICAgICAgICAgICBpc01vdXNlID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX01PVVNFKTtcblxuICAgICAgICAvLyB3aGVuIHdlJ3JlIGluIGEgdG91Y2ggZXZlbnQsIHNvICBibG9jayBhbGwgdXBjb21pbmcgbW91c2UgZXZlbnRzXG4gICAgICAgIC8vIG1vc3QgbW9iaWxlIGJyb3dzZXIgYWxzbyBlbWl0IG1vdXNlZXZlbnRzLCByaWdodCBhZnRlciB0b3VjaHN0YXJ0XG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICB0aGlzLm1vdXNlLmFsbG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiAhdGhpcy5tb3VzZS5hbGxvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgdGhlIGFsbG93TW91c2Ugd2hlbiB3ZSdyZSBkb25lXG4gICAgICAgIGlmIChpbnB1dEV2ZW50ICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIHRoaXMubW91c2UuYWxsb3cgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayhtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudG91Y2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1vdXNlLmRlc3Ryb3koKTtcbiAgICB9XG59KTtcblxudmFyIFBSRUZJWEVEX1RPVUNIX0FDVElPTiA9IHByZWZpeGVkKFRFU1RfRUxFTUVOVC5zdHlsZSwgJ3RvdWNoQWN0aW9uJyk7XG52YXIgTkFUSVZFX1RPVUNIX0FDVElPTiA9IFBSRUZJWEVEX1RPVUNIX0FDVElPTiAhPT0gdW5kZWZpbmVkO1xuXG4vLyBtYWdpY2FsIHRvdWNoQWN0aW9uIHZhbHVlXG52YXIgVE9VQ0hfQUNUSU9OX0NPTVBVVEUgPSAnY29tcHV0ZSc7XG52YXIgVE9VQ0hfQUNUSU9OX0FVVE8gPSAnYXV0byc7XG52YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcbnZhciBUT1VDSF9BQ1RJT05fTk9ORSA9ICdub25lJztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1ggPSAncGFuLXgnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XG5cbi8qKlxuICogVG91Y2ggQWN0aW9uXG4gKiBzZXRzIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBvciB1c2VzIHRoZSBqcyBhbHRlcm5hdGl2ZVxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUb3VjaEFjdGlvbihtYW5hZ2VyLCB2YWx1ZSkge1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5zZXQodmFsdWUpO1xufVxuXG5Ub3VjaEFjdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZSBvbiB0aGUgZWxlbWVudCBvciBlbmFibGUgdGhlIHBvbHlmaWxsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBmaW5kIG91dCB0aGUgdG91Y2gtYWN0aW9uIGJ5IHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgICBpZiAodmFsdWUgPT0gVE9VQ0hfQUNUSU9OX0NPTVBVVEUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jb21wdXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGVbUFJFRklYRURfVE9VQ0hfQUNUSU9OXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldCh0aGlzLm1hbmFnZXIub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgY29tcHV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLmNvbmNhdChyZWNvZ25pemVyLmdldFRvdWNoQWN0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uIGVhY2ggaW5wdXQgY3ljbGUgYW5kIHByb3ZpZGVzIHRoZSBwcmV2ZW50aW5nIG9mIHRoZSBicm93c2VyIGJlaGF2aW9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHRzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAvLyBub3QgbmVlZGVkIHdpdGggbmF0aXZlIHN1cHBvcnQgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eVxuICAgICAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XG5cbiAgICAgICAgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSk7XG4gICAgICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuXG4gICAgICAgIGlmIChoYXNOb25lIHx8XG4gICAgICAgICAgICAoaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkgfHxcbiAgICAgICAgICAgIChoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRTcmMoc3JjRXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGwgcHJldmVudERlZmF1bHQgdG8gcHJldmVudCB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IgKHNjcm9sbGluZyBpbiBtb3N0IGNhc2VzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNFdmVudFxuICAgICAqL1xuICAgIHByZXZlbnRTcmM6IGZ1bmN0aW9uKHNyY0V2ZW50KSB7XG4gICAgICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiB3aGVuIHRoZSB0b3VjaEFjdGlvbnMgYXJlIGNvbGxlY3RlZCB0aGV5IGFyZSBub3QgYSB2YWxpZCB2YWx1ZSwgc28gd2UgbmVlZCB0byBjbGVhbiB0aGluZ3MgdXAuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucykge1xuICAgIC8vIG5vbmVcbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xuXG4gICAgLy8gcGFuLXggYW5kIHBhbi15IGNhbiBiZSBjb21iaW5lZFxuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIFRPVUNIX0FDVElPTl9QQU5fWCArICcgJyArIFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgICB9XG5cbiAgICAvLyBwYW4teCBPUiBwYW4teVxuICAgIGlmIChoYXNQYW5YIHx8IGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XG4gICAgfVxuXG4gICAgLy8gbWFuaXB1bGF0aW9uXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04pKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OO1xuICAgIH1cblxuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbn1cblxuLyoqXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gKiBBbGwgcmVjb2duaXplcnMgaGF2ZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBQT1NTSUJMRSB3aGVuIGEgaW5wdXQgc2Vzc2lvbiBzdGFydHMuXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICpcbiAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gKlxuICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAqXG4gKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gKiAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgKy0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAqICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICovXG52YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xudmFyIFNUQVRFX0JFR0FOID0gMjtcbnZhciBTVEFURV9DSEFOR0VEID0gNDtcbnZhciBTVEFURV9FTkRFRCA9IDg7XG52YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xudmFyIFNUQVRFX0NBTkNFTExFRCA9IDE2O1xudmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xuXG4vKipcbiAqIFJlY29nbml6ZXJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdGhpcy5pZCA9IHVuaXF1ZUlkKCk7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMgfHwge30sIHRoaXMuZGVmYXVsdHMpO1xuXG4gICAgLy8gZGVmYXVsdCBpcyBlbmFibGUgdHJ1ZVxuICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSBpZlVuZGVmaW5lZCh0aGlzLm9wdGlvbnMuZW5hYmxlLCB0cnVlKTtcblxuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcblxuICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XG4gICAgdGhpcy5yZXF1aXJlRmFpbCA9IFtdO1xufVxuXG5SZWNvZ25pemVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgZGVmYXVsdHM6IHt9LFxuXG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1JlY29nbml6ZXJ9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGFsc28gdXBkYXRlIHRoZSB0b3VjaEFjdGlvbiwgaW4gY2FzZSBzb21ldGhpbmcgY2hhbmdlZCBhYm91dCB0aGUgZGlyZWN0aW9ucy9lbmFibGVkIHN0YXRlXG4gICAgICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgcmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpbXVsdGFuZW91cyA9IHRoaXMuc2ltdWx0YW5lb3VzO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGlmICghc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0pIHtcbiAgICAgICAgICAgIHNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdID0gb3RoZXJSZWNvZ25pemVyO1xuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBkcm9wUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWNvZ25pemVyIGNhbiBvbmx5IHJ1biB3aGVuIGFuIG90aGVyIGlzIGZhaWxpbmdcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgcmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVxdWlyZUZhaWwgPSB0aGlzLnJlcXVpcmVGYWlsO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIGlmIChpbkFycmF5KHJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpID09PSAtMSkge1xuICAgICAgICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIGRyb3BSZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkodGhpcy5yZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1JlcXVpcmVGYWlsdXJlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGlmIHRoZSByZWNvZ25pemVyIGNhbiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFlvdSBzaG91bGQgdXNlIGB0cnlFbWl0YCBpbnN0ZWFkIG9mIGBlbWl0YCBkaXJlY3RseSB0byBjaGVja1xuICAgICAqIHRoYXQgYWxsIHRoZSBuZWVkZWQgcmVjb2duaXplcnMgaGFzIGZhaWxlZCBiZWZvcmUgZW1pdHRpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGVtaXQod2l0aFN0YXRlKSB7XG4gICAgICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyAod2l0aFN0YXRlID8gc3RhdGVTdHIoc3RhdGUpIDogJycpLCBpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAncGFuc3RhcnQnIGFuZCAncGFubW92ZSdcbiAgICAgICAgaWYgKHN0YXRlIDwgU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgICAgIGVtaXQodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbWl0KCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgICAgICAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxuICAgICAgICBpZiAoc3RhdGUgPj0gU1RBVEVfRU5ERUQpIHtcbiAgICAgICAgICAgIGVtaXQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICovXG4gICAgdHJ5RW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbiB3ZSBlbWl0P1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNhbkVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIC8vIG1ha2UgYSBuZXcgY29weSBvZiB0aGUgaW5wdXREYXRhXG4gICAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGV4dGVuZCh7fSwgaW5wdXREYXRhKTtcblxuICAgICAgICAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cbiAgICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTtcblxuICAgICAgICAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAgICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5RW1pdChpbnB1dERhdGFDbG9uZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqIEByZXR1cm5zIHtDb25zdH0gU1RBVEVcbiAgICAgKi9cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dERhdGEpIHsgfSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHsgfVxufTtcblxuLyoqXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAqIEBwYXJhbSB7Q29uc3R9IHN0YXRlXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICovXG5mdW5jdGlvbiBzdGF0ZVN0cihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgICAgIHJldHVybiAnZW5kJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgICAgICByZXR1cm4gJ21vdmUnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICogQHBhcmFtIHtDb25zdH0gZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTikge1xuICAgICAgICByZXR1cm4gJ2Rvd24nO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCkge1xuICAgICAgICByZXR1cm4gJ3VwJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fTEVGVCkge1xuICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9SSUdIVCkge1xuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcbiAgICBpZiAobWFuYWdlcikge1xuICAgICAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG90aGVyUmVjb2duaXplcjtcbn1cblxuLyoqXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KEF0dHJSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICAgKi9cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcblxuICAgICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTtcblxuICAgICAgICAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXG4gICAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBhblxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGFuUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5wWCA9IG51bGw7XG4gICAgdGhpcy5wWSA9IG51bGw7XG59XG5cbmluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3BhbicsXG4gICAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICB9LFxuXG4gICAgZGlyZWN0aW9uVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQuZGlyZWN0aW9uO1xuICAgICAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcbiAgICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgLy8gbG9jayB0byBheGlzP1xuICAgICAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHggPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeSA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh5IDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHkgIT0gdGhpcy5wWTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgKCEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKSk7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUGluY2hcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKCkge1xuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoUGluY2hSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwaW5jaCcsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgcG9pbnRlcnM6IDJcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB9LFxuXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgaW5PdXQsIGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIFByZXNzXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBmb3IgeCBtcyB3aXRob3V0IGFueSBtb3ZlbWVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBQcmVzc1JlY29nbml6ZXIoKSB7XG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbn1cblxuaW5oZXJpdChQcmVzc1JlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFByZXNzUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncHJlc3MnLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgdGltZTogNTAwLCAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxuICAgICAgICB0aHJlc2hvbGQ6IDUgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9BVVRPXTtcbiAgICB9LFxuXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICAgIHZhciB2YWxpZFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPiBvcHRpb25zLnRpbWU7XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCAoaW5wdXQuZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgIXZhbGlkVGltZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgICAgIH0sIG9wdGlvbnMudGltZSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXQgJiYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArICd1cCcsIGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBSb3RhdGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVyIGFyZSBtb3ZpbmcgaW4gYSBjaXJjdWxhciBtb3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFJvdGF0ZVJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChSb3RhdGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUm90YXRlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncm90YXRlJyxcbiAgICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgICBwb2ludGVyczogMlxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQucm90YXRpb24pID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFN3aXBlXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChTd2lwZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBTd2lwZVJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBldmVudDogJ3N3aXBlJyxcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgICAgdmVsb2NpdHk6IDAuNjUsXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHZlbG9jaXR5O1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0LnZlbG9jaXR5O1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0LnZlbG9jaXR5WDtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQudmVsb2NpdHlZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICBkaXJlY3Rpb24gJiBpbnB1dC5kaXJlY3Rpb24gJiZcbiAgICAgICAgICAgIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJlxuICAgICAgICAgICAgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQuZGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBBIHRhcCBpcyBlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXG4gKiBiZXR3ZWVuIHRoZSBnaXZlbiBpbnRlcnZhbCBhbmQgcG9zaXRpb24uIFRoZSBkZWxheSBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVjb2duaXplIG11bHRpLXRhcHMgd2l0aG91dCBmaXJpbmdcbiAqIGEgc2luZ2xlIHRhcC5cbiAqXG4gKiBUaGUgZXZlbnREYXRhIGZyb20gdGhlIGVtaXR0ZWQgZXZlbnQgY29udGFpbnMgdGhlIHByb3BlcnR5IGB0YXBDb3VudGAsIHdoaWNoIGNvbnRhaW5zIHRoZSBhbW91bnQgb2ZcbiAqIG11bHRpLXRhcHMgYmVpbmcgcmVjb2duaXplZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBUYXBSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcbiAgICB0aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgdGhpcy5wQ2VudGVyID0gZmFsc2U7XG5cbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIHRoaXMuY291bnQgPSAwO1xufVxuXG5pbmhlcml0KFRhcFJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAndGFwJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRhcHM6IDEsXG4gICAgICAgIGludGVydmFsOiAzMDAsIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXG4gICAgICAgIHRpbWU6IDI1MCwgLy8gbWF4IHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgZG93biAobGlrZSBmaW5nZXIgb24gdGhlIHNjcmVlbilcbiAgICAgICAgdGhyZXNob2xkOiAyLCAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgICBwb3NUaHJlc2hvbGQ6IDEwIC8vIGEgbXVsdGktdGFwIGNhbiBiZSBhIGJpdCBvZmYgdGhlIGluaXRpYWwgcG9zaXRpb25cbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgIGlmICgoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpICYmICh0aGlzLmNvdW50ID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKHZhbGlkTW92ZW1lbnQgJiYgdmFsaWRUb3VjaFRpbWUgJiYgdmFsaWRQb2ludGVycykge1xuICAgICAgICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyAoaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwpIDogdHJ1ZTtcbiAgICAgICAgICAgIHZhciB2YWxpZE11bHRpVGFwID0gIXRoaXMucENlbnRlciB8fCBnZXREaXN0YW5jZSh0aGlzLnBDZW50ZXIsIGlucHV0LmNlbnRlcikgPCBvcHRpb25zLnBvc1RocmVzaG9sZDtcblxuICAgICAgICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcbiAgICAgICAgICAgIHRoaXMucENlbnRlciA9IGlucHV0LmNlbnRlcjtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAgICAgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxuICAgICAgICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cbiAgICAgICAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG4gICAgICAgICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gb3Igd2FpdCBhcyBsb25nIGFzIHRoZSBtdWx0aXRhcCBpbnRlcnZhbCB0byB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICBmYWlsVGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9SRUNPR05JWkVEICkge1xuICAgICAgICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBTaW1wbGUgd2F5IHRvIGNyZWF0ZSBhbiBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucmVjb2duaXplcnMgPSBpZlVuZGVmaW5lZChvcHRpb25zLnJlY29nbml6ZXJzLCBIYW1tZXIuZGVmYXVsdHMucHJlc2V0KTtcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cbkhhbW1lci5WRVJTSU9OID0gJzIuMC40JztcblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzXG4gKiBAbmFtZXNwYWNlXG4gKi9cbkhhbW1lci5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgICAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkb21FdmVudHM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG4gICAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXG4gICAgICovXG4gICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGVuYWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcbiAgICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dFRhcmdldDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGlucHV0Q2xhc3M6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAgICAgKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBwcmVzZXQ6IFtcbiAgICAgICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgICAgIFtSb3RhdGVSZWNvZ25pemVyLCB7IGVuYWJsZTogZmFsc2UgfV0sXG4gICAgICAgIFtQaW5jaFJlY29nbml6ZXIsIHsgZW5hYmxlOiBmYWxzZSB9LCBbJ3JvdGF0ZSddXSxcbiAgICAgICAgW1N3aXBlUmVjb2duaXplcix7IGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfV0sXG4gICAgICAgIFtQYW5SZWNvZ25pemVyLCB7IGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfSwgWydzd2lwZSddXSxcbiAgICAgICAgW1RhcFJlY29nbml6ZXJdLFxuICAgICAgICBbVGFwUmVjb2duaXplciwgeyBldmVudDogJ2RvdWJsZXRhcCcsIHRhcHM6IDIgfSwgWyd0YXAnXV0sXG4gICAgICAgIFtQcmVzc1JlY29nbml6ZXJdXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIFNvbWUgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSB0aGUgd29ya2luZyBvZiBIYW1tZXIuXG4gICAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBjc3NQcm9wczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGF0IGFuIGVudGlyZSBlbGVtZW50IHNob3VsZCBiZSBkcmFnZ2FibGUgaW5zdGVhZCBvZiBpdHMgY29udGVudHMuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyRHJhZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxuICAgICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICAgIH1cbn07XG5cbnZhciBTVE9QID0gMTtcbnZhciBGT1JDRURfU1RPUCA9IDI7XG5cbi8qKlxuICogTWFuYWdlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2Uob3B0aW9ucywgSGFtbWVyLmRlZmF1bHRzKTtcbiAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcblxuICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICB0aGlzLnJlY29nbml6ZXJzID0gW107XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcblxuICAgIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIHRydWUpO1xuXG4gICAgZWFjaChvcHRpb25zLnJlY29nbml6ZXJzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciByZWNvZ25pemVyID0gdGhpcy5hZGQobmV3IChpdGVtWzBdKShpdGVtWzFdKSk7XG4gICAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgICBpdGVtWzNdICYmIHJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUoaXRlbVszXSk7XG4gICAgfSwgdGhpcyk7XG59XG5cbk1hbmFnZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gT3B0aW9ucyB0aGF0IG5lZWQgYSBsaXR0bGUgbW9yZSBzZXR1cFxuICAgICAgICBpZiAob3B0aW9ucy50b3VjaEFjdGlvbikge1xuICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHN0b3AgcmVjb2duaXppbmcgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICAgKiBUaGlzIHNlc3Npb24gd2lsbCBiZSBkaXNjYXJkZWQsIHdoZW4gYSBuZXcgW2lucHV0XXN0YXJ0IGV2ZW50IGlzIGZpcmVkLlxuICAgICAqIFdoZW4gZm9yY2VkLCB0aGUgcmVjb2duaXplciBjeWNsZSBpcyBzdG9wcGVkIGltbWVkaWF0ZWx5LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zdG9wcGVkID0gZm9yY2UgPyBGT1JDRURfU1RPUCA6IFNUT1A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJ1biB0aGUgcmVjb2duaXplcnMhXG4gICAgICogY2FsbGVkIGJ5IHRoZSBpbnB1dEhhbmRsZXIgZnVuY3Rpb24gb24gZXZlcnkgbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXJzICh0b3VjaGVzKVxuICAgICAqIGl0IHdhbGtzIHRocm91Z2ggYWxsIHRoZSByZWNvZ25pemVycyBhbmQgdHJpZXMgdG8gZGV0ZWN0IHRoZSBnZXN0dXJlIHRoYXQgaXMgYmVpbmcgbWFkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcnVuIHRoZSB0b3VjaC1hY3Rpb24gcG9seWZpbGxcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHMoaW5wdXREYXRhKTtcblxuICAgICAgICB2YXIgcmVjb2duaXplcjtcbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgICAgICAvLyB0aGlzIGhvbGRzIHRoZSByZWNvZ25pemVyIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgLy8gc28gdGhlIHJlY29nbml6ZXIncyBzdGF0ZSBuZWVkcyB0byBiZSBCRUdBTiwgQ0hBTkdFRCwgRU5ERUQgb3IgUkVDT0dOSVpFRFxuICAgICAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG4gICAgICAgIHZhciBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyO1xuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gdGhlIGxhc3QgcmVjb2duaXplciBpcyByZWNvZ25pemVkXG4gICAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgfHwgKGN1clJlY29nbml6ZXIgJiYgY3VyUmVjb2duaXplci5zdGF0ZSAmIFNUQVRFX1JFQ09HTklaRUQpKSB7XG4gICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlY29nbml6ZXIgPSByZWNvZ25pemVyc1tpXTtcblxuICAgICAgICAgICAgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAgICAgICAvLyAyLiAgIGFsbG93IGlmIHdlIHN0aWxsIGhhdmVuJ3QgcmVjb2duaXplZCBhIGdlc3R1cmUgaW4gdGhpcyBzZXNzaW9uLCBvciB0aGUgdGhpcyByZWNvZ25pemVyIGlzIHRoZSBvbmVcbiAgICAgICAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAgICAgICAvLyAgICAgIHRoaXMgY2FuIGJlIHNldHVwIHdpdGggdGhlIGByZWNvZ25pemVXaXRoKClgIG1ldGhvZCBvbiB0aGUgcmVjb2duaXplci5cbiAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxuICAgICAgICAgICAgICAgICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09IGN1clJlY29nbml6ZXIgfHwgLy8gMlxuICAgICAgICAgICAgICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7IC8vIDNcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSByZWNvZ25pemVyIGhhcyBiZWVuIHJlY29nbml6aW5nIHRoZSBpbnB1dCBhcyBhIHZhbGlkIGdlc3R1cmUsIHdlIHdhbnQgdG8gc3RvcmUgdGhpcyBvbmUgYXMgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSByZWNvZ25pemVyLiBidXQgb25seSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gYWN0aXZlIHJlY29nbml6ZXJcbiAgICAgICAgICAgIGlmICghY3VyUmVjb2duaXplciAmJiByZWNvZ25pemVyLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEKSkge1xuICAgICAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVjb2duaXplcnNbaV0ub3B0aW9ucy5ldmVudCA9PSByZWNvZ25pemVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXJzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSByZWNvZ25pemVyIHRvIHRoZSBtYW5hZ2VyXG4gICAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE1hbmFnZXJ9XG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAnYWRkJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZXhpc3RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nbml6ZXIpO1xuICAgICAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYSByZWNvZ25pemVyIGJ5IG5hbWUgb3IgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAncmVtb3ZlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcbiAgICAgICAgcmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpO1xuICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5BcnJheShyZWNvZ25pemVycywgcmVjb2duaXplciksIDEpO1xuXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgZXZlbnQsIGxlYXZlIGVtaXQgYmxhbmsgdG8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGVtaXQgZXZlbnQgdG8gdGhlIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuICAgICAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEudHlwZSA9IGV2ZW50O1xuICAgICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXG4gICAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICAgIHZhciBlbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3ByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpXSA9IGFkZCA/IHZhbHVlIDogJyc7XG4gICAgfSk7XG59XG5cbi8qKlxuICogdHJpZ2dlciBkb20gZXZlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqL1xuZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGdlc3R1cmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xuICAgIGdlc3R1cmVFdmVudC5nZXN0dXJlID0gZGF0YTtcbiAgICBkYXRhLnRhcmdldC5kaXNwYXRjaEV2ZW50KGdlc3R1cmVFdmVudCk7XG59XG5cbmV4dGVuZChIYW1tZXIsIHtcbiAgICBJTlBVVF9TVEFSVDogSU5QVVRfU1RBUlQsXG4gICAgSU5QVVRfTU9WRTogSU5QVVRfTU9WRSxcbiAgICBJTlBVVF9FTkQ6IElOUFVUX0VORCxcbiAgICBJTlBVVF9DQU5DRUw6IElOUFVUX0NBTkNFTCxcblxuICAgIFNUQVRFX1BPU1NJQkxFOiBTVEFURV9QT1NTSUJMRSxcbiAgICBTVEFURV9CRUdBTjogU1RBVEVfQkVHQU4sXG4gICAgU1RBVEVfQ0hBTkdFRDogU1RBVEVfQ0hBTkdFRCxcbiAgICBTVEFURV9FTkRFRDogU1RBVEVfRU5ERUQsXG4gICAgU1RBVEVfUkVDT0dOSVpFRDogU1RBVEVfUkVDT0dOSVpFRCxcbiAgICBTVEFURV9DQU5DRUxMRUQ6IFNUQVRFX0NBTkNFTExFRCxcbiAgICBTVEFURV9GQUlMRUQ6IFNUQVRFX0ZBSUxFRCxcblxuICAgIERJUkVDVElPTl9OT05FOiBESVJFQ1RJT05fTk9ORSxcbiAgICBESVJFQ1RJT05fTEVGVDogRElSRUNUSU9OX0xFRlQsXG4gICAgRElSRUNUSU9OX1JJR0hUOiBESVJFQ1RJT05fUklHSFQsXG4gICAgRElSRUNUSU9OX1VQOiBESVJFQ1RJT05fVVAsXG4gICAgRElSRUNUSU9OX0RPV046IERJUkVDVElPTl9ET1dOLFxuICAgIERJUkVDVElPTl9IT1JJWk9OVEFMOiBESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgICBESVJFQ1RJT05fVkVSVElDQUw6IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICBESVJFQ1RJT05fQUxMOiBESVJFQ1RJT05fQUxMLFxuXG4gICAgTWFuYWdlcjogTWFuYWdlcixcbiAgICBJbnB1dDogSW5wdXQsXG4gICAgVG91Y2hBY3Rpb246IFRvdWNoQWN0aW9uLFxuXG4gICAgVG91Y2hJbnB1dDogVG91Y2hJbnB1dCxcbiAgICBNb3VzZUlucHV0OiBNb3VzZUlucHV0LFxuICAgIFBvaW50ZXJFdmVudElucHV0OiBQb2ludGVyRXZlbnRJbnB1dCxcbiAgICBUb3VjaE1vdXNlSW5wdXQ6IFRvdWNoTW91c2VJbnB1dCxcbiAgICBTaW5nbGVUb3VjaElucHV0OiBTaW5nbGVUb3VjaElucHV0LFxuXG4gICAgUmVjb2duaXplcjogUmVjb2duaXplcixcbiAgICBBdHRyUmVjb2duaXplcjogQXR0clJlY29nbml6ZXIsXG4gICAgVGFwOiBUYXBSZWNvZ25pemVyLFxuICAgIFBhbjogUGFuUmVjb2duaXplcixcbiAgICBTd2lwZTogU3dpcGVSZWNvZ25pemVyLFxuICAgIFBpbmNoOiBQaW5jaFJlY29nbml6ZXIsXG4gICAgUm90YXRlOiBSb3RhdGVSZWNvZ25pemVyLFxuICAgIFByZXNzOiBQcmVzc1JlY29nbml6ZXIsXG5cbiAgICBvbjogYWRkRXZlbnRMaXN0ZW5lcnMsXG4gICAgb2ZmOiByZW1vdmVFdmVudExpc3RlbmVycyxcbiAgICBlYWNoOiBlYWNoLFxuICAgIG1lcmdlOiBtZXJnZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBpbmhlcml0OiBpbmhlcml0LFxuICAgIGJpbmRGbjogYmluZEZuLFxuICAgIHByZWZpeGVkOiBwcmVmaXhlZFxufSk7XG5cbmlmICh0eXBlb2YgZGVmaW5lID09IFRZUEVfRlVOQ1RJT04gJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEhhbW1lcjtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSGFtbWVyO1xufSBlbHNlIHtcbiAgICB3aW5kb3dbZXhwb3J0TmFtZV0gPSBIYW1tZXI7XG59XG5cbn0pKHdpbmRvdywgZG9jdW1lbnQsICdIYW1tZXInKTtcbiIsIiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7dmFyIGY7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9mPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2Y9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoZj1zZWxmKSxmLnBhZ2U9ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gIC8qIGdsb2JhbHMgcmVxdWlyZSwgbW9kdWxlICovXG5cbi8qKlxuICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICAgKi9cblxuICB2YXIgcGF0aHRvUmVnZXhwID0gcmVxdWlyZSgncGF0aC10by1yZWdleHAnKTtcblxuICAvKipcbiAgICogTW9kdWxlIGV4cG9ydHMuXG4gICAqL1xuXG4gIG1vZHVsZS5leHBvcnRzID0gcGFnZTtcblxuICAvKipcbiAgICogVG8gd29yayBwcm9wZXJseSB3aXRoIHRoZSBVUkxcbiAgICogaGlzdG9yeS5sb2NhdGlvbiBnZW5lcmF0ZWQgcG9seWZpbGwgaW4gaHR0cHM6Ly9naXRodWIuY29tL2Rldm90ZS9IVE1MNS1IaXN0b3J5LUFQSVxuICAgKi9cblxuICB2YXIgbG9jYXRpb24gPSB3aW5kb3cuaGlzdG9yeS5sb2NhdGlvbiB8fCB3aW5kb3cubG9jYXRpb247XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gaW5pdGlhbCBkaXNwYXRjaC5cbiAgICovXG5cbiAgdmFyIGRpc3BhdGNoID0gdHJ1ZTtcblxuICAvKipcbiAgICogQmFzZSBwYXRoLlxuICAgKi9cblxuICB2YXIgYmFzZSA9ICcnO1xuXG4gIC8qKlxuICAgKiBSdW5uaW5nIGZsYWcuXG4gICAqL1xuXG4gIHZhciBydW5uaW5nO1xuXG4gIC8qKlxuICAqIEhhc2hCYW5nIG9wdGlvblxuICAqL1xuXG4gIHZhciBoYXNoYmFuZyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBQcmV2aW91cyBjb250ZXh0LCBmb3IgY2FwdHVyaW5nXG4gICAqIHBhZ2UgZXhpdCBldmVudHMuXG4gICAqL1xuXG4gIHZhciBwcmV2Q29udGV4dDtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYHBhdGhgIHdpdGggY2FsbGJhY2sgYGZuKClgLFxuICAgKiBvciByb3V0ZSBgcGF0aGAsIG9yIHJlZGlyZWN0aW9uLFxuICAgKiBvciBgcGFnZS5zdGFydCgpYC5cbiAgICpcbiAgICogICBwYWdlKGZuKTtcbiAgICogICBwYWdlKCcqJywgZm4pO1xuICAgKiAgIHBhZ2UoJy91c2VyLzppZCcsIGxvYWQsIHVzZXIpO1xuICAgKiAgIHBhZ2UoJy91c2VyLycgKyB1c2VyLmlkLCB7IHNvbWU6ICd0aGluZycgfSk7XG4gICAqICAgcGFnZSgnL3VzZXIvJyArIHVzZXIuaWQpO1xuICAgKiAgIHBhZ2UoJy9mcm9tJywgJy90bycpXG4gICAqICAgcGFnZSgpO1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gcGF0aFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbi4uLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBwYWdlKHBhdGgsIGZuKSB7XG4gICAgLy8gPGNhbGxiYWNrPlxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgcGF0aCkge1xuICAgICAgcmV0dXJuIHBhZ2UoJyonLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvLyByb3V0ZSA8cGF0aD4gdG8gPGNhbGxiYWNrIC4uLj5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZuKSB7XG4gICAgICB2YXIgcm91dGUgPSBuZXcgUm91dGUocGF0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBwYWdlLmNhbGxiYWNrcy5wdXNoKHJvdXRlLm1pZGRsZXdhcmUoYXJndW1lbnRzW2ldKSk7XG4gICAgICB9XG4gICAgLy8gc2hvdyA8cGF0aD4gd2l0aCBbc3RhdGVdXG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgcGF0aCkge1xuICAgICAgJ3N0cmluZycgPT09IHR5cGVvZiBmblxuICAgICAgICA/IHBhZ2UucmVkaXJlY3QocGF0aCwgZm4pXG4gICAgICAgIDogcGFnZS5zaG93KHBhdGgsIGZuKTtcbiAgICAvLyBzdGFydCBbb3B0aW9uc11cbiAgICB9IGVsc2Uge1xuICAgICAgcGFnZS5zdGFydChwYXRoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb25zLlxuICAgKi9cblxuICBwYWdlLmNhbGxiYWNrcyA9IFtdO1xuICBwYWdlLmV4aXRzID0gW107XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgYmFzZXBhdGggdG8gYHBhdGhgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBwYWdlLmJhc2UgPSBmdW5jdGlvbihwYXRoKXtcbiAgICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGJhc2U7XG4gICAgYmFzZSA9IHBhdGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJpbmQgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICAgKlxuICAgKiBPcHRpb25zOlxuICAgKlxuICAgKiAgICAtIGBjbGlja2AgYmluZCB0byBjbGljayBldmVudHMgW3RydWVdXG4gICAqICAgIC0gYHBvcHN0YXRlYCBiaW5kIHRvIHBvcHN0YXRlIFt0cnVlXVxuICAgKiAgICAtIGBkaXNwYXRjaGAgcGVyZm9ybSBpbml0aWFsIGRpc3BhdGNoIFt0cnVlXVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBwYWdlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHJ1bm5pbmcpIHJldHVybjtcbiAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICBpZiAoZmFsc2UgPT09IG9wdGlvbnMuZGlzcGF0Y2gpIGRpc3BhdGNoID0gZmFsc2U7XG4gICAgaWYgKGZhbHNlICE9PSBvcHRpb25zLnBvcHN0YXRlKSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvbnBvcHN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKGZhbHNlICE9PSBvcHRpb25zLmNsaWNrKSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbmNsaWNrLCBmYWxzZSk7XG4gICAgaWYgKHRydWUgPT09IG9wdGlvbnMuaGFzaGJhbmcpIGhhc2hiYW5nID0gdHJ1ZTtcbiAgICBpZiAoIWRpc3BhdGNoKSByZXR1cm47XG4gICAgdmFyIHVybCA9IChoYXNoYmFuZyAmJiB+bG9jYXRpb24uaGFzaC5pbmRleE9mKCcjIScpKVxuICAgICAgPyBsb2NhdGlvbi5oYXNoLnN1YnN0cigyKSArIGxvY2F0aW9uLnNlYXJjaFxuICAgICAgOiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2g7XG4gICAgcGFnZS5yZXBsYWNlKHVybCwgbnVsbCwgdHJ1ZSwgZGlzcGF0Y2gpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbmJpbmQgY2xpY2sgYW5kIHBvcHN0YXRlIGV2ZW50IGhhbmRsZXJzLlxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBwYWdlLnN0b3AgPSBmdW5jdGlvbigpe1xuICAgIGlmICghcnVubmluZykgcmV0dXJuO1xuICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbmNsaWNrLCBmYWxzZSk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25wb3BzdGF0ZSwgZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IGBwYXRoYCB3aXRoIG9wdGlvbmFsIGBzdGF0ZWAgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBkaXNwYXRjaFxuICAgKiBAcmV0dXJuIHtDb250ZXh0fVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBwYWdlLnNob3cgPSBmdW5jdGlvbihwYXRoLCBzdGF0ZSwgZGlzcGF0Y2gpe1xuICAgIHZhciBjdHggPSBuZXcgQ29udGV4dChwYXRoLCBzdGF0ZSk7XG4gICAgaWYgKGZhbHNlICE9PSBkaXNwYXRjaCkgcGFnZS5kaXNwYXRjaChjdHgpO1xuICAgIGlmIChmYWxzZSAhPT0gY3R4LmhhbmRsZWQpIGN0eC5wdXNoU3RhdGUoKTtcbiAgICByZXR1cm4gY3R4O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciByb3V0ZSB0byByZWRpcmVjdCBmcm9tIG9uZSBwYXRoIHRvIG90aGVyXG4gICAqIG9yIGp1c3QgcmVkaXJlY3QgdG8gYW5vdGhlciByb3V0ZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnJvbSAtIGlmIHBhcmFtICd0bycgaXMgdW5kZWZpbmVkIHJlZGlyZWN0cyB0byAnZnJvbSdcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt0b11cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIHBhZ2UucmVkaXJlY3QgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgIC8vIERlZmluZSByb3V0ZSBmcm9tIGEgcGF0aCB0byBhbm90aGVyXG4gICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgZnJvbSAmJiAnc3RyaW5nJyA9PT0gdHlwZW9mIHRvKSB7XG4gICAgICBwYWdlKGZyb20sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcGFnZS5yZXBsYWNlKHRvKTtcbiAgICAgICAgfSwwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFdhaXQgZm9yIHRoZSBwdXNoIHN0YXRlIGFuZCByZXBsYWNlIGl0IHdpdGggYW5vdGhlclxuICAgIGlmKCdzdHJpbmcnID09PSB0eXBlb2YgZnJvbSAmJiAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRvKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHBhZ2UucmVwbGFjZShmcm9tKTtcbiAgICAgIH0sMCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlIGBwYXRoYCB3aXRoIG9wdGlvbmFsIGBzdGF0ZWAgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQHJldHVybiB7Q29udGV4dH1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcGFnZS5yZXBsYWNlID0gZnVuY3Rpb24ocGF0aCwgc3RhdGUsIGluaXQsIGRpc3BhdGNoKXtcbiAgICB2YXIgY3R4ID0gbmV3IENvbnRleHQocGF0aCwgc3RhdGUpO1xuICAgIGN0eC5pbml0ID0gaW5pdDtcbiAgICBjdHguc2F2ZSgpOyAvLyBzYXZlIGJlZm9yZSBkaXNwYXRjaGluZywgd2hpY2ggbWF5IHJlZGlyZWN0XG4gICAgaWYgKGZhbHNlICE9PSBkaXNwYXRjaCkgcGFnZS5kaXNwYXRjaChjdHgpO1xuICAgIHJldHVybiBjdHg7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIHRoZSBnaXZlbiBgY3R4YC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgcGFnZS5kaXNwYXRjaCA9IGZ1bmN0aW9uKGN0eCl7XG4gICAgdmFyIHByZXYgPSBwcmV2Q29udGV4dDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGogPSAwO1xuXG4gICAgcHJldkNvbnRleHQgPSBjdHg7XG5cbiAgICBmdW5jdGlvbiBuZXh0RXhpdCgpIHtcbiAgICAgIHZhciBmbiA9IHBhZ2UuZXhpdHNbaisrXTtcbiAgICAgIGlmICghZm4pIHJldHVybiBuZXh0RW50ZXIoKTtcbiAgICAgIGZuKHByZXYsIG5leHRFeGl0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXh0RW50ZXIoKSB7XG4gICAgICB2YXIgZm4gPSBwYWdlLmNhbGxiYWNrc1tpKytdO1xuICAgICAgaWYgKCFmbikgcmV0dXJuIHVuaGFuZGxlZChjdHgpO1xuICAgICAgZm4oY3R4LCBuZXh0RW50ZXIpO1xuICAgIH1cblxuICAgIGlmIChwcmV2KSB7XG4gICAgICBuZXh0RXhpdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0RW50ZXIoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuaGFuZGxlZCBgY3R4YC4gV2hlbiBpdCdzIG5vdCB0aGUgaW5pdGlhbFxuICAgKiBwb3BzdGF0ZSB0aGVuIHJlZGlyZWN0LiBJZiB5b3Ugd2lzaCB0byBoYW5kbGVcbiAgICogNDA0cyBvbiB5b3VyIG93biB1c2UgYHBhZ2UoJyonLCBjYWxsYmFjaylgLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbnRleHR9IGN0eFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gdW5oYW5kbGVkKGN0eCkge1xuICAgIGlmIChjdHguaGFuZGxlZCkgcmV0dXJuO1xuICAgIHZhciBjdXJyZW50O1xuXG4gICAgaWYgKGhhc2hiYW5nKSB7XG4gICAgICBjdXJyZW50ID0gYmFzZSArIGxvY2F0aW9uLmhhc2gucmVwbGFjZSgnIyEnLCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudCA9IGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50ID09PSBjdHguY2Fub25pY2FsUGF0aCkgcmV0dXJuO1xuICAgIHBhZ2Uuc3RvcCgpO1xuICAgIGN0eC5oYW5kbGVkID0gZmFsc2U7XG4gICAgbG9jYXRpb24uaHJlZiA9IGN0eC5jYW5vbmljYWxQYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV4aXQgcm91dGUgb24gYHBhdGhgIHdpdGhcbiAgICogY2FsbGJhY2sgYGZuKClgLCB3aGljaCB3aWxsIGJlIGNhbGxlZFxuICAgKiBvbiB0aGUgcHJldmlvdXMgY29udGV4dCB3aGVuIGEgbmV3XG4gICAqIHBhZ2UgaXMgdmlzaXRlZC5cbiAgICovXG4gIHBhZ2UuZXhpdCA9IGZ1bmN0aW9uKHBhdGgsIGZuKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBwYWdlLmV4aXQoJyonLCBwYXRoKTtcbiAgICB9O1xuXG4gICAgdmFyIHJvdXRlID0gbmV3IFJvdXRlKHBhdGgpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBwYWdlLmV4aXRzLnB1c2gocm91dGUubWlkZGxld2FyZShhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICogUmVtb3ZlIFVSTCBlbmNvZGluZyBmcm9tIHRoZSBnaXZlbiBgc3RyYC5cbiAgKiBBY2NvbW1vZGF0ZXMgd2hpdGVzcGFjZSBpbiBib3RoIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICAqIGFuZCByZWd1bGFyIHBlcmNlbnQtZW5jb2RlZCBmb3JtLlxuICAqXG4gICogQHBhcmFtIHtzdHJ9IFVSTCBjb21wb25lbnQgdG8gZGVjb2RlXG4gICovXG4gIGZ1bmN0aW9uIGRlY29kZVVSTEVuY29kZWRVUklDb21wb25lbnQoc3RyKSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBuZXcgXCJyZXF1ZXN0XCIgYENvbnRleHRgXG4gICAqIHdpdGggdGhlIGdpdmVuIGBwYXRoYCBhbmQgb3B0aW9uYWwgaW5pdGlhbCBgc3RhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gQ29udGV4dChwYXRoLCBzdGF0ZSkge1xuICAgIHBhdGggPSBkZWNvZGVVUkxFbmNvZGVkVVJJQ29tcG9uZW50KHBhdGgpO1xuICAgIGlmICgnLycgPT09IHBhdGhbMF0gJiYgMCAhPT0gcGF0aC5pbmRleE9mKGJhc2UpKSBwYXRoID0gYmFzZSArIHBhdGg7XG4gICAgdmFyIGkgPSBwYXRoLmluZGV4T2YoJz8nKTtcblxuICAgIHRoaXMuY2Fub25pY2FsUGF0aCA9IHBhdGg7XG4gICAgdGhpcy5wYXRoID0gcGF0aC5yZXBsYWNlKGJhc2UsICcnKSB8fCAnLyc7XG5cbiAgICB0aGlzLnRpdGxlID0gZG9jdW1lbnQudGl0bGU7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlIHx8IHt9O1xuICAgIHRoaXMuc3RhdGUucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5xdWVyeXN0cmluZyA9IH5pXG4gICAgICA/IHBhdGguc2xpY2UoaSArIDEpXG4gICAgICA6ICcnO1xuICAgIHRoaXMucGF0aG5hbWUgPSB+aVxuICAgICAgPyBwYXRoLnNsaWNlKDAsIGkpXG4gICAgICA6IHBhdGg7XG4gICAgdGhpcy5wYXJhbXMgPSBbXTtcblxuICAgIC8vIGZyYWdtZW50XG4gICAgdGhpcy5oYXNoID0gJyc7XG4gICAgaWYgKCF+dGhpcy5wYXRoLmluZGV4T2YoJyMnKSkgcmV0dXJuO1xuICAgIHZhciBwYXJ0cyA9IHRoaXMucGF0aC5zcGxpdCgnIycpO1xuICAgIHRoaXMucGF0aCA9IHBhcnRzWzBdO1xuICAgIHRoaXMuaGFzaCA9IHBhcnRzWzFdIHx8ICcnO1xuICAgIHRoaXMucXVlcnlzdHJpbmcgPSB0aGlzLnF1ZXJ5c3RyaW5nLnNwbGl0KCcjJylbMF07XG4gIH1cblxuICAvKipcbiAgICogRXhwb3NlIGBDb250ZXh0YC5cbiAgICovXG5cbiAgcGFnZS5Db250ZXh0ID0gQ29udGV4dDtcblxuICAvKipcbiAgICogUHVzaCBzdGF0ZS5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIENvbnRleHQucHJvdG90eXBlLnB1c2hTdGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgaGlzdG9yeS5wdXNoU3RhdGUodGhpcy5zdGF0ZVxuICAgICAgLCB0aGlzLnRpdGxlXG4gICAgICAsIGhhc2hiYW5nICYmIHRoaXMucGF0aCAhPT0gJy8nXG4gICAgICAgID8gJyMhJyArIHRoaXMucGF0aFxuICAgICAgICA6IHRoaXMuY2Fub25pY2FsUGF0aCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNhdmUgdGhlIGNvbnRleHQgc3RhdGUuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIENvbnRleHQucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbigpe1xuICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHRoaXMuc3RhdGVcbiAgICAgICwgdGhpcy50aXRsZVxuICAgICAgLCBoYXNoYmFuZyAmJiB0aGlzLnBhdGggIT09ICcvJ1xuICAgICAgICA/ICcjIScgKyB0aGlzLnBhdGhcbiAgICAgICAgOiB0aGlzLmNhbm9uaWNhbFBhdGgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGBSb3V0ZWAgd2l0aCB0aGUgZ2l2ZW4gSFRUUCBgcGF0aGAsXG4gICAqIGFuZCBhbiBhcnJheSBvZiBgY2FsbGJhY2tzYCBhbmQgYG9wdGlvbnNgLlxuICAgKlxuICAgKiBPcHRpb25zOlxuICAgKlxuICAgKiAgIC0gYHNlbnNpdGl2ZWAgICAgZW5hYmxlIGNhc2Utc2Vuc2l0aXZlIHJvdXRlc1xuICAgKiAgIC0gYHN0cmljdGAgICAgICAgZW5hYmxlIHN0cmljdCBtYXRjaGluZyBmb3IgdHJhaWxpbmcgc2xhc2hlc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFJvdXRlKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnBhdGggPSAocGF0aCA9PT0gJyonKSA/ICcoLiopJyA6IHBhdGg7XG4gICAgdGhpcy5tZXRob2QgPSAnR0VUJztcbiAgICB0aGlzLnJlZ2V4cCA9IHBhdGh0b1JlZ2V4cCh0aGlzLnBhdGgsXG4gICAgICB0aGlzLmtleXMgPSBbXSxcbiAgICAgIG9wdGlvbnMuc2Vuc2l0aXZlLFxuICAgICAgb3B0aW9ucy5zdHJpY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9zZSBgUm91dGVgLlxuICAgKi9cblxuICBwYWdlLlJvdXRlID0gUm91dGU7XG5cbiAgLyoqXG4gICAqIFJldHVybiByb3V0ZSBtaWRkbGV3YXJlIHdpdGhcbiAgICogdGhlIGdpdmVuIGNhbGxiYWNrIGBmbigpYC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIFJvdXRlLnByb3RvdHlwZS5taWRkbGV3YXJlID0gZnVuY3Rpb24oZm4pe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24oY3R4LCBuZXh0KXtcbiAgICAgIGlmIChzZWxmLm1hdGNoKGN0eC5wYXRoLCBjdHgucGFyYW1zKSkgcmV0dXJuIGZuKGN0eCwgbmV4dCk7XG4gICAgICBuZXh0KCk7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyByb3V0ZSBtYXRjaGVzIGBwYXRoYCwgaWYgc29cbiAgICogcG9wdWxhdGUgYHBhcmFtc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtc1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgUm91dGUucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24ocGF0aCwgcGFyYW1zKXtcbiAgICB2YXIga2V5cyA9IHRoaXMua2V5cyxcbiAgICAgICAgcXNJbmRleCA9IHBhdGguaW5kZXhPZignPycpLFxuICAgICAgICBwYXRobmFtZSA9IH5xc0luZGV4XG4gICAgICAgICAgPyBwYXRoLnNsaWNlKDAsIHFzSW5kZXgpXG4gICAgICAgICAgOiBwYXRoLFxuICAgICAgICBtID0gdGhpcy5yZWdleHAuZXhlYyhkZWNvZGVVUklDb21wb25lbnQocGF0aG5hbWUpKTtcblxuICAgIGlmICghbSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IG0ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2kgLSAxXTtcblxuICAgICAgdmFyIHZhbCA9ICdzdHJpbmcnID09PSB0eXBlb2YgbVtpXVxuICAgICAgICA/IGRlY29kZVVSSUNvbXBvbmVudChtW2ldKVxuICAgICAgICA6IG1baV07XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IHVuZGVmaW5lZCAhPT0gcGFyYW1zW2tleS5uYW1lXVxuICAgICAgICAgID8gcGFyYW1zW2tleS5uYW1lXVxuICAgICAgICAgIDogdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zLnB1c2godmFsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIFwicG9wdWxhdGVcIiBldmVudHMuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9ucG9wc3RhdGUoZSkge1xuICAgIGlmIChlLnN0YXRlKSB7XG4gICAgICB2YXIgcGF0aCA9IGUuc3RhdGUucGF0aDtcbiAgICAgIHBhZ2UucmVwbGFjZShwYXRoLCBlLnN0YXRlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIFwiY2xpY2tcIiBldmVudHMuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uY2xpY2soZSkge1xuICAgIGlmICgxICE9IHdoaWNoKGUpKSByZXR1cm47XG4gICAgaWYgKGUubWV0YUtleSB8fCBlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSkgcmV0dXJuO1xuICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgIC8vIGVuc3VyZSBsaW5rXG4gICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgd2hpbGUgKGVsICYmICdBJyAhPSBlbC5ub2RlTmFtZSkgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgIGlmICghZWwgfHwgJ0EnICE9IGVsLm5vZGVOYW1lKSByZXR1cm47XG5cbiAgICAvLyBJZ25vcmUgaWYgdGFnIGhhcyBhIFwiZG93bmxvYWRcIiBhdHRyaWJ1dGVcbiAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKFwiZG93bmxvYWRcIikpIHJldHVybjtcblxuICAgIC8vIGVuc3VyZSBub24taGFzaCBmb3IgdGhlIHNhbWUgcGF0aFxuICAgIHZhciBsaW5rID0gZWwuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgaWYgKGVsLnBhdGhuYW1lID09PSBsb2NhdGlvbi5wYXRobmFtZSAmJiAoZWwuaGFzaCB8fCAnIycgPT09IGxpbmspKSByZXR1cm47XG5cbiAgICAvLyBDaGVjayBmb3IgbWFpbHRvOiBpbiB0aGUgaHJlZlxuICAgIGlmIChsaW5rICYmIGxpbmsuaW5kZXhPZihcIm1haWx0bzpcIikgPiAtMSkgcmV0dXJuO1xuXG4gICAgLy8gY2hlY2sgdGFyZ2V0XG4gICAgaWYgKGVsLnRhcmdldCkgcmV0dXJuO1xuXG4gICAgLy8geC1vcmlnaW5cbiAgICBpZiAoIXNhbWVPcmlnaW4oZWwuaHJlZikpIHJldHVybjtcblxuICAgIC8vIHJlYnVpbGQgcGF0aFxuICAgIHZhciBwYXRoID0gZWwucGF0aG5hbWUgKyBlbC5zZWFyY2ggKyAoZWwuaGFzaCB8fCAnJyk7XG5cbiAgICAvLyBzYW1lIHBhZ2VcbiAgICB2YXIgb3JpZyA9IHBhdGg7XG5cbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKGJhc2UsICcnKTtcblxuICAgIGlmIChiYXNlICYmIG9yaWcgPT09IHBhdGgpIHJldHVybjtcblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBwYWdlLnNob3cob3JpZyk7XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgYnV0dG9uLlxuICAgKi9cblxuICBmdW5jdGlvbiB3aGljaChlKSB7XG4gICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuICAgIHJldHVybiBudWxsID09PSBlLndoaWNoXG4gICAgICA/IGUuYnV0dG9uXG4gICAgICA6IGUud2hpY2g7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYGhyZWZgIGlzIHRoZSBzYW1lIG9yaWdpbi5cbiAgICovXG5cbiAgZnVuY3Rpb24gc2FtZU9yaWdpbihocmVmKSB7XG4gICAgdmFyIG9yaWdpbiA9IGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIGlmIChsb2NhdGlvbi5wb3J0KSBvcmlnaW4gKz0gJzonICsgbG9jYXRpb24ucG9ydDtcbiAgICByZXR1cm4gKGhyZWYgJiYgKDAgPT09IGhyZWYuaW5kZXhPZihvcmlnaW4pKSk7XG4gIH1cblxuICBwYWdlLnNhbWVPcmlnaW4gPSBzYW1lT3JpZ2luO1xuXG59LHtcInBhdGgtdG8tcmVnZXhwXCI6Mn1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBFeHBvc2UgYHBhdGh0b1JlZ2V4cGAuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcGF0aHRvUmVnZXhwO1xuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGFscmVhZHkgZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGluY29ycmVjdGx5IGFwcGVhclxuICAvLyBpbiBmdXR1cmUgbWF0Y2hlcy4gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0XG4gIC8vIHNob3VsZG4ndCBiZSB0cmFuc2Zvcm1lZC5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIl1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkXVxuICAnKFtcXFxcLy5dKT8oPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteKV0pKilcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXildKSopXFxcXCkpKFsrKj9dKT8nLFxuICAvLyBNYXRjaCByZWdleHAgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIGFsd2F5cyBiZSBlc2NhcGVkLlxuICAnKFsuKyo/PV4hOiR7fSgpW1xcXFxdfFxcXFwvXSknXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBncm91cFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpO1xufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7UmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbnZhciBhdHRhY2hLZXlzID0gZnVuY3Rpb24gKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzO1xuXG4gIHJldHVybiByZTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IHNob3VsZCBiZSBwYXNzZWQgaW4sIHdoaWNoIHdpbGwgY29udGFpbiB0aGUgcGxhY2Vob2xkZXIga2V5XG4gKiBuYW1lcy4gRm9yIGV4YW1wbGUgYC91c2VyLzppZGAgd2lsbCB0aGVuIGNvbnRhaW4gYFtcImlkXCJdYC5cbiAqXG4gKiBAcGFyYW0gIHsoU3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICAgICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGh0b1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAoa2V5cyAmJiAhQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSBrZXlzO1xuICAgIGtleXMgPSBudWxsO1xuICB9XG5cbiAga2V5cyA9IGtleXMgfHwgW107XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZTtcbiAgdmFyIGZsYWdzID0gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJztcbiAgdmFyIGluZGV4ID0gMDtcblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIE1hdGNoIGFsbCBjYXB0dXJpbmcgZ3JvdXBzIG9mIGEgcmVnZXhwLlxuICAgIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKSB8fCBbXTtcblxuICAgIC8vIE1hcCBhbGwgdGhlIG1hdGNoZXMgdG8gdGhlaXIgbnVtZXJpYyBrZXlzIGFuZCBwdXNoIGludG8gdGhlIGtleXMuXG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIGdyb3Vwcy5tYXAoZnVuY3Rpb24gKG1hdGNoLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogICAgICBpbmRleCxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogIGZhbHNlLFxuICAgICAgICByZXBlYXQ6ICAgIGZhbHNlXG4gICAgICB9O1xuICAgIH0pKTtcblxuICAgIC8vIFJldHVybiB0aGUgc291cmNlIGJhY2sgdG8gdGhlIHVzZXIuXG4gICAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cyk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIC8vIE1hcCBhcnJheSBwYXJ0cyBpbnRvIHJlZ2V4cHMgYW5kIHJldHVybiB0aGVpciBzb3VyY2UuIFdlIGFsc28gcGFzc1xuICAgIC8vIHRoZSBzYW1lIGtleXMgYW5kIG9wdGlvbnMgaW5zdGFuY2UgaW50byBldmVyeSBnZW5lcmF0aW9uIHRvIGdldFxuICAgIC8vIGNvbnNpc3RlbnQgbWF0Y2hpbmcgZ3JvdXBzIGJlZm9yZSB3ZSBqb2luIHRoZSBzb3VyY2VzIHRvZ2V0aGVyLlxuICAgIHBhdGggPSBwYXRoLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBwYXRodG9SZWdleHAodmFsdWUsIGtleXMsIG9wdGlvbnMpLnNvdXJjZTtcbiAgICB9KTtcblxuICAgIC8vIEdlbmVyYXRlIGEgbmV3IHJlZ2V4cCBpbnN0YW5jZSBieSBqb2luaW5nIGFsbCB0aGUgcGFydHMgdG9nZXRoZXIuXG4gICAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnKD86JyArIHBhdGguam9pbignfCcpICsgJyknLCBmbGFncyksIGtleXMpO1xuICB9XG5cbiAgLy8gQWx0ZXIgdGhlIHBhdGggc3RyaW5nIGludG8gYSB1c2FibGUgcmVnZXhwLlxuICBwYXRoID0gcGF0aC5yZXBsYWNlKFBBVEhfUkVHRVhQLCBmdW5jdGlvbiAobWF0Y2gsIGVzY2FwZWQsIHByZWZpeCwga2V5LCBjYXB0dXJlLCBncm91cCwgc3VmZml4LCBlc2NhcGUpIHtcbiAgICAvLyBBdm9pZGluZyByZS1lc2NhcGluZyBlc2NhcGVkIGNoYXJhY3RlcnMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHJldHVybiBlc2NhcGVkO1xuICAgIH1cblxuICAgIC8vIEVzY2FwZSByZWdleHAgc3BlY2lhbCBjaGFyYWN0ZXJzLlxuICAgIGlmIChlc2NhcGUpIHtcbiAgICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGU7XG4gICAgfVxuXG4gICAgdmFyIHJlcGVhdCAgID0gc3VmZml4ID09PSAnKycgfHwgc3VmZml4ID09PSAnKic7XG4gICAgdmFyIG9wdGlvbmFsID0gc3VmZml4ID09PSAnPycgfHwgc3VmZml4ID09PSAnKic7XG5cbiAgICBrZXlzLnB1c2goe1xuICAgICAgbmFtZTogICAgICBrZXkgfHwgaW5kZXgrKyxcbiAgICAgIGRlbGltaXRlcjogcHJlZml4IHx8ICcvJyxcbiAgICAgIG9wdGlvbmFsOiAgb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6ICAgIHJlcGVhdFxuICAgIH0pO1xuXG4gICAgLy8gRXNjYXBlIHRoZSBwcmVmaXggY2hhcmFjdGVyLlxuICAgIHByZWZpeCA9IHByZWZpeCA/ICdcXFxcJyArIHByZWZpeCA6ICcnO1xuXG4gICAgLy8gTWF0Y2ggdXNpbmcgdGhlIGN1c3RvbSBjYXB0dXJpbmcgZ3JvdXAsIG9yIGZhbGxiYWNrIHRvIGNhcHR1cmluZ1xuICAgIC8vIGV2ZXJ5dGhpbmcgdXAgdG8gdGhlIG5leHQgc2xhc2ggKG9yIG5leHQgcGVyaW9kIGlmIHRoZSBwYXJhbSB3YXNcbiAgICAvLyBwcmVmaXhlZCB3aXRoIGEgcGVyaW9kKS5cbiAgICBjYXB0dXJlID0gZXNjYXBlR3JvdXAoY2FwdHVyZSB8fCBncm91cCB8fCAnW14nICsgKHByZWZpeCB8fCAnXFxcXC8nKSArICddKz8nKTtcblxuICAgIC8vIEFsbG93IHBhcmFtZXRlcnMgdG8gYmUgcmVwZWF0ZWQgbW9yZSB0aGFuIG9uY2UuXG4gICAgaWYgKHJlcGVhdCkge1xuICAgICAgY2FwdHVyZSA9IGNhcHR1cmUgKyAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonO1xuICAgIH1cblxuICAgIC8vIEFsbG93IGEgcGFyYW1ldGVyIHRvIGJlIG9wdGlvbmFsLlxuICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgcmV0dXJuICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nO1xuICAgIH1cblxuICAgIC8vIEJhc2ljIHBhcmFtZXRlciBzdXBwb3J0LlxuICAgIHJldHVybiBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknO1xuICB9KTtcblxuICAvLyBDaGVjayB3aGV0aGVyIHRoZSBwYXRoIGVuZHMgaW4gYSBzbGFzaCBhcyBpdCBhbHRlcnMgc29tZSBtYXRjaCBiZWhhdmlvdXIuXG4gIHZhciBlbmRzV2l0aFNsYXNoID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnLyc7XG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGFuIG9wdGlvbmFsIHRyYWlsaW5nIHNsYXNoIGluIHRoZSBtYXRjaC4gSWZcbiAgLy8gdGhlIHBhdGggdG8gbWF0Y2ggYWxyZWFkeSBlbmRlZCB3aXRoIGEgc2xhc2gsIHdlIG5lZWQgdG8gcmVtb3ZlIGl0IGZvclxuICAvLyBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoIGlzIG9ubHkgdmFsaWQgYXQgdGhlIHZlcnkgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90XG4gIC8vIGFueXdoZXJlIGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50IGZvciBub24tZW5kaW5nIG1vZGUsIG90aGVyd2lzZVxuICAvLyBcIi90ZXN0L1wiIHdpbGwgbWF0Y2ggXCIvdGVzdC8vcm91dGVcIi5cbiAgaWYgKCFzdHJpY3QpIHtcbiAgICBwYXRoID0gKGVuZHNXaXRoU2xhc2ggPyBwYXRoLnNsaWNlKDAsIC0yKSA6IHBhdGgpICsgJyg/OlxcXFwvKD89JCkpPyc7XG4gIH1cblxuICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgcHJvbXB0IHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2hcbiAgLy8gYXMgcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgZm9yIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gIGlmICghZW5kKSB7XG4gICAgcGF0aCArPSBzdHJpY3QgJiYgZW5kc1dpdGhTbGFzaCA/ICcnIDogJyg/PVxcXFwvfCQpJztcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcGF0aCArIChlbmQgPyAnJCcgOiAnJyksIGZsYWdzKSwga2V5cyk7XG59O1xuXG59LHt9XX0se30sWzFdKSgxKVxufSk7IiwiLyohXG4gKiBQbGF0Zm9ybS5qcyB2MS4zLjAgPGh0dHA6Ly9tdGhzLmJlL3BsYXRmb3JtPlxuICogQ29weXJpZ2h0IDIwMTAtMjAxNCBKb2huLURhdmlkIERhbHRvbiA8aHR0cDovL2FsbHlvdWNhbmxlZXQuY29tLz5cbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cDovL210aHMuYmUvbWl0PlxuICovXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgYE9iamVjdGAgKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWVcbiAgfTtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCAqL1xuICB2YXIgcm9vdCA9IChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpIHx8IHRoaXM7XG5cbiAgLyoqIEJhY2t1cCBwb3NzaWJsZSBnbG9iYWwgb2JqZWN0ICovXG4gIHZhciBvbGRSb290ID0gcm9vdDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYCAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlIGFuZCB1c2UgaXQgYXMgYHJvb3RgICovXG4gIHZhciBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGFzIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhbiBhcnJheS1saWtlIG9iamVjdC5cbiAgICogU2VlIHRoZSBbRVM2IHNwZWNdKGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoKVxuICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgdmFyIG1heFNhZmVJbnRlZ2VyID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuICAvKiogT3BlcmEgcmVnZXhwICovXG4gIHZhciByZU9wZXJhID0gL1xcYk9wZXJhLztcblxuICAvKiogUG9zc2libGUgZ2xvYmFsIG9iamVjdCAqL1xuICB2YXIgdGhpc0JpbmRpbmcgPSB0aGlzO1xuXG4gIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgKi9cbiAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAvKiogVXNlZCB0byBjaGVjayBmb3Igb3duIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0ICovXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGludGVybmFsIGBbW0NsYXNzXV1gIG9mIHZhbHVlcyAqL1xuICB2YXIgdG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ2FwaXRhbGl6ZXMgYSBzdHJpbmcgdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSBTdHJpbmcoc3RyaW5nKTtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0byBjbGVhbiB1cCB0aGUgT1MgbmFtZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9zIFRoZSBPUyBuYW1lIHRvIGNsZWFuIHVwLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhdHRlcm5dIEEgYFJlZ0V4cGAgcGF0dGVybiBtYXRjaGluZyB0aGUgT1MgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYWJlbF0gQSBsYWJlbCBmb3IgdGhlIE9TLlxuICAgKi9cbiAgZnVuY3Rpb24gY2xlYW51cE9TKG9zLCBwYXR0ZXJuLCBsYWJlbCkge1xuICAgIC8vIHBsYXRmb3JtIHRva2VucyBkZWZpbmVkIGF0XG4gICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM3NTAzKFZTLjg1KS5hc3B4XG4gICAgLy8gaHR0cDovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAwODExMjIwNTM5NTAvaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM3NTAzKFZTLjg1KS5hc3B4XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAnNi40JzogICcxMCcsXG4gICAgICAnNi4zJzogICc4LjEnLFxuICAgICAgJzYuMic6ICAnOCcsXG4gICAgICAnNi4xJzogICdTZXJ2ZXIgMjAwOCBSMiAvIDcnLFxuICAgICAgJzYuMCc6ICAnU2VydmVyIDIwMDggLyBWaXN0YScsXG4gICAgICAnNS4yJzogICdTZXJ2ZXIgMjAwMyAvIFhQIDY0LWJpdCcsXG4gICAgICAnNS4xJzogICdYUCcsXG4gICAgICAnNS4wMSc6ICcyMDAwIFNQMScsXG4gICAgICAnNS4wJzogICcyMDAwJyxcbiAgICAgICc0LjAnOiAgJ05UJyxcbiAgICAgICc0LjkwJzogJ01FJ1xuICAgIH07XG4gICAgLy8gZGV0ZWN0IFdpbmRvd3MgdmVyc2lvbiBmcm9tIHBsYXRmb3JtIHRva2Vuc1xuICAgIGlmIChwYXR0ZXJuICYmIGxhYmVsICYmIC9eV2luL2kudGVzdChvcykgJiZcbiAgICAgICAgKGRhdGEgPSBkYXRhWzAvKk9wZXJhIDkuMjUgZml4Ki8sIC9bXFxkLl0rJC8uZXhlYyhvcyldKSkge1xuICAgICAgb3MgPSAnV2luZG93cyAnICsgZGF0YTtcbiAgICB9XG4gICAgLy8gY29ycmVjdCBjaGFyYWN0ZXIgY2FzZSBhbmQgY2xlYW51cFxuICAgIG9zID0gU3RyaW5nKG9zKTtcblxuICAgIGlmIChwYXR0ZXJuICYmIGxhYmVsKSB7XG4gICAgICBvcyA9IG9zLnJlcGxhY2UoUmVnRXhwKHBhdHRlcm4sICdpJyksIGxhYmVsKTtcbiAgICB9XG5cbiAgICBvcyA9IGZvcm1hdChcbiAgICAgIG9zLnJlcGxhY2UoLyBjZSQvaSwgJyBDRScpXG4gICAgICAgIC5yZXBsYWNlKC9cXGJocHcvaSwgJ3dlYicpXG4gICAgICAgIC5yZXBsYWNlKC9cXGJNYWNpbnRvc2hcXGIvLCAnTWFjIE9TJylcbiAgICAgICAgLnJlcGxhY2UoL19Qb3dlclBDXFxiL2ksICcgT1MnKVxuICAgICAgICAucmVwbGFjZSgvXFxiKE9TIFgpIFteIFxcZF0rL2ksICckMScpXG4gICAgICAgIC5yZXBsYWNlKC9cXGJNYWMgKE9TIFgpXFxiLywgJyQxJylcbiAgICAgICAgLnJlcGxhY2UoL1xcLyhcXGQpLywgJyAkMScpXG4gICAgICAgIC5yZXBsYWNlKC9fL2csICcuJylcbiAgICAgICAgLnJlcGxhY2UoLyg/OiBCZVBDfFsgLl0qZmNbIFxcZC5dKykkL2ksICcnKVxuICAgICAgICAucmVwbGFjZSgvXFxieDg2XFwuNjRcXGIvZ2ksICd4ODZfNjQnKVxuICAgICAgICAucmVwbGFjZSgvXFxiKFdpbmRvd3MgUGhvbmUpIE9TXFxiLywgJyQxJylcbiAgICAgICAgLnNwbGl0KCcgb24gJylbMF1cbiAgICApO1xuXG4gICAgcmV0dXJuIG9zO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGl0ZXJhdGlvbiB1dGlsaXR5IGZvciBhcnJheXMgYW5kIG9iamVjdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGVhY2gob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBvYmplY3QgPyBvYmplY3QubGVuZ3RoIDogMDtcblxuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGxlbmd0aCA+IC0xICYmIGxlbmd0aCA8PSBtYXhTYWZlSW50ZWdlcikge1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2sob2JqZWN0W2luZGV4XSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvck93bihvYmplY3QsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJpbSBhbmQgY29uZGl0aW9uYWxseSBjYXBpdGFsaXplIHN0cmluZyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBmb3JtYXQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gZm9ybWF0KHN0cmluZykge1xuICAgIHN0cmluZyA9IHRyaW0oc3RyaW5nKTtcbiAgICByZXR1cm4gL14oPzp3ZWJPU3xpKD86T1N8UCkpLy50ZXN0KHN0cmluZylcbiAgICAgID8gc3RyaW5nXG4gICAgICA6IGNhcGl0YWxpemUoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLCBleGVjdXRpbmcgdGhlIGBjYWxsYmFja2AgZm9yIGVhY2guXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBleGVjdXRlZCBwZXIgb3duIHByb3BlcnR5LlxuICAgKi9cbiAgZnVuY3Rpb24gZm9yT3duKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW50ZXJuYWwgYFtbQ2xhc3NdXWAgb2YgYSB2YWx1ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBgW1tDbGFzc11dYC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldENsYXNzT2YodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbFxuICAgICAgPyBjYXBpdGFsaXplKHZhbHVlKVxuICAgICAgOiB0b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSk7XG4gIH1cblxuICAvKipcbiAgICogSG9zdCBvYmplY3RzIGNhbiByZXR1cm4gdHlwZSB2YWx1ZXMgdGhhdCBhcmUgZGlmZmVyZW50IGZyb20gdGhlaXIgYWN0dWFsXG4gICAqIGRhdGEgdHlwZS4gVGhlIG9iamVjdHMgd2UgYXJlIGNvbmNlcm5lZCB3aXRoIHVzdWFsbHkgcmV0dXJuIG5vbi1wcmltaXRpdmVcbiAgICogdHlwZXMgb2YgXCJvYmplY3RcIiwgXCJmdW5jdGlvblwiLCBvciBcInVua25vd25cIi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG93bmVyIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyBhIG5vbi1wcmltaXRpdmUsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzSG9zdFR5cGUob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHZhciB0eXBlID0gb2JqZWN0ICE9IG51bGwgPyB0eXBlb2Ygb2JqZWN0W3Byb3BlcnR5XSA6ICdudW1iZXInO1xuICAgIHJldHVybiAhL14oPzpib29sZWFufG51bWJlcnxzdHJpbmd8dW5kZWZpbmVkKSQvLnRlc3QodHlwZSkgJiZcbiAgICAgICh0eXBlID09ICdvYmplY3QnID8gISFvYmplY3RbcHJvcGVydHldIDogdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZXMgYSBzdHJpbmcgZm9yIHVzZSBpbiBhIGBSZWdFeHBgIGJ5IG1ha2luZyBoeXBoZW5zIGFuZCBzcGFjZXMgb3B0aW9uYWwuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBxdWFsaWZ5LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcXVhbGlmaWVkIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHF1YWxpZnkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UoLyhbIC1dKSg/ISQpL2csICckMT8nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGJhcmUtYm9uZXMgYEFycmF5I3JlZHVjZWAgbGlrZSB1dGlsaXR5IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHsqfSBUaGUgYWNjdW11bGF0ZWQgcmVzdWx0LlxuICAgKi9cbiAgZnVuY3Rpb24gcmVkdWNlKGFycmF5LCBjYWxsYmFjaykge1xuICAgIHZhciBhY2N1bXVsYXRvciA9IG51bGw7XG4gICAgZWFjaChhcnJheSwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGFycmF5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIGZyb20gYSBzdHJpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0cmltLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHJpbW1lZCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiB0cmltKHN0cmluZykge1xuICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC9eICt8ICskL2csICcnKTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHBsYXRmb3JtIG9iamVjdC5cbiAgICpcbiAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW3VhPW5hdmlnYXRvci51c2VyQWdlbnRdIFRoZSB1c2VyIGFnZW50IHN0cmluZyBvclxuICAgKiAgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEgcGxhdGZvcm0gb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2UodWEpIHtcblxuICAgIC8qKiBUaGUgZW52aXJvbm1lbnQgY29udGV4dCBvYmplY3QgKi9cbiAgICB2YXIgY29udGV4dCA9IHJvb3Q7XG5cbiAgICAvKiogVXNlZCB0byBmbGFnIHdoZW4gYSBjdXN0b20gY29udGV4dCBpcyBwcm92aWRlZCAqL1xuICAgIHZhciBpc0N1c3RvbUNvbnRleHQgPSB1YSAmJiB0eXBlb2YgdWEgPT0gJ29iamVjdCcgJiYgZ2V0Q2xhc3NPZih1YSkgIT0gJ1N0cmluZyc7XG5cbiAgICAvLyBqdWdnbGUgYXJndW1lbnRzXG4gICAgaWYgKGlzQ3VzdG9tQ29udGV4dCkge1xuICAgICAgY29udGV4dCA9IHVhO1xuICAgICAgdWEgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKiBCcm93c2VyIG5hdmlnYXRvciBvYmplY3QgKi9cbiAgICB2YXIgbmF2ID0gY29udGV4dC5uYXZpZ2F0b3IgfHwge307XG5cbiAgICAvKiogQnJvd3NlciB1c2VyIGFnZW50IHN0cmluZyAqL1xuICAgIHZhciB1c2VyQWdlbnQgPSBuYXYudXNlckFnZW50IHx8ICcnO1xuXG4gICAgdWEgfHwgKHVhID0gdXNlckFnZW50KTtcblxuICAgIC8qKiBVc2VkIHRvIGZsYWcgd2hlbiBgdGhpc0JpbmRpbmdgIGlzIHRoZSBbTW9kdWxlU2NvcGVdICovXG4gICAgdmFyIGlzTW9kdWxlU2NvcGUgPSBpc0N1c3RvbUNvbnRleHQgfHwgdGhpc0JpbmRpbmcgPT0gb2xkUm9vdDtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBicm93c2VyIGlzIGxpa2UgQ2hyb21lICovXG4gICAgdmFyIGxpa2VDaHJvbWUgPSBpc0N1c3RvbUNvbnRleHRcbiAgICAgID8gISFuYXYubGlrZUNocm9tZVxuICAgICAgOiAvXFxiQ2hyb21lXFxiLy50ZXN0KHVhKSAmJiAhL2ludGVybmFsfFxcbi9pLnRlc3QodG9TdHJpbmcudG9TdHJpbmcoKSk7XG5cbiAgICAvKiogSW50ZXJuYWwgYFtbQ2xhc3NdXWAgdmFsdWUgc2hvcnRjdXRzICovXG4gICAgdmFyIG9iamVjdENsYXNzID0gJ09iamVjdCcsXG4gICAgICAgIGFpclJ1bnRpbWVDbGFzcyA9IGlzQ3VzdG9tQ29udGV4dCA/IG9iamVjdENsYXNzIDogJ1NjcmlwdEJyaWRnaW5nUHJveHlPYmplY3QnLFxuICAgICAgICBlbnZpcm9DbGFzcyA9IGlzQ3VzdG9tQ29udGV4dCA/IG9iamVjdENsYXNzIDogJ0Vudmlyb25tZW50JyxcbiAgICAgICAgamF2YUNsYXNzID0gKGlzQ3VzdG9tQ29udGV4dCAmJiBjb250ZXh0LmphdmEpID8gJ0phdmFQYWNrYWdlJyA6IGdldENsYXNzT2YoY29udGV4dC5qYXZhKSxcbiAgICAgICAgcGhhbnRvbUNsYXNzID0gaXNDdXN0b21Db250ZXh0ID8gb2JqZWN0Q2xhc3MgOiAnUnVudGltZU9iamVjdCc7XG5cbiAgICAvKiogRGV0ZWN0IEphdmEgZW52aXJvbm1lbnQgKi9cbiAgICB2YXIgamF2YSA9IC9cXGJKYXZhLy50ZXN0KGphdmFDbGFzcykgJiYgY29udGV4dC5qYXZhO1xuXG4gICAgLyoqIERldGVjdCBSaGlubyAqL1xuICAgIHZhciByaGlubyA9IGphdmEgJiYgZ2V0Q2xhc3NPZihjb250ZXh0LmVudmlyb25tZW50KSA9PSBlbnZpcm9DbGFzcztcblxuICAgIC8qKiBBIGNoYXJhY3RlciB0byByZXByZXNlbnQgYWxwaGEgKi9cbiAgICB2YXIgYWxwaGEgPSBqYXZhID8gJ2EnIDogJ1xcdTAzYjEnO1xuXG4gICAgLyoqIEEgY2hhcmFjdGVyIHRvIHJlcHJlc2VudCBiZXRhICovXG4gICAgdmFyIGJldGEgPSBqYXZhID8gJ2InIDogJ1xcdTAzYjInO1xuXG4gICAgLyoqIEJyb3dzZXIgZG9jdW1lbnQgb2JqZWN0ICovXG4gICAgdmFyIGRvYyA9IGNvbnRleHQuZG9jdW1lbnQgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgT3BlcmEgYnJvd3NlciAoUHJlc3RvLWJhc2VkKVxuICAgICAqIGh0dHA6Ly93d3cuaG93dG9jcmVhdGUuY28udWsvb3BlcmFTdHVmZi9vcGVyYU9iamVjdC5odG1sXG4gICAgICogaHR0cDovL2Rldi5vcGVyYS5jb20vYXJ0aWNsZXMvdmlldy9vcGVyYS1taW5pLXdlYi1jb250ZW50LWF1dGhvcmluZy1ndWlkZWxpbmVzLyNvcGVyYW1pbmlcbiAgICAgKi9cbiAgICB2YXIgb3BlcmEgPSBjb250ZXh0Lm9wZXJhbWluaSB8fCBjb250ZXh0Lm9wZXJhO1xuXG4gICAgLyoqIE9wZXJhIGBbW0NsYXNzXV1gICovXG4gICAgdmFyIG9wZXJhQ2xhc3MgPSByZU9wZXJhLnRlc3Qob3BlcmFDbGFzcyA9IChpc0N1c3RvbUNvbnRleHQgJiYgb3BlcmEpID8gb3BlcmFbJ1tbQ2xhc3NdXSddIDogZ2V0Q2xhc3NPZihvcGVyYSkpXG4gICAgICA/IG9wZXJhQ2xhc3NcbiAgICAgIDogKG9wZXJhID0gbnVsbCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKiogVGVtcG9yYXJ5IHZhcmlhYmxlIHVzZWQgb3ZlciB0aGUgc2NyaXB0J3MgbGlmZXRpbWUgKi9cbiAgICB2YXIgZGF0YTtcblxuICAgIC8qKiBUaGUgQ1BVIGFyY2hpdGVjdHVyZSAqL1xuICAgIHZhciBhcmNoID0gdWE7XG5cbiAgICAvKiogUGxhdGZvcm0gZGVzY3JpcHRpb24gYXJyYXkgKi9cbiAgICB2YXIgZGVzY3JpcHRpb24gPSBbXTtcblxuICAgIC8qKiBQbGF0Zm9ybSBhbHBoYS9iZXRhIGluZGljYXRvciAqL1xuICAgIHZhciBwcmVyZWxlYXNlID0gbnVsbDtcblxuICAgIC8qKiBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCBlbnZpcm9ubWVudCBmZWF0dXJlcyBzaG91bGQgYmUgdXNlZCB0byByZXNvbHZlIHRoZSBwbGF0Zm9ybSAqL1xuICAgIHZhciB1c2VGZWF0dXJlcyA9IHVhID09IHVzZXJBZ2VudDtcblxuICAgIC8qKiBUaGUgYnJvd3Nlci9lbnZpcm9ubWVudCB2ZXJzaW9uICovXG4gICAgdmFyIHZlcnNpb24gPSB1c2VGZWF0dXJlcyAmJiBvcGVyYSAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PSAnZnVuY3Rpb24nICYmIG9wZXJhLnZlcnNpb24oKTtcblxuICAgIC8qKiBBIGZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIE9TIGVuZHMgd2l0aCBcIi8gVmVyc2lvblwiICovXG4gICAgdmFyIGlzU3BlY2lhbENhc2VkT1M7XG5cbiAgICAvKiBEZXRlY3RhYmxlIGxheW91dCBlbmdpbmVzIChvcmRlciBpcyBpbXBvcnRhbnQpICovXG4gICAgdmFyIGxheW91dCA9IGdldExheW91dChbXG4gICAgICAnVHJpZGVudCcsXG4gICAgICB7ICdsYWJlbCc6ICdXZWJLaXQnLCAncGF0dGVybic6ICdBcHBsZVdlYktpdCcgfSxcbiAgICAgICdpQ2FiJyxcbiAgICAgICdQcmVzdG8nLFxuICAgICAgJ05ldEZyb250JyxcbiAgICAgICdUYXNtYW4nLFxuICAgICAgJ0tIVE1MJyxcbiAgICAgICdHZWNrbydcbiAgICBdKTtcblxuICAgIC8qIERldGVjdGFibGUgYnJvd3NlciBuYW1lcyAob3JkZXIgaXMgaW1wb3J0YW50KSAqL1xuICAgIHZhciBuYW1lID0gZ2V0TmFtZShbXG4gICAgICAnQWRvYmUgQUlSJyxcbiAgICAgICdBcm9yYScsXG4gICAgICAnQXZhbnQgQnJvd3NlcicsXG4gICAgICAnQnJlYWNoJyxcbiAgICAgICdDYW1pbm8nLFxuICAgICAgJ0VwaXBoYW55JyxcbiAgICAgICdGZW5uZWMnLFxuICAgICAgJ0Zsb2NrJyxcbiAgICAgICdHYWxlb24nLFxuICAgICAgJ0dyZWVuQnJvd3NlcicsXG4gICAgICAnaUNhYicsXG4gICAgICAnSWNld2Vhc2VsJyxcbiAgICAgIHsgJ2xhYmVsJzogJ1NSV2FyZSBJcm9uJywgJ3BhdHRlcm4nOiAnSXJvbicgfSxcbiAgICAgICdLLU1lbGVvbicsXG4gICAgICAnS29ucXVlcm9yJyxcbiAgICAgICdMdW5hc2NhcGUnLFxuICAgICAgJ01heHRob24nLFxuICAgICAgJ01pZG9yaScsXG4gICAgICAnTm9vayBCcm93c2VyJyxcbiAgICAgICdQaGFudG9tSlMnLFxuICAgICAgJ1JhdmVuJyxcbiAgICAgICdSZWtvbnEnLFxuICAgICAgJ1JvY2tNZWx0JyxcbiAgICAgICdTZWFNb25rZXknLFxuICAgICAgeyAnbGFiZWwnOiAnU2lsaycsICdwYXR0ZXJuJzogJyg/OkNsb3VkOXxTaWxrLUFjY2VsZXJhdGVkKScgfSxcbiAgICAgICdTbGVpcG5pcicsXG4gICAgICAnU2xpbUJyb3dzZXInLFxuICAgICAgJ1N1bnJpc2UnLFxuICAgICAgJ1N3aWZ0Zm94JyxcbiAgICAgICdXZWJQb3NpdGl2ZScsXG4gICAgICAnT3BlcmEgTWluaScsXG4gICAgICB7ICdsYWJlbCc6ICdPcGVyYSBNaW5pJywgJ3BhdHRlcm4nOiAnT1BpT1MnIH0sXG4gICAgICAnT3BlcmEnLFxuICAgICAgeyAnbGFiZWwnOiAnT3BlcmEnLCAncGF0dGVybic6ICdPUFInIH0sXG4gICAgICAnQ2hyb21lJyxcbiAgICAgIHsgJ2xhYmVsJzogJ0Nocm9tZSBNb2JpbGUnLCAncGF0dGVybic6ICcoPzpDcmlPU3xDck1vKScgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0ZpcmVmb3gnLCAncGF0dGVybic6ICcoPzpGaXJlZm94fE1pbmVmaWVsZCknIH0sXG4gICAgICB7ICdsYWJlbCc6ICdJRScsICdwYXR0ZXJuJzogJ0lFTW9iaWxlJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnSUUnLCAncGF0dGVybic6ICdNU0lFJyB9LFxuICAgICAgJ1NhZmFyaSdcbiAgICBdKTtcblxuICAgIC8qIERldGVjdGFibGUgcHJvZHVjdHMgKG9yZGVyIGlzIGltcG9ydGFudCkgKi9cbiAgICB2YXIgcHJvZHVjdCA9IGdldFByb2R1Y3QoW1xuICAgICAgeyAnbGFiZWwnOiAnQmxhY2tCZXJyeScsICdwYXR0ZXJuJzogJ0JCMTAnIH0sXG4gICAgICAnQmxhY2tCZXJyeScsXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUycsICdwYXR0ZXJuJzogJ0dULUk5MDAwJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnR2FsYXh5IFMyJywgJ3BhdHRlcm4nOiAnR1QtSTkxMDAnIH0sXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUzMnLCAncGF0dGVybic6ICdHVC1JOTMwMCcgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTNCcsICdwYXR0ZXJuJzogJ0dULUk5NTAwJyB9LFxuICAgICAgJ0dvb2dsZSBUVicsXG4gICAgICAnTHVtaWEnLFxuICAgICAgJ2lQYWQnLFxuICAgICAgJ2lQb2QnLFxuICAgICAgJ2lQaG9uZScsXG4gICAgICAnS2luZGxlJyxcbiAgICAgIHsgJ2xhYmVsJzogJ0tpbmRsZSBGaXJlJywgJ3BhdHRlcm4nOiAnKD86Q2xvdWQ5fFNpbGstQWNjZWxlcmF0ZWQpJyB9LFxuICAgICAgJ05vb2snLFxuICAgICAgJ1BsYXlCb29rJyxcbiAgICAgICdQbGF5U3RhdGlvbiA0JyxcbiAgICAgICdQbGF5U3RhdGlvbiAzJyxcbiAgICAgICdQbGF5U3RhdGlvbiBWaXRhJyxcbiAgICAgICdUb3VjaFBhZCcsXG4gICAgICAnVHJhbnNmb3JtZXInLFxuICAgICAgeyAnbGFiZWwnOiAnV2lpIFUnLCAncGF0dGVybic6ICdXaWlVJyB9LFxuICAgICAgJ1dpaScsXG4gICAgICAnWGJveCBPbmUnLFxuICAgICAgeyAnbGFiZWwnOiAnWGJveCAzNjAnLCAncGF0dGVybic6ICdYYm94JyB9LFxuICAgICAgJ1hvb20nXG4gICAgXSk7XG5cbiAgICAvKiBEZXRlY3RhYmxlIG1hbnVmYWN0dXJlcnMgKi9cbiAgICB2YXIgbWFudWZhY3R1cmVyID0gZ2V0TWFudWZhY3R1cmVyKHtcbiAgICAgICdBcHBsZSc6IHsgJ2lQYWQnOiAxLCAnaVBob25lJzogMSwgJ2lQb2QnOiAxIH0sXG4gICAgICAnQW1hem9uJzogeyAnS2luZGxlJzogMSwgJ0tpbmRsZSBGaXJlJzogMSB9LFxuICAgICAgJ0FzdXMnOiB7ICdUcmFuc2Zvcm1lcic6IDEgfSxcbiAgICAgICdCYXJuZXMgJiBOb2JsZSc6IHsgJ05vb2snOiAxIH0sXG4gICAgICAnQmxhY2tCZXJyeSc6IHsgJ1BsYXlCb29rJzogMSB9LFxuICAgICAgJ0dvb2dsZSc6IHsgJ0dvb2dsZSBUVic6IDEgfSxcbiAgICAgICdIUCc6IHsgJ1RvdWNoUGFkJzogMSB9LFxuICAgICAgJ0hUQyc6IHt9LFxuICAgICAgJ0xHJzoge30sXG4gICAgICAnTWljcm9zb2Z0JzogeyAnWGJveCc6IDEsICdYYm94IE9uZSc6IDEgfSxcbiAgICAgICdNb3Rvcm9sYSc6IHsgJ1hvb20nOiAxIH0sXG4gICAgICAnTmludGVuZG8nOiB7ICdXaWkgVSc6IDEsICAnV2lpJzogMSB9LFxuICAgICAgJ05va2lhJzogeyAnTHVtaWEnOiAxIH0sXG4gICAgICAnU2Ftc3VuZyc6IHsgJ0dhbGF4eSBTJzogMSwgJ0dhbGF4eSBTMic6IDEsICdHYWxheHkgUzMnOiAxLCAnR2FsYXh5IFM0JzogMSB9LFxuICAgICAgJ1NvbnknOiB7ICdQbGF5U3RhdGlvbiA0JzogMSwgJ1BsYXlTdGF0aW9uIDMnOiAxLCAnUGxheVN0YXRpb24gVml0YSc6IDEgfVxuICAgIH0pO1xuXG4gICAgLyogRGV0ZWN0YWJsZSBPU2VzIChvcmRlciBpcyBpbXBvcnRhbnQpICovXG4gICAgdmFyIG9zID0gZ2V0T1MoW1xuICAgICAgJ1dpbmRvd3MgUGhvbmUgJyxcbiAgICAgICdBbmRyb2lkJyxcbiAgICAgICdDZW50T1MnLFxuICAgICAgJ0RlYmlhbicsXG4gICAgICAnRmVkb3JhJyxcbiAgICAgICdGcmVlQlNEJyxcbiAgICAgICdHZW50b28nLFxuICAgICAgJ0hhaWt1JyxcbiAgICAgICdLdWJ1bnR1JyxcbiAgICAgICdMaW51eCBNaW50JyxcbiAgICAgICdSZWQgSGF0JyxcbiAgICAgICdTdVNFJyxcbiAgICAgICdVYnVudHUnLFxuICAgICAgJ1h1YnVudHUnLFxuICAgICAgJ0N5Z3dpbicsXG4gICAgICAnU3ltYmlhbiBPUycsXG4gICAgICAnaHB3T1MnLFxuICAgICAgJ3dlYk9TICcsXG4gICAgICAnd2ViT1MnLFxuICAgICAgJ1RhYmxldCBPUycsXG4gICAgICAnTGludXgnLFxuICAgICAgJ01hYyBPUyBYJyxcbiAgICAgICdNYWNpbnRvc2gnLFxuICAgICAgJ01hYycsXG4gICAgICAnV2luZG93cyA5ODsnLFxuICAgICAgJ1dpbmRvd3MgJ1xuICAgIF0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogUGlja3MgdGhlIGxheW91dCBlbmdpbmUgZnJvbSBhbiBhcnJheSBvZiBndWVzc2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBndWVzc2VzIEFuIGFycmF5IG9mIGd1ZXNzZXMuXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgbGF5b3V0IGVuZ2luZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRMYXlvdXQoZ3Vlc3Nlcykge1xuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgUmVnRXhwKCdcXFxcYicgKyAoXG4gICAgICAgICAgZ3Vlc3MucGF0dGVybiB8fCBxdWFsaWZ5KGd1ZXNzKVxuICAgICAgICApICsgJ1xcXFxiJywgJ2knKS5leGVjKHVhKSAmJiAoZ3Vlc3MubGFiZWwgfHwgZ3Vlc3MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGlja3MgdGhlIG1hbnVmYWN0dXJlciBmcm9tIGFuIGFycmF5IG9mIGd1ZXNzZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGd1ZXNzZXMgQW4gb2JqZWN0IG9mIGd1ZXNzZXMuXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgbWFudWZhY3R1cmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hbnVmYWN0dXJlcihndWVzc2VzKSB7XG4gICAgICByZXR1cm4gcmVkdWNlKGd1ZXNzZXMsIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgICAvLyBsb29rdXAgdGhlIG1hbnVmYWN0dXJlciBieSBwcm9kdWN0IG9yIHNjYW4gdGhlIFVBIGZvciB0aGUgbWFudWZhY3R1cmVyXG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgKFxuICAgICAgICAgIHZhbHVlW3Byb2R1Y3RdIHx8XG4gICAgICAgICAgdmFsdWVbMC8qT3BlcmEgOS4yNSBmaXgqLywgL15bYS16XSsoPzogK1thLXpdK1xcYikqL2kuZXhlYyhwcm9kdWN0KV0gfHxcbiAgICAgICAgICBSZWdFeHAoJ1xcXFxiJyArIHF1YWxpZnkoa2V5KSArICcoPzpcXFxcYnxcXFxcdypcXFxcZCknLCAnaScpLmV4ZWModWEpXG4gICAgICAgICkgJiYga2V5O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGlja3MgdGhlIGJyb3dzZXIgbmFtZSBmcm9tIGFuIGFycmF5IG9mIGd1ZXNzZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGd1ZXNzZXMgQW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cbiAgICAgKiBAcmV0dXJucyB7bnVsbHxzdHJpbmd9IFRoZSBkZXRlY3RlZCBicm93c2VyIG5hbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmFtZShndWVzc2VzKSB7XG4gICAgICByZXR1cm4gcmVkdWNlKGd1ZXNzZXMsIGZ1bmN0aW9uKHJlc3VsdCwgZ3Vlc3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBSZWdFeHAoJ1xcXFxiJyArIChcbiAgICAgICAgICBndWVzcy5wYXR0ZXJuIHx8IHF1YWxpZnkoZ3Vlc3MpXG4gICAgICAgICkgKyAnXFxcXGInLCAnaScpLmV4ZWModWEpICYmIChndWVzcy5sYWJlbCB8fCBndWVzcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQaWNrcyB0aGUgT1MgbmFtZSBmcm9tIGFuIGFycmF5IG9mIGd1ZXNzZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGd1ZXNzZXMgQW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cbiAgICAgKiBAcmV0dXJucyB7bnVsbHxzdHJpbmd9IFRoZSBkZXRlY3RlZCBPUyBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE9TKGd1ZXNzZXMpIHtcbiAgICAgIHJldHVybiByZWR1Y2UoZ3Vlc3NlcywgZnVuY3Rpb24ocmVzdWx0LCBndWVzcykge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGd1ZXNzLnBhdHRlcm4gfHwgcXVhbGlmeShndWVzcyk7XG4gICAgICAgIGlmICghcmVzdWx0ICYmIChyZXN1bHQgPVxuICAgICAgICAgICAgICBSZWdFeHAoJ1xcXFxiJyArIHBhdHRlcm4gKyAnKD86L1tcXFxcZC5dK3xbIFxcXFx3Ll0qKScsICdpJykuZXhlYyh1YSlcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBjbGVhbnVwT1MocmVzdWx0LCBwYXR0ZXJuLCBndWVzcy5sYWJlbCB8fCBndWVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBpY2tzIHRoZSBwcm9kdWN0IG5hbWUgZnJvbSBhbiBhcnJheSBvZiBndWVzc2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBndWVzc2VzIEFuIGFycmF5IG9mIGd1ZXNzZXMuXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgcHJvZHVjdCBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFByb2R1Y3QoZ3Vlc3Nlcykge1xuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gZ3Vlc3MucGF0dGVybiB8fCBxdWFsaWZ5KGd1ZXNzKTtcbiAgICAgICAgaWYgKCFyZXN1bHQgJiYgKHJlc3VsdCA9XG4gICAgICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcGF0dGVybiArICcgKlxcXFxkK1suXFxcXHdfXSonLCAnaScpLmV4ZWModWEpIHx8XG4gICAgICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcGF0dGVybiArICcoPzo7ICooPzpbYS16XStbXy1dKT9bYS16XStcXFxcZCt8W14gKCk7LV0qKScsICdpJykuZXhlYyh1YSlcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAvLyBzcGxpdCBieSBmb3J3YXJkIHNsYXNoIGFuZCBhcHBlbmQgcHJvZHVjdCB2ZXJzaW9uIGlmIG5lZWRlZFxuICAgICAgICAgIGlmICgocmVzdWx0ID0gU3RyaW5nKChndWVzcy5sYWJlbCAmJiAhUmVnRXhwKHBhdHRlcm4sICdpJykudGVzdChndWVzcy5sYWJlbCkpID8gZ3Vlc3MubGFiZWwgOiByZXN1bHQpLnNwbGl0KCcvJykpWzFdICYmICEvW1xcZC5dKy8udGVzdChyZXN1bHRbMF0pKSB7XG4gICAgICAgICAgICByZXN1bHRbMF0gKz0gJyAnICsgcmVzdWx0WzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb3JyZWN0IGNoYXJhY3RlciBjYXNlIGFuZCBjbGVhbnVwXG4gICAgICAgICAgZ3Vlc3MgPSBndWVzcy5sYWJlbCB8fCBndWVzcztcbiAgICAgICAgICByZXN1bHQgPSBmb3JtYXQocmVzdWx0WzBdXG4gICAgICAgICAgICAucmVwbGFjZShSZWdFeHAocGF0dGVybiwgJ2knKSwgZ3Vlc3MpXG4gICAgICAgICAgICAucmVwbGFjZShSZWdFeHAoJzsgKig/OicgKyBndWVzcyArICdbXy1dKT8nLCAnaScpLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZShSZWdFeHAoJygnICsgZ3Vlc3MgKyAnKVstXy5dPyhcXFxcdyknLCAnaScpLCAnJDEgJDInKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSB2ZXJzaW9uIHVzaW5nIGFuIGFycmF5IG9mIFVBIHBhdHRlcm5zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXR0ZXJucyBBbiBhcnJheSBvZiBVQSBwYXR0ZXJucy5cbiAgICAgKiBAcmV0dXJucyB7bnVsbHxzdHJpbmd9IFRoZSBkZXRlY3RlZCB2ZXJzaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFZlcnNpb24ocGF0dGVybnMpIHtcbiAgICAgIHJldHVybiByZWR1Y2UocGF0dGVybnMsIGZ1bmN0aW9uKHJlc3VsdCwgcGF0dGVybikge1xuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IChSZWdFeHAocGF0dGVybiArXG4gICAgICAgICAgJyg/Oi1bXFxcXGQuXSsvfCg/OiBmb3IgW1xcXFx3LV0rKT9bIC8tXSkoW1xcXFxkLl0rW14gKCk7L18tXSopJywgJ2knKS5leGVjKHVhKSB8fCAwKVsxXSB8fCBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgcGxhdGZvcm0uZGVzY3JpcHRpb25gIHdoZW4gdGhlIHBsYXRmb3JtIG9iamVjdCBpcyBjb2VyY2VkIHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQG5hbWUgdG9TdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIGBwbGF0Zm9ybS5kZXNjcmlwdGlvbmAgaWYgYXZhaWxhYmxlLCBlbHNlIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1N0cmluZ1BsYXRmb3JtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRpb24gfHwgJyc7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gY29udmVydCBsYXlvdXQgdG8gYW4gYXJyYXkgc28gd2UgY2FuIGFkZCBleHRyYSBkZXRhaWxzXG4gICAgbGF5b3V0ICYmIChsYXlvdXQgPSBbbGF5b3V0XSk7XG5cbiAgICAvLyBkZXRlY3QgcHJvZHVjdCBuYW1lcyB0aGF0IGNvbnRhaW4gdGhlaXIgbWFudWZhY3R1cmVyJ3MgbmFtZVxuICAgIGlmIChtYW51ZmFjdHVyZXIgJiYgIXByb2R1Y3QpIHtcbiAgICAgIHByb2R1Y3QgPSBnZXRQcm9kdWN0KFttYW51ZmFjdHVyZXJdKTtcbiAgICB9XG4gICAgLy8gY2xlYW4gdXAgR29vZ2xlIFRWXG4gICAgaWYgKChkYXRhID0gL1xcYkdvb2dsZSBUVlxcYi8uZXhlYyhwcm9kdWN0KSkpIHtcbiAgICAgIHByb2R1Y3QgPSBkYXRhWzBdO1xuICAgIH1cbiAgICAvLyBkZXRlY3Qgc2ltdWxhdG9yc1xuICAgIGlmICgvXFxiU2ltdWxhdG9yXFxiL2kudGVzdCh1YSkpIHtcbiAgICAgIHByb2R1Y3QgPSAocHJvZHVjdCA/IHByb2R1Y3QgKyAnICcgOiAnJykgKyAnU2ltdWxhdG9yJztcbiAgICB9XG4gICAgLy8gZGV0ZWN0IE9wZXJhIE1pbmkgOCsgcnVubmluZyBpbiBUdXJiby9VbmNvbXByZXNzZWQgbW9kZSBvbiBpT1NcbiAgICBpZiAobmFtZSA9PSAnT3BlcmEgTWluaScgJiYgL1xcYk9QaU9TXFxiLy50ZXN0KHVhKSkge1xuICAgICAgZGVzY3JpcHRpb24ucHVzaCgncnVubmluZyBpbiBUdXJiby9VbmNvbXByZXNzZWQgbW9kZScpO1xuICAgIH1cbiAgICAvLyBkZXRlY3QgaU9TXG4gICAgaWYgKC9eaVAvLnRlc3QocHJvZHVjdCkpIHtcbiAgICAgIG5hbWUgfHwgKG5hbWUgPSAnU2FmYXJpJyk7XG4gICAgICBvcyA9ICdpT1MnICsgKChkYXRhID0gLyBPUyAoW1xcZF9dKykvaS5leGVjKHVhKSlcbiAgICAgICAgPyAnICcgKyBkYXRhWzFdLnJlcGxhY2UoL18vZywgJy4nKVxuICAgICAgICA6ICcnKTtcbiAgICB9XG4gICAgLy8gZGV0ZWN0IEt1YnVudHVcbiAgICBlbHNlIGlmIChuYW1lID09ICdLb25xdWVyb3InICYmICEvYnVudHUvaS50ZXN0KG9zKSkge1xuICAgICAgb3MgPSAnS3VidW50dSc7XG4gICAgfVxuICAgIC8vIGRldGVjdCBBbmRyb2lkIGJyb3dzZXJzXG4gICAgZWxzZSBpZiAobWFudWZhY3R1cmVyICYmIG1hbnVmYWN0dXJlciAhPSAnR29vZ2xlJyAmJlxuICAgICAgICAoKC9DaHJvbWUvLnRlc3QobmFtZSkgJiYgIS9cXGJNb2JpbGUgU2FmYXJpXFxiL2kudGVzdCh1YSkpIHx8IC9cXGJWaXRhXFxiLy50ZXN0KHByb2R1Y3QpKSkge1xuICAgICAgbmFtZSA9ICdBbmRyb2lkIEJyb3dzZXInO1xuICAgICAgb3MgPSAvXFxiQW5kcm9pZFxcYi8udGVzdChvcykgPyBvcyA6ICdBbmRyb2lkJztcbiAgICB9XG4gICAgLy8gZGV0ZWN0IGZhbHNlIHBvc2l0aXZlcyBmb3IgRmlyZWZveC9TYWZhcmlcbiAgICBlbHNlIGlmICghbmFtZSB8fCAoZGF0YSA9ICEvXFxiTWluZWZpZWxkXFxifFxcKEFuZHJvaWQ7L2kudGVzdCh1YSkgJiYgL1xcYig/OkZpcmVmb3h8U2FmYXJpKVxcYi8uZXhlYyhuYW1lKSkpIHtcbiAgICAgIC8vIGVzY2FwZSB0aGUgYC9gIGZvciBGaXJlZm94IDFcbiAgICAgIGlmIChuYW1lICYmICFwcm9kdWN0ICYmIC9bXFwvLF18XlteKF0rP1xcKS8udGVzdCh1YS5zbGljZSh1YS5pbmRleE9mKGRhdGEgKyAnLycpICsgOCkpKSB7XG4gICAgICAgIC8vIGNsZWFyIG5hbWUgb2YgZmFsc2UgcG9zaXRpdmVzXG4gICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gcmVhc3NpZ24gYSBnZW5lcmljIG5hbWVcbiAgICAgIGlmICgoZGF0YSA9IHByb2R1Y3QgfHwgbWFudWZhY3R1cmVyIHx8IG9zKSAmJlxuICAgICAgICAgIChwcm9kdWN0IHx8IG1hbnVmYWN0dXJlciB8fCAvXFxiKD86QW5kcm9pZHxTeW1iaWFuIE9TfFRhYmxldCBPU3x3ZWJPUylcXGIvLnRlc3Qob3MpKSkge1xuICAgICAgICBuYW1lID0gL1thLXpdKyg/OiBIYXQpPy9pLmV4ZWMoL1xcYkFuZHJvaWRcXGIvLnRlc3Qob3MpID8gb3MgOiBkYXRhKSArICcgQnJvd3Nlcic7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGRldGVjdCBGaXJlZm94IE9TXG4gICAgaWYgKChkYXRhID0gL1xcKChNb2JpbGV8VGFibGV0KS4qP0ZpcmVmb3hcXGIvaS5leGVjKHVhKSkgJiYgZGF0YVsxXSkge1xuICAgICAgb3MgPSAnRmlyZWZveCBPUyc7XG4gICAgICBpZiAoIXByb2R1Y3QpIHtcbiAgICAgICAgcHJvZHVjdCA9IGRhdGFbMV07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGRldGVjdCBub24tT3BlcmEgdmVyc2lvbnMgKG9yZGVyIGlzIGltcG9ydGFudClcbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIHZlcnNpb24gPSBnZXRWZXJzaW9uKFtcbiAgICAgICAgJyg/OkNsb3VkOXxDcmlPU3xDck1vfElFTW9iaWxlfElyb258T3BlcmEgP01pbml8T1BpT1N8T1BSfFJhdmVufFNpbGsoPyEvW1xcXFxkLl0rJCkpJyxcbiAgICAgICAgJ1ZlcnNpb24nLFxuICAgICAgICBxdWFsaWZ5KG5hbWUpLFxuICAgICAgICAnKD86RmlyZWZveHxNaW5lZmllbGR8TmV0RnJvbnQpJ1xuICAgICAgXSk7XG4gICAgfVxuICAgIC8vIGRldGVjdCBzdHViYm9ybiBsYXlvdXQgZW5naW5lc1xuICAgIGlmIChsYXlvdXQgPT0gJ2lDYWInICYmIHBhcnNlRmxvYXQodmVyc2lvbikgPiAzKSB7XG4gICAgICBsYXlvdXQgPSBbJ1dlYktpdCddO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGxheW91dCAhPSAnVHJpZGVudCcgJiZcbiAgICAgICAgKGRhdGEgPVxuICAgICAgICAgIC9cXGJPcGVyYVxcYi8udGVzdChuYW1lKSAmJiAoL1xcYk9QUlxcYi8udGVzdCh1YSkgPyAnQmxpbmsnIDogJ1ByZXN0bycpIHx8XG4gICAgICAgICAgL1xcYig/Ok1pZG9yaXxOb29rfFNhZmFyaSlcXGIvaS50ZXN0KHVhKSAmJiAnV2ViS2l0JyB8fFxuICAgICAgICAgICFsYXlvdXQgJiYgL1xcYk1TSUVcXGIvaS50ZXN0KHVhKSAmJiAob3MgPT0gJ01hYyBPUycgPyAnVGFzbWFuJyA6ICdUcmlkZW50JylcbiAgICAgICAgKVxuICAgICkge1xuICAgICAgbGF5b3V0ID0gW2RhdGFdO1xuICAgIH1cbiAgICAvLyBkZXRlY3QgTmV0RnJvbnQgb24gUGxheVN0YXRpb25cbiAgICBlbHNlIGlmICgvXFxiUGxheVN0YXRpb25cXGIoPyEgVml0YVxcYikvaS50ZXN0KG5hbWUpICYmIGxheW91dCA9PSAnV2ViS2l0Jykge1xuICAgICAgbGF5b3V0ID0gWydOZXRGcm9udCddO1xuICAgIH1cbiAgICAvLyBkZXRlY3QgV2luZG93cyBQaG9uZSA3IGRlc2t0b3AgbW9kZVxuICAgIGlmIChuYW1lID09ICdJRScgJiYgKGRhdGEgPSAoLzsgKig/OlhCTFdQfFp1bmVXUCkoXFxkKykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcbiAgICAgIG5hbWUgKz0gJyBNb2JpbGUnO1xuICAgICAgb3MgPSAnV2luZG93cyBQaG9uZSAnICsgKC9cXCskLy50ZXN0KGRhdGEpID8gZGF0YSA6IGRhdGEgKyAnLngnKTtcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ2Rlc2t0b3AgbW9kZScpO1xuICAgIH1cbiAgICAvLyBkZXRlY3QgV2luZG93cyBQaG9uZSA4KyBkZXNrdG9wIG1vZGVcbiAgICBlbHNlIGlmICgvXFxiV1BEZXNrdG9wXFxiL2kudGVzdCh1YSkpIHtcbiAgICAgIG5hbWUgPSAnSUUgTW9iaWxlJztcbiAgICAgIG9zID0gJ1dpbmRvd3MgUGhvbmUgOCsnO1xuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XG4gICAgICB2ZXJzaW9uIHx8ICh2ZXJzaW9uID0gKC9cXGJydjooW1xcZC5dKykvLmV4ZWModWEpIHx8IDApWzFdKTtcbiAgICB9XG4gICAgLy8gZGV0ZWN0IElFIDExIGFuZCBhYm92ZVxuICAgIGVsc2UgaWYgKG5hbWUgIT0gJ0lFJyAmJiBsYXlvdXQgPT0gJ1RyaWRlbnQnICYmIChkYXRhID0gL1xcYnJ2OihbXFxkLl0rKS8uZXhlYyh1YSkpKSB7XG4gICAgICBpZiAoIS9cXGJXUERlc2t0b3BcXGIvaS50ZXN0KHVhKSkge1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgIGRlc2NyaXB0aW9uLnB1c2goJ2lkZW50aWZ5aW5nIGFzICcgKyBuYW1lICsgKHZlcnNpb24gPyAnICcgKyB2ZXJzaW9uIDogJycpKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gJ0lFJztcbiAgICAgIH1cbiAgICAgIHZlcnNpb24gPSBkYXRhWzFdO1xuICAgIH1cbiAgICAvLyBkZXRlY3QgSUUgVGVjaCBQcmV2aWV3XG4gICAgZWxzZSBpZiAoKG5hbWUgPT0gJ0Nocm9tZScgfHwgbmFtZSAhPSAnSUUnKSAmJiAoZGF0YSA9IC9cXGJFZGdlXFwvKFtcXGQuXSspLy5leGVjKHVhKSkpIHtcbiAgICAgIG5hbWUgPSAnSUUnO1xuICAgICAgdmVyc2lvbiA9IGRhdGFbMV07XG4gICAgICBsYXlvdXQgPSBbJ1RyaWRlbnQnXTtcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ3BsYXRmb3JtIHByZXZpZXcnKTtcbiAgICB9XG4gICAgLy8gbGV2ZXJhZ2UgZW52aXJvbm1lbnQgZmVhdHVyZXNcbiAgICBpZiAodXNlRmVhdHVyZXMpIHtcbiAgICAgIC8vIGRldGVjdCBzZXJ2ZXItc2lkZSBlbnZpcm9ubWVudHNcbiAgICAgIC8vIFJoaW5vIGhhcyBhIGdsb2JhbCBmdW5jdGlvbiB3aGlsZSBvdGhlcnMgaGF2ZSBhIGdsb2JhbCBvYmplY3RcbiAgICAgIGlmIChpc0hvc3RUeXBlKGNvbnRleHQsICdnbG9iYWwnKSkge1xuICAgICAgICBpZiAoamF2YSkge1xuICAgICAgICAgIGRhdGEgPSBqYXZhLmxhbmcuU3lzdGVtO1xuICAgICAgICAgIGFyY2ggPSBkYXRhLmdldFByb3BlcnR5KCdvcy5hcmNoJyk7XG4gICAgICAgICAgb3MgPSBvcyB8fCBkYXRhLmdldFByb3BlcnR5KCdvcy5uYW1lJykgKyAnICcgKyBkYXRhLmdldFByb3BlcnR5KCdvcy52ZXJzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTW9kdWxlU2NvcGUgJiYgaXNIb3N0VHlwZShjb250ZXh0LCAnc3lzdGVtJykgJiYgKGRhdGEgPSBbY29udGV4dC5zeXN0ZW1dKVswXSkge1xuICAgICAgICAgIG9zIHx8IChvcyA9IGRhdGFbMF0ub3MgfHwgbnVsbCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGFbMV0gPSBjb250ZXh0LnJlcXVpcmUoJ3JpbmdvL2VuZ2luZScpLnZlcnNpb247XG4gICAgICAgICAgICB2ZXJzaW9uID0gZGF0YVsxXS5qb2luKCcuJyk7XG4gICAgICAgICAgICBuYW1lID0gJ1JpbmdvSlMnO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0uZ2xvYmFsLnN5c3RlbSA9PSBjb250ZXh0LnN5c3RlbSkge1xuICAgICAgICAgICAgICBuYW1lID0gJ05hcndoYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29udGV4dC5wcm9jZXNzID09ICdvYmplY3QnICYmIChkYXRhID0gY29udGV4dC5wcm9jZXNzKSkge1xuICAgICAgICAgIG5hbWUgPSAnTm9kZS5qcyc7XG4gICAgICAgICAgYXJjaCA9IGRhdGEuYXJjaDtcbiAgICAgICAgICBvcyA9IGRhdGEucGxhdGZvcm07XG4gICAgICAgICAgdmVyc2lvbiA9IC9bXFxkLl0rLy5leGVjKGRhdGEudmVyc2lvbilbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmhpbm8pIHtcbiAgICAgICAgICBuYW1lID0gJ1JoaW5vJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZGV0ZWN0IEFkb2JlIEFJUlxuICAgICAgZWxzZSBpZiAoZ2V0Q2xhc3NPZigoZGF0YSA9IGNvbnRleHQucnVudGltZSkpID09IGFpclJ1bnRpbWVDbGFzcykge1xuICAgICAgICBuYW1lID0gJ0Fkb2JlIEFJUic7XG4gICAgICAgIG9zID0gZGF0YS5mbGFzaC5zeXN0ZW0uQ2FwYWJpbGl0aWVzLm9zO1xuICAgICAgfVxuICAgICAgLy8gZGV0ZWN0IFBoYW50b21KU1xuICAgICAgZWxzZSBpZiAoZ2V0Q2xhc3NPZigoZGF0YSA9IGNvbnRleHQucGhhbnRvbSkpID09IHBoYW50b21DbGFzcykge1xuICAgICAgICBuYW1lID0gJ1BoYW50b21KUyc7XG4gICAgICAgIHZlcnNpb24gPSAoZGF0YSA9IGRhdGEudmVyc2lvbiB8fCBudWxsKSAmJiAoZGF0YS5tYWpvciArICcuJyArIGRhdGEubWlub3IgKyAnLicgKyBkYXRhLnBhdGNoKTtcbiAgICAgIH1cbiAgICAgIC8vIGRldGVjdCBJRSBjb21wYXRpYmlsaXR5IG1vZGVzXG4gICAgICBlbHNlIGlmICh0eXBlb2YgZG9jLmRvY3VtZW50TW9kZSA9PSAnbnVtYmVyJyAmJiAoZGF0YSA9IC9cXGJUcmlkZW50XFwvKFxcZCspL2kuZXhlYyh1YSkpKSB7XG4gICAgICAgIC8vIHdlJ3JlIGluIGNvbXBhdGliaWxpdHkgbW9kZSB3aGVuIHRoZSBUcmlkZW50IHZlcnNpb24gKyA0IGRvZXNuJ3RcbiAgICAgICAgLy8gZXF1YWwgdGhlIGRvY3VtZW50IG1vZGVcbiAgICAgICAgdmVyc2lvbiA9IFt2ZXJzaW9uLCBkb2MuZG9jdW1lbnRNb2RlXTtcbiAgICAgICAgaWYgKChkYXRhID0gK2RhdGFbMV0gKyA0KSAhPSB2ZXJzaW9uWzFdKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb24ucHVzaCgnSUUgJyArIHZlcnNpb25bMV0gKyAnIG1vZGUnKTtcbiAgICAgICAgICBsYXlvdXQgJiYgKGxheW91dFsxXSA9ICcnKTtcbiAgICAgICAgICB2ZXJzaW9uWzFdID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB2ZXJzaW9uID0gbmFtZSA9PSAnSUUnID8gU3RyaW5nKHZlcnNpb25bMV0udG9GaXhlZCgxKSkgOiB2ZXJzaW9uWzBdO1xuICAgICAgfVxuICAgICAgb3MgPSBvcyAmJiBmb3JtYXQob3MpO1xuICAgIH1cbiAgICAvLyBkZXRlY3QgcHJlcmVsZWFzZSBwaGFzZXNcbiAgICBpZiAodmVyc2lvbiAmJiAoZGF0YSA9XG4gICAgICAgICAgLyg/OlthYl18ZHB8cHJlfFthYl1cXGQrcHJlKSg/OlxcZCtcXCs/KT8kL2kuZXhlYyh2ZXJzaW9uKSB8fFxuICAgICAgICAgIC8oPzphbHBoYXxiZXRhKSg/OiA/XFxkKT8vaS5leGVjKHVhICsgJzsnICsgKHVzZUZlYXR1cmVzICYmIG5hdi5hcHBNaW5vclZlcnNpb24pKSB8fFxuICAgICAgICAgIC9cXGJNaW5lZmllbGRcXGIvaS50ZXN0KHVhKSAmJiAnYSdcbiAgICAgICAgKSkge1xuICAgICAgcHJlcmVsZWFzZSA9IC9iL2kudGVzdChkYXRhKSA/ICdiZXRhJyA6ICdhbHBoYSc7XG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbi5yZXBsYWNlKFJlZ0V4cChkYXRhICsgJ1xcXFwrPyQnKSwgJycpICtcbiAgICAgICAgKHByZXJlbGVhc2UgPT0gJ2JldGEnID8gYmV0YSA6IGFscGhhKSArICgvXFxkK1xcKz8vLmV4ZWMoZGF0YSkgfHwgJycpO1xuICAgIH1cbiAgICAvLyBkZXRlY3QgRmlyZWZveCBNb2JpbGVcbiAgICBpZiAobmFtZSA9PSAnRmVubmVjJyB8fCBuYW1lID09ICdGaXJlZm94JyAmJiAvXFxiKD86QW5kcm9pZHxGaXJlZm94IE9TKVxcYi8udGVzdChvcykpIHtcbiAgICAgIG5hbWUgPSAnRmlyZWZveCBNb2JpbGUnO1xuICAgIH1cbiAgICAvLyBvYnNjdXJlIE1heHRob24ncyB1bnJlbGlhYmxlIHZlcnNpb25cbiAgICBlbHNlIGlmIChuYW1lID09ICdNYXh0aG9uJyAmJiB2ZXJzaW9uKSB7XG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbi5yZXBsYWNlKC9cXC5bXFxkLl0rLywgJy54Jyk7XG4gICAgfVxuICAgIC8vIGRldGVjdCBTaWxrIGRlc2t0b3AvYWNjZWxlcmF0ZWQgbW9kZXNcbiAgICBlbHNlIGlmIChuYW1lID09ICdTaWxrJykge1xuICAgICAgaWYgKCEvXFxiTW9iaS9pLnRlc3QodWEpKSB7XG4gICAgICAgIG9zID0gJ0FuZHJvaWQnO1xuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdkZXNrdG9wIG1vZGUnKTtcbiAgICAgIH1cbiAgICAgIGlmICgvQWNjZWxlcmF0ZWQgKj0gKnRydWUvaS50ZXN0KHVhKSkge1xuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdhY2NlbGVyYXRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBkZXRlY3QgWGJveCAzNjAgYW5kIFhib3ggT25lXG4gICAgZWxzZSBpZiAoL1xcYlhib3hcXGIvaS50ZXN0KHByb2R1Y3QpKSB7XG4gICAgICBvcyA9IG51bGw7XG4gICAgICBpZiAocHJvZHVjdCA9PSAnWGJveCAzNjAnICYmIC9cXGJJRU1vYmlsZVxcYi8udGVzdCh1YSkpIHtcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnbW9iaWxlIG1vZGUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIG1vYmlsZSBwb3N0Zml4XG4gICAgZWxzZSBpZiAoKC9eKD86Q2hyb21lfElFfE9wZXJhKSQvLnRlc3QobmFtZSkgfHwgbmFtZSAmJiAhcHJvZHVjdCAmJiAhL0Jyb3dzZXJ8TW9iaS8udGVzdChuYW1lKSkgJiZcbiAgICAgICAgKG9zID09ICdXaW5kb3dzIENFJyB8fCAvTW9iaS9pLnRlc3QodWEpKSkge1xuICAgICAgbmFtZSArPSAnIE1vYmlsZSc7XG4gICAgfVxuICAgIC8vIGRldGVjdCBJRSBwbGF0Zm9ybSBwcmV2aWV3XG4gICAgZWxzZSBpZiAobmFtZSA9PSAnSUUnICYmIHVzZUZlYXR1cmVzICYmIGNvbnRleHQuZXh0ZXJuYWwgPT09IG51bGwpIHtcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ3BsYXRmb3JtIHByZXZpZXcnKTtcbiAgICB9XG4gICAgLy8gZGV0ZWN0IEJsYWNrQmVycnkgT1MgdmVyc2lvblxuICAgIC8vIGh0dHA6Ly9kb2NzLmJsYWNrYmVycnkuY29tL2VuL2RldmVsb3BlcnMvZGVsaXZlcmFibGVzLzE4MTY5L0hUVFBfaGVhZGVyc19zZW50X2J5X0JCX0Jyb3dzZXJfMTIzNDkxMV8xMS5qc3BcbiAgICBlbHNlIGlmICgoL1xcYkJsYWNrQmVycnlcXGIvLnRlc3QocHJvZHVjdCkgfHwgL1xcYkJCMTBcXGIvLnRlc3QodWEpKSAmJiAoZGF0YSA9XG4gICAgICAgICAgKFJlZ0V4cChwcm9kdWN0LnJlcGxhY2UoLyArL2csICcgKicpICsgJy8oWy5cXFxcZF0rKScsICdpJykuZXhlYyh1YSkgfHwgMClbMV0gfHxcbiAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICkpIHtcbiAgICAgIGRhdGEgPSBbZGF0YSwgL0JCMTAvLnRlc3QodWEpXTtcbiAgICAgIG9zID0gKGRhdGFbMV0gPyAocHJvZHVjdCA9IG51bGwsIG1hbnVmYWN0dXJlciA9ICdCbGFja0JlcnJ5JykgOiAnRGV2aWNlIFNvZnR3YXJlJykgKyAnICcgKyBkYXRhWzBdO1xuICAgICAgdmVyc2lvbiA9IG51bGw7XG4gICAgfVxuICAgIC8vIGRldGVjdCBPcGVyYSBpZGVudGlmeWluZy9tYXNraW5nIGl0c2VsZiBhcyBhbm90aGVyIGJyb3dzZXJcbiAgICAvLyBodHRwOi8vd3d3Lm9wZXJhLmNvbS9zdXBwb3J0L2tiL3ZpZXcvODQzL1xuICAgIGVsc2UgaWYgKHRoaXMgIT0gZm9yT3duICYmIChcbiAgICAgICAgICBwcm9kdWN0ICE9ICdXaWknICYmIChcbiAgICAgICAgICAgICh1c2VGZWF0dXJlcyAmJiBvcGVyYSkgfHxcbiAgICAgICAgICAgICgvT3BlcmEvLnRlc3QobmFtZSkgJiYgL1xcYig/Ok1TSUV8RmlyZWZveClcXGIvaS50ZXN0KHVhKSkgfHxcbiAgICAgICAgICAgIChuYW1lID09ICdGaXJlZm94JyAmJiAvXFxiT1MgWCAoPzpcXGQrXFwuKXsyLH0vLnRlc3Qob3MpKSB8fFxuICAgICAgICAgICAgKG5hbWUgPT0gJ0lFJyAmJiAoXG4gICAgICAgICAgICAgIChvcyAmJiAhL15XaW4vLnRlc3Qob3MpICYmIHZlcnNpb24gPiA1LjUpIHx8XG4gICAgICAgICAgICAgIC9cXGJXaW5kb3dzIFhQXFxiLy50ZXN0KG9zKSAmJiB2ZXJzaW9uID4gOCB8fFxuICAgICAgICAgICAgICB2ZXJzaW9uID09IDggJiYgIS9cXGJUcmlkZW50XFxiLy50ZXN0KHVhKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgICApXG4gICAgICAgICkgJiYgIXJlT3BlcmEudGVzdCgoZGF0YSA9IHBhcnNlLmNhbGwoZm9yT3duLCB1YS5yZXBsYWNlKHJlT3BlcmEsICcnKSArICc7JykpKSAmJiBkYXRhLm5hbWUpIHtcblxuICAgICAgLy8gd2hlbiBcImluZGVudGlmeWluZ1wiLCB0aGUgVUEgY29udGFpbnMgYm90aCBPcGVyYSBhbmQgdGhlIG90aGVyIGJyb3dzZXIncyBuYW1lXG4gICAgICBkYXRhID0gJ2luZyBhcyAnICsgZGF0YS5uYW1lICsgKChkYXRhID0gZGF0YS52ZXJzaW9uKSA/ICcgJyArIGRhdGEgOiAnJyk7XG4gICAgICBpZiAocmVPcGVyYS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGlmICgvXFxiSUVcXGIvLnRlc3QoZGF0YSkgJiYgb3MgPT0gJ01hYyBPUycpIHtcbiAgICAgICAgICBvcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9ICdpZGVudGlmeScgKyBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gd2hlbiBcIm1hc2tpbmdcIiwgdGhlIFVBIGNvbnRhaW5zIG9ubHkgdGhlIG90aGVyIGJyb3dzZXIncyBuYW1lXG4gICAgICBlbHNlIHtcbiAgICAgICAgZGF0YSA9ICdtYXNrJyArIGRhdGE7XG4gICAgICAgIGlmIChvcGVyYUNsYXNzKSB7XG4gICAgICAgICAgbmFtZSA9IGZvcm1hdChvcGVyYUNsYXNzLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMSAkMicpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gJ09wZXJhJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoL1xcYklFXFxiLy50ZXN0KGRhdGEpKSB7XG4gICAgICAgICAgb3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXNlRmVhdHVyZXMpIHtcbiAgICAgICAgICB2ZXJzaW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGF5b3V0ID0gWydQcmVzdG8nXTtcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIC8vIGRldGVjdCBXZWJLaXQgTmlnaHRseSBhbmQgYXBwcm94aW1hdGUgQ2hyb21lL1NhZmFyaSB2ZXJzaW9uc1xuICAgIGlmICgoZGF0YSA9ICgvXFxiQXBwbGVXZWJLaXRcXC8oW1xcZC5dK1xcKz8pL2kuZXhlYyh1YSkgfHwgMClbMV0pKSB7XG4gICAgICAvLyBjb3JyZWN0IGJ1aWxkIGZvciBudW1lcmljIGNvbXBhcmlzb25cbiAgICAgIC8vIChlLmcuIFwiNTMyLjVcIiBiZWNvbWVzIFwiNTMyLjA1XCIpXG4gICAgICBkYXRhID0gW3BhcnNlRmxvYXQoZGF0YS5yZXBsYWNlKC9cXC4oXFxkKSQvLCAnLjAkMScpKSwgZGF0YV07XG4gICAgICAvLyBuaWdodGx5IGJ1aWxkcyBhcmUgcG9zdGZpeGVkIHdpdGggYSBgK2BcbiAgICAgIGlmIChuYW1lID09ICdTYWZhcmknICYmIGRhdGFbMV0uc2xpY2UoLTEpID09ICcrJykge1xuICAgICAgICBuYW1lID0gJ1dlYktpdCBOaWdodGx5JztcbiAgICAgICAgcHJlcmVsZWFzZSA9ICdhbHBoYSc7XG4gICAgICAgIHZlcnNpb24gPSBkYXRhWzFdLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICAgIC8vIGNsZWFyIGluY29ycmVjdCBicm93c2VyIHZlcnNpb25zXG4gICAgICBlbHNlIGlmICh2ZXJzaW9uID09IGRhdGFbMV0gfHxcbiAgICAgICAgICB2ZXJzaW9uID09IChkYXRhWzJdID0gKC9cXGJTYWZhcmlcXC8oW1xcZC5dK1xcKz8pL2kuZXhlYyh1YSkgfHwgMClbMV0pKSB7XG4gICAgICAgIHZlcnNpb24gPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gdXNlIHRoZSBmdWxsIENocm9tZSB2ZXJzaW9uIHdoZW4gYXZhaWxhYmxlXG4gICAgICBkYXRhWzFdID0gKC9cXGJDaHJvbWVcXC8oW1xcZC5dKykvaS5leGVjKHVhKSB8fCAwKVsxXTtcbiAgICAgIC8vIGRldGVjdCBCbGluayBsYXlvdXQgZW5naW5lXG4gICAgICBpZiAoZGF0YVswXSA9PSA1MzcuMzYgJiYgZGF0YVsyXSA9PSA1MzcuMzYgJiYgcGFyc2VGbG9hdChkYXRhWzFdKSA+PSAyOCAmJiBuYW1lICE9ICdJRScpIHtcbiAgICAgICAgbGF5b3V0ID0gWydCbGluayddO1xuICAgICAgfVxuICAgICAgLy8gZGV0ZWN0IEphdmFTY3JpcHRDb3JlXG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY3Njg0NzQvaG93LWNhbi1pLWRldGVjdC13aGljaC1qYXZhc2NyaXB0LWVuZ2luZS12OC1vci1qc2MtaXMtdXNlZC1hdC1ydW50aW1lLWluLWFuZHJvaVxuICAgICAgaWYgKCF1c2VGZWF0dXJlcyB8fCAoIWxpa2VDaHJvbWUgJiYgIWRhdGFbMV0pKSB7XG4gICAgICAgIGxheW91dCAmJiAobGF5b3V0WzFdID0gJ2xpa2UgU2FmYXJpJyk7XG4gICAgICAgIGRhdGEgPSAoZGF0YSA9IGRhdGFbMF0sIGRhdGEgPCA0MDAgPyAxIDogZGF0YSA8IDUwMCA/IDIgOiBkYXRhIDwgNTI2ID8gMyA6IGRhdGEgPCA1MzMgPyA0IDogZGF0YSA8IDUzNCA/ICc0KycgOiBkYXRhIDwgNTM1ID8gNSA6IGRhdGEgPCA1MzcgPyA2IDogZGF0YSA8IDUzOCA/IDcgOiBkYXRhIDwgNjAxID8gOCA6ICc4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXlvdXQgJiYgKGxheW91dFsxXSA9ICdsaWtlIENocm9tZScpO1xuICAgICAgICBkYXRhID0gZGF0YVsxXSB8fCAoZGF0YSA9IGRhdGFbMF0sIGRhdGEgPCA1MzAgPyAxIDogZGF0YSA8IDUzMiA/IDIgOiBkYXRhIDwgNTMyLjA1ID8gMyA6IGRhdGEgPCA1MzMgPyA0IDogZGF0YSA8IDUzNC4wMyA/IDUgOiBkYXRhIDwgNTM0LjA3ID8gNiA6IGRhdGEgPCA1MzQuMTAgPyA3IDogZGF0YSA8IDUzNC4xMyA/IDggOiBkYXRhIDwgNTM0LjE2ID8gOSA6IGRhdGEgPCA1MzQuMjQgPyAxMCA6IGRhdGEgPCA1MzQuMzAgPyAxMSA6IGRhdGEgPCA1MzUuMDEgPyAxMiA6IGRhdGEgPCA1MzUuMDIgPyAnMTMrJyA6IGRhdGEgPCA1MzUuMDcgPyAxNSA6IGRhdGEgPCA1MzUuMTEgPyAxNiA6IGRhdGEgPCA1MzUuMTkgPyAxNyA6IGRhdGEgPCA1MzYuMDUgPyAxOCA6IGRhdGEgPCA1MzYuMTAgPyAxOSA6IGRhdGEgPCA1MzcuMDEgPyAyMCA6IGRhdGEgPCA1MzcuMTEgPyAnMjErJyA6IGRhdGEgPCA1MzcuMTMgPyAyMyA6IGRhdGEgPCA1MzcuMTggPyAyNCA6IGRhdGEgPCA1MzcuMjQgPyAyNSA6IGRhdGEgPCA1MzcuMzYgPyAyNiA6IGxheW91dCAhPSAnQmxpbmsnID8gJzI3JyA6ICcyOCcpO1xuICAgICAgfVxuICAgICAgLy8gYWRkIHRoZSBwb3N0Zml4IG9mIFwiLnhcIiBvciBcIitcIiBmb3IgYXBwcm94aW1hdGUgdmVyc2lvbnNcbiAgICAgIGxheW91dCAmJiAobGF5b3V0WzFdICs9ICcgJyArIChkYXRhICs9IHR5cGVvZiBkYXRhID09ICdudW1iZXInID8gJy54JyA6IC9bLitdLy50ZXN0KGRhdGEpID8gJycgOiAnKycpKTtcbiAgICAgIC8vIG9ic2N1cmUgdmVyc2lvbiBmb3Igc29tZSBTYWZhcmkgMS0yIHJlbGVhc2VzXG4gICAgICBpZiAobmFtZSA9PSAnU2FmYXJpJyAmJiAoIXZlcnNpb24gfHwgcGFyc2VJbnQodmVyc2lvbikgPiA0NSkpIHtcbiAgICAgICAgdmVyc2lvbiA9IGRhdGE7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGRldGVjdCBPcGVyYSBkZXNrdG9wIG1vZGVzXG4gICAgaWYgKG5hbWUgPT0gJ09wZXJhJyAmJiAgKGRhdGEgPSAvXFxiemJvdnx6dmF2JC8uZXhlYyhvcykpKSB7XG4gICAgICBuYW1lICs9ICcgJztcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ2Rlc2t0b3AgbW9kZScpO1xuICAgICAgaWYgKGRhdGEgPT0gJ3p2YXYnKSB7XG4gICAgICAgIG5hbWUgKz0gJ01pbmknO1xuICAgICAgICB2ZXJzaW9uID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgKz0gJ01vYmlsZSc7XG4gICAgICB9XG4gICAgICBvcyA9IG9zLnJlcGxhY2UoUmVnRXhwKCcgKicgKyBkYXRhICsgJyQnKSwgJycpO1xuICAgIH1cbiAgICAvLyBkZXRlY3QgQ2hyb21lIGRlc2t0b3AgbW9kZVxuICAgIGVsc2UgaWYgKG5hbWUgPT0gJ1NhZmFyaScgJiYgL1xcYkNocm9tZVxcYi8uZXhlYyhsYXlvdXQgJiYgbGF5b3V0WzFdKSkge1xuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XG4gICAgICBuYW1lID0gJ0Nocm9tZSBNb2JpbGUnO1xuICAgICAgdmVyc2lvbiA9IG51bGw7XG5cbiAgICAgIGlmICgvXFxiT1MgWFxcYi8udGVzdChvcykpIHtcbiAgICAgICAgbWFudWZhY3R1cmVyID0gJ0FwcGxlJztcbiAgICAgICAgb3MgPSAnaU9TIDQuMysnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBzdHJpcCBpbmNvcnJlY3QgT1MgdmVyc2lvbnNcbiAgICBpZiAodmVyc2lvbiAmJiB2ZXJzaW9uLmluZGV4T2YoKGRhdGEgPSAvW1xcZC5dKyQvLmV4ZWMob3MpKSkgPT0gMCAmJlxuICAgICAgICB1YS5pbmRleE9mKCcvJyArIGRhdGEgKyAnLScpID4gLTEpIHtcbiAgICAgIG9zID0gdHJpbShvcy5yZXBsYWNlKGRhdGEsICcnKSk7XG4gICAgfVxuICAgIC8vIGFkZCBsYXlvdXQgZW5naW5lXG4gICAgaWYgKGxheW91dCAmJiAhL1xcYig/OkF2YW50fE5vb2spXFxiLy50ZXN0KG5hbWUpICYmIChcbiAgICAgICAgL0Jyb3dzZXJ8THVuYXNjYXBlfE1heHRob24vLnRlc3QobmFtZSkgfHxcbiAgICAgICAgL14oPzpBZG9iZXxBcm9yYXxCcmVhY2h8TWlkb3JpfE9wZXJhfFBoYW50b218UmVrb25xfFJvY2t8U2xlaXBuaXJ8V2ViKS8udGVzdChuYW1lKSAmJiBsYXlvdXRbMV0pKSB7XG4gICAgICAvLyBkb24ndCBhZGQgbGF5b3V0IGRldGFpbHMgdG8gZGVzY3JpcHRpb24gaWYgdGhleSBhcmUgZmFsc2V5XG4gICAgICAoZGF0YSA9IGxheW91dFtsYXlvdXQubGVuZ3RoIC0gMV0pICYmIGRlc2NyaXB0aW9uLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIC8vIGNvbWJpbmUgY29udGV4dHVhbCBpbmZvcm1hdGlvblxuICAgIGlmIChkZXNjcmlwdGlvbi5sZW5ndGgpIHtcbiAgICAgIGRlc2NyaXB0aW9uID0gWycoJyArIGRlc2NyaXB0aW9uLmpvaW4oJzsgJykgKyAnKSddO1xuICAgIH1cbiAgICAvLyBhcHBlbmQgbWFudWZhY3R1cmVyXG4gICAgaWYgKG1hbnVmYWN0dXJlciAmJiBwcm9kdWN0ICYmIHByb2R1Y3QuaW5kZXhPZihtYW51ZmFjdHVyZXIpIDwgMCkge1xuICAgICAgZGVzY3JpcHRpb24ucHVzaCgnb24gJyArIG1hbnVmYWN0dXJlcik7XG4gICAgfVxuICAgIC8vIGFwcGVuZCBwcm9kdWN0XG4gICAgaWYgKHByb2R1Y3QpIHtcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goKC9eb24gLy50ZXN0KGRlc2NyaXB0aW9uW2Rlc2NyaXB0aW9uLmxlbmd0aCAtMV0pID8gJycgOiAnb24gJykgKyBwcm9kdWN0KTtcbiAgICB9XG4gICAgLy8gcGFyc2UgT1MgaW50byBhbiBvYmplY3RcbiAgICBpZiAob3MpIHtcbiAgICAgIGRhdGEgPSAvIChbXFxkLitdKykkLy5leGVjKG9zKTtcbiAgICAgIGlzU3BlY2lhbENhc2VkT1MgPSBkYXRhICYmIG9zLmNoYXJBdChvcy5sZW5ndGggLSBkYXRhWzBdLmxlbmd0aCAtIDEpID09ICcvJztcbiAgICAgIG9zID0ge1xuICAgICAgICAnYXJjaGl0ZWN0dXJlJzogMzIsXG4gICAgICAgICdmYW1pbHknOiAoZGF0YSAmJiAhaXNTcGVjaWFsQ2FzZWRPUykgPyBvcy5yZXBsYWNlKGRhdGFbMF0sICcnKSA6IG9zLFxuICAgICAgICAndmVyc2lvbic6IGRhdGEgPyBkYXRhWzFdIDogbnVsbCxcbiAgICAgICAgJ3RvU3RyaW5nJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZlcnNpb24gPSB0aGlzLnZlcnNpb247XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmFtaWx5ICsgKCh2ZXJzaW9uICYmICFpc1NwZWNpYWxDYXNlZE9TKSA/ICcgJyArIHZlcnNpb24gOiAnJykgKyAodGhpcy5hcmNoaXRlY3R1cmUgPT0gNjQgPyAnIDY0LWJpdCcgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIC8vIGFkZCBicm93c2VyL09TIGFyY2hpdGVjdHVyZVxuICAgIGlmICgoZGF0YSA9IC9cXGIoPzpBTUR8SUF8V2lufFdPV3x4ODZffHgpNjRcXGIvaS5leGVjKGFyY2gpKSAmJiAhL1xcYmk2ODZcXGIvaS50ZXN0KGFyY2gpKSB7XG4gICAgICBpZiAob3MpIHtcbiAgICAgICAgb3MuYXJjaGl0ZWN0dXJlID0gNjQ7XG4gICAgICAgIG9zLmZhbWlseSA9IG9zLmZhbWlseS5yZXBsYWNlKFJlZ0V4cCgnIConICsgZGF0YSksICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgICBuYW1lICYmICgvXFxiV09XNjRcXGIvaS50ZXN0KHVhKSB8fFxuICAgICAgICAgICh1c2VGZWF0dXJlcyAmJiAvXFx3KD86ODZ8MzIpJC8udGVzdChuYXYuY3B1Q2xhc3MgfHwgbmF2LnBsYXRmb3JtKSAmJiAhL1xcYldpbjY0OyB4NjRcXGIvaS50ZXN0KHVhKSkpXG4gICAgICApIHtcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnMzItYml0Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdWEgfHwgKHVhID0gbnVsbCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGxhdGZvcm0gb2JqZWN0LlxuICAgICAqXG4gICAgICogQG5hbWUgcGxhdGZvcm1cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB2YXIgcGxhdGZvcm0gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwbGF0Zm9ybSBkZXNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXG4gICAgICovXG4gICAgcGxhdGZvcm0uZGVzY3JpcHRpb24gPSB1YTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBicm93c2VyJ3MgbGF5b3V0IGVuZ2luZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXG4gICAgICovXG4gICAgcGxhdGZvcm0ubGF5b3V0ID0gbGF5b3V0ICYmIGxheW91dFswXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9kdWN0J3MgbWFudWZhY3R1cmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS5tYW51ZmFjdHVyZXIgPSBtYW51ZmFjdHVyZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgYnJvd3Nlci9lbnZpcm9ubWVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXG4gICAgICovXG4gICAgcGxhdGZvcm0ubmFtZSA9IG5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYWxwaGEvYmV0YSByZWxlYXNlIGluZGljYXRvci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXG4gICAgICovXG4gICAgcGxhdGZvcm0ucHJlcmVsZWFzZSA9IHByZXJlbGVhc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJvZHVjdCBob3N0aW5nIHRoZSBicm93c2VyLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS5wcm9kdWN0ID0gcHJvZHVjdDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBicm93c2VyJ3MgdXNlciBhZ2VudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxuICAgICAqL1xuICAgIHBsYXRmb3JtLnVhID0gdWE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYnJvd3Nlci9lbnZpcm9ubWVudCB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS52ZXJzaW9uID0gbmFtZSAmJiB2ZXJzaW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIG9wZXJhdGluZyBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS5vcyA9IG9zIHx8IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgQ1BVIGFyY2hpdGVjdHVyZSB0aGUgT1MgaXMgYnVpbHQgZm9yLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybS5vc1xuICAgICAgICogQHR5cGUgbnVtYmVyfG51bGxcbiAgICAgICAqL1xuICAgICAgJ2FyY2hpdGVjdHVyZSc6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGZhbWlseSBvZiB0aGUgT1MuXG4gICAgICAgKlxuICAgICAgICogQ29tbW9uIHZhbHVlcyBpbmNsdWRlOlxuICAgICAgICogXCJXaW5kb3dzXCIsIFwiV2luZG93cyBTZXJ2ZXIgMjAwOCBSMiAvIDdcIiwgXCJXaW5kb3dzIFNlcnZlciAyMDA4IC8gVmlzdGFcIixcbiAgICAgICAqIFwiV2luZG93cyBYUFwiLCBcIk9TIFhcIiwgXCJVYnVudHVcIiwgXCJEZWJpYW5cIiwgXCJGZWRvcmFcIiwgXCJSZWQgSGF0XCIsIFwiU3VTRVwiLFxuICAgICAgICogXCJBbmRyb2lkXCIsIFwiaU9TXCIgYW5kIFwiV2luZG93cyBQaG9uZVwiXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIHBsYXRmb3JtLm9zXG4gICAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxuICAgICAgICovXG4gICAgICAnZmFtaWx5JzogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgT1MuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIHBsYXRmb3JtLm9zXG4gICAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxuICAgICAgICovXG4gICAgICAndmVyc2lvbic6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgT1Mgc3RyaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybS5vc1xuICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIE9TIHN0cmluZy5cbiAgICAgICAqL1xuICAgICAgJ3RvU3RyaW5nJzogZnVuY3Rpb24oKSB7IHJldHVybiAnbnVsbCc7IH1cbiAgICB9O1xuXG4gICAgcGxhdGZvcm0ucGFyc2UgPSBwYXJzZTtcbiAgICBwbGF0Zm9ybS50b1N0cmluZyA9IHRvU3RyaW5nUGxhdGZvcm07XG5cbiAgICBpZiAocGxhdGZvcm0udmVyc2lvbikge1xuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCh2ZXJzaW9uKTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtLm5hbWUpIHtcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQobmFtZSk7XG4gICAgfVxuICAgIGlmIChvcyAmJiBuYW1lICYmICEob3MgPT0gU3RyaW5nKG9zKS5zcGxpdCgnICcpWzBdICYmIChvcyA9PSBuYW1lLnNwbGl0KCcgJylbMF0gfHwgcHJvZHVjdCkpKSB7XG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKHByb2R1Y3QgPyAnKCcgKyBvcyArICcpJyA6ICdvbiAnICsgb3MpO1xuICAgIH1cbiAgICBpZiAoZGVzY3JpcHRpb24ubGVuZ3RoKSB7XG4gICAgICBwbGF0Zm9ybS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBsYXRmb3JtO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gZXhwb3J0IHBsYXRmb3JtXG4gIC8vIHNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIGRlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlIGFsaWFzZWRcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGFyc2UoKTtcbiAgICB9KTtcbiAgfVxuICAvLyBjaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0XG4gIGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcbiAgICAvLyBpbiBOYXJ3aGFsLCBOb2RlLmpzLCBSaGlubyAtcmVxdWlyZSwgb3IgUmluZ29KU1xuICAgIGZvck93bihwYXJzZSgpLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICBmcmVlRXhwb3J0c1trZXldID0gdmFsdWU7XG4gICAgfSk7XG4gIH1cbiAgLy8gaW4gYSBicm93c2VyIG9yIFJoaW5vXG4gIGVsc2Uge1xuICAgIHJvb3QucGxhdGZvcm0gPSBwYXJzZSgpO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiLypcblxuXHRyYWN0aXZlLWV2ZW50cy10YXBcblx0PT09PT09PT09PT09PT09PT09XG5cblx0VmVyc2lvbiAwLjEuMi5cblxuXHRPbiBtb2JpbGUgZGV2aWNlcywgdXNpbmcgYG9uLWNsaWNrYCBpc24ndCBnb29kIGVub3VnaC4gVGFwcGluZyB0aGVcblx0dG91Y2hzY3JlZW4gd2lsbCBmaXJlIGEgc2ltdWxhdGVkIGNsaWNrIGV2ZW50LCBidXQgb25seSBhZnRlciBhIDMwMFxuXHRtaWxsaXNlY29uZCBkZWxheSwgd2hpY2ggbWFrZXMgeW91ciBhcHAgZmVlbCBzbHVnZ2lzaC4gSXQgYWxzb1xuXHRjYXVzZXMgdGhlIHRhcHBlZCBhcmVhIHRvIGhpZ2hsaWdodCwgd2hpY2ggaW4gbW9zdCBjYXNlcyBsb29rcyBhXG5cdGJpdCBtZXNzeS5cblxuXHRJbnN0ZWFkLCB1c2UgYG9uLXRhcGAuIFdoZW4geW91IHRhcCBhbiBhcmVhLCB0aGUgc2ltdWxhdGVkIGNsaWNrXG5cdGV2ZW50IHdpbGwgYmUgcHJldmVudGVkLCBhbmQgdGhlIHVzZXIncyBhY3Rpb24gaXMgcmVzcG9uZGVkIHRvXG5cdGluc3RhbnRseS4gVGhlIGBvbi10YXBgIGV2ZW50IGFsc28gZGlmZmVycyBmcm9tIGBvbi1jbGlja2AgaW4gdGhhdFxuXHR0aGUgY2xpY2sgZXZlbnQgd2lsbCAoZnJhbmtseSByYXRoZXIgYml6YXJyZWx5KSBmaXJlIGV2ZW4gaWYgeW91XG5cdGhvbGQgdGhlIG1vdXNlIGRvd24gb3ZlciBhIHNpbmdsZSBlbGVtZW50IGZvciBzZXZlcmFsIHNlY29uZHMgYW5kXG5cdHdhZ2dsZSBpdCBhYm91dC5cblxuXHRQb2ludGVyIGV2ZW50cyBhcmUgYWxzbyBzdXBwb3J0ZWQsIGFzIGlzIHByZXNzaW5nIHRoZSBzcGFjZWJhciB3aGVuXG5cdHRoZSByZWxldmFudCBlbGVtZW50IGlzIGZvY3VzZWQgKHdoaWNoIHRyaWdnZXJzIGEgY2xpY2sgZXZlbnQsIGFuZFxuXHRpcyBnb29kIGZvciBhY2Nlc3NpYmlsaXR5KS5cblxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFRyb3VibGVzaG9vdGluZzogSWYgeW91J3JlIHVzaW5nIGEgbW9kdWxlIHN5c3RlbSBpbiB5b3VyIGFwcCAoQU1EIG9yXG5cdHNvbWV0aGluZyBtb3JlIG5vZGV5KSB0aGVuIHlvdSBtYXkgbmVlZCB0byBjaGFuZ2UgdGhlIHBhdGhzIGJlbG93LFxuXHR3aGVyZSBpdCBzYXlzIGByZXF1aXJlKCAncmFjdGl2ZScgKWAgb3IgYGRlZmluZShbICdyYWN0aXZlJyBdLi4uKWAuXG5cblx0PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXHRVc2FnZTogSW5jbHVkZSB0aGlzIGZpbGUgb24geW91ciBwYWdlIGJlbG93IFJhY3RpdmUsIGUuZzpcblxuXHQgICAgPHNjcmlwdCBzcmM9J2xpYi9yYWN0aXZlLmpzJz48L3NjcmlwdD5cblx0ICAgIDxzY3JpcHQgc3JjPSdsaWIvcmFjdGl2ZS1ldmVudHMtdGFwLmpzJz48L3NjcmlwdD5cblxuXHRPciwgaWYgeW91J3JlIHVzaW5nIGEgbW9kdWxlIGxvYWRlciwgcmVxdWlyZSB0aGlzIG1vZHVsZTpcblxuXHQgICAgLy8gcmVxdWlyaW5nIHRoZSBwbHVnaW4gd2lsbCAnYWN0aXZhdGUnIGl0IC0gbm8gbmVlZCB0byB1c2Vcblx0ICAgIC8vIHRoZSByZXR1cm4gdmFsdWVcblx0ICAgIHJlcXVpcmUoICdyYWN0aXZlLWV2ZW50cy10YXAnICk7XG5cblx0QWRkIGEgdGFwIGV2ZW50IGluIHRoZSBub3JtYWwgZmFzaGlvbjpcblxuXHQgICAgPGRpdiBvbi10YXA9J2Zvbyc+dGFwIG1lITwvZGl2PlxuXG5cdFRoZW4gYWRkIGEgaGFuZGxlcjpcblxuXHQgICAgcmFjdGl2ZS5vbiggJ2ZvbycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cdCAgICAgIGFsZXJ0KCAndGFwcGVkJyApO1xuXHQgICAgfSk7XG5cbiovXG5cbihmdW5jdGlvbiAoIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0Ly8gQ29tbW9uIEpTIChpLmUuIGJyb3dzZXJpZnkpIGVudmlyb25tZW50XG5cdGlmICggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0ZmFjdG9yeSggcmVxdWlyZSggXCIuLy4uL3JhY3RpdmUvcmFjdGl2ZS5qc1wiICkgKTtcblx0fVxuXG5cdC8vIEFNRD9cblx0ZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHRkZWZpbmUoWyAncmFjdGl2ZScgXSwgZmFjdG9yeSApO1xuXHR9XG5cblx0Ly8gYnJvd3NlciBnbG9iYWxcblx0ZWxzZSBpZiAoIGdsb2JhbC5SYWN0aXZlICkge1xuXHRcdGZhY3RvcnkoIGdsb2JhbC5SYWN0aXZlICk7XG5cdH1cblxuXHRlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb3VsZCBub3QgZmluZCBSYWN0aXZlISBJdCBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgdGhlIHJhY3RpdmUtZXZlbnRzLXRhcCBwbHVnaW4nICk7XG5cdH1cblxufSggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAoIFJhY3RpdmUgKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciB0YXAgPSBmdW5jdGlvbiAoIG5vZGUsIGZpcmUgKSB7XG5cdFx0dmFyIG1vdXNlZG93biwgdG91Y2hzdGFydCwgZm9jdXNIYW5kbGVyLCBkaXN0YW5jZVRocmVzaG9sZCwgdGltZVRocmVzaG9sZCwgcHJldmVudE1vdXNlZG93bkV2ZW50cywgcHJldmVudE1vdXNlZG93blRpbWVvdXQ7XG5cblx0XHRkaXN0YW5jZVRocmVzaG9sZCA9IDU7IC8vIG1heGltdW0gcGl4ZWxzIHBvaW50ZXIgY2FuIG1vdmUgYmVmb3JlIGNhbmNlbFxuXHRcdHRpbWVUaHJlc2hvbGQgPSA0MDA7ICAgLy8gbWF4aW11bSBtaWxsaXNlY29uZHMgYmV0d2VlbiBkb3duIGFuZCB1cCBiZWZvcmUgY2FuY2VsXG5cblx0XHRtb3VzZWRvd24gPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHRcdFx0dmFyIGN1cnJlbnRUYXJnZXQsIHgsIHksIHBvaW50ZXJJZCwgdXAsIG1vdmUsIGNhbmNlbDtcblxuXHRcdFx0aWYgKCBwcmV2ZW50TW91c2Vkb3duRXZlbnRzICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZXZlbnQud2hpY2ggIT09IHVuZGVmaW5lZCAmJiBldmVudC53aGljaCAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR4ID0gZXZlbnQuY2xpZW50WDtcblx0XHRcdHkgPSBldmVudC5jbGllbnRZO1xuXHRcdFx0Y3VycmVudFRhcmdldCA9IHRoaXM7XG5cdFx0XHQvLyBUaGlzIHdpbGwgYmUgbnVsbCBmb3IgbW91c2UgZXZlbnRzLlxuXHRcdFx0cG9pbnRlcklkID0gZXZlbnQucG9pbnRlcklkO1xuXG5cdFx0XHR1cCA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggZXZlbnQucG9pbnRlcklkICE9IHBvaW50ZXJJZCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmaXJlKHtcblx0XHRcdFx0XHRub2RlOiBjdXJyZW50VGFyZ2V0LFxuXHRcdFx0XHRcdG9yaWdpbmFsOiBldmVudFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRjYW5jZWwoKTtcblx0XHRcdH07XG5cblx0XHRcdG1vdmUgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIGV2ZW50LnBvaW50ZXJJZCAhPSBwb2ludGVySWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCAoIE1hdGguYWJzKCBldmVudC5jbGllbnRYIC0geCApID49IGRpc3RhbmNlVGhyZXNob2xkICkgfHwgKCBNYXRoLmFicyggZXZlbnQuY2xpZW50WSAtIHkgKSA+PSBkaXN0YW5jZVRocmVzaG9sZCApICkge1xuXHRcdFx0XHRcdGNhbmNlbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ01TUG9pbnRlclVwJywgdXAsIGZhbHNlICk7XG5cdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdNU1BvaW50ZXJNb3ZlJywgbW92ZSwgZmFsc2UgKTtcblx0XHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ01TUG9pbnRlckNhbmNlbCcsIGNhbmNlbCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcnVwJywgdXAsIGZhbHNlICk7XG5cdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVybW92ZScsIG1vdmUsIGZhbHNlICk7XG5cdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVyY2FuY2VsJywgY2FuY2VsLCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIHVwLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgbW92ZSwgZmFsc2UgKTtcblx0XHRcdH07XG5cblx0XHRcdGlmICggd2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCApIHtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcnVwJywgdXAsIGZhbHNlICk7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVybW92ZScsIG1vdmUsIGZhbHNlICk7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVyY2FuY2VsJywgY2FuY2VsLCBmYWxzZSApO1xuXHRcdFx0fSBlbHNlIGlmICggd2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkICkge1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdNU1BvaW50ZXJVcCcsIHVwLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnTVNQb2ludGVyTW92ZScsIG1vdmUsIGZhbHNlICk7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdNU1BvaW50ZXJDYW5jZWwnLCBjYW5jZWwsIGZhbHNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIHVwLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgbW92ZSwgZmFsc2UgKTtcblx0XHRcdH1cblxuXHRcdFx0c2V0VGltZW91dCggY2FuY2VsLCB0aW1lVGhyZXNob2xkICk7XG5cdFx0fTtcblxuXHRcdGlmICggd2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCApIHtcblx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJkb3duJywgbW91c2Vkb3duLCBmYWxzZSApO1xuXHRcdH0gZWxzZSBpZiAoIHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCApIHtcblx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ01TUG9pbnRlckRvd24nLCBtb3VzZWRvd24sIGZhbHNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIG1vdXNlZG93biwgZmFsc2UgKTtcblx0XHR9XG5cblxuXHRcdHRvdWNoc3RhcnQgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHRcdFx0dmFyIGN1cnJlbnRUYXJnZXQsIHgsIHksIHRvdWNoLCBmaW5nZXIsIG1vdmUsIHVwLCBjYW5jZWw7XG5cblx0XHRcdGlmICggZXZlbnQudG91Y2hlcy5sZW5ndGggIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuXG5cdFx0XHR4ID0gdG91Y2guY2xpZW50WDtcblx0XHRcdHkgPSB0b3VjaC5jbGllbnRZO1xuXHRcdFx0Y3VycmVudFRhcmdldCA9IHRoaXM7XG5cblx0XHRcdGZpbmdlciA9IHRvdWNoLmlkZW50aWZpZXI7XG5cblx0XHRcdHVwID0gZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRvdWNoO1xuXG5cdFx0XHRcdHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cdFx0XHRcdGlmICggdG91Y2guaWRlbnRpZmllciAhPT0gZmluZ2VyICkge1xuXHRcdFx0XHRcdGNhbmNlbCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTsgIC8vIHByZXZlbnQgY29tcGF0aWJpbGl0eSBtb3VzZSBldmVudFxuXG5cdFx0XHRcdC8vIGZvciB0aGUgYmVuZWZpdCBvZiBtb2JpbGUgRmlyZWZveCBhbmQgb2xkIEFuZHJvaWQgYnJvd3NlcnMsIHdlIG5lZWQgdGhpcyBhYnN1cmQgaGFjay5cblx0XHRcdFx0cHJldmVudE1vdXNlZG93bkV2ZW50cyA9IHRydWU7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggcHJldmVudE1vdXNlZG93blRpbWVvdXQgKTtcblxuXHRcdFx0XHRwcmV2ZW50TW91c2Vkb3duVGltZW91dCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRwcmV2ZW50TW91c2Vkb3duRXZlbnRzID0gZmFsc2U7XG5cdFx0XHRcdH0sIDQwMCApO1xuXG5cdFx0XHRcdGZpcmUoe1xuXHRcdFx0XHRcdG5vZGU6IGN1cnJlbnRUYXJnZXQsXG5cdFx0XHRcdFx0b3JpZ2luYWw6IGV2ZW50XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGNhbmNlbCgpO1xuXHRcdFx0fTtcblxuXHRcdFx0bW92ZSA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cdFx0XHRcdHZhciB0b3VjaDtcblxuXHRcdFx0XHRpZiAoIGV2ZW50LnRvdWNoZXMubGVuZ3RoICE9PSAxIHx8IGV2ZW50LnRvdWNoZXNbMF0uaWRlbnRpZmllciAhPT0gZmluZ2VyICkge1xuXHRcdFx0XHRcdGNhbmNlbCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuXHRcdFx0XHRpZiAoICggTWF0aC5hYnMoIHRvdWNoLmNsaWVudFggLSB4ICkgPj0gZGlzdGFuY2VUaHJlc2hvbGQgKSB8fCAoIE1hdGguYWJzKCB0b3VjaC5jbGllbnRZIC0geSApID49IGRpc3RhbmNlVGhyZXNob2xkICkgKSB7XG5cdFx0XHRcdFx0Y2FuY2VsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2hlbmQnLCB1cCwgZmFsc2UgKTtcblx0XHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaG1vdmUnLCBtb3ZlLCBmYWxzZSApO1xuXHRcdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoY2FuY2VsJywgY2FuY2VsLCBmYWxzZSApO1xuXHRcdFx0fTtcblxuXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hlbmQnLCB1cCwgZmFsc2UgKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgbW92ZSwgZmFsc2UgKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hjYW5jZWwnLCBjYW5jZWwsIGZhbHNlICk7XG5cblx0XHRcdHNldFRpbWVvdXQoIGNhbmNlbCwgdGltZVRocmVzaG9sZCApO1xuXHRcdH07XG5cblx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydCwgZmFsc2UgKTtcblxuXG5cdFx0Ly8gbmF0aXZlIGJ1dHRvbnMsIGFuZCA8aW5wdXQgdHlwZT0nYnV0dG9uJz4gZWxlbWVudHMsIHNob3VsZCBmaXJlIGEgdGFwIGV2ZW50XG5cdFx0Ly8gd2hlbiB0aGUgc3BhY2Uga2V5IGlzIHByZXNzZWRcblx0XHRpZiAoIG5vZGUudGFnTmFtZSA9PT0gJ0JVVFRPTicgfHwgbm9kZS50eXBlID09PSAnYnV0dG9uJyApIHtcblx0XHRcdGZvY3VzSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGJsdXJIYW5kbGVyLCBrZXlkb3duSGFuZGxlcjtcblxuXHRcdFx0XHRrZXlkb3duSGFuZGxlciA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudC53aGljaCA9PT0gMzIgKSB7IC8vIHNwYWNlIGtleVxuXHRcdFx0XHRcdFx0ZmlyZSh7XG5cdFx0XHRcdFx0XHRcdG5vZGU6IG5vZGUsXG5cdFx0XHRcdFx0XHRcdG9yaWdpbmFsOiBldmVudFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGJsdXJIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBrZXlkb3duSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdibHVyJywgYmx1ckhhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIGtleWRvd25IYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdibHVyJywgYmx1ckhhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHR9O1xuXG5cdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdmb2N1cycsIGZvY3VzSGFuZGxlciwgZmFsc2UgKTtcblx0XHR9XG5cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVyZG93bicsIG1vdXNlZG93biwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnTVNQb2ludGVyRG93bicsIG1vdXNlZG93biwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgbW91c2Vkb3duLCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZm9jdXMnLCBmb2N1c0hhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblxuXHRSYWN0aXZlLmV2ZW50cy50YXAgPSB0YXA7XG5cbn0pKTtcbiIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsncmFjdGl2ZScsICdoYW1tZXJqcyddLCBmYWN0b3J5KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKFwiLi8uLi9yYWN0aXZlL3JhY3RpdmUuanNcIiksIHJlcXVpcmUoXCIuLy4uL2hhbW1lcmpzL2hhbW1lci5qc1wiKSk7XG4gIH1cblxuICBlbHNlIHtcbiAgICBmYWN0b3J5KHJvb3QuUmFjdGl2ZSwgcm9vdC5IYW1tZXIpO1xuICB9XG5cbn0odGhpcywgZnVuY3Rpb24gKFJhY3RpdmUsIEhhbW1lcikge1xuXG4gIC8vIENoZWNrIHRoZSByZWNvZ25pemVycyBkb2N1bWVudGF0aW9uLlxuICAvLyBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL3JlY29nbml6ZXItdGFwXG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIHRhcDoge1xuICAgICAgcmVjb2duaXplckNsYXNzOiBIYW1tZXIuVGFwLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0aW1lOiA1MDBcbiAgICAgIH0sXG4gICAgICBldmVudHM6IFtcbiAgICAgICAgJ3RhcCcgXG4gICAgICBdXG4gICAgfSxcbiAgICBkb3VibGV0YXA6IHtcbiAgICAgIHJlY29nbml6ZXJDbGFzczogSGFtbWVyLlRhcCxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdGFwczogMixcbiAgICAgICAgZXZlbnQ6ICdkb3VibGV0YXAnXG4gICAgICB9LFxuICAgICAgcmVjb2duaXplV2l0aDogWyd0YXAnXSxcbiAgICAgIGV2ZW50czogW1xuICAgICAgICAnZG91YmxldGFwJyBcbiAgICAgIF1cbiAgICB9LFxuICAgIHN3aXBlOiB7XG4gICAgICByZWNvZ25pemVyQ2xhc3M6IEhhbW1lci5Td2lwZSxcbiAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgZXZlbnRzOiBbXG4gICAgICAgICdzd2lwZScsXG4gICAgICAgICdzd2lwZWxlZnQnLFxuICAgICAgICAnc3dpcGVyaWdodCcsXG4gICAgICAgICdzd2lwZXVwJyxcbiAgICAgICAgJ3N3aXBlZG93bicgXG4gICAgICBdXG4gICAgfSxcbiAgICBwYW46IHtcbiAgICAgIHJlY29nbml6ZXJDbGFzczogSGFtbWVyLlBhbixcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUxcbiAgICAgIH0sXG4gICAgICByZWNvZ25pemVXaXRoOiBbJ3N3aXBlJ10sXG4gICAgICBldmVudHM6IFtcbiAgICAgICAgJ3BhbicsXG4gICAgICAgICdwYW5zdGFydCcsXG4gICAgICAgICdwYW5tb3ZlJyxcbiAgICAgICAgJ3BhbmVuZCcsXG4gICAgICAgICdwYW5jYW5jZWwnLFxuICAgICAgICAncGFubGVmdCcsXG4gICAgICAgICdwYW5yaWdodCcsXG4gICAgICAgICdwYW51cCcsXG4gICAgICAgICdwYW5kb3duJyBcbiAgICAgIF1cbiAgICB9LFxuICAgIHByZXNzOiB7XG4gICAgICByZWNvZ25pemVyQ2xhc3M6IEhhbW1lci5QcmVzcyxcbiAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgZXZlbnRzOiBbXG4gICAgICAgICdwcmVzcycgXG4gICAgICBdXG4gICAgfSxcbiAgICByb3RhdGU6IHtcbiAgICAgIHJlY29nbml6ZXJDbGFzczogSGFtbWVyLlJvdGF0ZSxcbiAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgZXZlbnRzOiBbXG4gICAgICAgICdyb3RhdGUnLFxuICAgICAgICAncm90YXRlc3RhcnQnLFxuICAgICAgICAncm90YXRlbW92ZScsXG4gICAgICAgICdyb3RhdGVlbmQnLFxuICAgICAgICAncm90YXRlY2FuY2VsJyBcbiAgICAgIF1cbiAgICB9LFxuICAgIHBpbmNoOiB7XG4gICAgICByZWNvZ25pemVyQ2xhc3M6IEhhbW1lci5QaW5jaCxcbiAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgcmVjb2duaXplV2l0aDogWydyb3RhdGUnXSxcbiAgICAgIGV2ZW50czogW1xuICAgICAgICAncGluY2gnLFxuICAgICAgICAncGluY2hzdGFydCcsXG4gICAgICAgICdwaW5jaG1vdmUnLFxuICAgICAgICAncGluY2hlbmQnLFxuICAgICAgICAncGluY2hjYW5jZWwnLFxuICAgICAgICAncGluY2hpbicsXG4gICAgICAgICdwaW5jaG91dCcgXG4gICAgICBdXG4gICAgfVxuICB9O1xuXG4gIHZhciBhbGlhc2VzO1xuXG4gIC8vIGJpbmQgYWxsIGV2ZW50cyB1c2luZyBidWlsZEV2ZW50XG4gIGZvciAodmFyIHJlY29nbml6ZXJOYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKCFkZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShyZWNvZ25pemVyTmFtZSkpIGNvbnRpbnVlO1xuICAgIFxuICAgIHZhciBldmVudHMgPSBkZWZhdWx0c1tyZWNvZ25pemVyTmFtZV0uZXZlbnRzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWlsZEV2ZW50KGV2ZW50c1tpXSwgcmVjb2duaXplck5hbWUsIGRlZmF1bHRzW3JlY29nbml6ZXJOYW1lXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGJ1aWxkRXZlbnQgOiBidWlsZEV2ZW50KGV2ZW50LCByZWNvZ25pemVyTmFtZSwgY29uZmlnKVxuICAgKiAocHJpdmF0ZSkgcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIGJ1aWxkRXZlbnQuXG4gICAqXG4gICAqICAgICBidWlsZEV2ZW50KCdwYW5zdGFydCcsICdwYW4nLCB7IC4uLiB9KTtcbiAgICovXG5cbiAgZnVuY3Rpb24gYnVpbGRFdmVudChldmVudE5hbWUsIHJlY29nbml6ZXJOYW1lLCBjb25maWcpIHtcbiAgICBSYWN0aXZlLmV2ZW50c1tldmVudE5hbWVdID0gYnVpbGRFdmVudEhhbmRsZXIoZXZlbnROYW1lLCByZWNvZ25pemVyTmFtZSwgY29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBidWlsZEV2ZW50SGFuZGxlcigpIDogYnVpbGRFdmVudEhhbmRsZXIoZXZlbnQsIHJlY29nbml6ZXJOYW1lLCBjb25maWcpXG4gICAqIChwcml2YXRlKSBDcmVhdGVzIHRoZSBldmVudCBoYW5kbGVyIGZvciBhIGdpdmVuIGBldmVudE5hbWVgIHRoYXQgd2lsbCBiZVxuICAgKiByZWdpc3RlcmVkIHRvIGBSYWN0aXZlLmV2ZW50c2AuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJ1aWxkRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSwgcmVjb2duaXplck5hbWUsIGNvbmZpZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwgZmlyZSkge1xuICAgICAgdmFyIGhhbW1lck1hbmFnZXIgPSBnZXRIYW1tZXJNYW5hZ2VyKG5vZGUpO1xuXG4gICAgICB2YXIgcmVjb2duaXplckV4aXN0cyA9IChoYW1tZXJNYW5hZ2VyLmdldChyZWNvZ25pemVyTmFtZSkgIT09IG51bGwpO1xuXG4gICAgICBpZiAoIXJlY29nbml6ZXJFeGlzdHMpIHtcbiAgICAgICAgLy8gaW5pdCB3aXRoIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICB2YXIgcmVjb2duaXplciA9IG5ldyBjb25maWcucmVjb2duaXplckNsYXNzKGNvbmZpZy5vcHRpb25zKTtcblxuICAgICAgICAvLyBIYW1tZXIuUmVjb2duaXplci5zZXQgbWVyZ2VzIGl0IG9uIHRvcCBvZiB0aGUgZGVmYXVsdHMgc3VwcGxpZWQgYWJvdmVcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMobm9kZSwgcmVjb2duaXplck5hbWUpO1xuICAgICAgICBpZiAob3B0aW9ucylcbiAgICAgICAgICByZWNvZ25pemVyLnNldChvcHRpb25zKTtcblxuICAgICAgICBoYW1tZXJNYW5hZ2VyLmFkZChyZWNvZ25pemVyKTtcbiAgICAgICAgXG4gICAgICAgIHVwZGF0ZVJlY29nbml6ZVdpdGgoaGFtbWVyTWFuYWdlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlZ2lzdGVyIHRoZSBoYW5kbGVyXG4gICAgICBoYW1tZXJNYW5hZ2VyLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZmlyZSh7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvcmlnaW5hbDogZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBoYW5kbGUgZXhpdHNcbiAgICAgIGZ1bmN0aW9uIHRlYXJkb3duKCkge1xuICAgICAgICBnZXRIYW1tZXJNYW5hZ2VyKG5vZGUpLmRlc3Ryb3koKTtcbiAgICAgICAgZGVsZXRlIG5vZGUuX2hhbW1lcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgdGVhcmRvd246IHRlYXJkb3duIH07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiB1cGRhdGVSZWNvZ25pemVXaXRoIDogdXBkYXRlUmVjb2duaXplV2l0aChoYW1tZXJNYW5hZ2VyKVxuICAgKiAocHJpdmF0ZSkgU2V0cyByZWNvZ25pemVXaXRoIGlmIGRlZmF1bHRzIGhhdmUgaXRcbiAgICpcbiAgICogU2luY2Ugd2UgYWRkIHJlY29nbml6ZXJzIGR5bmFtaWNhbGx5IGFuZCB3aXRob3V0IGFueSBzdHJpY3Qgb3JkZXIsXG4gICAqICB3ZSBuZWVkIHRvIGd1YXJkIGFnYWluc3QgdHJ5aW5nIHRvIHNldCBhIHJlcXVpcmVXaXRoIGZvciBhIHJlY29nbml6ZXJcbiAgICogIHRoYXQgaGF2ZW4ndCBiZWVuIGNyZWF0ZWQgeWV0LlxuICAgKiBcbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZVJlY29nbml6ZVdpdGgoaGFtbWVyTWFuYWdlcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFtbWVyTWFuYWdlci5yZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlY29nbml6ZXIgPSBoYW1tZXJNYW5hZ2VyLnJlY29nbml6ZXJzW2ldO1xuICAgICAgdmFyIHJlY29nbml6ZXJOYW1lID0gcmVjb2duaXplci5vcHRpb25zLmV2ZW50O1xuXG4gICAgICBpZiAoIWRlZmF1bHRzW3JlY29nbml6ZXJOYW1lXS5oYXNPd25Qcm9wZXJ0eSgncmVjb2duaXplV2l0aCcpKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgdmFyIHJlY29nbml6ZVdpdGhzID0gZGVmYXVsdHNbcmVjb2duaXplck5hbWVdLnJlY29nbml6ZVdpdGg7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHJlY29nbml6ZVdpdGhzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSByZWNnb25pemVyIHdlJ3JlIHRyeWluZyB0byBkZXBlbmQgb24gaXMgcmVhbGx5IHRoZXJlXG4gICAgICAgIGlmICghaGFtbWVyTWFuYWdlci5nZXQocmVjb2duaXplV2l0aHNba10pKSBjb250aW51ZTtcblxuICAgICAgICAvLyBJdCdzIHNhZmUgdG8gcmVjb2duaXplV2l0aCBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWUgcmVjb2duaXplclxuICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgocmVjb2duaXplV2l0aHNba10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZU9wdGlvbnMgOiBwYXJzZU9wdGlvbnMobm9kZSwga2V5KVxuICAgKiAocHJpdmF0ZSkgUmV0dXJucyBvcHRpb25zIGZvciBhIGdpdmVuIERPTSBub2RlLlxuICAgKlxuICAgKiAgICAgbm9kZSA9IDxkaXYgZGF0YS1zd2lwZS1kaXJlY3Rpb249J2xlZnQnIGRhdGEtc3dpcGUtdGhyZXNob2xkPScyJz5cbiAgICpcbiAgICogICAgIHBhcnNlT3B0aW9ucyhub2RlLCAnc3dpcGUnKVxuICAgKiAgICAgPT4geyBkaXJlY3Rpb246ICdsZWZ0JywgdGhyZXNob2xkOiAyIH1cbiAgICovXG5cbiAgZnVuY3Rpb24gcGFyc2VPcHRpb25zKG5vZGUsIGtleSkge1xuICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cmlidXRlcyxcbiAgICAgICAgb3V0cHV0LFxuICAgICAgICByZSA9IG5ldyBSZWdFeHAoXCJeKD86ZGF0YS0pP1wiK2tleStcIi0oLiopJFwiKTtcblxuICAgIGZvciAodmFyIGkgPSBhdHRycy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhdHRyID0gYXR0cnNbaV0sXG4gICAgICAgICAgbSA9IGF0dHIubmFtZS5tYXRjaChyZSk7XG5cbiAgICAgIGlmICghbSkgY29udGludWU7XG4gICAgICBpZiAoIW91dHB1dCkgb3V0cHV0ID0ge307XG4gICAgICBvdXRwdXRbbVsxXV0gPSBwYXJzZUhhbW1lclZhbHVlKGF0dHIudmFsdWUsIG1bMV0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICAvKipcbiAgICogcGFyc2VIYW1tZXJWYWx1ZSA6IHBhcnNlSGFtbWVyVmFsdWUoc3RyLCBrZXkpXG4gICAqIChwcml2YXRlKSBWYWx1ZS1pemVzIGEgZ2l2ZW4gc3RyaW5nIGBzdHJgLCBjb252ZXJ0aW5nIGl0IHRvIGEgbnVtYmVyIGFzXG4gICAqIG5lZWRlZC4gSWYgYGtleWAgaXMgZ2l2ZW4sIGl0IGNhbiBhbHNvIHJlc29sdmUgYWxpYXNlcyBmb3IgdGhhdCBnaXZlblxuICAgKiBrZXkuXG4gICAqXG4gICAqIFVzZWQgYnkgYGdldERhdGEoKWAuIFxuICAgKlxuICAgKiAgICAgcGFyc2VIYW1tZXJWYWx1ZShcIjEwMFwiKSAgID0+IDEwMFxuICAgKiAgICAgcGFyc2VIYW1tZXJWYWx1ZShcInJpZ2h0XCIpID0+IFwicmlnaHRcIlxuICAgKiAgICAgcGFyc2VIYW1tZXJWYWx1ZShcInJpZ2h0XCIsIFwiZGlyZWN0aW9uXCIpID0+IEhhbW1lci5ESVJFQ1RJT05fUklHSFRcbiAgICovXG5cbiAgZnVuY3Rpb24gcGFyc2VIYW1tZXJWYWx1ZShzdHIsIGtleSkge1xuICAgIGlmIChzdHIubWF0Y2ggJiYgc3RyLm1hdGNoKC9eLT9cXGQrKD86XFwuXFxkKyk/JC8pKSByZXR1cm4gK3N0cjtcbiAgICByZXR1cm4gKGFsaWFzZXNba2V5XSAmJiBhbGlhc2VzW2tleV1bc3RyXSkgfHxcbiAgICAgIGFsaWFzZXMuYWxsW3N0cl0gfHwgc3RyO1xuICB9XG5cbiAgLypcbiAgICogQWxpYXNlcyBmb3IgYHZhbCgpYC5cbiAgICovXG5cbiAgYWxpYXNlcyA9IHtcbiAgICBhbGw6IHtcbiAgICAgICd0cnVlJzogdHJ1ZSxcbiAgICAgICdmYWxzZSc6IGZhbHNlLFxuICAgICAgJ3VuZGVmaW5lZCc6IHVuZGVmaW5lZCxcbiAgICAgICdudWxsJzogbnVsbFxuICAgIH0sXG4gICAgZGlyZWN0aW9uOiB7XG4gICAgICAnbm9uZSc6IEhhbW1lci5ESVJFQ1RJT05fTk9ORSxcbiAgICAgICdhbGwnOiBIYW1tZXIuRElSRUNUSU9OX0FMTCxcbiAgICAgICd1cCc6IEhhbW1lci5ESVJFQ1RJT05fVVAsXG4gICAgICAnZG93bic6IEhhbW1lci5ESVJFQ1RJT05fRE9XTixcbiAgICAgICdsZWZ0JzogSGFtbWVyLkRJUkVDVElPTl9MRUZULFxuICAgICAgJ3JpZ2h0JzogSGFtbWVyLkRJUkVDVElPTl9SSUdIVCxcbiAgICAgICdob3Jpem9udGFsJzogSGFtbWVyLkRJUkVDVElPTl9IT1JJWk9OVEFMLFxuICAgICAgJ3ZlcnRpY2FsJzogSGFtbWVyLkRJUkVDVElPTl9WRVJUSUNBTFxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogZ2V0SGFtbWVyTWFuYWdlciA6IGdldEhhbW1lck1hbmFnZXIobm9kZSlcbiAgICogKHByaXZhdGUpIFJldHVybnMgdGhlIGBIYW1tZXJNYW5hZ2VyYCBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIG5vZGUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldEhhbW1lck1hbmFnZXIobm9kZSkge1xuICAgIGlmIChub2RlLl9oYW1tZXIpIHJldHVybiBub2RlLl9oYW1tZXI7XG5cbiAgICBub2RlLl9oYW1tZXIgPSBuZXcgSGFtbWVyLk1hbmFnZXIobm9kZSwge3JlY29nbml6ZXJzOiBbXX0pO1xuICAgIHJldHVybiBub2RlLl9oYW1tZXI7XG4gIH1cblxuXG4gIHJldHVybiB7ZGVmYXVsdHM6IGRlZmF1bHRzfTtcblxufSkpO1xuIiwiLypcblxuXHRyYWN0aXZlLXRyYW5zaXRpb25zLWZhZGVcblx0PT09PT09PT09PT09PT09PT09PT09PT09XG5cblx0VmVyc2lvbiAwLjEuMi5cblxuXHRUaGlzIHBsdWdpbiBkb2VzIGV4YWN0bHkgd2hhdCBpdCBzYXlzIG9uIHRoZSB0aW4gLSBpdCBmYWRlcyBlbGVtZW50c1xuXHRpbiBhbmQgb3V0LCB1c2luZyBDU1MgdHJhbnNpdGlvbnMuIFlvdSBjYW4gY29udHJvbCB0aGUgZm9sbG93aW5nXG5cdHByb3BlcnRpZXM6IGBkdXJhdGlvbmAsIGBkZWxheWAgYW5kIGBlYXNpbmdgICh3aGljaCBtdXN0IGJlIGEgdmFsaWRcblx0Q1NTIHRyYW5zaXRpb24gdGltaW5nIGZ1bmN0aW9uLCBhbmQgZGVmYXVsdHMgdG8gYGxpbmVhcmApLlxuXG5cdFRoZSBgZHVyYXRpb25gIHByb3BlcnR5IGlzIGluIG1pbGxpc2Vjb25kcywgYW5kIGRlZmF1bHRzIHRvIDMwMCAoeW91XG5cdGNhbiBhbHNvIHVzZSBgZmFzdGAgb3IgYHNsb3dgIGluc3RlYWQgb2YgYSBtaWxsaXNlY29uZCB2YWx1ZSwgd2hpY2hcblx0ZXF1YXRlIHRvIDIwMCBhbmQgNjAwIHJlc3BlY3RpdmVseSkuIEFzIGEgc2hvcnRoYW5kLCB5b3UgY2FuIHVzZVxuXHRgaW50cm89J2ZhZGU6NTAwJ2AgaW5zdGVhZCBvZiBgaW50cm89J2ZhZGU6e1wiZHVyYXRpb25cIjo1MDB9J2AgLSB0aGlzXG5cdGFwcGxpZXMgdG8gbWFueSBvdGhlciB0cmFuc2l0aW9uIHBsdWdpbnMgYXMgd2VsbC5cblxuXHRJZiBhbiBlbGVtZW50IGhhcyBhbiBvcGFjaXR5IG90aGVyIHRoYW4gMSAod2hldGhlciBkaXJlY3RseSwgYmVjYXVzZVxuXHRvZiBhbiBpbmxpbmUgc3R5bGUsIG9yIGluZGlyZWN0bHkgYmVjYXVzZSBvZiBhIENTUyBydWxlKSwgaXQgd2lsbCBiZVxuXHRyZXNwZWN0ZWQuIFlvdSBjYW4gb3ZlcnJpZGUgdGhlIHRhcmdldCBvcGFjaXR5IG9mIGFuIGludHJvIGZhZGUgYnlcblx0c3BlY2lmeWluZyBhIGB0b2AgcHJvcGVydHkgYmV0d2VlbiAwIGFuZCAxLlxuXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblx0VHJvdWJsZXNob290aW5nOiBJZiB5b3UncmUgdXNpbmcgYSBtb2R1bGUgc3lzdGVtIGluIHlvdXIgYXBwIChBTUQgb3Jcblx0c29tZXRoaW5nIG1vcmUgbm9kZXkpIHRoZW4geW91IG1heSBuZWVkIHRvIGNoYW5nZSB0aGUgcGF0aHMgYmVsb3csXG5cdHdoZXJlIGl0IHNheXMgYHJlcXVpcmUoICdSYWN0aXZlJyApYCBvciBgZGVmaW5lKFsgJ1JhY3RpdmUnIF0uLi4pYC5cblxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFVzYWdlOiBJbmNsdWRlIHRoaXMgZmlsZSBvbiB5b3VyIHBhZ2UgYmVsb3cgUmFjdGl2ZSwgZS5nOlxuXG5cdCAgICA8c2NyaXB0IHNyYz0nbGliL3JhY3RpdmUuanMnPjwvc2NyaXB0PlxuXHQgICAgPHNjcmlwdCBzcmM9J2xpYi9yYWN0aXZlLXRyYW5zaXRpb25zLWZhZGUuanMnPjwvc2NyaXB0PlxuXG5cdE9yLCBpZiB5b3UncmUgdXNpbmcgYSBtb2R1bGUgbG9hZGVyLCByZXF1aXJlIHRoaXMgbW9kdWxlOlxuXG5cdCAgICAvLyByZXF1aXJpbmcgdGhlIHBsdWdpbiB3aWxsICdhY3RpdmF0ZScgaXQgLSBubyBuZWVkIHRvIHVzZVxuXHQgICAgLy8gdGhlIHJldHVybiB2YWx1ZVxuXHQgICAgcmVxdWlyZSggJ3JhY3RpdmUtdHJhbnNpdGlvbnMtZmFkZScgKTtcblxuXHRBZGQgYSBmYWRlIHRyYW5zaXRpb24gbGlrZSBzbzpcblxuXHQgICAgPGRpdiBpbnRybz0nZmFkZSc+dGhpcyB3aWxsIGZhZGUgaW48L2Rpdj5cblxuKi9cblxuKGZ1bmN0aW9uICggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvLyBDb21tb24gSlMgKGkuZS4gYnJvd3NlcmlmeSkgZW52aXJvbm1lbnRcblx0aWYgKCB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRmYWN0b3J5KCByZXF1aXJlKCBcIi4vLi4vcmFjdGl2ZS9yYWN0aXZlLmpzXCIgKSApO1xuXHR9XG5cblx0Ly8gQU1EP1xuXHRlbHNlIGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXHRcdGRlZmluZShbICdyYWN0aXZlJyBdLCBmYWN0b3J5ICk7XG5cdH1cblxuXHQvLyBicm93c2VyIGdsb2JhbFxuXHRlbHNlIGlmICggZ2xvYmFsLlJhY3RpdmUgKSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsLlJhY3RpdmUgKTtcblx0fVxuXG5cdGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvciggJ0NvdWxkIG5vdCBmaW5kIFJhY3RpdmUhIEl0IG11c3QgYmUgbG9hZGVkIGJlZm9yZSB0aGUgcmFjdGl2ZS10cmFuc2l0aW9ucy1mYWRlIHBsdWdpbicgKTtcblx0fVxuXG59KCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uICggUmFjdGl2ZSApIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGZhZGUsIGRlZmF1bHRzO1xuXG5cdGRlZmF1bHRzID0ge1xuXHRcdGRlbGF5OiAwLFxuXHRcdGR1cmF0aW9uOiAzMDAsXG5cdFx0ZWFzaW5nOiAnbGluZWFyJ1xuXHR9O1xuXG5cdGZhZGUgPSBmdW5jdGlvbiAoIHQsIHBhcmFtcyApIHtcblx0XHR2YXIgdGFyZ2V0T3BhY2l0eTtcblxuXHRcdHBhcmFtcyA9IHQucHJvY2Vzc1BhcmFtcyggcGFyYW1zLCBkZWZhdWx0cyApO1xuXG5cdFx0aWYgKCB0LmlzSW50cm8gKSB7XG5cdFx0XHR0YXJnZXRPcGFjaXR5ID0gdC5nZXRTdHlsZSggJ29wYWNpdHknICk7XG5cdFx0XHR0LnNldFN0eWxlKCAnb3BhY2l0eScsIDAgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0T3BhY2l0eSA9IDA7XG5cdFx0fVxuXG5cdFx0dC5hbmltYXRlU3R5bGUoICdvcGFjaXR5JywgdGFyZ2V0T3BhY2l0eSwgcGFyYW1zICkudGhlbiggdC5jb21wbGV0ZSApO1xuXHR9O1xuXG5cdFJhY3RpdmUudHJhbnNpdGlvbnMuZmFkZSA9IGZhZGU7XG5cbn0pKTtcbiIsIi8qXG5cblx0cmFjdGl2ZS10cmFuc2l0aW9ucy1mbHlcblx0PT09PT09PT09PT09PT09PT09PT09PT1cblxuXHRWZXJzaW9uIDAuMS4zLlxuXG5cdFRoaXMgdHJhbnNpdGlvbiB1c2VzIENTUyB0cmFuc2Zvcm1zIHRvICdmbHknIGVsZW1lbnRzIHRvIHRoZWlyXG5cdG5hdHVyYWwgbG9jYXRpb24gb24gdGhlIHBhZ2UsIGZhZGluZyBpbiBmcm9tIHRyYW5zcGFyZW50IGFzIHRoZXkgZ28uXG5cdEJ5IGRlZmF1bHQsIHRoZXkgd2lsbCBmbHkgaW4gZnJvbSBsZWZ0LlxuXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblx0VHJvdWJsZXNob290aW5nOiBJZiB5b3UncmUgdXNpbmcgYSBtb2R1bGUgc3lzdGVtIGluIHlvdXIgYXBwIChBTUQgb3Jcblx0c29tZXRoaW5nIG1vcmUgbm9kZXkpIHRoZW4geW91IG1heSBuZWVkIHRvIGNoYW5nZSB0aGUgcGF0aHMgYmVsb3csXG5cdHdoZXJlIGl0IHNheXMgYHJlcXVpcmUoICdyYWN0aXZlJyApYCBvciBgZGVmaW5lKFsgJ3JhY3RpdmUnIF0uLi4pYC5cblxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFVzYWdlOiBJbmNsdWRlIHRoaXMgZmlsZSBvbiB5b3VyIHBhZ2UgYmVsb3cgUmFjdGl2ZSwgZS5nOlxuXG5cdCAgICA8c2NyaXB0IHNyYz0nbGliL3JhY3RpdmUuanMnPjwvc2NyaXB0PlxuXHQgICAgPHNjcmlwdCBzcmM9J2xpYi9yYWN0aXZlLXRyYW5zaXRpb25zLWZseS5qcyc+PC9zY3JpcHQ+XG5cblx0T3IsIGlmIHlvdSdyZSB1c2luZyBhIG1vZHVsZSBsb2FkZXIsIHJlcXVpcmUgdGhpcyBtb2R1bGU6XG5cblx0ICAgIC8vIHJlcXVpcmluZyB0aGUgcGx1Z2luIHdpbGwgJ2FjdGl2YXRlJyBpdCAtIG5vIG5lZWQgdG8gdXNlXG5cdCAgICAvLyB0aGUgcmV0dXJuIHZhbHVlXG5cdCAgICByZXF1aXJlKCAncmFjdGl2ZS10cmFuc2l0aW9ucy1mbHknICk7XG5cblx0WW91IGNhbiBhZGp1c3QgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOiBgeGAsIGB5YCwgYGR1cmF0aW9uYCxcblx0YGRlbGF5YCBhbmQgYGVhc2luZ2AuXG5cbiovXG5cbihmdW5jdGlvbiAoIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0Ly8gQ29tbW9uIEpTIChpLmUuIGJyb3dzZXJpZnkpIGVudmlyb25tZW50XG5cdGlmICggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0ZmFjdG9yeSggcmVxdWlyZSggXCIuLy4uL3JhY3RpdmUvcmFjdGl2ZS5qc1wiICkgKTtcblx0fVxuXG5cdC8vIEFNRD9cblx0ZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHRkZWZpbmUoWyAncmFjdGl2ZScgXSwgZmFjdG9yeSApO1xuXHR9XG5cblx0Ly8gYnJvd3NlciBnbG9iYWxcblx0ZWxzZSBpZiAoIGdsb2JhbC5SYWN0aXZlICkge1xuXHRcdGZhY3RvcnkoIGdsb2JhbC5SYWN0aXZlICk7XG5cdH1cblxuXHRlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb3VsZCBub3QgZmluZCBSYWN0aXZlISBJdCBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgdGhlIHJhY3RpdmUtdHJhbnNpdGlvbnMtZmx5IHBsdWdpbicgKTtcblx0fVxuXG59KCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uICggUmFjdGl2ZSApIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGZseSwgYWRkUHgsIGRlZmF1bHRzO1xuXG5cdGRlZmF1bHRzID0ge1xuXHRcdGR1cmF0aW9uOiA4MDAsXG5cdFx0ZWFzaW5nOiAnY3ViaWMtYmV6aWVyKDAuNzcwLCAwLjAwMCwgMC4xNzUsIDEuMDAwKScsXG5cdFx0eDogLTUwMCxcblx0XHR5OiAwXG5cdH07XG5cblx0YWRkUHggPSBmdW5jdGlvbiAoIG51bSApIHtcblx0XHRpZiAoIG51bSA9PT0gMCB8fCB0eXBlb2YgbnVtID09PSAnc3RyaW5nJyApIHtcblx0XHRcdHJldHVybiBudW07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bSArICdweCc7XG5cdH07XG5cblx0Zmx5ID0gZnVuY3Rpb24gKCB0LCBwYXJhbXMgKSB7XG5cdFx0dmFyIHgsIHksIG9mZnNjcmVlbiwgdGFyZ2V0O1xuXG5cdFx0cGFyYW1zID0gdC5wcm9jZXNzUGFyYW1zKCBwYXJhbXMsIGRlZmF1bHRzICk7XG5cblx0XHR4ID0gYWRkUHgoIHBhcmFtcy54ICk7XG5cdFx0eSA9IGFkZFB4KCBwYXJhbXMueSApO1xuXG5cdFx0b2Zmc2NyZWVuID0ge1xuXHRcdFx0dHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyB4ICsgJywnICsgeSArICcpJ1xuXHRcdH07XG5cblx0XHRpZiAoIHQuaXNJbnRybyApIHtcblx0XHRcdC8vIGFuaW1hdGUgdG8gdGhlIGN1cnJlbnQgc3R5bGVcblx0XHRcdHRhcmdldCA9IHQuZ2V0U3R5bGUoWyAndHJhbnNmb3JtJyBdKTtcblxuXHRcdFx0Ly8gc2V0IG9mZnNjcmVlbiBzdHlsZVxuXHRcdFx0dC5zZXRTdHlsZSggb2Zmc2NyZWVuICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldCA9IG9mZnNjcmVlbjtcblx0XHR9XG5cblx0XHR0LmFuaW1hdGVTdHlsZSggdGFyZ2V0LCBwYXJhbXMgKS50aGVuKCB0LmNvbXBsZXRlICk7XG5cdH07XG5cblx0UmFjdGl2ZS50cmFuc2l0aW9ucy5mbHkgPSBmbHk7XG5cbn0pKTtcbiIsIi8qXG5cblx0cmFjdGl2ZS10cmFuc2l0aW9ucy1zbGlkZVxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09XG5cblx0VmVyc2lvbiAwLjEuMi5cblxuXHRUaGlzIHRyYW5zaXRpb24gc2xpZGVzIGFuIGVsZW1lbnQgaW4gYW5kIG91dCBvZiB2aWV3LFxuXHR1c2luZyBDU1MgdHJhbnNpdGlvbnMgd2hlcmUgcG9zc2libGUuXG5cblx0PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXHRUcm91Ymxlc2hvb3Rpbmc6IElmIHlvdSdyZSB1c2luZyBhIG1vZHVsZSBzeXN0ZW0gaW4geW91ciBhcHAgKEFNRCBvclxuXHRzb21ldGhpbmcgbW9yZSBub2RleSkgdGhlbiB5b3UgbWF5IG5lZWQgdG8gY2hhbmdlIHRoZSBwYXRocyBiZWxvdyxcblx0d2hlcmUgaXQgc2F5cyBgcmVxdWlyZSggJ3JhY3RpdmUnIClgIG9yIGBkZWZpbmUoWyAncmFjdGl2ZScgXS4uLilgLlxuXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblx0VXNhZ2U6IEluY2x1ZGUgdGhpcyBmaWxlIG9uIHlvdXIgcGFnZSBiZWxvdyBSYWN0aXZlLCBlLmc6XG5cblx0ICAgIDxzY3JpcHQgc3JjPSdsaWIvcmFjdGl2ZS5qcyc+PC9zY3JpcHQ+XG5cdCAgICA8c2NyaXB0IHNyYz0nbGliL3JhY3RpdmUtdHJhbnNpdGlvbnMtc2xpZGUuanMnPjwvc2NyaXB0PlxuXG5cdE9yLCBpZiB5b3UncmUgdXNpbmcgYSBtb2R1bGUgbG9hZGVyLCByZXF1aXJlIHRoaXMgbW9kdWxlOlxuXG5cdCAgICAvLyByZXF1aXJpbmcgdGhlIHBsdWdpbiB3aWxsICdhY3RpdmF0ZScgaXQgLSBubyBuZWVkIHRvIHVzZVxuXHQgICAgLy8gdGhlIHJldHVybiB2YWx1ZVxuXHQgICAgcmVxdWlyZSggJ3JhY3RpdmUtdHJhbnNpdGlvbnMtc2xpZGUnICk7XG5cblx0WW91IGNhbiBzcGVjaWZ5IHRoZSBgZGVsYXlgLCBgZHVyYXRpb25gIGFuZCBgZWFzaW5nYCBwcm9wZXJ0aWVzXG5cdHVzaW5nIHRoZSBjb252ZW50aW9uYWwgc3ludGF4OlxuXG5cdCAgICA8ZGl2IGludHJvPSdzbGlkZTp7XCJkZWxheVwiOjUwMCxcImVhc2luZ1wiOlwiZWFzZS1vdXRcIn0nPmNvbnRlbnQ8L2Rpdj5cblxuXHRCb3RoIGBkZWxheWAgYW5kIGBkdXJhdGlvbmAgYXJlIGluIG1pbGxpc2Vjb25kcy4gVGhlIGBlYXNpbmdgIHZhbHVlXG5cdG11c3QgYmUgYSB2YWxpZCBDU1MgZWFzaW5nIGZ1bmN0aW9uIChzZWUgaHR0cDovL2N1YmljLWJlemllci5jb20vKS5cblxuKi9cblxuKGZ1bmN0aW9uICggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvLyBDb21tb24gSlMgKGkuZS4gYnJvd3NlcmlmeSkgZW52aXJvbm1lbnRcblx0aWYgKCB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRmYWN0b3J5KCByZXF1aXJlKCBcIi4vLi4vcmFjdGl2ZS9yYWN0aXZlLmpzXCIgKSApO1xuXHR9XG5cblx0Ly8gQU1EP1xuXHRlbHNlIGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXHRcdGRlZmluZShbICdyYWN0aXZlJyBdLCBmYWN0b3J5ICk7XG5cdH1cblxuXHQvLyBicm93c2VyIGdsb2JhbFxuXHRlbHNlIGlmICggZ2xvYmFsLlJhY3RpdmUgKSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsLlJhY3RpdmUgKTtcblx0fVxuXG5cdGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvciggJ0NvdWxkIG5vdCBmaW5kIFJhY3RpdmUhIEl0IG11c3QgYmUgbG9hZGVkIGJlZm9yZSB0aGUgcmFjdGl2ZS10cmFuc2l0aW9ucy1zbGlkZSBwbHVnaW4nICk7XG5cdH1cblxufSggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAoIFJhY3RpdmUgKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBzbGlkZSwgcHJvcHMsIGNvbGxhcHNlZCwgZGVmYXVsdHM7XG5cblx0ZGVmYXVsdHMgPSB7XG5cdFx0ZHVyYXRpb246IDMwMCxcblx0XHRlYXNpbmc6ICdlYXNlSW5PdXQnXG5cdH07XG5cblx0cHJvcHMgPSBbXG5cdFx0J2hlaWdodCcsXG5cdFx0J2JvcmRlclRvcFdpZHRoJyxcblx0XHQnYm9yZGVyQm90dG9tV2lkdGgnLFxuXHRcdCdwYWRkaW5nVG9wJyxcblx0XHQncGFkZGluZ0JvdHRvbScsXG5cdFx0J21hcmdpblRvcCcsXG5cdFx0J21hcmdpbkJvdHRvbSdcblx0XTtcblxuXHRjb2xsYXBzZWQgPSB7XG5cdFx0aGVpZ2h0OiAwLFxuXHRcdGJvcmRlclRvcFdpZHRoOiAwLFxuXHRcdGJvcmRlckJvdHRvbVdpZHRoOiAwLFxuXHRcdHBhZGRpbmdUb3A6IDAsXG5cdFx0cGFkZGluZ0JvdHRvbTogMCxcblx0XHRtYXJnaW5Ub3A6IDAsXG5cdFx0bWFyZ2luQm90dG9tOiAwXG5cdH07XG5cblx0c2xpZGUgPSBmdW5jdGlvbiAoIHQsIHBhcmFtcyApIHtcblx0XHR2YXIgdGFyZ2V0U3R5bGU7XG5cblx0XHRwYXJhbXMgPSB0LnByb2Nlc3NQYXJhbXMoIHBhcmFtcywgZGVmYXVsdHMgKTtcblxuXHRcdGlmICggdC5pc0ludHJvICkge1xuXHRcdFx0dGFyZ2V0U3R5bGUgPSB0LmdldFN0eWxlKCBwcm9wcyApO1xuXHRcdFx0dC5zZXRTdHlsZSggY29sbGFwc2VkICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIG1ha2Ugc3R5bGUgZXhwbGljaXQsIHNvIHdlJ3JlIG5vdCB0cmFuc2l0aW9uaW5nIHRvICdhdXRvJ1xuXHRcdFx0dC5zZXRTdHlsZSggdC5nZXRTdHlsZSggcHJvcHMgKSApO1xuXHRcdFx0dGFyZ2V0U3R5bGUgPSBjb2xsYXBzZWQ7XG5cdFx0fVxuXG5cdFx0dC5zZXRTdHlsZSggJ292ZXJmbG93WScsICdoaWRkZW4nICk7XG5cblx0XHR0LmFuaW1hdGVTdHlsZSggdGFyZ2V0U3R5bGUsIHBhcmFtcyApLnRoZW4oIHQuY29tcGxldGUgKTtcblx0fTtcblxuXHRSYWN0aXZlLnRyYW5zaXRpb25zLnNsaWRlID0gc2xpZGU7XG5cbn0pKTtcbiIsIi8qXG5cdHJhY3RpdmUuanMgdjAuNi4xXG5cdDIwMTQtMTAtMjUgLSBjb21taXQgM2E1NzZlYjMgXG5cblx0aHR0cDovL3JhY3RpdmVqcy5vcmdcblx0aHR0cDovL3R3aXR0ZXIuY29tL1JhY3RpdmVKU1xuXG5cdFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiovXG5cbiggZnVuY3Rpb24oIGdsb2JhbCApIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIG5vQ29uZmxpY3QgPSBnbG9iYWwuUmFjdGl2ZTtcblxuXHQvKiBjb25maWcvZGVmYXVsdHMvb3B0aW9ucy5qcyAqL1xuXHR2YXIgb3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXHRcdFx0Ly8gcmVuZGVyIHBsYWNlbWVudDpcblx0XHRcdGVsOiB2b2lkIDAsXG5cdFx0XHRhcHBlbmQ6IGZhbHNlLFxuXHRcdFx0Ly8gdGVtcGxhdGU6XG5cdFx0XHR0ZW1wbGF0ZToge1xuXHRcdFx0XHR2OiAxLFxuXHRcdFx0XHR0OiBbXVxuXHRcdFx0fSxcblx0XHRcdHlpZWxkOiBudWxsLFxuXHRcdFx0Ly8gcGFyc2U6XG5cdFx0XHRwcmVzZXJ2ZVdoaXRlc3BhY2U6IGZhbHNlLFxuXHRcdFx0c2FuaXRpemU6IGZhbHNlLFxuXHRcdFx0c3RyaXBDb21tZW50czogdHJ1ZSxcblx0XHRcdC8vIGRhdGEgJiBiaW5kaW5nOlxuXHRcdFx0ZGF0YToge30sXG5cdFx0XHRjb21wdXRlZDoge30sXG5cdFx0XHRtYWdpYzogZmFsc2UsXG5cdFx0XHRtb2RpZnlBcnJheXM6IHRydWUsXG5cdFx0XHRhZGFwdDogW10sXG5cdFx0XHRpc29sYXRlZDogZmFsc2UsXG5cdFx0XHR0d293YXk6IHRydWUsXG5cdFx0XHRsYXp5OiBmYWxzZSxcblx0XHRcdC8vIHRyYW5zaXRpb25zOlxuXHRcdFx0bm9JbnRybzogZmFsc2UsXG5cdFx0XHR0cmFuc2l0aW9uc0VuYWJsZWQ6IHRydWUsXG5cdFx0XHRjb21wbGV0ZTogdm9pZCAwLFxuXHRcdFx0Ly8gY3NzOlxuXHRcdFx0bm9Dc3NUcmFuc2Zvcm06IGZhbHNlLFxuXHRcdFx0Ly8gZGVidWc6XG5cdFx0XHRkZWJ1ZzogZmFsc2Vcblx0XHR9O1xuXHRcdHJldHVybiBkZWZhdWx0T3B0aW9ucztcblx0fSgpO1xuXG5cdC8qIGNvbmZpZy9kZWZhdWx0cy9lYXNpbmcuanMgKi9cblx0dmFyIGVhc2luZyA9IHtcblx0XHRsaW5lYXI6IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRyZXR1cm4gcG9zO1xuXHRcdH0sXG5cdFx0ZWFzZUluOiBmdW5jdGlvbiggcG9zICkge1xuXHRcdFx0cmV0dXJuIE1hdGgucG93KCBwb3MsIDMgKTtcblx0XHR9LFxuXHRcdGVhc2VPdXQ6IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIHBvcyAtIDEsIDMgKSArIDE7XG5cdFx0fSxcblx0XHRlYXNlSW5PdXQ6IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRpZiAoICggcG9zIC89IDAuNSApIDwgMSApIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIE1hdGgucG93KCBwb3MsIDMgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwLjUgKiAoIE1hdGgucG93KCBwb3MgLSAyLCAzICkgKyAyICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIGNpcmN1bGFyLmpzICovXG5cdHZhciBjaXJjdWxhciA9IFtdO1xuXG5cdC8qIHV0aWxzL2hhc093blByb3BlcnR5LmpzICovXG5cdHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cdC8qIHV0aWxzL2lzQXJyYXkuanMgKi9cblx0dmFyIGlzQXJyYXkgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdFx0Ly8gdGhhbmtzLCBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9pbnN0YW5jZW9mLWNvbnNpZGVyZWQtaGFybWZ1bC1vci1ob3ctdG8td3JpdGUtYS1yb2J1c3QtaXNhcnJheS9cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdFx0cmV0dXJuIHRvU3RyaW5nLmNhbGwoIHRoaW5nICkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHV0aWxzL2lzT2JqZWN0LmpzICovXG5cdHZhciBpc09iamVjdCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdFx0cmV0dXJuIHRoaW5nICYmIHRvU3RyaW5nLmNhbGwoIHRoaW5nICkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB1dGlscy9pc051bWVyaWMuanMgKi9cblx0dmFyIGlzTnVtZXJpYyA9IGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRyZXR1cm4gIWlzTmFOKCBwYXJzZUZsb2F0KCB0aGluZyApICkgJiYgaXNGaW5pdGUoIHRoaW5nICk7XG5cdH07XG5cblx0LyogY29uZmlnL2RlZmF1bHRzL2ludGVycG9sYXRvcnMuanMgKi9cblx0dmFyIGludGVycG9sYXRvcnMgPSBmdW5jdGlvbiggY2lyY3VsYXIsIGhhc093blByb3BlcnR5LCBpc0FycmF5LCBpc09iamVjdCwgaXNOdW1lcmljICkge1xuXG5cdFx0dmFyIGludGVycG9sYXRvcnMsIGludGVycG9sYXRlLCBjc3NMZW5ndGhQYXR0ZXJuO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aW50ZXJwb2xhdGUgPSBjaXJjdWxhci5pbnRlcnBvbGF0ZTtcblx0XHR9ICk7XG5cdFx0Y3NzTGVuZ3RoUGF0dGVybiA9IC9eKFsrLV0/WzAtOV0rXFwuPyg/OlswLTldKyk/KShweHxlbXxleHwlfGlufGNtfG1tfHB0fHBjKSQvO1xuXHRcdGludGVycG9sYXRvcnMgPSB7XG5cdFx0XHRudW1iZXI6IGZ1bmN0aW9uKCBmcm9tLCB0byApIHtcblx0XHRcdFx0dmFyIGRlbHRhO1xuXHRcdFx0XHRpZiAoICFpc051bWVyaWMoIGZyb20gKSB8fCAhaXNOdW1lcmljKCB0byApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZyb20gPSArZnJvbTtcblx0XHRcdFx0dG8gPSArdG87XG5cdFx0XHRcdGRlbHRhID0gdG8gLSBmcm9tO1xuXHRcdFx0XHRpZiAoICFkZWx0YSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnJvbTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnJvbSArIHQgKiBkZWx0YTtcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRhcnJheTogZnVuY3Rpb24oIGZyb20sIHRvICkge1xuXHRcdFx0XHR2YXIgaW50ZXJtZWRpYXRlLCBpbnRlcnBvbGF0b3JzLCBsZW4sIGk7XG5cdFx0XHRcdGlmICggIWlzQXJyYXkoIGZyb20gKSB8fCAhaXNBcnJheSggdG8gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbnRlcm1lZGlhdGUgPSBbXTtcblx0XHRcdFx0aW50ZXJwb2xhdG9ycyA9IFtdO1xuXHRcdFx0XHRpID0gbGVuID0gTWF0aC5taW4oIGZyb20ubGVuZ3RoLCB0by5sZW5ndGggKTtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aW50ZXJwb2xhdG9yc1sgaSBdID0gaW50ZXJwb2xhdGUoIGZyb21bIGkgXSwgdG9bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHN1cnBsdXMgdmFsdWVzIC0gZG9uJ3QgaW50ZXJwb2xhdGUsIGJ1dCBkb24ndCBleGNsdWRlIHRoZW0gZWl0aGVyXG5cdFx0XHRcdGZvciAoIGkgPSBsZW47IGkgPCBmcm9tLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdGludGVybWVkaWF0ZVsgaSBdID0gZnJvbVsgaSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIGkgPSBsZW47IGkgPCB0by5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIGkgXSA9IHRvWyBpIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB0ICkge1xuXHRcdFx0XHRcdHZhciBpID0gbGVuO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBpIF0gPSBpbnRlcnBvbGF0b3JzWyBpIF0oIHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGludGVybWVkaWF0ZTtcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRvYmplY3Q6IGZ1bmN0aW9uKCBmcm9tLCB0byApIHtcblx0XHRcdFx0dmFyIHByb3BlcnRpZXMsIGxlbiwgaW50ZXJwb2xhdG9ycywgaW50ZXJtZWRpYXRlLCBwcm9wO1xuXHRcdFx0XHRpZiAoICFpc09iamVjdCggZnJvbSApIHx8ICFpc09iamVjdCggdG8gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9wZXJ0aWVzID0gW107XG5cdFx0XHRcdGludGVybWVkaWF0ZSA9IHt9O1xuXHRcdFx0XHRpbnRlcnBvbGF0b3JzID0ge307XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gZnJvbSApIHtcblx0XHRcdFx0XHRpZiAoIGhhc093blByb3BlcnR5LmNhbGwoIGZyb20sIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdGlmICggaGFzT3duUHJvcGVydHkuY2FsbCggdG8sIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKCBwcm9wICk7XG5cdFx0XHRcdFx0XHRcdGludGVycG9sYXRvcnNbIHByb3AgXSA9IGludGVycG9sYXRlKCBmcm9tWyBwcm9wIF0sIHRvWyBwcm9wIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGludGVybWVkaWF0ZVsgcHJvcCBdID0gZnJvbVsgcHJvcCBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCBwcm9wIGluIHRvICkge1xuXHRcdFx0XHRcdGlmICggaGFzT3duUHJvcGVydHkuY2FsbCggdG8sIHByb3AgKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbCggZnJvbSwgcHJvcCApICkge1xuXHRcdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBwcm9wIF0gPSB0b1sgcHJvcCBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRsZW4gPSBwcm9wZXJ0aWVzLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB0ICkge1xuXHRcdFx0XHRcdHZhciBpID0gbGVuLFxuXHRcdFx0XHRcdFx0cHJvcDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdHByb3AgPSBwcm9wZXJ0aWVzWyBpIF07XG5cdFx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIHByb3AgXSA9IGludGVycG9sYXRvcnNbIHByb3AgXSggdCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaW50ZXJtZWRpYXRlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIGludGVycG9sYXRvcnM7XG5cdH0oIGNpcmN1bGFyLCBoYXNPd24sIGlzQXJyYXksIGlzT2JqZWN0LCBpc051bWVyaWMgKTtcblxuXHQvKiBjb25maWcvc3ZnLmpzICovXG5cdHZhciBzdmcgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBzdmc7XG5cdFx0aWYgKCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0c3ZnID0gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN2ZyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoICdodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlJywgJzEuMScgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN2Zztcblx0fSgpO1xuXG5cdC8qIHV0aWxzL3dhcm4uanMgKi9cblx0dmFyIHdhcm4gPSBmdW5jdGlvbigpIHtcblxuXHRcdC8qIGdsb2JhbCBjb25zb2xlICovXG5cdFx0dmFyIHdhcm4sIHdhcm5lZCA9IHt9O1xuXHRcdGlmICggdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUud2Fybi5hcHBseSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHdhcm4gPSBmdW5jdGlvbiggbWVzc2FnZSwgYWxsb3dEdXBsaWNhdGVzICkge1xuXHRcdFx0XHRpZiAoICFhbGxvd0R1cGxpY2F0ZXMgKSB7XG5cdFx0XHRcdFx0aWYgKCB3YXJuZWRbIG1lc3NhZ2UgXSApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2FybmVkWyBtZXNzYWdlIF0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnNvbGUud2FybiggJyVjUmFjdGl2ZS5qczogJWMnICsgbWVzc2FnZSwgJ2NvbG9yOiByZ2IoMTE0LCAxNTcsIDUyKTsnLCAnY29sb3I6IHJnYig4NSwgODUsIDg1KTsnICk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3YXJuID0gZnVuY3Rpb24oKSB7fTtcblx0XHR9XG5cdFx0cmV0dXJuIHdhcm47XG5cdH0oKTtcblxuXHQvKiBjb25maWcvZXJyb3JzLmpzICovXG5cdHZhciBlcnJvcnMgPSB7XG5cdFx0bWlzc2luZ1BhcnNlcjogJ01pc3NpbmcgUmFjdGl2ZS5wYXJzZSAtIGNhbm5vdCBwYXJzZSB0ZW1wbGF0ZS4gRWl0aGVyIHByZXBhcnNlIG9yIHVzZSB0aGUgdmVyc2lvbiB0aGF0IGluY2x1ZGVzIHRoZSBwYXJzZXInLFxuXHRcdG1lcmdlQ29tcGFyaXNvbkZhaWw6ICdNZXJnZSBvcGVyYXRpb246IGNvbXBhcmlzb24gZmFpbGVkLiBGYWxsaW5nIGJhY2sgdG8gaWRlbnRpdHkgY2hlY2tpbmcnLFxuXHRcdG5vQ29tcG9uZW50RXZlbnRBcmd1bWVudHM6ICdDb21wb25lbnRzIGN1cnJlbnRseSBvbmx5IHN1cHBvcnQgc2ltcGxlIGV2ZW50cyAtIHlvdSBjYW5ub3QgaW5jbHVkZSBhcmd1bWVudHMuIFNvcnJ5IScsXG5cdFx0bm9UZW1wbGF0ZUZvclBhcnRpYWw6ICdDb3VsZCBub3QgZmluZCB0ZW1wbGF0ZSBmb3IgcGFydGlhbCBcIntuYW1lfVwiJyxcblx0XHRub05lc3RlZFBhcnRpYWxzOiAnUGFydGlhbHMgKHt7PntuYW1lfX19KSBjYW5ub3QgY29udGFpbiBuZXN0ZWQgaW5saW5lIHBhcnRpYWxzJyxcblx0XHRldmFsdWF0aW9uRXJyb3I6ICdFcnJvciBldmFsdWF0aW5nIFwie3VuaXF1ZVN0cmluZ31cIjoge2Vycn0nLFxuXHRcdGJhZEFyZ3VtZW50czogJ0JhZCBhcmd1bWVudHMgXCJ7YXJndW1lbnRzfVwiLiBJXFwnbSBub3QgYWxsb3dlZCB0byBhcmd1ZSB1bmxlc3MgeW91XFwndmUgcGFpZC4nLFxuXHRcdGZhaWxlZENvbXB1dGF0aW9uOiAnRmFpbGVkIHRvIGNvbXB1dGUgXCJ7a2V5fVwiOiB7ZXJyfScsXG5cdFx0bWlzc2luZ1BsdWdpbjogJ01pc3NpbmcgXCJ7bmFtZX1cIiB7cGx1Z2lufSBwbHVnaW4uIFlvdSBtYXkgbmVlZCB0byBkb3dubG9hZCBhIHtwbHVnaW59IHZpYSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9wbHVnaW5zI3twbHVnaW59cycsXG5cdFx0YmFkUmFkaW9JbnB1dEJpbmRpbmc6ICdBIHJhZGlvIGlucHV0IGNhbiBoYXZlIHR3by13YXkgYmluZGluZyBvbiBpdHMgbmFtZSBhdHRyaWJ1dGUsIG9yIGl0cyBjaGVja2VkIGF0dHJpYnV0ZSAtIG5vdCBib3RoJyxcblx0XHRub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm46ICdBIGZ1bmN0aW9uIHdhcyBzcGVjaWZpZWQgZm9yIFwie25hbWV9XCIge3JlZ2lzdHJ5fSwgYnV0IG5vIHtyZWdpc3RyeX0gd2FzIHJldHVybmVkJyxcblx0XHRkZWZhdWx0RWxTcGVjaWZpZWQ6ICdUaGUgPHtuYW1lfS8+IGNvbXBvbmVudCBoYXMgYSBkZWZhdWx0IGBlbGAgcHJvcGVydHk7IGl0IGhhcyBiZWVuIGRpc3JlZ2FyZGVkJyxcblx0XHRub0VsZW1lbnRQcm94eUV2ZW50V2lsZGNhcmRzOiAnT25seSBjb21wb25lbnQgcHJveHktZXZlbnRzIG1heSBjb250YWluIFwiKlwiIHdpbGRjYXJkcywgPHtlbGVtZW50fSBvbi17ZXZlbnR9Lz4gaXMgbm90IHZhbGlkLicsXG5cdFx0bWV0aG9kRGVwcmVjYXRlZDogJ1RoZSBtZXRob2QgXCJ7ZGVwcmVjYXRlZH1cIiBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIFwie3JlcGxhY2VtZW50fVwiIGFuZCB3aWxsIGxpa2VseSBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuIFNlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9taWdyYXRpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJ1xuXHR9O1xuXG5cdC8qIHV0aWxzL2xvZy5qcyAqL1xuXHR2YXIgbG9nID0gZnVuY3Rpb24oIGNvbnNvbGV3YXJuLCBlcnJvcnMgKSB7XG5cblx0XHR2YXIgbG9nID0ge1xuXHRcdFx0d2FybjogZnVuY3Rpb24oIG9wdGlvbnMsIHBhc3N0aHJ1ICkge1xuXHRcdFx0XHRpZiAoICFvcHRpb25zLmRlYnVnICYmICFwYXNzdGhydSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy53YXJuQWx3YXlzKCBvcHRpb25zICk7XG5cdFx0XHR9LFxuXHRcdFx0d2FybkFsd2F5czogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHRoaXMubG9nZ2VyKCBnZXRNZXNzYWdlKCBvcHRpb25zICksIG9wdGlvbnMuYWxsb3dEdXBsaWNhdGVzICk7XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3I6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0XHR0aGlzLmVycm9yT25seSggb3B0aW9ucyApO1xuXHRcdFx0XHRpZiAoICFvcHRpb25zLmRlYnVnICkge1xuXHRcdFx0XHRcdHRoaXMud2Fybiggb3B0aW9ucywgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3JPbmx5OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmRlYnVnICkge1xuXHRcdFx0XHRcdHRoaXMuY3JpdGljYWwoIG9wdGlvbnMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGNyaXRpY2FsOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0dmFyIGVyciA9IG9wdGlvbnMuZXJyIHx8IG5ldyBFcnJvciggZ2V0TWVzc2FnZSggb3B0aW9ucyApICk7XG5cdFx0XHRcdHRoaXMudGhyb3dlciggZXJyICk7XG5cdFx0XHR9LFxuXHRcdFx0bG9nZ2VyOiBjb25zb2xld2Fybixcblx0XHRcdHRocm93ZXI6IGZ1bmN0aW9uKCBlcnIgKSB7XG5cdFx0XHRcdHRocm93IGVycjtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0TWVzc2FnZSggb3B0aW9ucyApIHtcblx0XHRcdHZhciBtZXNzYWdlID0gZXJyb3JzWyBvcHRpb25zLm1lc3NhZ2UgXSB8fCBvcHRpb25zLm1lc3NhZ2UgfHwgJyc7XG5cdFx0XHRyZXR1cm4gaW50ZXJwb2xhdGUoIG1lc3NhZ2UsIG9wdGlvbnMuYXJncyApO1xuXHRcdH1cblx0XHQvLyBzaW1wbGUgaW50ZXJwb2xhdGlvbi4gcHJvYmFibHkgcXVpY2tlciAoYW5kIGJldHRlcikgb3V0IHRoZXJlLFxuXHRcdC8vIGJ1dCBsb2cgaXMgbm90IGluIGdvbGRlbiBwYXRoIG9mIGV4ZWN1dGlvbiwgb25seSBleGNlcHRpb25zXG5cdFx0ZnVuY3Rpb24gaW50ZXJwb2xhdGUoIG1lc3NhZ2UsIGFyZ3MgKSB7XG5cdFx0XHRyZXR1cm4gbWVzc2FnZS5yZXBsYWNlKCAveyhbXnt9XSopfS9nLCBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdFx0cmV0dXJuIGFyZ3NbIGIgXTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIGxvZztcblx0fSggd2FybiwgZXJyb3JzICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL2hvb2tzL0hvb2suanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2sgPSBmdW5jdGlvbiggbG9nICkge1xuXG5cdFx0dmFyIGRlcHJlY2F0aW9ucyA9IHtcblx0XHRcdGNvbnN0cnVjdDoge1xuXHRcdFx0XHRkZXByZWNhdGVkOiAnYmVmb3JlSW5pdCcsXG5cdFx0XHRcdHJlcGxhY2VtZW50OiAnb25jb25zdHJ1Y3QnXG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiB7XG5cdFx0XHRcdGRlcHJlY2F0ZWQ6ICdpbml0Jyxcblx0XHRcdFx0bWVzc2FnZTogJ1RoZSBcImluaXRcIiBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZCAnICsgJ2FuZCB3aWxsIGxpa2VseSBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuICcgKyAnWW91IGNhbiBlaXRoZXIgdXNlIHRoZSBcIm9uaW5pdFwiIG1ldGhvZCB3aGljaCB3aWxsIGZpcmUgJyArICdvbmx5IG9uY2UgcHJpb3IgdG8sIGFuZCByZWdhcmRsZXNzIG9mLCBhbnkgZXZlbnR1YWwgcmFjdGl2ZSAnICsgJ2luc3RhbmNlIGJlaW5nIHJlbmRlcmVkLCBvciBpZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlICcgKyAncmVuZGVyZWQgRE9NLCB1c2UgXCJvbnJlbmRlclwiIGluc3RlYWQuICcgKyAnU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L21pZ3JhdGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nXG5cdFx0XHR9LFxuXHRcdFx0Y29tcGxldGU6IHtcblx0XHRcdFx0ZGVwcmVjYXRlZDogJ2NvbXBsZXRlJyxcblx0XHRcdFx0cmVwbGFjZW1lbnQ6ICdvbmNvbXBsZXRlJ1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBIb29rKCBldmVudCApIHtcblx0XHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0XHRcdHRoaXMubWV0aG9kID0gJ29uJyArIGV2ZW50O1xuXHRcdFx0dGhpcy5kZXByZWNhdGUgPSBkZXByZWNhdGlvbnNbIGV2ZW50IF07XG5cdFx0fVxuXHRcdEhvb2sucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbiggcmFjdGl2ZSwgYXJnICkge1xuXHRcdFx0ZnVuY3Rpb24gY2FsbCggbWV0aG9kICkge1xuXHRcdFx0XHRpZiAoIHJhY3RpdmVbIG1ldGhvZCBdICkge1xuXHRcdFx0XHRcdGFyZyA/IHJhY3RpdmVbIG1ldGhvZCBdKCBhcmcgKSA6IHJhY3RpdmVbIG1ldGhvZCBdKCk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhbGwoIHRoaXMubWV0aG9kICk7XG5cdFx0XHRpZiAoICFyYWN0aXZlWyB0aGlzLm1ldGhvZCBdICYmIHRoaXMuZGVwcmVjYXRlICYmIGNhbGwoIHRoaXMuZGVwcmVjYXRlLmRlcHJlY2F0ZWQgKSApIHtcblx0XHRcdFx0bG9nLndhcm5BbHdheXMoIHtcblx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiB0aGlzLmRlcHJlY2F0ZS5tZXNzYWdlIHx8ICdtZXRob2REZXByZWNhdGVkJyxcblx0XHRcdFx0XHRhcmdzOiB0aGlzLmRlcHJlY2F0ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRhcmcgPyByYWN0aXZlLmZpcmUoIHRoaXMuZXZlbnQsIGFyZyApIDogcmFjdGl2ZS5maXJlKCB0aGlzLmV2ZW50ICk7XG5cdFx0fTtcblx0XHRyZXR1cm4gSG9vaztcblx0fSggbG9nICk7XG5cblx0LyogdXRpbHMvcmVtb3ZlRnJvbUFycmF5LmpzICovXG5cdHZhciByZW1vdmVGcm9tQXJyYXkgPSBmdW5jdGlvbiggYXJyYXksIG1lbWJlciApIHtcblx0XHR2YXIgaW5kZXggPSBhcnJheS5pbmRleE9mKCBtZW1iZXIgKTtcblx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdGFycmF5LnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdXRpbHMvUHJvbWlzZS5qcyAqL1xuXHR2YXIgUHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBfUHJvbWlzZSwgUEVORElORyA9IHt9LFxuXHRcdFx0RlVMRklMTEVEID0ge30sXG5cdFx0XHRSRUpFQ1RFRCA9IHt9O1xuXHRcdGlmICggdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHQvLyB1c2UgbmF0aXZlIFByb21pc2Vcblx0XHRcdF9Qcm9taXNlID0gUHJvbWlzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0X1Byb21pc2UgPSBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdHZhciBmdWxmaWxsZWRIYW5kbGVycyA9IFtdLFxuXHRcdFx0XHRcdHJlamVjdGVkSGFuZGxlcnMgPSBbXSxcblx0XHRcdFx0XHRzdGF0ZSA9IFBFTkRJTkcsXG5cdFx0XHRcdFx0cmVzdWx0LCBkaXNwYXRjaEhhbmRsZXJzLCBtYWtlUmVzb2x2ZXIsIGZ1bGZpbCwgcmVqZWN0LCBwcm9taXNlO1xuXHRcdFx0XHRtYWtlUmVzb2x2ZXIgPSBmdW5jdGlvbiggbmV3U3RhdGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRcdGlmICggc3RhdGUgIT09IFBFTkRJTkcgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlc3VsdCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0c3RhdGUgPSBuZXdTdGF0ZTtcblx0XHRcdFx0XHRcdGRpc3BhdGNoSGFuZGxlcnMgPSBtYWtlRGlzcGF0Y2hlciggc3RhdGUgPT09IEZVTEZJTExFRCA/IGZ1bGZpbGxlZEhhbmRsZXJzIDogcmVqZWN0ZWRIYW5kbGVycywgcmVzdWx0ICk7XG5cdFx0XHRcdFx0XHQvLyBkaXNwYXRjaCBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBoYW5kbGVycyBhc3luY2hyb25vdXNseVxuXHRcdFx0XHRcdFx0d2FpdCggZGlzcGF0Y2hIYW5kbGVycyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHRcdGZ1bGZpbCA9IG1ha2VSZXNvbHZlciggRlVMRklMTEVEICk7XG5cdFx0XHRcdHJlamVjdCA9IG1ha2VSZXNvbHZlciggUkVKRUNURUQgKTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjYWxsYmFjayggZnVsZmlsLCByZWplY3QgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0XHRyZWplY3QoIGVyciApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdFx0Ly8gYHRoZW4oKWAgcmV0dXJucyBhIFByb21pc2UgLSAyLjIuN1xuXHRcdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCApIHtcblx0XHRcdFx0XHRcdHZhciBwcm9taXNlMiA9IG5ldyBfUHJvbWlzZSggZnVuY3Rpb24oIGZ1bGZpbCwgcmVqZWN0ICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgcHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyID0gZnVuY3Rpb24oIGhhbmRsZXIsIGhhbmRsZXJzLCBmb3J3YXJkICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIDIuMi4xLjFcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aGFuZGxlcnMucHVzaCggZnVuY3Rpb24oIHAxcmVzdWx0ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgeDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR4ID0gaGFuZGxlciggcDFyZXN1bHQgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBwcm9taXNlMiwgeCwgZnVsZmlsLCByZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZWplY3QoIGVyciApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvcndhcmQgdGhlIHJlc3VsdCBvZiBwcm9taXNlMSB0byBwcm9taXNlMiwgaWYgcmVzb2x1dGlvbiBoYW5kbGVyc1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gYXJlIG5vdCBnaXZlblxuXHRcdFx0XHRcdFx0XHRcdFx0aGFuZGxlcnMucHVzaCggZm9yd2FyZCApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0Ly8gMi4yXG5cdFx0XHRcdFx0XHRcdHByb2Nlc3NSZXNvbHV0aW9uSGFuZGxlciggb25GdWxmaWxsZWQsIGZ1bGZpbGxlZEhhbmRsZXJzLCBmdWxmaWwgKTtcblx0XHRcdFx0XHRcdFx0cHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyKCBvblJlamVjdGVkLCByZWplY3RlZEhhbmRsZXJzLCByZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gUEVORElORyApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJvbWlzZSBoYXMgcmVzb2x2ZWQgYWxyZWFkeSwgZGlzcGF0Y2ggdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXJzIGFzeW5jaHJvbm91c2x5XG5cdFx0XHRcdFx0XHRcdFx0d2FpdCggZGlzcGF0Y2hIYW5kbGVycyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZTI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRwcm9taXNlWyAnY2F0Y2gnIF0gPSBmdW5jdGlvbiggb25SZWplY3RlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy50aGVuKCBudWxsLCBvblJlamVjdGVkICk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdFx0fTtcblx0XHRcdF9Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uKCBwcm9taXNlcyApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZSggZnVuY3Rpb24oIGZ1bGZpbCwgcmVqZWN0ICkge1xuXHRcdFx0XHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHRcdFx0XHRcdHBlbmRpbmcsIGksIHByb2Nlc3NQcm9taXNlO1xuXHRcdFx0XHRcdGlmICggIXByb21pc2VzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGZ1bGZpbCggcmVzdWx0ICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHByb2Nlc3NQcm9taXNlID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0XHRwcm9taXNlc1sgaSBdLnRoZW4oIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0WyBpIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0aWYgKCAhLS1wZW5kaW5nICkge1xuXHRcdFx0XHRcdFx0XHRcdGZ1bGZpbCggcmVzdWx0ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIHJlamVjdCApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cGVuZGluZyA9IGkgPSBwcm9taXNlcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRwcm9jZXNzUHJvbWlzZSggaSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fTtcblx0XHRcdF9Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgX1Byb21pc2UoIGZ1bmN0aW9uKCBmdWxmaWwgKSB7XG5cdFx0XHRcdFx0ZnVsZmlsKCB2YWx1ZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9O1xuXHRcdFx0X1Byb21pc2UucmVqZWN0ID0gZnVuY3Rpb24oIHJlYXNvbiApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZSggZnVuY3Rpb24oIGZ1bGZpbCwgcmVqZWN0ICkge1xuXHRcdFx0XHRcdHJlamVjdCggcmVhc29uICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdF9fZXhwb3J0ID0gX1Byb21pc2U7XG5cdFx0Ly8gVE9ETyB1c2UgTXV0YXRpb25PYnNlcnZlcnMgb3Igc29tZXRoaW5nIHRvIHNpbXVsYXRlIHNldEltbWVkaWF0ZVxuXHRcdGZ1bmN0aW9uIHdhaXQoIGNhbGxiYWNrICkge1xuXHRcdFx0c2V0VGltZW91dCggY2FsbGJhY2ssIDAgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBtYWtlRGlzcGF0Y2hlciggaGFuZGxlcnMsIHJlc3VsdCApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGhhbmRsZXI7XG5cdFx0XHRcdHdoaWxlICggaGFuZGxlciA9IGhhbmRsZXJzLnNoaWZ0KCkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlciggcmVzdWx0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZSggcHJvbWlzZSwgeCwgZnVsZmlsLCByZWplY3QgKSB7XG5cdFx0XHQvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlXG5cdFx0XHR2YXIgdGhlbjtcblx0XHRcdC8vIDIuMy4xXG5cdFx0XHRpZiAoIHggPT09IHByb21pc2UgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdBIHByb21pc2VcXCdzIGZ1bGZpbGxtZW50IGhhbmRsZXIgY2Fubm90IHJldHVybiB0aGUgc2FtZSBwcm9taXNlJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gMi4zLjJcblx0XHRcdGlmICggeCBpbnN0YW5jZW9mIF9Qcm9taXNlICkge1xuXHRcdFx0XHR4LnRoZW4oIGZ1bGZpbCwgcmVqZWN0ICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB4ICYmICggdHlwZW9mIHggPT09ICdvYmplY3QnIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICkgKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhlbiA9IHgudGhlbjtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0cmVqZWN0KCBlICk7XG5cdFx0XHRcdFx0Ly8gMi4zLjMuMlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyAyLjMuMy4zXG5cdFx0XHRcdGlmICggdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0dmFyIGNhbGxlZCwgcmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2U7XG5cdFx0XHRcdFx0cmVzb2x2ZVByb21pc2UgPSBmdW5jdGlvbiggeSApIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGVkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSggcHJvbWlzZSwgeSwgZnVsZmlsLCByZWplY3QgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHJlamVjdFByb21pc2UgPSBmdW5jdGlvbiggciApIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGVkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0cmVqZWN0KCByICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dGhlbi5jYWxsKCB4LCByZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZSApO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhY2FsbGVkICkge1xuXHRcdFx0XHRcdFx0XHQvLyAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoIGUgKTtcblx0XHRcdFx0XHRcdFx0Ly8gMi4zLjMuMy40LjJcblx0XHRcdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmdWxmaWwoIHggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZnVsZmlsKCB4ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHV0aWxzL25vcm1hbGlzZVJlZi5qcyAqL1xuXHR2YXIgbm9ybWFsaXNlUmVmID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgcmVnZXggPSAvXFxbXFxzKihcXCp8WzAtOV18WzEtOV1bMC05XSspXFxzKlxcXS9nO1xuXHRcdHJldHVybiBmdW5jdGlvbiBub3JtYWxpc2VSZWYoIHJlZiApIHtcblx0XHRcdHJldHVybiAoIHJlZiB8fCAnJyApLnJlcGxhY2UoIHJlZ2V4LCAnLiQxJyApO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiBzaGFyZWQvZ2V0SW5uZXJDb250ZXh0LmpzICovXG5cdHZhciBnZXRJbm5lckNvbnRleHQgPSBmdW5jdGlvbiggZnJhZ21lbnQgKSB7XG5cdFx0ZG8ge1xuXHRcdFx0aWYgKCBmcmFnbWVudC5jb250ZXh0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmcmFnbWVudC5jb250ZXh0O1xuXHRcdFx0fVxuXHRcdH0gd2hpbGUgKCBmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudCApO1xuXHRcdHJldHVybiAnJztcblx0fTtcblxuXHQvKiB1dGlscy9pc0VxdWFsLmpzICovXG5cdHZhciBpc0VxdWFsID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBudWxsICYmIGIgPT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgYSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgPT09ICdvYmplY3QnICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gYSA9PT0gYjtcblx0fTtcblxuXHQvKiBzaGFyZWQvY3JlYXRlQ29tcG9uZW50QmluZGluZy5qcyAqL1xuXHR2YXIgY3JlYXRlQ29tcG9uZW50QmluZGluZyA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgaXNFcXVhbCApIHtcblxuXHRcdHZhciBydW5sb29wO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHJ1bmxvb3AgPSBjaXJjdWxhci5ydW5sb29wO1xuXHRcdH0gKTtcblx0XHR2YXIgQmluZGluZyA9IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXlwYXRoLCBvdGhlckluc3RhbmNlLCBvdGhlcktleXBhdGggKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0dGhpcy5vdGhlckluc3RhbmNlID0gb3RoZXJJbnN0YW5jZTtcblx0XHRcdHRoaXMub3RoZXJLZXlwYXRoID0gb3RoZXJLZXlwYXRoO1xuXHRcdFx0dGhpcy5sb2NrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzJDAudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0fTtcblx0XHRcdHRoaXMudW5sb2NrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzJDAudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLmJpbmQoKTtcblx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCggdGhpcy5rZXlwYXRoICk7XG5cdFx0fTtcblx0XHRCaW5kaW5nLnByb3RvdHlwZSA9IHtcblx0XHRcdGlzTG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudXBkYXRpbmcgfHwgdGhpcy5jb3VudGVycGFydCAmJiB0aGlzLmNvdW50ZXJwYXJ0LnVwZGF0aW5nO1xuXHRcdFx0fSxcblx0XHRcdHNodWZmbGU6IGZ1bmN0aW9uKCBuZXdJbmRpY2VzLCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy5wcm9wYWdhdGVDaGFuZ2UoIHZhbHVlLCBuZXdJbmRpY2VzICk7XG5cdFx0XHR9LFxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy5wcm9wYWdhdGVDaGFuZ2UoIHZhbHVlICk7XG5cdFx0XHR9LFxuXHRcdFx0cHJvcGFnYXRlQ2hhbmdlOiBmdW5jdGlvbiggdmFsdWUsIG5ld0luZGljZXMgKSB7XG5cdFx0XHRcdHZhciBvdGhlcjtcblx0XHRcdFx0Ly8gT25seSAqeW91KiBjYW4gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuXHRcdFx0XHRpZiAoIHRoaXMuaXNMb2NrZWQoKSApIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5sb2NrKCk7XG5cdFx0XHRcdFx0Ly8gVE9ETyBtYXliZSB0aGUgY2FzZSB0aGF0IGB2YWx1ZSA9PT0gdGhpcy52YWx1ZWAgLSBzaG91bGQgdGhhdCByZXN1bHRcblx0XHRcdFx0XHQvLyBpbiBhbiB1cGRhdGUgcmF0aGVyIHRoYW4gYSBzZXQ/XG5cdFx0XHRcdFx0Ly8gaWYgdGhlIG90aGVyIHZpZXdtb2RlbCBpcyBhbHJlYWR5IGxvY2tlZCB1cCwgbmVlZCB0byBkbyBhIGRlZmVycmVkIHVwZGF0ZVxuXHRcdFx0XHRcdGlmICggIXJ1bmxvb3AuYWRkVmlld21vZGVsKCBvdGhlciA9IHRoaXMub3RoZXJJbnN0YW5jZS52aWV3bW9kZWwgKSAmJiB0aGlzLmNvdW50ZXJwYXJ0LnZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJ1bmxvb3AuYWRkVmlld21vZGVsKCBvdGhlciApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG5ld0luZGljZXMgKSB7XG5cdFx0XHRcdFx0XHRvdGhlci5zbWFydFVwZGF0ZSggdGhpcy5vdGhlcktleXBhdGgsIHZhbHVlLCBuZXdJbmRpY2VzICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICggaXNTZXR0YWJsZSggb3RoZXIsIHRoaXMub3RoZXJLZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0XHRcdG90aGVyLnNldCggdGhpcy5vdGhlcktleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHQvLyBUT0RPIHdpbGwgdGhlIGNvdW50ZXJwYXJ0IHVwZGF0ZSBhZnRlciB0aGlzIGxpbmUsIGR1cmluZ1xuXHRcdFx0XHRcdC8vIHRoZSBydW5sb29wIGVuZCBjeWNsZT8gbWF5IGJlIGEgcHJvYmxlbS4uLlxuXHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCB0aGlzLnVubG9jayApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVmaW5lVmFsdWU6IGZ1bmN0aW9uKCBrZXlwYXRocyApIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHZhciBvdGhlcjtcblx0XHRcdFx0aWYgKCB0aGlzLmlzTG9ja2VkKCkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubG9jaygpO1xuXHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggb3RoZXIgPSB0aGlzLm90aGVySW5zdGFuY2Uudmlld21vZGVsICk7XG5cdFx0XHRcdGtleXBhdGhzLm1hcCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5vdGhlcktleXBhdGggKyBrZXlwYXRoLnN1YnN0ciggdGhpcyQwLmtleXBhdGgubGVuZ3RoICk7XG5cdFx0XHRcdH0gKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3RoZXIubWFyaygga2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCB0aGlzLnVubG9jayApO1xuXHRcdFx0fSxcblx0XHRcdGJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLnVuYmluZCgpO1xuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBuZXdLZXlwYXRoO1xuXHRcdFx0XHR0aGlzLmNvdW50ZXJwYXJ0Lm90aGVyS2V5cGF0aCA9IG5ld0tleXBhdGg7XG5cdFx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGlzU2V0dGFibGUoIHZpZXdtb2RlbCwga2V5cGF0aCApIHtcblx0XHRcdHZhciBjb21wdXRlZCA9IHZpZXdtb2RlbC5jb21wdXRhdGlvbnNbIGtleXBhdGggXTtcblx0XHRcdHJldHVybiAhY29tcHV0ZWQgfHwgY29tcHV0ZWQuc2V0dGVyO1xuXHRcdH1cblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50QmluZGluZyggY29tcG9uZW50LCBwYXJlbnRJbnN0YW5jZSwgcGFyZW50S2V5cGF0aCwgY2hpbGRLZXlwYXRoICkge1xuXHRcdFx0dmFyIGhhc2gsIGNoaWxkSW5zdGFuY2UsIGJpbmRpbmdzLCBwYXJlbnRUb0NoaWxkQmluZGluZywgY2hpbGRUb1BhcmVudEJpbmRpbmc7XG5cdFx0XHRoYXNoID0gcGFyZW50S2V5cGF0aCArICc9JyArIGNoaWxkS2V5cGF0aDtcblx0XHRcdGJpbmRpbmdzID0gY29tcG9uZW50LmJpbmRpbmdzO1xuXHRcdFx0aWYgKCBiaW5kaW5nc1sgaGFzaCBdICkge1xuXHRcdFx0XHQvLyBUT0RPIGRvZXMgdGhpcyBldmVyIGhhcHBlbj9cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y2hpbGRJbnN0YW5jZSA9IGNvbXBvbmVudC5pbnN0YW5jZTtcblx0XHRcdHBhcmVudFRvQ2hpbGRCaW5kaW5nID0gbmV3IEJpbmRpbmcoIHBhcmVudEluc3RhbmNlLCBwYXJlbnRLZXlwYXRoLCBjaGlsZEluc3RhbmNlLCBjaGlsZEtleXBhdGggKTtcblx0XHRcdGJpbmRpbmdzLnB1c2goIHBhcmVudFRvQ2hpbGRCaW5kaW5nICk7XG5cdFx0XHRpZiAoIGNoaWxkSW5zdGFuY2UudHdvd2F5ICkge1xuXHRcdFx0XHRjaGlsZFRvUGFyZW50QmluZGluZyA9IG5ldyBCaW5kaW5nKCBjaGlsZEluc3RhbmNlLCBjaGlsZEtleXBhdGgsIHBhcmVudEluc3RhbmNlLCBwYXJlbnRLZXlwYXRoICk7XG5cdFx0XHRcdGJpbmRpbmdzLnB1c2goIGNoaWxkVG9QYXJlbnRCaW5kaW5nICk7XG5cdFx0XHRcdHBhcmVudFRvQ2hpbGRCaW5kaW5nLmNvdW50ZXJwYXJ0ID0gY2hpbGRUb1BhcmVudEJpbmRpbmc7XG5cdFx0XHRcdGNoaWxkVG9QYXJlbnRCaW5kaW5nLmNvdW50ZXJwYXJ0ID0gcGFyZW50VG9DaGlsZEJpbmRpbmc7XG5cdFx0XHR9XG5cdFx0XHRiaW5kaW5nc1sgaGFzaCBdID0gcGFyZW50VG9DaGlsZEJpbmRpbmc7XG5cdFx0fTtcblx0fSggY2lyY3VsYXIsIGlzRXF1YWwgKTtcblxuXHQvKiBzaGFyZWQvcmVzb2x2ZVJlZi5qcyAqL1xuXHR2YXIgcmVzb2x2ZVJlZiA9IGZ1bmN0aW9uKCBub3JtYWxpc2VSZWYsIGdldElubmVyQ29udGV4dCwgY3JlYXRlQ29tcG9uZW50QmluZGluZyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgYW5jZXN0b3JFcnJvck1lc3NhZ2UsIGdldE9wdGlvbnM7XG5cdFx0YW5jZXN0b3JFcnJvck1lc3NhZ2UgPSAnQ291bGQgbm90IHJlc29sdmUgcmVmZXJlbmNlIC0gdG9vIG1hbnkgXCIuLi9cIiBwcmVmaXhlcyc7XG5cdFx0Z2V0T3B0aW9ucyA9IHtcblx0XHRcdGV2YWx1YXRlV3JhcHBlZDogdHJ1ZVxuXHRcdH07XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiByZXNvbHZlUmVmKCByYWN0aXZlLCByZWYsIGZyYWdtZW50LCBpc1BhcmVudExvb2t1cCApIHtcblx0XHRcdHZhciBjb250ZXh0LCBrZXksIGluZGV4LCBrZXlwYXRoLCBwYXJlbnRWYWx1ZSwgaGFzQ29udGV4dENoYWluLCBwYXJlbnRLZXlzLCBjaGlsZEtleXMsIHBhcmVudEtleXBhdGgsIGNoaWxkS2V5cGF0aDtcblx0XHRcdHJlZiA9IG5vcm1hbGlzZVJlZiggcmVmICk7XG5cdFx0XHQvLyBJZiBhIHJlZmVyZW5jZSBiZWdpbnMgJ34vJywgaXQncyBhIHRvcC1sZXZlbCByZWZlcmVuY2Vcblx0XHRcdGlmICggcmVmLnN1YnN0ciggMCwgMiApID09PSAnfi8nICkge1xuXHRcdFx0XHRyZXR1cm4gcmVmLnN1YnN0cmluZyggMiApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgYSByZWZlcmVuY2UgYmVnaW5zIHdpdGggJy4nLCBpdCdzIGVpdGhlciBhIHJlc3RyaWN0ZWQgcmVmZXJlbmNlIG9yXG5cdFx0XHQvLyBhbiBhbmNlc3RvciByZWZlcmVuY2UuLi5cblx0XHRcdGlmICggcmVmLmNoYXJBdCggMCApID09PSAnLicgKSB7XG5cdFx0XHRcdHJldHVybiByZXNvbHZlQW5jZXN0b3JSZWZlcmVuY2UoIGdldElubmVyQ29udGV4dCggZnJhZ21lbnQgKSwgcmVmICk7XG5cdFx0XHR9XG5cdFx0XHQvLyAuLi5vdGhlcndpc2Ugd2UgbmVlZCB0byBmaW5kIHRoZSBrZXlwYXRoXG5cdFx0XHRrZXkgPSByZWYuc3BsaXQoICcuJyApWyAwIF07XG5cdFx0XHQvLyBnZXQoKSBpbiB2aWV3bW9kZWwgY3JlYXRpb24gbWVhbnMgbm8gZnJhZ21lbnQgKHlldClcblx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQgfHwge307XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGNvbnRleHQgPSBmcmFnbWVudC5jb250ZXh0O1xuXHRcdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhhc0NvbnRleHRDaGFpbiA9IHRydWU7XG5cdFx0XHRcdHBhcmVudFZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KCBjb250ZXh0LCBnZXRPcHRpb25zICk7XG5cdFx0XHRcdGlmICggcGFyZW50VmFsdWUgJiYgKCB0eXBlb2YgcGFyZW50VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyApICYmIGtleSBpbiBwYXJlbnRWYWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gY29udGV4dCArICcuJyArIHJlZjtcblx0XHRcdFx0fVxuXHRcdFx0fSB3aGlsZSAoIGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50ICk7XG5cdFx0XHQvLyBSb290L2NvbXB1dGVkIHByb3BlcnR5P1xuXHRcdFx0aWYgKCBrZXkgaW4gcmFjdGl2ZS5kYXRhIHx8IGtleSBpbiByYWN0aXZlLnZpZXdtb2RlbC5jb21wdXRhdGlvbnMgKSB7XG5cdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGlubGluZSBjb21wb25lbnQsIGFuZCBpdCdzIG5vdCBpc29sYXRlZCwgd2Vcblx0XHRcdC8vIGNhbiB0cnkgZ29pbmcgdXAgdGhlIHNjb3BlIGNoYWluXG5cdFx0XHRpZiAoIHJhY3RpdmUuX3BhcmVudCAmJiAhcmFjdGl2ZS5pc29sYXRlZCApIHtcblx0XHRcdFx0aGFzQ29udGV4dENoYWluID0gdHJ1ZTtcblx0XHRcdFx0ZnJhZ21lbnQgPSByYWN0aXZlLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gaW5kZXggcmVmc1xuXHRcdFx0XHRpZiAoIGZyYWdtZW50LmluZGV4UmVmcyAmJiAoIGluZGV4ID0gZnJhZ21lbnQuaW5kZXhSZWZzWyByZWYgXSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGFuIGluZGV4IHJlZiBiaW5kaW5nLCBzbyB0aGF0IGl0IGNhbiBiZSByZWJvdW5kIGxldHRlciBpZiBuZWNlc3NhcnkuXG5cdFx0XHRcdFx0Ly8gSXQgZG9lc24ndCBoYXZlIGFuIGFsaWFzIHNpbmNlIGl0J3MgYW4gaW1wbGljaXQgYmluZGluZywgaGVuY2UgYC4uLlsgcmVmIF0gPSByZWZgXG5cdFx0XHRcdFx0cmFjdGl2ZS5jb21wb25lbnQuaW5kZXhSZWZCaW5kaW5nc1sgcmVmIF0gPSByZWY7XG5cdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KCByZWYsIGluZGV4LCB0cnVlICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleXBhdGggPSByZXNvbHZlUmVmKCByYWN0aXZlLl9wYXJlbnQsIHJlZiwgZnJhZ21lbnQsIHRydWUgKTtcblx0XHRcdFx0aWYgKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gY3JlYXRlIGFuIGludGVyLWNvbXBvbmVudCBiaW5kaW5nXG5cdFx0XHRcdFx0Ly8gSWYgcGFyZW50IGtleXBhdGggaXMgJ29uZS5mb28nIGFuZCBjaGlsZCBpcyAndHdvLmZvbycsIHdlIGJpbmRcblx0XHRcdFx0XHQvLyAnb25lJyB0byAndHdvJyBhcyBpdCdzIG1vcmUgZWZmaWNpZW50IGFuZCBhdm9pZHMgZWRnZSBjYXNlc1xuXHRcdFx0XHRcdHBhcmVudEtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdFx0XHRjaGlsZEtleXMgPSByZWYuc3BsaXQoICcuJyApO1xuXHRcdFx0XHRcdHdoaWxlICggcGFyZW50S2V5cy5sZW5ndGggPiAxICYmIGNoaWxkS2V5cy5sZW5ndGggPiAxICYmIHBhcmVudEtleXNbIHBhcmVudEtleXMubGVuZ3RoIC0gMSBdID09PSBjaGlsZEtleXNbIGNoaWxkS2V5cy5sZW5ndGggLSAxIF0gKSB7XG5cdFx0XHRcdFx0XHRwYXJlbnRLZXlzLnBvcCgpO1xuXHRcdFx0XHRcdFx0Y2hpbGRLZXlzLnBvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJlbnRLZXlwYXRoID0gcGFyZW50S2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0XHRjaGlsZEtleXBhdGggPSBjaGlsZEtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KCBjaGlsZEtleXBhdGgsIHJhY3RpdmUuX3BhcmVudC52aWV3bW9kZWwuZ2V0KCBwYXJlbnRLZXlwYXRoICksIHRydWUgKTtcblx0XHRcdFx0XHRjcmVhdGVDb21wb25lbnRCaW5kaW5nKCByYWN0aXZlLmNvbXBvbmVudCwgcmFjdGl2ZS5fcGFyZW50LCBwYXJlbnRLZXlwYXRoLCBjaGlsZEtleXBhdGggKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVmO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGVyZSdzIG5vIGNvbnRleHQgY2hhaW4sIGFuZCB0aGUgaW5zdGFuY2UgaXMgZWl0aGVyIGEpIGlzb2xhdGVkIG9yXG5cdFx0XHQvLyBiKSBhbiBvcnBoYW4sIHRoZW4gd2Uga25vdyB0aGF0IHRoZSBrZXlwYXRoIGlzIGlkZW50aWNhbCB0byB0aGUgcmVmZXJlbmNlXG5cdFx0XHRpZiAoICFpc1BhcmVudExvb2t1cCAmJiAhaGFzQ29udGV4dENoYWluICkge1xuXHRcdFx0XHQvLyB0aGUgZGF0YSBvYmplY3QgbmVlZHMgdG8gaGF2ZSBhIHByb3BlcnR5IGJ5IHRoaXMgbmFtZSxcblx0XHRcdFx0Ly8gdG8gcHJldmVudCBmdXR1cmUgZmFpbGVkIGxvb2t1cHNcblx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KCByZWYsIHVuZGVmaW5lZCApO1xuXHRcdFx0XHRyZXR1cm4gcmVmO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCByYWN0aXZlLnZpZXdtb2RlbC5nZXQoIHJlZiApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlc29sdmVBbmNlc3RvclJlZmVyZW5jZSggYmFzZUNvbnRleHQsIHJlZiApIHtcblx0XHRcdHZhciBjb250ZXh0S2V5cztcblx0XHRcdC8vIHt7Ln19IG1lYW5zICdjdXJyZW50IGNvbnRleHQnXG5cdFx0XHRpZiAoIHJlZiA9PT0gJy4nIClcblx0XHRcdFx0cmV0dXJuIGJhc2VDb250ZXh0O1xuXHRcdFx0Y29udGV4dEtleXMgPSBiYXNlQ29udGV4dCA/IGJhc2VDb250ZXh0LnNwbGl0KCAnLicgKSA6IFtdO1xuXHRcdFx0Ly8gYW5jZXN0b3IgcmVmZXJlbmNlcyAoc3RhcnRpbmcgXCIuLi9cIikgZ28gdXAgdGhlIHRyZWVcblx0XHRcdGlmICggcmVmLnN1YnN0ciggMCwgMyApID09PSAnLi4vJyApIHtcblx0XHRcdFx0d2hpbGUgKCByZWYuc3Vic3RyKCAwLCAzICkgPT09ICcuLi8nICkge1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHRLZXlzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggYW5jZXN0b3JFcnJvck1lc3NhZ2UgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29udGV4dEtleXMucG9wKCk7XG5cdFx0XHRcdFx0cmVmID0gcmVmLnN1YnN0cmluZyggMyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRleHRLZXlzLnB1c2goIHJlZiApO1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dEtleXMuam9pbiggJy4nICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBub3QgYW4gYW5jZXN0b3IgcmVmZXJlbmNlIC0gbXVzdCBiZSBhIHJlc3RyaWN0ZWQgcmVmZXJlbmNlIChwcmVwZW5kZWQgd2l0aCBcIi5cIiBvciBcIi4vXCIpXG5cdFx0XHRpZiAoICFiYXNlQ29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlZi5yZXBsYWNlKCAvXlxcLlxcLz8vLCAnJyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJhc2VDb250ZXh0ICsgcmVmLnJlcGxhY2UoIC9eXFwuXFwvLywgJy4nICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggbm9ybWFsaXNlUmVmLCBnZXRJbm5lckNvbnRleHQsIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgKTtcblxuXHQvKiBnbG9iYWwvVHJhbnNpdGlvbk1hbmFnZXIuanMgKi9cblx0dmFyIFRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24oIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHZhciBUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uKCBjYWxsYmFjaywgcGFyZW50ICkge1xuXHRcdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cdFx0XHR0aGlzLmludHJvcyA9IFtdO1xuXHRcdFx0dGhpcy5vdXRyb3MgPSBbXTtcblx0XHRcdHRoaXMuY2hpbGRyZW4gPSBbXTtcblx0XHRcdHRoaXMudG90YWxDaGlsZHJlbiA9IHRoaXMub3V0cm9DaGlsZHJlbiA9IDA7XG5cdFx0XHR0aGlzLmRldGFjaFF1ZXVlID0gW107XG5cdFx0XHR0aGlzLm91dHJvc0NvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LmFkZENoaWxkKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRUcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRhZGRDaGlsZDogZnVuY3Rpb24oIGNoaWxkICkge1xuXHRcdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goIGNoaWxkICk7XG5cdFx0XHRcdHRoaXMudG90YWxDaGlsZHJlbiArPSAxO1xuXHRcdFx0XHR0aGlzLm91dHJvQ2hpbGRyZW4gKz0gMTtcblx0XHRcdH0sXG5cdFx0XHRkZWNyZW1lbnRPdXRyb3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLm91dHJvQ2hpbGRyZW4gLT0gMTtcblx0XHRcdFx0Y2hlY2soIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRkZWNyZW1lbnRUb3RhbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMudG90YWxDaGlsZHJlbiAtPSAxO1xuXHRcdFx0XHRjaGVjayggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGFkZDogZnVuY3Rpb24oIHRyYW5zaXRpb24gKSB7XG5cdFx0XHRcdHZhciBsaXN0ID0gdHJhbnNpdGlvbi5pc0ludHJvID8gdGhpcy5pbnRyb3MgOiB0aGlzLm91dHJvcztcblx0XHRcdFx0bGlzdC5wdXNoKCB0cmFuc2l0aW9uICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiggdHJhbnNpdGlvbiApIHtcblx0XHRcdFx0dmFyIGxpc3QgPSB0cmFuc2l0aW9uLmlzSW50cm8gPyB0aGlzLmludHJvcyA6IHRoaXMub3V0cm9zO1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIGxpc3QsIHRyYW5zaXRpb24gKTtcblx0XHRcdFx0Y2hlY2soIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yZWFkeSA9IHRydWU7XG5cdFx0XHRcdGNoZWNrKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0ZGV0YWNoTm9kZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmRldGFjaFF1ZXVlLmZvckVhY2goIGRldGFjaCApO1xuXHRcdFx0XHR0aGlzLmNoaWxkcmVuLmZvckVhY2goIGRldGFjaE5vZGVzICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGRldGFjaCggZWxlbWVudCApIHtcblx0XHRcdGVsZW1lbnQuZGV0YWNoKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGV0YWNoTm9kZXMoIHRtICkge1xuXHRcdFx0dG0uZGV0YWNoTm9kZXMoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVjayggdG0gKSB7XG5cdFx0XHRpZiAoICF0bS5yZWFkeSB8fCB0bS5vdXRyb3MubGVuZ3RoIHx8IHRtLm91dHJvQ2hpbGRyZW4gKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHQvLyBJZiBhbGwgb3V0cm9zIGFyZSBjb21wbGV0ZSwgYW5kIHdlIGhhdmVuJ3QgYWxyZWFkeSBkb25lIHRoaXMsXG5cdFx0XHQvLyB3ZSBub3RpZnkgdGhlIHBhcmVudCBpZiB0aGVyZSBpcyBvbmUsIG90aGVyd2lzZVxuXHRcdFx0Ly8gc3RhcnQgZGV0YWNoaW5nIG5vZGVzXG5cdFx0XHRpZiAoICF0bS5vdXRyb3NDb21wbGV0ZSApIHtcblx0XHRcdFx0aWYgKCB0bS5wYXJlbnQgKSB7XG5cdFx0XHRcdFx0dG0ucGFyZW50LmRlY3JlbWVudE91dHJvcyggdG0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0bS5kZXRhY2hOb2RlcygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRtLm91dHJvc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIE9uY2UgZXZlcnl0aGluZyBpcyBkb25lLCB3ZSBjYW4gbm90aWZ5IHBhcmVudCB0cmFuc2l0aW9uXG5cdFx0XHQvLyBtYW5hZ2VyIGFuZCBjYWxsIHRoZSBjYWxsYmFja1xuXHRcdFx0aWYgKCAhdG0uaW50cm9zLmxlbmd0aCAmJiAhdG0udG90YWxDaGlsZHJlbiApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2YgdG0uY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0dG0uY2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRtLnBhcmVudCApIHtcblx0XHRcdFx0XHR0bS5wYXJlbnQuZGVjcmVtZW50VG90YWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gVHJhbnNpdGlvbk1hbmFnZXI7XG5cdH0oIHJlbW92ZUZyb21BcnJheSApO1xuXG5cdC8qIGdsb2JhbC9ydW5sb29wLmpzICovXG5cdHZhciBydW5sb29wID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBIb29rLCByZW1vdmVGcm9tQXJyYXksIFByb21pc2UsIHJlc29sdmVSZWYsIFRyYW5zaXRpb25NYW5hZ2VyICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBiYXRjaCwgcnVubG9vcCwgdW5yZXNvbHZlZCA9IFtdLFxuXHRcdFx0Y2hhbmdlSG9vayA9IG5ldyBIb29rKCAnY2hhbmdlJyApO1xuXHRcdHJ1bmxvb3AgPSB7XG5cdFx0XHRzdGFydDogZnVuY3Rpb24oIGluc3RhbmNlLCByZXR1cm5Qcm9taXNlICkge1xuXHRcdFx0XHR2YXIgcHJvbWlzZSwgZnVsZmlsUHJvbWlzZTtcblx0XHRcdFx0aWYgKCByZXR1cm5Qcm9taXNlICkge1xuXHRcdFx0XHRcdHByb21pc2UgPSBuZXcgUHJvbWlzZSggZnVuY3Rpb24oIGYgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVsZmlsUHJvbWlzZSA9IGY7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJhdGNoID0ge1xuXHRcdFx0XHRcdHByZXZpb3VzQmF0Y2g6IGJhdGNoLFxuXHRcdFx0XHRcdHRyYW5zaXRpb25NYW5hZ2VyOiBuZXcgVHJhbnNpdGlvbk1hbmFnZXIoIGZ1bGZpbFByb21pc2UsIGJhdGNoICYmIGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyICksXG5cdFx0XHRcdFx0dmlld3M6IFtdLFxuXHRcdFx0XHRcdHRhc2tzOiBbXSxcblx0XHRcdFx0XHR2aWV3bW9kZWxzOiBbXSxcblx0XHRcdFx0XHRpbnN0YW5jZTogaW5zdGFuY2Vcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRiYXRjaC52aWV3bW9kZWxzLnB1c2goIGluc3RhbmNlLnZpZXdtb2RlbCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdFx0fSxcblx0XHRcdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZsdXNoQ2hhbmdlcygpO1xuXHRcdFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5pbml0KCk7XG5cdFx0XHRcdGlmICggIWJhdGNoLnByZXZpb3VzQmF0Y2ggJiYgISFiYXRjaC5pbnN0YW5jZSApXG5cdFx0XHRcdFx0YmF0Y2guaW5zdGFuY2Uudmlld21vZGVsLmNoYW5nZXMgPSBbXTtcblx0XHRcdFx0YmF0Y2ggPSBiYXRjaC5wcmV2aW91c0JhdGNoO1xuXHRcdFx0fSxcblx0XHRcdGFkZFZpZXdtb2RlbDogZnVuY3Rpb24oIHZpZXdtb2RlbCApIHtcblx0XHRcdFx0aWYgKCBiYXRjaCApIHtcblx0XHRcdFx0XHRpZiAoIGJhdGNoLnZpZXdtb2RlbHMuaW5kZXhPZiggdmlld21vZGVsICkgPT09IC0xICkge1xuXHRcdFx0XHRcdFx0YmF0Y2gudmlld21vZGVscy5wdXNoKCB2aWV3bW9kZWwgKTtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZpZXdtb2RlbC5hcHBseUNoYW5nZXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZWdpc3RlclRyYW5zaXRpb246IGZ1bmN0aW9uKCB0cmFuc2l0aW9uICkge1xuXHRcdFx0XHR0cmFuc2l0aW9uLl9tYW5hZ2VyID0gYmF0Y2gudHJhbnNpdGlvbk1hbmFnZXI7XG5cdFx0XHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmFkZCggdHJhbnNpdGlvbiApO1xuXHRcdFx0fSxcblx0XHRcdGFkZFZpZXc6IGZ1bmN0aW9uKCB2aWV3ICkge1xuXHRcdFx0XHRiYXRjaC52aWV3cy5wdXNoKCB2aWV3ICk7XG5cdFx0XHR9LFxuXHRcdFx0YWRkVW5yZXNvbHZlZDogZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdFx0XHR1bnJlc29sdmVkLnB1c2goIHRoaW5nICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVtb3ZlVW5yZXNvbHZlZDogZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHVucmVzb2x2ZWQsIHRoaW5nICk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gc3luY2hyb25pc2Ugbm9kZSBkZXRhY2htZW50cyB3aXRoIHRyYW5zaXRpb24gZW5kc1xuXHRcdFx0ZGV0YWNoV2hlblJlYWR5OiBmdW5jdGlvbiggdGhpbmcgKSB7XG5cdFx0XHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmRldGFjaFF1ZXVlLnB1c2goIHRoaW5nICk7XG5cdFx0XHR9LFxuXHRcdFx0c2NoZWR1bGVUYXNrOiBmdW5jdGlvbiggdGFzaywgcG9zdFJlbmRlciApIHtcblx0XHRcdFx0dmFyIF9iYXRjaDtcblx0XHRcdFx0aWYgKCAhYmF0Y2ggKSB7XG5cdFx0XHRcdFx0dGFzaygpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9iYXRjaCA9IGJhdGNoO1xuXHRcdFx0XHRcdHdoaWxlICggcG9zdFJlbmRlciAmJiBfYmF0Y2gucHJldmlvdXNCYXRjaCApIHtcblx0XHRcdFx0XHRcdC8vIHRoaXMgY2FuJ3QgaGFwcGVuIHVudGlsIHRoZSBET00gaGFzIGJlZW4gZnVsbHkgdXBkYXRlZFxuXHRcdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIGluIHNvbWUgc2l0dWF0aW9ucyAod2l0aCBjb21wb25lbnRzIGluc2lkZSBlbGVtZW50cylcblx0XHRcdFx0XHRcdC8vIHRyYW5zaXRpb25zIGFuZCBkZWNvcmF0b3JzIHdpbGwgaW5pdGlhbGlzZSBwcmVtYXR1cmVseVxuXHRcdFx0XHRcdFx0X2JhdGNoID0gX2JhdGNoLnByZXZpb3VzQmF0Y2g7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9iYXRjaC50YXNrcy5wdXNoKCB0YXNrICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdGNpcmN1bGFyLnJ1bmxvb3AgPSBydW5sb29wO1xuXHRcdF9fZXhwb3J0ID0gcnVubG9vcDtcblxuXHRcdGZ1bmN0aW9uIGZsdXNoQ2hhbmdlcygpIHtcblx0XHRcdHZhciBpLCB0aGluZywgY2hhbmdlSGFzaDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgYmF0Y2gudmlld21vZGVscy5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0dGhpbmcgPSBiYXRjaC52aWV3bW9kZWxzWyBpIF07XG5cdFx0XHRcdGNoYW5nZUhhc2ggPSB0aGluZy5hcHBseUNoYW5nZXMoKTtcblx0XHRcdFx0aWYgKCBjaGFuZ2VIYXNoICkge1xuXHRcdFx0XHRcdGNoYW5nZUhvb2suZmlyZSggdGhpbmcucmFjdGl2ZSwgY2hhbmdlSGFzaCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRiYXRjaC52aWV3bW9kZWxzLmxlbmd0aCA9IDA7XG5cdFx0XHRhdHRlbXB0S2V5cGF0aFJlc29sdXRpb24oKTtcblx0XHRcdC8vIE5vdyB0aGF0IGNoYW5nZXMgaGF2ZSBiZWVuIGZ1bGx5IHByb3BhZ2F0ZWQsIHdlIGNhbiB1cGRhdGUgdGhlIERPTVxuXHRcdFx0Ly8gYW5kIGNvbXBsZXRlIG90aGVyIHRhc2tzXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGJhdGNoLnZpZXdzLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRiYXRjaC52aWV3c1sgaSBdLnVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0YmF0Y2gudmlld3MubGVuZ3RoID0gMDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgYmF0Y2gudGFza3MubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdGJhdGNoLnRhc2tzWyBpIF0oKTtcblx0XHRcdH1cblx0XHRcdGJhdGNoLnRhc2tzLmxlbmd0aCA9IDA7XG5cdFx0XHQvLyBJZiB1cGRhdGluZyB0aGUgdmlldyBjYXVzZWQgc29tZSBtb2RlbCBibG93YmFjayAtIGUuZy4gYSB0cmlwbGVcblx0XHRcdC8vIGNvbnRhaW5pbmcgPG9wdGlvbj4gZWxlbWVudHMgY2F1c2VkIHRoZSBiaW5kaW5nIG9uIHRoZSA8c2VsZWN0PlxuXHRcdFx0Ly8gdG8gdXBkYXRlIC0gdGhlbiB3ZSBzdGFydCBvdmVyXG5cdFx0XHRpZiAoIGJhdGNoLnZpZXdtb2RlbHMubGVuZ3RoIClcblx0XHRcdFx0cmV0dXJuIGZsdXNoQ2hhbmdlcygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGF0dGVtcHRLZXlwYXRoUmVzb2x1dGlvbigpIHtcblx0XHRcdHZhciBpLCBpdGVtLCBrZXlwYXRoLCByZXNvbHZlZDtcblx0XHRcdGkgPSB1bnJlc29sdmVkLmxlbmd0aDtcblx0XHRcdC8vIHNlZSBpZiB3ZSBjYW4gcmVzb2x2ZSBhbnkgdW5yZXNvbHZlZCByZWZlcmVuY2VzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aXRlbSA9IHVucmVzb2x2ZWRbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmtleXBhdGggKSB7XG5cdFx0XHRcdFx0Ly8gaXQgcmVzb2x2ZWQgc29tZSBvdGhlciB3YXkuIFRPRE8gaG93PyB0d28td2F5IGJpbmRpbmc/IFNlZW1zXG5cdFx0XHRcdFx0Ly8gd2VpcmQgdGhhdCB3ZSdkIHN0aWxsIGVuZCB1cCBoZXJlXG5cdFx0XHRcdFx0dW5yZXNvbHZlZC5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGtleXBhdGggPSByZXNvbHZlUmVmKCBpdGVtLnJvb3QsIGl0ZW0ucmVmLCBpdGVtLnBhcmVudEZyYWdtZW50ICkgKSB7XG5cdFx0XHRcdFx0KCByZXNvbHZlZCB8fCAoIHJlc29sdmVkID0gW10gKSApLnB1c2goIHtcblx0XHRcdFx0XHRcdGl0ZW06IGl0ZW0sXG5cdFx0XHRcdFx0XHRrZXlwYXRoOiBrZXlwYXRoXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHVucmVzb2x2ZWQuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggcmVzb2x2ZWQgKSB7XG5cdFx0XHRcdHJlc29sdmVkLmZvckVhY2goIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNvbHZlKCByZXNvbHZlZCApIHtcblx0XHRcdHJlc29sdmVkLml0ZW0ucmVzb2x2ZSggcmVzb2x2ZWQua2V5cGF0aCApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGNpcmN1bGFyLCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCByZW1vdmVGcm9tQXJyYXksIFByb21pc2UsIHJlc29sdmVSZWYsIFRyYW5zaXRpb25NYW5hZ2VyICk7XG5cblx0LyogdXRpbHMvY3JlYXRlQnJhbmNoLmpzICovXG5cdHZhciBjcmVhdGVCcmFuY2ggPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBudW1lcmljID0gL15cXHMqWzAtOV0rXFxzKiQvO1xuXHRcdHJldHVybiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0cmV0dXJuIG51bWVyaWMudGVzdCgga2V5ICkgPyBbXSA6IHt9O1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9tYWdpY0FkYXB0b3IuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfbWFnaWNBZGFwdG9yID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGNyZWF0ZUJyYW5jaCwgaXNBcnJheSApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgbWFnaWNBZGFwdG9yLCBNYWdpY1dyYXBwZXI7XG5cdFx0dHJ5IHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgge30sICd0ZXN0Jywge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fSApO1xuXHRcdFx0bWFnaWNBZGFwdG9yID0ge1xuXHRcdFx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUgKSB7XG5cdFx0XHRcdFx0dmFyIGtleXMsIGtleSwgcGFyZW50S2V5cGF0aCwgcGFyZW50V3JhcHBlciwgcGFyZW50VmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAha2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0XHRcdGtleSA9IGtleXMucG9wKCk7XG5cdFx0XHRcdFx0cGFyZW50S2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHBhcmVudCB2YWx1ZSBpcyBhIHdyYXBwZXIsIG90aGVyIHRoYW4gYSBtYWdpYyB3cmFwcGVyLFxuXHRcdFx0XHRcdC8vIHdlIHNob3VsZG4ndCB3cmFwIHRoaXMgcHJvcGVydHlcblx0XHRcdFx0XHRpZiAoICggcGFyZW50V3JhcHBlciA9IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRbIHBhcmVudEtleXBhdGggXSApICYmICFwYXJlbnRXcmFwcGVyLm1hZ2ljICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJlbnRWYWx1ZSA9IHJhY3RpdmUuZ2V0KCBwYXJlbnRLZXlwYXRoICk7XG5cdFx0XHRcdFx0Ly8gaWYgcGFyZW50VmFsdWUgaXMgYW4gYXJyYXkgdGhhdCBkb2Vzbid0IGluY2x1ZGUgdGhpcyBtZW1iZXIsXG5cdFx0XHRcdFx0Ly8gd2Ugc2hvdWxkIHJldHVybiBmYWxzZSBvdGhlcndpc2UgbGVuZ3RocyB3aWxsIGdldCBtZXNzZWQgdXBcblx0XHRcdFx0XHRpZiAoIGlzQXJyYXkoIHBhcmVudFZhbHVlICkgJiYgL15bMC05XSskLy50ZXN0KCBrZXkgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudFZhbHVlICYmICggdHlwZW9mIHBhcmVudFZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFyZW50VmFsdWUgPT09ICdmdW5jdGlvbicgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0d3JhcDogZnVuY3Rpb24oIHJhY3RpdmUsIHByb3BlcnR5LCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgTWFnaWNXcmFwcGVyKCByYWN0aXZlLCBwcm9wZXJ0eSwga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0TWFnaWNXcmFwcGVyID0gZnVuY3Rpb24oIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIga2V5cywgb2JqS2V5cGF0aCwgdGVtcGxhdGUsIHNpYmxpbmdzO1xuXHRcdFx0XHR0aGlzLm1hZ2ljID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcblx0XHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRcdHRoaXMucHJvcCA9IGtleXMucG9wKCk7XG5cdFx0XHRcdG9iaktleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHR0aGlzLm9iaiA9IG9iaktleXBhdGggPyByYWN0aXZlLmdldCggb2JqS2V5cGF0aCApIDogcmFjdGl2ZS5kYXRhO1xuXHRcdFx0XHR0ZW1wbGF0ZSA9IHRoaXMub3JpZ2luYWxEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggdGhpcy5vYmosIHRoaXMucHJvcCApO1xuXHRcdFx0XHQvLyBIYXMgdGhpcyBwcm9wZXJ0eSBhbHJlYWR5IGJlZW4gd3JhcHBlZD9cblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5zZXQgJiYgKCBzaWJsaW5ncyA9IHRlbXBsYXRlLnNldC5fcmFjdGl2ZVdyYXBwZXJzICkgKSB7XG5cdFx0XHRcdFx0Ly8gWWVzLiBSZWdpc3RlciB0aGlzIHdyYXBwZXIgdG8gdGhpcyBwcm9wZXJ0eSwgaWYgaXQgaGFzbid0IGJlZW4gYWxyZWFkeVxuXHRcdFx0XHRcdGlmICggc2libGluZ3MuaW5kZXhPZiggdGhpcyApID09PSAtMSApIHtcblx0XHRcdFx0XHRcdHNpYmxpbmdzLnB1c2goIHRoaXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIE5vLCBpdCBoYXNuJ3QgYmVlbiB3cmFwcGVkXG5cdFx0XHRcdGNyZWF0ZUFjY2Vzc29ycyggdGhpcywgdmFsdWUsIHRlbXBsYXRlICk7XG5cdFx0XHR9O1xuXHRcdFx0TWFnaWNXcmFwcGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMub2JqWyB0aGlzLnByb3AgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdC8vIHRyaWdnZXIgc2V0KCkgYWNjZXNzb3Jcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggdGhpcy5yYWN0aXZlLnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdHRoaXMucmFjdGl2ZS52aWV3bW9kZWwubWFyayggdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggdGhpcy51cGRhdGluZyApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhdGhpcy5vYmpbIHRoaXMucHJvcCBdICkge1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR0aGlzLm9ialsgdGhpcy5wcm9wIF0gPSBjcmVhdGVCcmFuY2goIGtleSApO1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLm9ialsgdGhpcy5wcm9wIF1bIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgdGVtcGxhdGUsIHNldCwgdmFsdWUsIHdyYXBwZXJzLCBpbmRleDtcblx0XHRcdFx0XHQvLyBJZiB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkIGJlY2F1c2UgdGhlIGNhY2hlIHdhcyBiZWluZyBjbGVhcmVkIGFzIGFcblx0XHRcdFx0XHQvLyByZXN1bHQgb2YgYSBzZXQoKS91cGRhdGUoKSBjYWxsIG1hZGUgYnkgdGhpcyB3cmFwcGVyLCB3ZSByZXR1cm4gZmFsc2Vcblx0XHRcdFx0XHQvLyBzbyB0aGF0IGl0IGRvZXNuJ3QgZ2V0IHRvcm4gZG93blxuXHRcdFx0XHRcdGlmICggdGhpcy51cGRhdGluZyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCB0aGlzLm9iaiwgdGhpcy5wcm9wICk7XG5cdFx0XHRcdFx0c2V0ID0gdGVtcGxhdGUgJiYgdGVtcGxhdGUuc2V0O1xuXHRcdFx0XHRcdGlmICggIXNldCApIHtcblx0XHRcdFx0XHRcdC8vIG1vc3QgbGlrZWx5LCB0aGlzIHdhcyBhbiBhcnJheSBtZW1iZXIgdGhhdCB3YXMgc3BsaWNlZCBvdXRcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d3JhcHBlcnMgPSBzZXQuX3JhY3RpdmVXcmFwcGVycztcblx0XHRcdFx0XHRpbmRleCA9IHdyYXBwZXJzLmluZGV4T2YoIHRoaXMgKTtcblx0XHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdHdyYXBwZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gTGFzdCBvbmUgb3V0LCB0dXJuIG9mZiB0aGUgbGlnaHRzXG5cdFx0XHRcdFx0aWYgKCAhd3JhcHBlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB0aGlzLm9ialsgdGhpcy5wcm9wIF07XG5cdFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMub2JqLCB0aGlzLnByb3AsIHRoaXMub3JpZ2luYWxEZXNjcmlwdG9yIHx8IHtcblx0XHRcdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0dGhpcy5vYmpbIHRoaXMucHJvcCBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRtYWdpY0FkYXB0b3IgPSBmYWxzZTtcblx0XHR9XG5cdFx0X19leHBvcnQgPSBtYWdpY0FkYXB0b3I7XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVBY2Nlc3NvcnMoIG9yaWdpbmFsV3JhcHBlciwgdmFsdWUsIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIG9iamVjdCwgcHJvcGVydHksIG9sZEdldCwgb2xkU2V0LCBnZXQsIHNldDtcblx0XHRcdG9iamVjdCA9IG9yaWdpbmFsV3JhcHBlci5vYmo7XG5cdFx0XHRwcm9wZXJ0eSA9IG9yaWdpbmFsV3JhcHBlci5wcm9wO1xuXHRcdFx0Ly8gSXMgdGhpcyB0ZW1wbGF0ZSBjb25maWd1cmFibGU/XG5cdFx0XHRpZiAoIHRlbXBsYXRlICYmICF0ZW1wbGF0ZS5jb25maWd1cmFibGUgKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGFycmF5IGxlbmd0aFxuXHRcdFx0XHRpZiAoIHByb3BlcnR5ID09PSAnbGVuZ3RoJyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2Fubm90IHVzZSBtYWdpYyBtb2RlIHdpdGggcHJvcGVydHkgXCInICsgcHJvcGVydHkgKyAnXCIgLSBvYmplY3QgaXMgbm90IGNvbmZpZ3VyYWJsZScgKTtcblx0XHRcdH1cblx0XHRcdC8vIFRpbWUgdG8gd3JhcCB0aGlzIHByb3BlcnR5XG5cdFx0XHRpZiAoIHRlbXBsYXRlICkge1xuXHRcdFx0XHRvbGRHZXQgPSB0ZW1wbGF0ZS5nZXQ7XG5cdFx0XHRcdG9sZFNldCA9IHRlbXBsYXRlLnNldDtcblx0XHRcdH1cblx0XHRcdGdldCA9IG9sZEdldCB8fCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fTtcblx0XHRcdHNldCA9IGZ1bmN0aW9uKCB2ICkge1xuXHRcdFx0XHRpZiAoIG9sZFNldCApIHtcblx0XHRcdFx0XHRvbGRTZXQoIHYgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZSA9IG9sZEdldCA/IG9sZEdldCgpIDogdjtcblx0XHRcdFx0c2V0Ll9yYWN0aXZlV3JhcHBlcnMuZm9yRWFjaCggdXBkYXRlV3JhcHBlciApO1xuXHRcdFx0fTtcblxuXHRcdFx0ZnVuY3Rpb24gdXBkYXRlV3JhcHBlciggd3JhcHBlciApIHtcblx0XHRcdFx0dmFyIGtleXBhdGgsIHJhY3RpdmU7XG5cdFx0XHRcdHdyYXBwZXIudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKCB3cmFwcGVyLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyYWN0aXZlID0gd3JhcHBlci5yYWN0aXZlO1xuXHRcdFx0XHRrZXlwYXRoID0gd3JhcHBlci5rZXlwYXRoO1xuXHRcdFx0XHR3cmFwcGVyLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0cnVubG9vcC5zdGFydCggcmFjdGl2ZSApO1xuXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5tYXJrKCBrZXlwYXRoICk7XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdHdyYXBwZXIudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIENyZWF0ZSBhbiBhcnJheSBvZiB3cmFwcGVycywgaW4gY2FzZSBvdGhlciBrZXlwYXRocy9yYWN0aXZlcyBkZXBlbmQgb24gdGhpcyBwcm9wZXJ0eS5cblx0XHRcdC8vIEhhbmRpbHksIHdlIGNhbiBzdG9yZSB0aGVtIGFzIGEgcHJvcGVydHkgb2YgdGhlIHNldCBmdW5jdGlvbi4gWWF5IEphdmFTY3JpcHQuXG5cdFx0XHRzZXQuX3JhY3RpdmVXcmFwcGVycyA9IFsgb3JpZ2luYWxXcmFwcGVyIF07XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9iamVjdCwgcHJvcGVydHksIHtcblx0XHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRcdHNldDogc2V0LFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBydW5sb29wLCBjcmVhdGVCcmFuY2gsIGlzQXJyYXkgKTtcblxuXHQvKiBjb25maWcvbWFnaWMuanMgKi9cblx0dmFyIG1hZ2ljID0gZnVuY3Rpb24oIG1hZ2ljQWRhcHRvciApIHtcblxuXHRcdHJldHVybiAhIW1hZ2ljQWRhcHRvcjtcblx0fSggdmlld21vZGVsJGdldF9tYWdpY0FkYXB0b3IgKTtcblxuXHQvKiBjb25maWcvbmFtZXNwYWNlcy5qcyAqL1xuXHR2YXIgbmFtZXNwYWNlcyA9IHtcblx0XHRodG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsXG5cdFx0bWF0aG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcsXG5cdFx0c3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuXHRcdHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG5cdFx0eG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJyxcblx0XHR4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJ1xuXHR9O1xuXG5cdC8qIHV0aWxzL2NyZWF0ZUVsZW1lbnQuanMgKi9cblx0dmFyIGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiggc3ZnLCBuYW1lc3BhY2VzICkge1xuXG5cdFx0dmFyIGNyZWF0ZUVsZW1lbnQ7XG5cdFx0Ly8gVGVzdCBmb3IgU1ZHIHN1cHBvcnRcblx0XHRpZiAoICFzdmcgKSB7XG5cdFx0XHRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24oIHR5cGUsIG5zICkge1xuXHRcdFx0XHRpZiAoIG5zICYmIG5zICE9PSBuYW1lc3BhY2VzLmh0bWwgKSB7XG5cdFx0XHRcdFx0dGhyb3cgJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG5hbWVzcGFjZXMgb3RoZXIgdGhhbiBodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sLiBUaGUgbW9zdCBsaWtlbHkgY2F1c2Ugb2YgdGhpcyBlcnJvciBpcyB0aGF0IHlvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgU1ZHIGluIGFuIG9sZGVyIGJyb3dzZXIuIFNlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9zdmctYW5kLW9sZGVyLWJyb3dzZXJzIGZvciBtb3JlIGluZm9ybWF0aW9uJztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggdHlwZSApO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKCB0eXBlLCBucyApIHtcblx0XHRcdFx0aWYgKCAhbnMgfHwgbnMgPT09IG5hbWVzcGFjZXMuaHRtbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoIG5zLCB0eXBlICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudDtcblx0fSggc3ZnLCBuYW1lc3BhY2VzICk7XG5cblx0LyogY29uZmlnL2lzQ2xpZW50LmpzICovXG5cdHZhciBpc0NsaWVudCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGlzQ2xpZW50ID0gdHlwZW9mIGRvY3VtZW50ID09PSAnb2JqZWN0Jztcblx0XHRyZXR1cm4gaXNDbGllbnQ7XG5cdH0oKTtcblxuXHQvKiB1dGlscy9kZWZpbmVQcm9wZXJ0eS5qcyAqL1xuXHR2YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiggaXNDbGllbnQgKSB7XG5cblx0XHR2YXIgZGVmaW5lUHJvcGVydHk7XG5cdFx0dHJ5IHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgge30sICd0ZXN0Jywge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fSApO1xuXHRcdFx0aWYgKCBpc0NsaWVudCApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApLCAndGVzdCcsIHtcblx0XHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0Ly8gT2JqZWN0LmRlZmluZVByb3BlcnR5IGRvZXNuJ3QgZXhpc3QsIG9yIHdlJ3JlIGluIElFOCB3aGVyZSB5b3UgY2FuXG5cdFx0XHQvLyBvbmx5IHVzZSBpdCB3aXRoIERPTSBvYmplY3RzICh3aGF0IHRoZSBmdWNrIHdlcmUgeW91IHNtb2tpbmcsIE1TRlQ/KVxuXHRcdFx0ZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiggb2JqLCBwcm9wLCBkZXNjICkge1xuXHRcdFx0XHRvYmpbIHByb3AgXSA9IGRlc2MudmFsdWU7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gZGVmaW5lUHJvcGVydHk7XG5cdH0oIGlzQ2xpZW50ICk7XG5cblx0LyogdXRpbHMvZGVmaW5lUHJvcGVydGllcy5qcyAqL1xuXHR2YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBjcmVhdGVFbGVtZW50LCBkZWZpbmVQcm9wZXJ0eSwgaXNDbGllbnQgKSB7XG5cblx0XHR2YXIgZGVmaW5lUHJvcGVydGllcztcblx0XHR0cnkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHt9LCB7XG5cdFx0XHRcdFx0dGVzdDoge1xuXHRcdFx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdC8vIFRPRE8gaG93IGRvIHdlIGFjY291bnQgZm9yIHRoaXM/IG5vTWFnaWMgPSB0cnVlO1xuXHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGlzQ2xpZW50ICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggY3JlYXRlRWxlbWVudCggJ2RpdicgKSwge1xuXHRcdFx0XHRcdHRlc3Q6IHtcblx0XHRcdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG5cdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiggb2JqLCBwcm9wcyApIHtcblx0XHRcdFx0dmFyIHByb3A7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0XHRcdFx0aWYgKCBwcm9wcy5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xuXHRcdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoIG9iaiwgcHJvcCwgcHJvcHNbIHByb3AgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGRlZmluZVByb3BlcnRpZXM7XG5cdH0oIGNyZWF0ZUVsZW1lbnQsIGRlZmluZVByb3BlcnR5LCBpc0NsaWVudCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9hZGQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX2FkZCA9IGZ1bmN0aW9uKCBpc051bWVyaWMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gYWRkKCByb290LCBrZXlwYXRoLCBkICkge1xuXHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0aWYgKCB0eXBlb2Yga2V5cGF0aCAhPT0gJ3N0cmluZycgfHwgIWlzTnVtZXJpYyggZCApICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdCYWQgYXJndW1lbnRzJyApO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSArcm9vdC5nZXQoIGtleXBhdGggKSB8fCAwO1xuXHRcdFx0aWYgKCAhaXNOdW1lcmljKCB2YWx1ZSApICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDYW5ub3QgYWRkIHRvIGEgbm9uLW51bWVyaWMgdmFsdWUnICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcm9vdC5zZXQoIGtleXBhdGgsIHZhbHVlICsgZCApO1xuXHRcdH07XG5cdH0oIGlzTnVtZXJpYyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2FkZC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRhZGQgPSBmdW5jdGlvbiggYWRkICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkYWRkKCBrZXlwYXRoLCBkICkge1xuXHRcdFx0cmV0dXJuIGFkZCggdGhpcywga2V5cGF0aCwgZCA9PT0gdW5kZWZpbmVkID8gMSA6ICtkICk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfYWRkICk7XG5cblx0LyogdXRpbHMvbm9ybWFsaXNlS2V5cGF0aC5qcyAqL1xuXHR2YXIgbm9ybWFsaXNlS2V5cGF0aCA9IGZ1bmN0aW9uKCBub3JtYWxpc2VSZWYgKSB7XG5cblx0XHR2YXIgbGVhZGluZ0RvdCA9IC9eXFwuKy87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKSB7XG5cdFx0XHRyZXR1cm4gbm9ybWFsaXNlUmVmKCBrZXlwYXRoICkucmVwbGFjZSggbGVhZGluZ0RvdCwgJycgKTtcblx0XHR9O1xuXHR9KCBub3JtYWxpc2VSZWYgKTtcblxuXHQvKiBjb25maWcvdmVuZG9ycy5qcyAqL1xuXHR2YXIgdmVuZG9ycyA9IFtcblx0XHQnbycsXG5cdFx0J21zJyxcblx0XHQnbW96Jyxcblx0XHQnd2Via2l0J1xuXHRdO1xuXG5cdC8qIHV0aWxzL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyAqL1xuXHR2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oIHZlbmRvcnMgKSB7XG5cblx0XHR2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdC8vIElmIHdpbmRvdyBkb2Vzbid0IGV4aXN0LCB3ZSBkb24ndCBuZWVkIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuXHRcdGlmICggdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvMTU3OTY3MVxuXHRcdFx0KCBmdW5jdGlvbiggdmVuZG9ycywgbGFzdFRpbWUsIHdpbmRvdyApIHtcblx0XHRcdFx0dmFyIHgsIHNldFRpbWVvdXQ7XG5cdFx0XHRcdGlmICggd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4ICkge1xuXHRcdFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbIHZlbmRvcnNbIHggXSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdFx0XHRzZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XG5cdFx0XHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHZhciBjdXJyVGltZSwgdGltZVRvQ2FsbCwgaWQ7XG5cdFx0XHRcdFx0XHRjdXJyVGltZSA9IERhdGUubm93KCk7XG5cdFx0XHRcdFx0XHR0aW1lVG9DYWxsID0gTWF0aC5tYXgoIDAsIDE2IC0gKCBjdXJyVGltZSAtIGxhc3RUaW1lICkgKTtcblx0XHRcdFx0XHRcdGlkID0gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKCBjdXJyVGltZSArIHRpbWVUb0NhbGwgKTtcblx0XHRcdFx0XHRcdH0sIHRpbWVUb0NhbGwgKTtcblx0XHRcdFx0XHRcdGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGlkO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH0oIHZlbmRvcnMsIDAsIHdpbmRvdyApICk7XG5cdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHR9KCB2ZW5kb3JzICk7XG5cblx0LyogdXRpbHMvZ2V0VGltZS5qcyAqL1xuXHR2YXIgZ2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGdldFRpbWU7XG5cdFx0aWYgKCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgdHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRnZXRUaW1lID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnZXRUaW1lID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBEYXRlLm5vdygpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGdldFRpbWU7XG5cdH0oKTtcblxuXHQvKiBzaGFyZWQvYW5pbWF0aW9ucy5qcyAqL1xuXHR2YXIgYW5pbWF0aW9ucyA9IGZ1bmN0aW9uKCByQUYsIGdldFRpbWUsIHJ1bmxvb3AgKSB7XG5cblx0XHR2YXIgcXVldWUgPSBbXTtcblx0XHR2YXIgYW5pbWF0aW9ucyA9IHtcblx0XHRcdHRpY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaSwgYW5pbWF0aW9uLCBub3c7XG5cdFx0XHRcdG5vdyA9IGdldFRpbWUoKTtcblx0XHRcdFx0cnVubG9vcC5zdGFydCgpO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbiA9IHF1ZXVlWyBpIF07XG5cdFx0XHRcdFx0aWYgKCAhYW5pbWF0aW9uLnRpY2soIG5vdyApICkge1xuXHRcdFx0XHRcdFx0Ly8gYW5pbWF0aW9uIGlzIGNvbXBsZXRlLCByZW1vdmUgaXQgZnJvbSB0aGUgc3RhY2ssIGFuZCBkZWNyZW1lbnQgaSBzbyB3ZSBkb24ndCBtaXNzIG9uZVxuXHRcdFx0XHRcdFx0cXVldWUuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0aWYgKCBxdWV1ZS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0ckFGKCBhbmltYXRpb25zLnRpY2sgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhbmltYXRpb25zLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGFkZDogZnVuY3Rpb24oIGFuaW1hdGlvbiApIHtcblx0XHRcdFx0cXVldWUucHVzaCggYW5pbWF0aW9uICk7XG5cdFx0XHRcdGlmICggIWFuaW1hdGlvbnMucnVubmluZyApIHtcblx0XHRcdFx0XHRhbmltYXRpb25zLnJ1bm5pbmcgPSB0cnVlO1xuXHRcdFx0XHRcdHJBRiggYW5pbWF0aW9ucy50aWNrICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvLyBUT0RPIG9wdGltaXNlIHRoaXNcblx0XHRcdGFib3J0OiBmdW5jdGlvbigga2V5cGF0aCwgcm9vdCApIHtcblx0XHRcdFx0dmFyIGkgPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRcdFx0YW5pbWF0aW9uO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRhbmltYXRpb24gPSBxdWV1ZVsgaSBdO1xuXHRcdFx0XHRcdGlmICggYW5pbWF0aW9uLnJvb3QgPT09IHJvb3QgJiYgYW5pbWF0aW9uLmtleXBhdGggPT09IGtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHRhbmltYXRpb24uc3RvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIGFuaW1hdGlvbnM7XG5cdH0oIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgZ2V0VGltZSwgcnVubG9vcCApO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL2Nzcy90cmFuc2Zvcm0uanMgKi9cblx0dmFyIHRyYW5zZm9ybSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBzZWxlY3RvcnNQYXR0ZXJuID0gLyg/Ol58XFx9KT9cXHMqKFteXFx7XFx9XSspXFxzKlxcey9nLFxuXHRcdFx0Y29tbWVudHNQYXR0ZXJuID0gL1xcL1xcKi4qP1xcKlxcLy9nLFxuXHRcdFx0c2VsZWN0b3JVbml0UGF0dGVybiA9IC8oKD86KD86XFxbW15cXF0rXVxcXSl8KD86W15cXHNcXCtcXD5cXH46XSkpKykoKD86OlteXFxzXFwrXFw+XFx+XSspP1xccypbXFxzXFwrXFw+XFx+XT8pXFxzKi9nLFxuXHRcdFx0bWVkaWFRdWVyeVBhdHRlcm4gPSAvXkBtZWRpYS8sXG5cdFx0XHRkYXRhUnZjR3VpZFBhdHRlcm4gPSAvXFxbZGF0YS1ydmNndWlkPVwiW2EtejAtOS1dK1wiXS9nO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gdHJhbnNmb3JtQ3NzKCBjc3MsIGd1aWQgKSB7XG5cdFx0XHR2YXIgdHJhbnNmb3JtZWQsIGFkZEd1aWQ7XG5cdFx0XHRhZGRHdWlkID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0XHR2YXIgc2VsZWN0b3JVbml0cywgbWF0Y2gsIHVuaXQsIGRhdGFBdHRyLCBiYXNlLCBwcmVwZW5kZWQsIGFwcGVuZGVkLCBpLCB0cmFuc2Zvcm1lZCA9IFtdO1xuXHRcdFx0XHRzZWxlY3RvclVuaXRzID0gW107XG5cdFx0XHRcdHdoaWxlICggbWF0Y2ggPSBzZWxlY3RvclVuaXRQYXR0ZXJuLmV4ZWMoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0c2VsZWN0b3JVbml0cy5wdXNoKCB7XG5cdFx0XHRcdFx0XHRzdHI6IG1hdGNoWyAwIF0sXG5cdFx0XHRcdFx0XHRiYXNlOiBtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0bW9kaWZpZXJzOiBtYXRjaFsgMiBdXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEZvciBlYWNoIHNpbXBsZSBzZWxlY3RvciB3aXRoaW4gdGhlIHNlbGVjdG9yLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHZlcnNpb25cblx0XHRcdFx0Ly8gdGhhdCBhKSBjb21iaW5lcyB3aXRoIHRoZSBndWlkLCBhbmQgYikgaXMgaW5zaWRlIHRoZSBndWlkXG5cdFx0XHRcdGRhdGFBdHRyID0gJ1tkYXRhLXJ2Y2d1aWQ9XCInICsgZ3VpZCArICdcIl0nO1xuXHRcdFx0XHRiYXNlID0gc2VsZWN0b3JVbml0cy5tYXAoIGV4dHJhY3RTdHJpbmcgKTtcblx0XHRcdFx0aSA9IHNlbGVjdG9yVW5pdHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRhcHBlbmRlZCA9IGJhc2Uuc2xpY2UoKTtcblx0XHRcdFx0XHQvLyBQc2V1ZG8tc2VsZWN0b3JzIHNob3VsZCBnbyBhZnRlciB0aGUgYXR0cmlidXRlIHNlbGVjdG9yXG5cdFx0XHRcdFx0dW5pdCA9IHNlbGVjdG9yVW5pdHNbIGkgXTtcblx0XHRcdFx0XHRhcHBlbmRlZFsgaSBdID0gdW5pdC5iYXNlICsgZGF0YUF0dHIgKyB1bml0Lm1vZGlmaWVycyB8fCAnJztcblx0XHRcdFx0XHRwcmVwZW5kZWQgPSBiYXNlLnNsaWNlKCk7XG5cdFx0XHRcdFx0cHJlcGVuZGVkWyBpIF0gPSBkYXRhQXR0ciArICcgJyArIHByZXBlbmRlZFsgaSBdO1xuXHRcdFx0XHRcdHRyYW5zZm9ybWVkLnB1c2goIGFwcGVuZGVkLmpvaW4oICcgJyApLCBwcmVwZW5kZWQuam9pbiggJyAnICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJhbnNmb3JtZWQuam9pbiggJywgJyApO1xuXHRcdFx0fTtcblx0XHRcdGlmICggZGF0YVJ2Y0d1aWRQYXR0ZXJuLnRlc3QoIGNzcyApICkge1xuXHRcdFx0XHR0cmFuc2Zvcm1lZCA9IGNzcy5yZXBsYWNlKCBkYXRhUnZjR3VpZFBhdHRlcm4sICdbZGF0YS1ydmNndWlkPVwiJyArIGd1aWQgKyAnXCJdJyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHJhbnNmb3JtZWQgPSBjc3MucmVwbGFjZSggY29tbWVudHNQYXR0ZXJuLCAnJyApLnJlcGxhY2UoIHNlbGVjdG9yc1BhdHRlcm4sIGZ1bmN0aW9uKCBtYXRjaCwgJDEgKSB7XG5cdFx0XHRcdFx0dmFyIHNlbGVjdG9ycywgdHJhbnNmb3JtZWQ7XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgdHJhbnNmb3JtIG1lZGlhIHF1ZXJpZXMhXG5cdFx0XHRcdFx0aWYgKCBtZWRpYVF1ZXJ5UGF0dGVybi50ZXN0KCAkMSApIClcblx0XHRcdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdFx0XHRzZWxlY3RvcnMgPSAkMS5zcGxpdCggJywnICkubWFwKCB0cmltICk7XG5cdFx0XHRcdFx0dHJhbnNmb3JtZWQgPSBzZWxlY3RvcnMubWFwKCBhZGRHdWlkICkuam9pbiggJywgJyApICsgJyAnO1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaC5yZXBsYWNlKCAkMSwgdHJhbnNmb3JtZWQgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRyYW5zZm9ybWVkO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB0cmltKCBzdHIgKSB7XG5cdFx0XHRpZiAoIHN0ci50cmltICkge1xuXHRcdFx0XHRyZXR1cm4gc3RyLnRyaW0oKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSggL15cXHMrLywgJycgKS5yZXBsYWNlKCAvXFxzKyQvLCAnJyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGV4dHJhY3RTdHJpbmcoIHVuaXQgKSB7XG5cdFx0XHRyZXR1cm4gdW5pdC5zdHI7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL2Nzcy9jc3MuanMgKi9cblx0dmFyIGNzcyA9IGZ1bmN0aW9uKCB0cmFuc2Zvcm1Dc3MgKSB7XG5cblx0XHR2YXIgY3NzQ29uZmlnID0ge1xuXHRcdFx0bmFtZTogJ2NzcycsXG5cdFx0XHRleHRlbmQ6IGV4dGVuZCxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge31cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZXh0ZW5kKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGd1aWQgPSBwcm90by5jb25zdHJ1Y3Rvci5fZ3VpZCxcblx0XHRcdFx0Y3NzO1xuXHRcdFx0aWYgKCBjc3MgPSBnZXRDc3MoIG9wdGlvbnMuY3NzLCBvcHRpb25zLCBndWlkICkgfHwgZ2V0Q3NzKCBQYXJlbnQuY3NzLCBQYXJlbnQsIGd1aWQgKSApIHtcblx0XHRcdFx0cHJvdG8uY29uc3RydWN0b3IuY3NzID0gY3NzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENzcyggY3NzLCB0YXJnZXQsIGd1aWQgKSB7XG5cdFx0XHRpZiAoICFjc3MgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0YXJnZXQubm9Dc3NUcmFuc2Zvcm0gPyBjc3MgOiB0cmFuc2Zvcm1Dc3MoIGNzcywgZ3VpZCApO1xuXHRcdH1cblx0XHRyZXR1cm4gY3NzQ29uZmlnO1xuXHR9KCB0cmFuc2Zvcm0gKTtcblxuXHQvKiB1dGlscy93cmFwTWV0aG9kLmpzICovXG5cdHZhciB3cmFwTWV0aG9kID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiggbWV0aG9kLCBzdXBlck1ldGhvZCwgZm9yY2UgKSB7XG5cdFx0XHRpZiAoIGZvcmNlIHx8IG5lZWRzU3VwZXIoIG1ldGhvZCwgc3VwZXJNZXRob2QgKSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBoYXNTdXBlciA9ICdfc3VwZXInIGluIHRoaXMsXG5cdFx0XHRcdFx0XHRfc3VwZXIgPSB0aGlzLl9zdXBlcixcblx0XHRcdFx0XHRcdHJlc3VsdDtcblx0XHRcdFx0XHR0aGlzLl9zdXBlciA9IHN1cGVyTWV0aG9kO1xuXHRcdFx0XHRcdHJlc3VsdCA9IG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0aWYgKCBoYXNTdXBlciApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N1cGVyID0gX3N1cGVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG1ldGhvZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gbmVlZHNTdXBlciggbWV0aG9kLCBzdXBlck1ldGhvZCApIHtcblx0XHRcdHJldHVybiB0eXBlb2Ygc3VwZXJNZXRob2QgPT09ICdmdW5jdGlvbicgJiYgL19zdXBlci8udGVzdCggbWV0aG9kICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL2RhdGEuanMgKi9cblx0dmFyIGRhdGEgPSBmdW5jdGlvbiggd3JhcCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgZGF0YUNvbmZpZyA9IHtcblx0XHRcdG5hbWU6ICdkYXRhJyxcblx0XHRcdGV4dGVuZDogZXh0ZW5kLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlc2V0OiByZXNldFxuXHRcdH07XG5cdFx0X19leHBvcnQgPSBkYXRhQ29uZmlnO1xuXG5cdFx0ZnVuY3Rpb24gY29tYmluZSggUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBvcHRpb25zLmRhdGEgfHwge30sXG5cdFx0XHRcdHBhcmVudFZhbHVlID0gZ2V0QWRkZWRLZXlzKCBQYXJlbnQucHJvdG90eXBlLmRhdGEgKTtcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdkYXRhIG9wdGlvbiBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBcIicgKyB2YWx1ZSArICdcIiBpcyBub3QgdmFsaWQnICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGlzcGF0Y2goIHBhcmVudFZhbHVlLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGV4dGVuZCggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdHByb3RvLmRhdGEgPSBjb21iaW5lKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5pdCggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHZhbHVlID0gb3B0aW9ucy5kYXRhLFxuXHRcdFx0XHRyZXN1bHQgPSBjb21iaW5lKCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKTtcblx0XHRcdGlmICggdHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LmNhbGwoIHJhY3RpdmUsIHZhbHVlICkgfHwgdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmFjdGl2ZS5kYXRhID0gcmVzdWx0IHx8IHt9O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc2V0KCByYWN0aXZlICkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMuaW5pdCggcmFjdGl2ZS5jb25zdHJ1Y3RvciwgcmFjdGl2ZSwgcmFjdGl2ZSApO1xuXHRcdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRcdHJhY3RpdmUuZGF0YSA9IHJlc3VsdDtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QWRkZWRLZXlzKCBwYXJlbnQgKSB7XG5cdFx0XHQvLyBvbmx5IGZvciBmdW5jdGlvbnMgdGhhdCBoYWQga2V5cyBhZGRlZFxuXHRcdFx0aWYgKCB0eXBlb2YgcGFyZW50ICE9PSAnZnVuY3Rpb24nIHx8ICFPYmplY3Qua2V5cyggcGFyZW50ICkubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0Ly8gY29weSB0aGUgYWRkZWQga2V5cyB0byB0ZW1wICdvYmplY3QnLCBvdGhlcndpc2Vcblx0XHRcdC8vIHBhcmVudCB3b3VsZCBiZSBpbnRlcnByZXRlZCBhcyAnZnVuY3Rpb24nIGJ5IGRpc3BhdGNoXG5cdFx0XHR2YXIgdGVtcCA9IHt9O1xuXHRcdFx0Y29weSggcGFyZW50LCB0ZW1wICk7XG5cdFx0XHQvLyByb2xsIGluIGFkZGVkIGtleXNcblx0XHRcdHJldHVybiBkaXNwYXRjaCggcGFyZW50LCB0ZW1wICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGlzcGF0Y2goIHBhcmVudCwgY2hpbGQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuIGV4dGVuZEZuKCBjaGlsZCwgcGFyZW50ICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgcGFyZW50ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRyZXR1cm4gZnJvbUZuKCBjaGlsZCwgcGFyZW50ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZnJvbVByb3BlcnRpZXMoIGNoaWxkLCBwYXJlbnQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb3B5KCBmcm9tLCB0bywgZmlsbE9ubHkgKSB7XG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIGZyb20gKSB7XG5cdFx0XHRcdGlmICggZmlsbE9ubHkgJiYga2V5IGluIHRvICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRvWyBrZXkgXSA9IGZyb21bIGtleSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZyb21Qcm9wZXJ0aWVzKCBjaGlsZCwgcGFyZW50ICkge1xuXHRcdFx0Y2hpbGQgPSBjaGlsZCB8fCB7fTtcblx0XHRcdGlmICggIXBhcmVudCApIHtcblx0XHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdFx0fVxuXHRcdFx0Y29weSggcGFyZW50LCBjaGlsZCwgdHJ1ZSApO1xuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZyb21GbiggY2hpbGQsIHBhcmVudEZuICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0XHR2YXIga2V5cztcblx0XHRcdFx0aWYgKCBjaGlsZCApIHtcblx0XHRcdFx0XHQvLyBUcmFjayB0aGUga2V5cyB0aGF0IG91ciBvbiB0aGUgY2hpbGQsXG5cdFx0XHRcdFx0Ly8gYnV0IG5vdCBvbiB0aGUgZGF0YS4gV2UnbGwgbmVlZCB0byBhcHBseSB0aGVzZVxuXHRcdFx0XHRcdC8vIGFmdGVyIHRoZSBwYXJlbnQgZnVuY3Rpb24gcmV0dXJucy5cblx0XHRcdFx0XHRrZXlzID0gW107XG5cdFx0XHRcdFx0Zm9yICggdmFyIGtleSBpbiBjaGlsZCApIHtcblx0XHRcdFx0XHRcdGlmICggIWRhdGEgfHwgISgga2V5IGluIGRhdGEgKSApIHtcblx0XHRcdFx0XHRcdFx0a2V5cy5wdXNoKCBrZXkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gY2FsbCB0aGUgcGFyZW50IGZuLCB1c2UgZGF0YSBpZiBubyByZXR1cm4gdmFsdWVcblx0XHRcdFx0ZGF0YSA9IHBhcmVudEZuLmNhbGwoIHRoaXMsIGRhdGEgKSB8fCBkYXRhO1xuXHRcdFx0XHQvLyBDb3B5IGNoaWxkIGtleXMgYmFjayBvbnRvIGRhdGEuIFRoZSBjaGlsZCBrZXlzXG5cdFx0XHRcdC8vIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB3aGF0ZXZlciB0aGVcblx0XHRcdFx0Ly8gcGFyZW50IGRpZCB3aXRoIHRoZSBkYXRhLlxuXHRcdFx0XHRpZiAoIGtleXMgJiYga2V5cy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0XHRcdFx0a2V5cy5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdFx0ZGF0YVsga2V5IF0gPSBjaGlsZFsga2V5IF07XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHRlbmRGbiggY2hpbGRGbiwgcGFyZW50ICkge1xuXHRcdFx0dmFyIHBhcmVudEZuO1xuXHRcdFx0aWYgKCB0eXBlb2YgcGFyZW50ICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHQvLyBjb3B5IHByb3BzIHRvIGRhdGFcblx0XHRcdFx0cGFyZW50Rm4gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0XHRmcm9tUHJvcGVydGllcyggZGF0YSwgcGFyZW50ICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXJlbnRGbiA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0XHRcdC8vIGdpdmUgcGFyZW50IGZ1bmN0aW9uIGl0J3Mgb3duIHRoaXMuX3N1cGVyIGNvbnRleHQsXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHRoaXMuX3N1cGVyIGlzIGZyb20gY2hpbGQgYW5kXG5cdFx0XHRcdFx0Ly8gY2F1c2VzIGluZmluaXRlIGxvb3Bcblx0XHRcdFx0XHRwYXJlbnQgPSB3cmFwKCBwYXJlbnQsIGZ1bmN0aW9uKCkge30sIHRydWUgKTtcblx0XHRcdFx0XHRyZXR1cm4gcGFyZW50LmNhbGwoIHRoaXMsIGRhdGEgKSB8fCBkYXRhO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHdyYXAoIGNoaWxkRm4sIHBhcmVudEZuICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggd3JhcE1ldGhvZCApO1xuXG5cdC8qIGNvbmZpZy90eXBlcy5qcyAqL1xuXHR2YXIgdHlwZXMgPSB7XG5cdFx0VEVYVDogMSxcblx0XHRJTlRFUlBPTEFUT1I6IDIsXG5cdFx0VFJJUExFOiAzLFxuXHRcdFNFQ1RJT046IDQsXG5cdFx0SU5WRVJURUQ6IDUsXG5cdFx0Q0xPU0lORzogNixcblx0XHRFTEVNRU5UOiA3LFxuXHRcdFBBUlRJQUw6IDgsXG5cdFx0Q09NTUVOVDogOSxcblx0XHRERUxJTUNIQU5HRTogMTAsXG5cdFx0TVVTVEFDSEU6IDExLFxuXHRcdFRBRzogMTIsXG5cdFx0QVRUUklCVVRFOiAxMyxcblx0XHRDTE9TSU5HX1RBRzogMTQsXG5cdFx0Q09NUE9ORU5UOiAxNSxcblx0XHROVU1CRVJfTElURVJBTDogMjAsXG5cdFx0U1RSSU5HX0xJVEVSQUw6IDIxLFxuXHRcdEFSUkFZX0xJVEVSQUw6IDIyLFxuXHRcdE9CSkVDVF9MSVRFUkFMOiAyMyxcblx0XHRCT09MRUFOX0xJVEVSQUw6IDI0LFxuXHRcdEdMT0JBTDogMjYsXG5cdFx0S0VZX1ZBTFVFX1BBSVI6IDI3LFxuXHRcdFJFRkVSRU5DRTogMzAsXG5cdFx0UkVGSU5FTUVOVDogMzEsXG5cdFx0TUVNQkVSOiAzMixcblx0XHRQUkVGSVhfT1BFUkFUT1I6IDMzLFxuXHRcdEJSQUNLRVRFRDogMzQsXG5cdFx0Q09ORElUSU9OQUw6IDM1LFxuXHRcdElORklYX09QRVJBVE9SOiAzNixcblx0XHRJTlZPQ0FUSU9OOiA0MCxcblx0XHRTRUNUSU9OX0lGOiA1MCxcblx0XHRTRUNUSU9OX1VOTEVTUzogNTEsXG5cdFx0U0VDVElPTl9FQUNIOiA1Mixcblx0XHRTRUNUSU9OX1dJVEg6IDUzLFxuXHRcdFNFQ1RJT05fSUZfV0lUSDogNTRcblx0fTtcblxuXHQvKiB1dGlscy9jcmVhdGUuanMgKi9cblx0dmFyIGNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGNyZWF0ZTtcblx0XHR0cnkge1xuXHRcdFx0T2JqZWN0LmNyZWF0ZSggbnVsbCApO1xuXHRcdFx0Y3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0Ly8gc2lnaFxuXHRcdFx0Y3JlYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBGID0gZnVuY3Rpb24oKSB7fTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBwcm90bywgcHJvcHMgKSB7XG5cdFx0XHRcdFx0dmFyIG9iajtcblx0XHRcdFx0XHRpZiAoIHByb3RvID09PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xuXHRcdFx0XHRcdG9iaiA9IG5ldyBGKCk7XG5cdFx0XHRcdFx0aWYgKCBwcm9wcyApIHtcblx0XHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBvYmosIHByb3BzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdH07XG5cdFx0XHR9KCk7XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGU7XG5cdH0oKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvc2hhcmVkL2Vycm9ycy5qcyAqL1xuXHR2YXIgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMgPSB7XG5cdFx0ZXhwZWN0ZWRFeHByZXNzaW9uOiAnRXhwZWN0ZWQgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb24nLFxuXHRcdGV4cGVjdGVkUGFyZW46ICdFeHBlY3RlZCBjbG9zaW5nIHBhcmVuJ1xuXHR9O1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvbnVtYmVyTGl0ZXJhbC5qcyAqL1xuXHR2YXIgbnVtYmVyTGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHZhciBudW1iZXJQYXR0ZXJuID0gL14oPzpbKy1dPykoPzooPzooPzowfFsxLTldXFxkKik/XFwuXFxkKyl8KD86KD86MHxbMS05XVxcZCopXFwuKXwoPzowfFsxLTldXFxkKikpKD86W2VFXVsrLV0/XFxkKyk/Lztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cdFx0XHRpZiAoIHJlc3VsdCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIG51bWJlclBhdHRlcm4gKSApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5OVU1CRVJfTElURVJBTCxcblx0XHRcdFx0XHR2OiByZXN1bHRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9ib29sZWFuTGl0ZXJhbC5qcyAqL1xuXHR2YXIgYm9vbGVhbkxpdGVyYWwgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciByZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRpZiAoIHJlbWFpbmluZy5zdWJzdHIoIDAsIDQgKSA9PT0gJ3RydWUnICkge1xuXHRcdFx0XHRwYXJzZXIucG9zICs9IDQ7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuQk9PTEVBTl9MSVRFUkFMLFxuXHRcdFx0XHRcdHY6ICd0cnVlJ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCByZW1haW5pbmcuc3Vic3RyKCAwLCA1ICkgPT09ICdmYWxzZScgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5CT09MRUFOX0xJVEVSQUwsXG5cdFx0XHRcdFx0djogJ2ZhbHNlJ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL3N0cmluZ0xpdGVyYWwvbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIuanMgKi9cblx0dmFyIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgc3RyaW5nTWlkZGxlUGF0dGVybiwgZXNjYXBlU2VxdWVuY2VQYXR0ZXJuLCBsaW5lQ29udGludWF0aW9uUGF0dGVybjtcblx0XHQvLyBNYXRjaCBvbmUgb3IgbW9yZSBjaGFyYWN0ZXJzIHVudGlsOiBcIiwgJywgXFwsIG9yIEVPTC9FT0YuXG5cdFx0Ly8gRU9ML0VPRiBpcyB3cml0dGVuIGFzICg/IS4pIChtZWFuaW5nIHRoZXJlJ3Mgbm8gbm9uLW5ld2xpbmUgY2hhciBuZXh0KS5cblx0XHRzdHJpbmdNaWRkbGVQYXR0ZXJuID0gL14oPz0uKVteXCInXFxcXF0rPyg/Oig/IS4pfCg/PVtcIidcXFxcXSkpLztcblx0XHQvLyBNYXRjaCBvbmUgZXNjYXBlIHNlcXVlbmNlLCBpbmNsdWRpbmcgdGhlIGJhY2tzbGFzaC5cblx0XHRlc2NhcGVTZXF1ZW5jZVBhdHRlcm4gPSAvXlxcXFwoPzpbJ1wiXFxcXGJmbnJ0XXwwKD8hWzAtOV0pfHhbMC05YS1mQS1GXXsyfXx1WzAtOWEtZkEtRl17NH18KD89LilbXnV4MC05XSkvO1xuXHRcdC8vIE1hdGNoIG9uZSBFUzUgbGluZSBjb250aW51YXRpb24gKGJhY2tzbGFzaCArIGxpbmUgdGVybWluYXRvcikuXG5cdFx0bGluZUNvbnRpbnVhdGlvblBhdHRlcm4gPSAvXlxcXFwoPzpcXHJcXG58W1xcdTAwMEFcXHUwMDBEXFx1MjAyOFxcdTIwMjldKS87XG5cdFx0Ly8gSGVscGVyIGZvciBkZWZpbmluZyBnZXREb3VibGVRdW90ZWRTdHJpbmcgYW5kIGdldFNpbmdsZVF1b3RlZFN0cmluZy5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIG9rUXVvdGUgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdFx0dmFyIHN0YXJ0LCBsaXRlcmFsLCBkb25lLCBuZXh0O1xuXHRcdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRcdGxpdGVyYWwgPSAnXCInO1xuXHRcdFx0XHRkb25lID0gZmFsc2U7XG5cdFx0XHRcdHdoaWxlICggIWRvbmUgKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHN0cmluZ01pZGRsZVBhdHRlcm4gKSB8fCBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBlc2NhcGVTZXF1ZW5jZVBhdHRlcm4gKSB8fCBwYXJzZXIubWF0Y2hTdHJpbmcoIG9rUXVvdGUgKTtcblx0XHRcdFx0XHRpZiAoIG5leHQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5leHQgPT09ICdcIicgKSB7XG5cdFx0XHRcdFx0XHRcdGxpdGVyYWwgKz0gJ1xcXFxcIic7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSAnXFxcXFxcJycgKSB7XG5cdFx0XHRcdFx0XHRcdGxpdGVyYWwgKz0gJ1xcJyc7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsICs9IG5leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5leHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBsaW5lQ29udGludWF0aW9uUGF0dGVybiApO1xuXHRcdFx0XHRcdFx0aWYgKCBuZXh0ICkge1xuXHRcdFx0XHRcdFx0XHQvLyBjb252ZXJ0IFxcKG5ld2xpbmUtbGlrZSkgaW50byBhIFxcdSBlc2NhcGUsIHdoaWNoIGlzIGFsbG93ZWQgaW4gSlNPTlxuXHRcdFx0XHRcdFx0XHRsaXRlcmFsICs9ICdcXFxcdScgKyAoICcwMDAnICsgbmV4dC5jaGFyQ29kZUF0KCAxICkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLTQgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGRvbmUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRsaXRlcmFsICs9ICdcIic7XG5cdFx0XHRcdC8vIHVzZSBKU09OLnBhcnNlIHRvIGludGVycHJldCBlc2NhcGVzXG5cdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKCBsaXRlcmFsICk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL3N0cmluZ0xpdGVyYWwvc2luZ2xlUXVvdGVkU3RyaW5nLmpzICovXG5cdHZhciBzaW5nbGVRdW90ZWRTdHJpbmcgPSBmdW5jdGlvbiggbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIgKSB7XG5cblx0XHRyZXR1cm4gbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIoICdcIicgKTtcblx0fSggbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL3N0cmluZ0xpdGVyYWwvZG91YmxlUXVvdGVkU3RyaW5nLmpzICovXG5cdHZhciBkb3VibGVRdW90ZWRTdHJpbmcgPSBmdW5jdGlvbiggbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIgKSB7XG5cblx0XHRyZXR1cm4gbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIoICdcXCcnICk7XG5cdH0oIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9zdHJpbmdMaXRlcmFsL19zdHJpbmdMaXRlcmFsLmpzICovXG5cdHZhciBzdHJpbmdMaXRlcmFsID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRTaW5nbGVRdW90ZWRTdHJpbmcsIGdldERvdWJsZVF1b3RlZFN0cmluZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBzdHJpbmc7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ1wiJyApICkge1xuXHRcdFx0XHRzdHJpbmcgPSBnZXREb3VibGVRdW90ZWRTdHJpbmcoIHBhcnNlciApO1xuXHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICdcIicgKSApIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5TVFJJTkdfTElURVJBTCxcblx0XHRcdFx0XHR2OiBzdHJpbmdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnXFwnJyApICkge1xuXHRcdFx0XHRzdHJpbmcgPSBnZXRTaW5nbGVRdW90ZWRTdHJpbmcoIHBhcnNlciApO1xuXHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICdcXCcnICkgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuU1RSSU5HX0xJVEVSQUwsXG5cdFx0XHRcdFx0djogc3RyaW5nXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9KCB0eXBlcywgc2luZ2xlUXVvdGVkU3RyaW5nLCBkb3VibGVRdW90ZWRTdHJpbmcgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvc2hhcmVkL3BhdHRlcm5zLmpzICovXG5cdHZhciBwYXR0ZXJucyA9IHtcblx0XHRuYW1lOiAvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKi9cblx0fTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvc2hhcmVkL2tleS5qcyAqL1xuXHR2YXIga2V5ID0gZnVuY3Rpb24oIGdldFN0cmluZ0xpdGVyYWwsIGdldE51bWJlckxpdGVyYWwsIHBhdHRlcm5zICkge1xuXG5cdFx0dmFyIGlkZW50aWZpZXIgPSAvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKiQvO1xuXHRcdC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtcHJvcGVydGllc1xuXHRcdC8vIGNhbiBiZSBhbnkgbmFtZSwgc3RyaW5nIGxpdGVyYWwsIG9yIG51bWJlciBsaXRlcmFsXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgdG9rZW47XG5cdFx0XHRpZiAoIHRva2VuID0gZ2V0U3RyaW5nTGl0ZXJhbCggcGFyc2VyICkgKSB7XG5cdFx0XHRcdHJldHVybiBpZGVudGlmaWVyLnRlc3QoIHRva2VuLnYgKSA/IHRva2VuLnYgOiAnXCInICsgdG9rZW4udi5yZXBsYWNlKCAvXCIvZywgJ1xcXFxcIicgKSArICdcIic7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRva2VuID0gZ2V0TnVtYmVyTGl0ZXJhbCggcGFyc2VyICkgKSB7XG5cdFx0XHRcdHJldHVybiB0b2tlbi52O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0b2tlbiA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHBhdHRlcm5zLm5hbWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHRva2VuO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHN0cmluZ0xpdGVyYWwsIG51bWJlckxpdGVyYWwsIHBhdHRlcm5zICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9vYmplY3RMaXRlcmFsL2tleVZhbHVlUGFpci5qcyAqL1xuXHR2YXIga2V5VmFsdWVQYWlyID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRLZXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwga2V5LCB2YWx1ZTtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiAneycgYW5kIGtleVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0a2V5ID0gZ2V0S2V5KCBwYXJzZXIgKTtcblx0XHRcdGlmICgga2V5ID09PSBudWxsICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGtleSBhbmQgJzonXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlICc6J1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnOicgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiAnOicgYW5kIHZhbHVlXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHQvLyBuZXh0IGV4cHJlc3Npb24gbXVzdCBiZSBhLCB3ZWxsLi4uIGV4cHJlc3Npb25cblx0XHRcdHZhbHVlID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuS0VZX1ZBTFVFX1BBSVIsXG5cdFx0XHRcdGs6IGtleSxcblx0XHRcdFx0djogdmFsdWVcblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIGtleSApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvb2JqZWN0TGl0ZXJhbC9rZXlWYWx1ZVBhaXJzLmpzICovXG5cdHZhciBrZXlWYWx1ZVBhaXJzID0gZnVuY3Rpb24oIGdldEtleVZhbHVlUGFpciApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRLZXlWYWx1ZVBhaXJzKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIHBhaXJzLCBwYWlyLCBrZXlWYWx1ZVBhaXJzO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0cGFpciA9IGdldEtleVZhbHVlUGFpciggcGFyc2VyICk7XG5cdFx0XHRpZiAoIHBhaXIgPT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFpcnMgPSBbIHBhaXIgXTtcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcblx0XHRcdFx0a2V5VmFsdWVQYWlycyA9IGdldEtleVZhbHVlUGFpcnMoIHBhcnNlciApO1xuXHRcdFx0XHRpZiAoICFrZXlWYWx1ZVBhaXJzICkge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcGFpcnMuY29uY2F0KCBrZXlWYWx1ZVBhaXJzICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFpcnM7XG5cdFx0fTtcblx0fSgga2V5VmFsdWVQYWlyICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9vYmplY3RMaXRlcmFsL19vYmplY3RMaXRlcmFsLmpzICovXG5cdHZhciBvYmplY3RMaXRlcmFsID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRLZXlWYWx1ZVBhaXJzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGtleVZhbHVlUGFpcnM7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICd7JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0a2V5VmFsdWVQYWlycyA9IGdldEtleVZhbHVlUGFpcnMoIHBhcnNlciApO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGZpbmFsIHZhbHVlIGFuZCAnfSdcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ30nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5PQkpFQ1RfTElURVJBTCxcblx0XHRcdFx0bToga2V5VmFsdWVQYWlyc1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywga2V5VmFsdWVQYWlycyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9zaGFyZWQvZXhwcmVzc2lvbkxpc3QuanMgKi9cblx0dmFyIGV4cHJlc3Npb25MaXN0ID0gZnVuY3Rpb24oIGVycm9ycyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRFeHByZXNzaW9uTGlzdCggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBleHByZXNzaW9ucywgZXhwciwgbmV4dDtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGV4cHIgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdGlmICggZXhwciA9PT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRleHByZXNzaW9ucyA9IFsgZXhwciBdO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGV4cHJlc3Npb24gYW5kICcsJ1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcsJyApICkge1xuXHRcdFx0XHRuZXh0ID0gZ2V0RXhwcmVzc2lvbkxpc3QoIHBhcnNlciApO1xuXHRcdFx0XHRpZiAoIG5leHQgPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV4dC5mb3JFYWNoKCBhcHBlbmQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYXBwZW5kKCBleHByZXNzaW9uICkge1xuXHRcdFx0XHRleHByZXNzaW9ucy5wdXNoKCBleHByZXNzaW9uICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZXhwcmVzc2lvbnM7XG5cdFx0fTtcblx0fSggcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL2FycmF5TGl0ZXJhbC5qcyAqL1xuXHR2YXIgYXJyYXlMaXRlcmFsID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRFeHByZXNzaW9uTGlzdCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uTGlzdDtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlICdbJ1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnWycgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGV4cHJlc3Npb25MaXN0ID0gZ2V0RXhwcmVzc2lvbkxpc3QoIHBhcnNlciApO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnXScgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLkFSUkFZX0xJVEVSQUwsXG5cdFx0XHRcdG06IGV4cHJlc3Npb25MaXN0XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBleHByZXNzaW9uTGlzdCApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvX2xpdGVyYWwuanMgKi9cblx0dmFyIGxpdGVyYWwgPSBmdW5jdGlvbiggZ2V0TnVtYmVyTGl0ZXJhbCwgZ2V0Qm9vbGVhbkxpdGVyYWwsIGdldFN0cmluZ0xpdGVyYWwsIGdldE9iamVjdExpdGVyYWwsIGdldEFycmF5TGl0ZXJhbCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIGxpdGVyYWwgPSBnZXROdW1iZXJMaXRlcmFsKCBwYXJzZXIgKSB8fCBnZXRCb29sZWFuTGl0ZXJhbCggcGFyc2VyICkgfHwgZ2V0U3RyaW5nTGl0ZXJhbCggcGFyc2VyICkgfHwgZ2V0T2JqZWN0TGl0ZXJhbCggcGFyc2VyICkgfHwgZ2V0QXJyYXlMaXRlcmFsKCBwYXJzZXIgKTtcblx0XHRcdHJldHVybiBsaXRlcmFsO1xuXHRcdH07XG5cdH0oIG51bWJlckxpdGVyYWwsIGJvb2xlYW5MaXRlcmFsLCBzdHJpbmdMaXRlcmFsLCBvYmplY3RMaXRlcmFsLCBhcnJheUxpdGVyYWwgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9yZWZlcmVuY2UuanMgKi9cblx0dmFyIHJlZmVyZW5jZSA9IGZ1bmN0aW9uKCB0eXBlcywgcGF0dGVybnMgKSB7XG5cblx0XHR2YXIgZG90UmVmaW5lbWVudFBhdHRlcm4sIGFycmF5TWVtYmVyUGF0dGVybiwgZ2V0QXJyYXlSZWZpbmVtZW50LCBnbG9iYWxzLCBrZXl3b3Jkcztcblx0XHRkb3RSZWZpbmVtZW50UGF0dGVybiA9IC9eXFwuW2EtekEtWl8kMC05XSsvO1xuXHRcdGdldEFycmF5UmVmaW5lbWVudCA9IGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgbnVtID0gcGFyc2VyLm1hdGNoUGF0dGVybiggYXJyYXlNZW1iZXJQYXR0ZXJuICk7XG5cdFx0XHRpZiAoIG51bSApIHtcblx0XHRcdFx0cmV0dXJuICcuJyArIG51bTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0YXJyYXlNZW1iZXJQYXR0ZXJuID0gL15cXFsoMHxbMS05XVswLTldKilcXF0vO1xuXHRcdC8vIGlmIGEgcmVmZXJlbmNlIGlzIGEgYnJvd3NlciBnbG9iYWwsIHdlIGRvbid0IGRlZmVyZW5jZSBpdCBsYXRlciwgc28gaXQgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnRcblx0XHRnbG9iYWxzID0gL14oPzpBcnJheXxjb25zb2xlfERhdGV8UmVnRXhwfGRlY29kZVVSSUNvbXBvbmVudHxkZWNvZGVVUkl8ZW5jb2RlVVJJQ29tcG9uZW50fGVuY29kZVVSSXxpc0Zpbml0ZXxpc05hTnxwYXJzZUZsb2F0fHBhcnNlSW50fEpTT058TWF0aHxOYU58dW5kZWZpbmVkfG51bGwpJC87XG5cdFx0Ly8ga2V5d29yZHMgYXJlIG5vdCB2YWxpZCByZWZlcmVuY2VzLCB3aXRoIHRoZSBleGNlcHRpb24gb2YgYHRoaXNgXG5cdFx0a2V5d29yZHMgPSAvXig/OmJyZWFrfGNhc2V8Y2F0Y2h8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxmaW5hbGx5fGZvcnxmdW5jdGlvbnxpZnxpbnxpbnN0YW5jZW9mfG5ld3xyZXR1cm58c3dpdGNofHRocm93fHRyeXx0eXBlb2Z8dmFyfHZvaWR8d2hpbGV8d2l0aCkkLztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydFBvcywgYW5jZXN0b3IsIG5hbWUsIGRvdCwgY29tYm8sIHJlZmluZW1lbnQsIGxhc3REb3RJbmRleDtcblx0XHRcdHN0YXJ0UG9zID0gcGFyc2VyLnBvcztcblx0XHRcdC8vIHdlIG1pZ2h0IGhhdmUgYSByb290LWxldmVsIHJlZmVyZW5jZVxuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICd+LycgKSApIHtcblx0XHRcdFx0YW5jZXN0b3IgPSAnfi8nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gd2UgbWlnaHQgaGF2ZSBhbmNlc3RvciByZWZzLi4uXG5cdFx0XHRcdGFuY2VzdG9yID0gJyc7XG5cdFx0XHRcdHdoaWxlICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLi4vJyApICkge1xuXHRcdFx0XHRcdGFuY2VzdG9yICs9ICcuLi8nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFhbmNlc3RvciApIHtcblx0XHRcdFx0Ly8gd2UgbWlnaHQgaGF2ZSBhbiBpbXBsaWNpdCBpdGVyYXRvciBvciBhIHJlc3RyaWN0ZWQgcmVmZXJlbmNlXG5cdFx0XHRcdGRvdCA9IHBhcnNlci5tYXRjaFN0cmluZyggJy4vJyApIHx8IHBhcnNlci5tYXRjaFN0cmluZyggJy4nICkgfHwgJyc7XG5cdFx0XHR9XG5cdFx0XHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybiggL15AKD86a2V5cGF0aHxpbmRleHxrZXkpLyApIHx8IHBhcnNlci5tYXRjaFBhdHRlcm4oIHBhdHRlcm5zLm5hbWUgKSB8fCAnJztcblx0XHRcdC8vIGJ1ZyBvdXQgaWYgaXQncyBhIGtleXdvcmRcblx0XHRcdGlmICgga2V5d29yZHMudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3M7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIGJyb3dzZXIgZ2xvYmFsLCBzdG9wIGhlcmVcblx0XHRcdGlmICggIWFuY2VzdG9yICYmICFkb3QgJiYgZ2xvYmFscy50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuR0xPQkFMLFxuXHRcdFx0XHRcdHY6IG5hbWVcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGNvbWJvID0gKCBhbmNlc3RvciB8fCBkb3QgKSArIG5hbWU7XG5cdFx0XHRpZiAoICFjb21ibyApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoIHJlZmluZW1lbnQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBkb3RSZWZpbmVtZW50UGF0dGVybiApIHx8IGdldEFycmF5UmVmaW5lbWVudCggcGFyc2VyICkgKSB7XG5cdFx0XHRcdGNvbWJvICs9IHJlZmluZW1lbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJygnICkgKSB7XG5cdFx0XHRcdC8vIGlmIHRoaXMgaXMgYSBtZXRob2QgaW52b2NhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIGZ1bmN0aW9uKSB3ZSBuZWVkXG5cdFx0XHRcdC8vIHRvIHN0cmlwIHRoZSBtZXRob2QgbmFtZSBmcm9tIHRoZSByZWZlcmVuY2UgY29tYm8sIGVsc2UgdGhlIGNvbnRleHRcblx0XHRcdFx0Ly8gd2lsbCBiZSB3cm9uZ1xuXHRcdFx0XHRsYXN0RG90SW5kZXggPSBjb21iby5sYXN0SW5kZXhPZiggJy4nICk7XG5cdFx0XHRcdGlmICggbGFzdERvdEluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRjb21ibyA9IGNvbWJvLnN1YnN0ciggMCwgbGFzdERvdEluZGV4ICk7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0UG9zICsgY29tYm8ubGVuZ3RoO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgLT0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuUkVGRVJFTkNFLFxuXHRcdFx0XHRuOiBjb21iby5yZXBsYWNlKCAvXnRoaXNcXC4vLCAnLi8nICkucmVwbGFjZSggL150aGlzJC8sICcuJyApXG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBwYXR0ZXJucyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2JyYWNrZXRlZEV4cHJlc3Npb24uanMgKi9cblx0dmFyIGJyYWNrZXRlZEV4cHJlc3Npb24gPSBmdW5jdGlvbiggdHlwZXMsIGVycm9ycyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBleHByO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnKCcgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRleHByID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRpZiAoICFleHByICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJyknICkgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkUGFyZW4gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLkJSQUNLRVRFRCxcblx0XHRcdFx0eDogZXhwclxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9fcHJpbWFyeS5qcyAqL1xuXHR2YXIgcHJpbWFyeSA9IGZ1bmN0aW9uKCBnZXRMaXRlcmFsLCBnZXRSZWZlcmVuY2UsIGdldEJyYWNrZXRlZEV4cHJlc3Npb24gKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHJldHVybiBnZXRMaXRlcmFsKCBwYXJzZXIgKSB8fCBnZXRSZWZlcmVuY2UoIHBhcnNlciApIHx8IGdldEJyYWNrZXRlZEV4cHJlc3Npb24oIHBhcnNlciApO1xuXHRcdH07XG5cdH0oIGxpdGVyYWwsIHJlZmVyZW5jZSwgYnJhY2tldGVkRXhwcmVzc2lvbiApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9zaGFyZWQvcmVmaW5lbWVudC5qcyAqL1xuXHR2YXIgcmVmaW5lbWVudCA9IGZ1bmN0aW9uKCB0eXBlcywgZXJyb3JzLCBwYXR0ZXJucyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRSZWZpbmVtZW50KCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIG5hbWUsIGV4cHI7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHQvLyBcIi5cIiBuYW1lXG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJy4nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0aWYgKCBuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybiggcGF0dGVybnMubmFtZSApICkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0OiB0eXBlcy5SRUZJTkVNRU5ULFxuXHRcdFx0XHRcdFx0bjogbmFtZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgYSBwcm9wZXJ0eSBuYW1lJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gXCJbXCIgZXhwcmVzc2lvbiBcIl1cIlxuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICdbJyApICkge1xuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdGV4cHIgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdFx0aWYgKCAhZXhwciApIHtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ10nICkgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgXFwnXVxcJycgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLlJFRklORU1FTlQsXG5cdFx0XHRcdFx0eDogZXhwclxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fSggdHlwZXMsIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzLCBwYXR0ZXJucyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9tZW1iZXJPckludm9jYXRpb24uanMgKi9cblx0dmFyIG1lbWJlck9ySW52b2NhdGlvbiA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0UHJpbWFyeSwgZ2V0RXhwcmVzc2lvbkxpc3QsIGdldFJlZmluZW1lbnQsIGVycm9ycyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIGN1cnJlbnQsIGV4cHJlc3Npb24sIHJlZmluZW1lbnQsIGV4cHJlc3Npb25MaXN0O1xuXHRcdFx0ZXhwcmVzc2lvbiA9IGdldFByaW1hcnkoIHBhcnNlciApO1xuXHRcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoIGV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdGN1cnJlbnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0XHRpZiAoIHJlZmluZW1lbnQgPSBnZXRSZWZpbmVtZW50KCBwYXJzZXIgKSApIHtcblx0XHRcdFx0XHRleHByZXNzaW9uID0ge1xuXHRcdFx0XHRcdFx0dDogdHlwZXMuTUVNQkVSLFxuXHRcdFx0XHRcdFx0eDogZXhwcmVzc2lvbixcblx0XHRcdFx0XHRcdHI6IHJlZmluZW1lbnRcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcoJyApICkge1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRleHByZXNzaW9uTGlzdCA9IGdldEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKTtcblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnKScgKSApIHtcblx0XHRcdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkUGFyZW4gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbiA9IHtcblx0XHRcdFx0XHRcdHQ6IHR5cGVzLklOVk9DQVRJT04sXG5cdFx0XHRcdFx0XHR4OiBleHByZXNzaW9uXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRpZiAoIGV4cHJlc3Npb25MaXN0ICkge1xuXHRcdFx0XHRcdFx0ZXhwcmVzc2lvbi5vID0gZXhwcmVzc2lvbkxpc3Q7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcblx0XHR9O1xuXHR9KCB0eXBlcywgcHJpbWFyeSwgZXhwcmVzc2lvbkxpc3QsIHJlZmluZW1lbnQsIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3R5cGVvZi5qcyAqL1xuXHR2YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKCB0eXBlcywgZXJyb3JzLCBnZXRNZW1iZXJPckludm9jYXRpb24gKSB7XG5cblx0XHR2YXIgZ2V0VHlwZW9mLCBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyO1xuXHRcdG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXIgPSBmdW5jdGlvbiggc3ltYm9sLCBmYWxsdGhyb3VnaCApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0XHR2YXIgZXhwcmVzc2lvbjtcblx0XHRcdFx0aWYgKCBleHByZXNzaW9uID0gZmFsbHRocm91Z2goIHBhcnNlciApICkge1xuXHRcdFx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggc3ltYm9sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRleHByZXNzaW9uID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRcdGlmICggIWV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRzOiBzeW1ib2wsXG5cdFx0XHRcdFx0bzogZXhwcmVzc2lvbixcblx0XHRcdFx0XHR0OiB0eXBlcy5QUkVGSVhfT1BFUkFUT1Jcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHQvLyBjcmVhdGUgYWxsIHByZWZpeCBzZXF1ZW5jZSBtYXRjaGVycywgcmV0dXJuIGdldFR5cGVvZlxuXHRcdCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSwgbGVuLCBtYXRjaGVyLCBwcmVmaXhPcGVyYXRvcnMsIGZhbGx0aHJvdWdoO1xuXHRcdFx0cHJlZml4T3BlcmF0b3JzID0gJyEgfiArIC0gdHlwZW9mJy5zcGxpdCggJyAnICk7XG5cdFx0XHRmYWxsdGhyb3VnaCA9IGdldE1lbWJlck9ySW52b2NhdGlvbjtcblx0XHRcdGZvciAoIGkgPSAwLCBsZW4gPSBwcmVmaXhPcGVyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdG1hdGNoZXIgPSBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyKCBwcmVmaXhPcGVyYXRvcnNbIGkgXSwgZmFsbHRocm91Z2ggKTtcblx0XHRcdFx0ZmFsbHRocm91Z2ggPSBtYXRjaGVyO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdHlwZW9mIG9wZXJhdG9yIGlzIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gbXVsdGlwbGljYXRpb24sIHNvIHByb3ZpZGVzIHRoZVxuXHRcdFx0Ly8gZmFsbHRocm91Z2ggZm9yIHRoZSBtdWx0aXBsaWNhdGlvbiBzZXF1ZW5jZSBtYXRjaGVyIHdlJ3JlIGFib3V0IHRvIGNyZWF0ZVxuXHRcdFx0Ly8gKHdlJ3JlIHNraXBwaW5nIHZvaWQgYW5kIGRlbGV0ZSlcblx0XHRcdGdldFR5cGVvZiA9IGZhbGx0aHJvdWdoO1xuXHRcdH0oKSApO1xuXHRcdHJldHVybiBnZXRUeXBlb2Y7XG5cdH0oIHR5cGVzLCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycywgbWVtYmVyT3JJbnZvY2F0aW9uICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL2xvZ2ljYWxPci5qcyAqL1xuXHR2YXIgbG9naWNhbE9yID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRUeXBlb2YgKSB7XG5cblx0XHR2YXIgZ2V0TG9naWNhbE9yLCBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXI7XG5cdFx0bWFrZUluZml4U2VxdWVuY2VNYXRjaGVyID0gZnVuY3Rpb24oIHN5bWJvbCwgZmFsbHRocm91Z2ggKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdFx0dmFyIHN0YXJ0LCBsZWZ0LCByaWdodDtcblx0XHRcdFx0bGVmdCA9IGZhbGx0aHJvdWdoKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAhbGVmdCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBMb29wIHRvIGhhbmRsZSBsZWZ0LXJlY3Vyc2lvbiBpbiBhIGNhc2UgbGlrZSBgYSAqIGIgKiBjYCBhbmQgcHJvZHVjZVxuXHRcdFx0XHQvLyBsZWZ0IGFzc29jaWF0aW9uLCBpLmUuIGAoYSAqIGIpICogY2AuICBUaGUgbWF0Y2hlciBjYW4ndCBjYWxsIGl0c2VsZlxuXHRcdFx0XHQvLyB0byBwYXJzZSBgbGVmdGAgYmVjYXVzZSB0aGF0IHdvdWxkIGJlIGluZmluaXRlIHJlZ3Jlc3MuXG5cdFx0XHRcdHdoaWxlICggdHJ1ZSApIHtcblx0XHRcdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggc3ltYm9sICkgKSB7XG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbGVmdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gaW4gb3BlcmF0b3IgbXVzdCBub3QgYmUgZm9sbG93ZWQgYnkgW2EtekEtWl8kMC05XVxuXHRcdFx0XHRcdGlmICggc3ltYm9sID09PSAnaW4nICYmIC9bYS16QS1aXyQwLTldLy50ZXN0KCBwYXJzZXIucmVtYWluaW5nKCkuY2hhckF0KCAwICkgKSApIHtcblx0XHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRcdHJldHVybiBsZWZ0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0Ly8gcmlnaHQgb3BlcmFuZCBtdXN0IGFsc28gY29uc2lzdCBvZiBvbmx5IGhpZ2hlci1wcmVjZWRlbmNlIG9wZXJhdG9yc1xuXHRcdFx0XHRcdHJpZ2h0ID0gZmFsbHRocm91Z2goIHBhcnNlciApO1xuXHRcdFx0XHRcdGlmICggIXJpZ2h0ICkge1xuXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxlZnQgPSB7XG5cdFx0XHRcdFx0XHR0OiB0eXBlcy5JTkZJWF9PUEVSQVRPUixcblx0XHRcdFx0XHRcdHM6IHN5bWJvbCxcblx0XHRcdFx0XHRcdG86IFtcblx0XHRcdFx0XHRcdFx0bGVmdCxcblx0XHRcdFx0XHRcdFx0cmlnaHRcblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0Ly8gY3JlYXRlIGFsbCBpbmZpeCBzZXF1ZW5jZSBtYXRjaGVycywgYW5kIHJldHVybiBnZXRMb2dpY2FsT3Jcblx0XHQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGksIGxlbiwgbWF0Y2hlciwgaW5maXhPcGVyYXRvcnMsIGZhbGx0aHJvdWdoO1xuXHRcdFx0Ly8gQWxsIHRoZSBpbmZpeCBvcGVyYXRvcnMgb24gb3JkZXIgb2YgcHJlY2VkZW5jZSAoc291cmNlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9PcGVyYXRvcl9QcmVjZWRlbmNlKVxuXHRcdFx0Ly8gRWFjaCBzZXF1ZW5jZSBtYXRjaGVyIHdpbGwgaW5pdGlhbGx5IGZhbGwgdGhyb3VnaCB0byBpdHMgaGlnaGVyIHByZWNlZGVuY2Vcblx0XHRcdC8vIG5laWdoYm91ciwgYW5kIG9ubHkgYXR0ZW1wdCB0byBtYXRjaCBpZiBvbmUgb2YgdGhlIGhpZ2hlciBwcmVjZWRlbmNlIG9wZXJhdG9yc1xuXHRcdFx0Ly8gKG9yLCB1bHRpbWF0ZWx5LCBhIGxpdGVyYWwsIHJlZmVyZW5jZSwgb3IgYnJhY2tldGVkIGV4cHJlc3Npb24pIGFscmVhZHkgbWF0Y2hlZFxuXHRcdFx0aW5maXhPcGVyYXRvcnMgPSAnKiAvICUgKyAtIDw8ID4+ID4+PiA8IDw9ID4gPj0gaW4gaW5zdGFuY2VvZiA9PSAhPSA9PT0gIT09ICYgXiB8ICYmIHx8Jy5zcGxpdCggJyAnICk7XG5cdFx0XHQvLyBBIHR5cGVvZiBvcGVyYXRvciBpcyBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIG11bHRpcGxpY2F0aW9uXG5cdFx0XHRmYWxsdGhyb3VnaCA9IGdldFR5cGVvZjtcblx0XHRcdGZvciAoIGkgPSAwLCBsZW4gPSBpbmZpeE9wZXJhdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0bWF0Y2hlciA9IG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlciggaW5maXhPcGVyYXRvcnNbIGkgXSwgZmFsbHRocm91Z2ggKTtcblx0XHRcdFx0ZmFsbHRocm91Z2ggPSBtYXRjaGVyO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTG9naWNhbCBPUiBpcyB0aGUgZmFsbHRocm91Z2ggZm9yIHRoZSBjb25kaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRnZXRMb2dpY2FsT3IgPSBmYWxsdGhyb3VnaDtcblx0XHR9KCkgKTtcblx0XHRyZXR1cm4gZ2V0TG9naWNhbE9yO1xuXHR9KCB0eXBlcywgX3R5cGVvZiApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9jb25kaXRpb25hbC5qcyAqL1xuXHR2YXIgY29uZGl0aW9uYWwgPSBmdW5jdGlvbiggdHlwZXMsIGdldExvZ2ljYWxPciwgZXJyb3JzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIGlmVHJ1ZSwgaWZGYWxzZTtcblx0XHRcdGV4cHJlc3Npb24gPSBnZXRMb2dpY2FsT3IoIHBhcnNlciApO1xuXHRcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc/JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWZUcnVlID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRpZiAoICFpZlRydWUgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnOicgKSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgXCI6XCInICk7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZkZhbHNlID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRpZiAoICFpZkZhbHNlICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLkNPTkRJVElPTkFMLFxuXHRcdFx0XHRvOiBbXG5cdFx0XHRcdFx0ZXhwcmVzc2lvbixcblx0XHRcdFx0XHRpZlRydWUsXG5cdFx0XHRcdFx0aWZGYWxzZVxuXHRcdFx0XHRdXG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBsb2dpY2FsT3IsIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL3V0aWxzL2ZsYXR0ZW5FeHByZXNzaW9uLmpzICovXG5cdHZhciBmbGF0dGVuRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCB0eXBlcywgaXNPYmplY3QgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiggZXhwcmVzc2lvbiApIHtcblx0XHRcdHZhciByZWZzID0gW10sXG5cdFx0XHRcdGZsYXR0ZW5lZDtcblx0XHRcdGV4dHJhY3RSZWZzKCBleHByZXNzaW9uLCByZWZzICk7XG5cdFx0XHRmbGF0dGVuZWQgPSB7XG5cdFx0XHRcdHI6IHJlZnMsXG5cdFx0XHRcdHM6IHN0cmluZ2lmeSggdGhpcywgZXhwcmVzc2lvbiwgcmVmcyApXG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGZsYXR0ZW5lZDtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcXVvdGVTdHJpbmdMaXRlcmFsKCBzdHIgKSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoIFN0cmluZyggc3RyICkgKTtcblx0XHR9XG5cdFx0Ly8gVE9ETyBtYXliZSByZWZhY3RvciB0aGlzP1xuXHRcdGZ1bmN0aW9uIGV4dHJhY3RSZWZzKCBub2RlLCByZWZzICkge1xuXHRcdFx0dmFyIGksIGxpc3Q7XG5cdFx0XHRpZiAoIG5vZGUudCA9PT0gdHlwZXMuUkVGRVJFTkNFICkge1xuXHRcdFx0XHRpZiAoIHJlZnMuaW5kZXhPZiggbm9kZS5uICkgPT09IC0xICkge1xuXHRcdFx0XHRcdHJlZnMudW5zaGlmdCggbm9kZS5uICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxpc3QgPSBub2RlLm8gfHwgbm9kZS5tO1xuXHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRpZiAoIGlzT2JqZWN0KCBsaXN0ICkgKSB7XG5cdFx0XHRcdFx0ZXh0cmFjdFJlZnMoIGxpc3QsIHJlZnMgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRleHRyYWN0UmVmcyggbGlzdFsgaSBdLCByZWZzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG5vZGUueCApIHtcblx0XHRcdFx0ZXh0cmFjdFJlZnMoIG5vZGUueCwgcmVmcyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBub2RlLnIgKSB7XG5cdFx0XHRcdGV4dHJhY3RSZWZzKCBub2RlLnIsIHJlZnMgKTtcblx0XHRcdH1cblx0XHRcdGlmICggbm9kZS52ICkge1xuXHRcdFx0XHRleHRyYWN0UmVmcyggbm9kZS52LCByZWZzICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUsIHJlZnMgKSB7XG5cdFx0XHR2YXIgc3RyaW5naWZ5QWxsID0gZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRcdHJldHVybiBzdHJpbmdpZnkoIHBhcnNlciwgaXRlbSwgcmVmcyApO1xuXHRcdFx0fTtcblx0XHRcdHN3aXRjaCAoIG5vZGUudCApIHtcblx0XHRcdFx0Y2FzZSB0eXBlcy5CT09MRUFOX0xJVEVSQUw6XG5cdFx0XHRcdGNhc2UgdHlwZXMuR0xPQkFMOlxuXHRcdFx0XHRjYXNlIHR5cGVzLk5VTUJFUl9MSVRFUkFMOlxuXHRcdFx0XHRcdHJldHVybiBub2RlLnY7XG5cdFx0XHRcdGNhc2UgdHlwZXMuU1RSSU5HX0xJVEVSQUw6XG5cdFx0XHRcdFx0cmV0dXJuIHF1b3RlU3RyaW5nTGl0ZXJhbCggbm9kZS52ICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuQVJSQVlfTElURVJBTDpcblx0XHRcdFx0XHRyZXR1cm4gJ1snICsgKCBub2RlLm0gPyBub2RlLm0ubWFwKCBzdHJpbmdpZnlBbGwgKS5qb2luKCAnLCcgKSA6ICcnICkgKyAnXSc7XG5cdFx0XHRcdGNhc2UgdHlwZXMuT0JKRUNUX0xJVEVSQUw6XG5cdFx0XHRcdFx0cmV0dXJuICd7JyArICggbm9kZS5tID8gbm9kZS5tLm1hcCggc3RyaW5naWZ5QWxsICkuam9pbiggJywnICkgOiAnJyApICsgJ30nO1xuXHRcdFx0XHRjYXNlIHR5cGVzLktFWV9WQUxVRV9QQUlSOlxuXHRcdFx0XHRcdHJldHVybiBub2RlLmsgKyAnOicgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS52LCByZWZzICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuUFJFRklYX09QRVJBVE9SOlxuXHRcdFx0XHRcdHJldHVybiAoIG5vZGUucyA9PT0gJ3R5cGVvZicgPyAndHlwZW9mICcgOiBub2RlLnMgKSArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm8sIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5JTkZJWF9PUEVSQVRPUjpcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUub1sgMCBdLCByZWZzICkgKyAoIG5vZGUucy5zdWJzdHIoIDAsIDIgKSA9PT0gJ2luJyA/ICcgJyArIG5vZGUucyArICcgJyA6IG5vZGUucyApICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUub1sgMSBdLCByZWZzICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuSU5WT0NBVElPTjpcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUueCwgcmVmcyApICsgJygnICsgKCBub2RlLm8gPyBub2RlLm8ubWFwKCBzdHJpbmdpZnlBbGwgKS5qb2luKCAnLCcgKSA6ICcnICkgKyAnKSc7XG5cdFx0XHRcdGNhc2UgdHlwZXMuQlJBQ0tFVEVEOlxuXHRcdFx0XHRcdHJldHVybiAnKCcgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS54LCByZWZzICkgKyAnKSc7XG5cdFx0XHRcdGNhc2UgdHlwZXMuTUVNQkVSOlxuXHRcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS54LCByZWZzICkgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5yLCByZWZzICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuUkVGSU5FTUVOVDpcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS5uID8gJy4nICsgbm9kZS5uIDogJ1snICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUueCwgcmVmcyApICsgJ10nO1xuXHRcdFx0XHRjYXNlIHR5cGVzLkNPTkRJVElPTkFMOlxuXHRcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAwIF0sIHJlZnMgKSArICc/JyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm9bIDEgXSwgcmVmcyApICsgJzonICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUub1sgMiBdLCByZWZzICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuUkVGRVJFTkNFOlxuXHRcdFx0XHRcdHJldHVybiAnXycgKyByZWZzLmluZGV4T2YoIG5vZGUubiApO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIGxlZ2FsIEphdmFTY3JpcHQnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdHlwZXMsIGlzT2JqZWN0ICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL19QYXJzZXIuanMgKi9cblx0dmFyIFBhcnNlciA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgY3JlYXRlLCBoYXNPd25Qcm9wZXJ0eSwgZ2V0Q29uZGl0aW9uYWwsIGZsYXR0ZW5FeHByZXNzaW9uICkge1xuXG5cdFx0dmFyIFBhcnNlciwgUGFyc2VFcnJvciwgbGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccysvO1xuXHRcdFBhcnNlRXJyb3IgPSBmdW5jdGlvbiggbWVzc2FnZSApIHtcblx0XHRcdHRoaXMubmFtZSA9ICdQYXJzZUVycm9yJztcblx0XHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1lc3NhZ2UgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHR0aGlzLnN0YWNrID0gZS5zdGFjaztcblx0XHRcdH1cblx0XHR9O1xuXHRcdFBhcnNlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXHRcdFBhcnNlciA9IGZ1bmN0aW9uKCBzdHIsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgaXRlbXMsIGl0ZW0sIGxpbmVTdGFydCA9IDA7XG5cdFx0XHR0aGlzLnN0ciA9IHN0cjtcblx0XHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHR0aGlzLnBvcyA9IDA7XG5cdFx0XHR0aGlzLmxpbmVzID0gdGhpcy5zdHIuc3BsaXQoICdcXG4nICk7XG5cdFx0XHR0aGlzLmxpbmVFbmRzID0gdGhpcy5saW5lcy5tYXAoIGZ1bmN0aW9uKCBsaW5lICkge1xuXHRcdFx0XHR2YXIgbGluZUVuZCA9IGxpbmVTdGFydCArIGxpbmUubGVuZ3RoICsgMTtcblx0XHRcdFx0Ly8gKzEgZm9yIHRoZSBuZXdsaW5lXG5cdFx0XHRcdGxpbmVTdGFydCA9IGxpbmVFbmQ7XG5cdFx0XHRcdHJldHVybiBsaW5lRW5kO1xuXHRcdFx0fSwgMCApO1xuXHRcdFx0Ly8gQ3VzdG9tIGluaXQgbG9naWNcblx0XHRcdGlmICggdGhpcy5pbml0IClcblx0XHRcdFx0dGhpcy5pbml0KCBzdHIsIG9wdGlvbnMgKTtcblx0XHRcdGl0ZW1zID0gW107XG5cdFx0XHR3aGlsZSAoIHRoaXMucG9zIDwgdGhpcy5zdHIubGVuZ3RoICYmICggaXRlbSA9IHRoaXMucmVhZCgpICkgKSB7XG5cdFx0XHRcdGl0ZW1zLnB1c2goIGl0ZW0gKTtcblx0XHRcdH1cblx0XHRcdHRoaXMubGVmdG92ZXIgPSB0aGlzLnJlbWFpbmluZygpO1xuXHRcdFx0dGhpcy5yZXN1bHQgPSB0aGlzLnBvc3RQcm9jZXNzID8gdGhpcy5wb3N0UHJvY2VzcyggaXRlbXMsIG9wdGlvbnMgKSA6IGl0ZW1zO1xuXHRcdH07XG5cdFx0UGFyc2VyLnByb3RvdHlwZSA9IHtcblx0XHRcdHJlYWQ6IGZ1bmN0aW9uKCBjb252ZXJ0ZXJzICkge1xuXHRcdFx0XHR2YXIgcG9zLCBpLCBsZW4sIGl0ZW07XG5cdFx0XHRcdGlmICggIWNvbnZlcnRlcnMgKVxuXHRcdFx0XHRcdGNvbnZlcnRlcnMgPSB0aGlzLmNvbnZlcnRlcnM7XG5cdFx0XHRcdHBvcyA9IHRoaXMucG9zO1xuXHRcdFx0XHRsZW4gPSBjb252ZXJ0ZXJzLmxlbmd0aDtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0XHR0aGlzLnBvcyA9IHBvcztcblx0XHRcdFx0XHQvLyByZXNldCBmb3IgZWFjaCBhdHRlbXB0XG5cdFx0XHRcdFx0aWYgKCBpdGVtID0gY29udmVydGVyc1sgaSBdKCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9LFxuXHRcdFx0cmVhZEV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBUaGUgY29uZGl0aW9uYWwgb3BlcmF0b3IgaXMgdGhlIGxvd2VzdCBwcmVjZWRlbmNlIG9wZXJhdG9yIChleGNlcHQgeWllbGQsXG5cdFx0XHRcdC8vIGFzc2lnbm1lbnQgb3BlcmF0b3JzLCBhbmQgY29tbWFzLCBub25lIG9mIHdoaWNoIGFyZSBzdXBwb3J0ZWQpLCBzbyB3ZVxuXHRcdFx0XHQvLyBzdGFydCB0aGVyZS4gSWYgaXQgZG9lc24ndCBtYXRjaCwgaXQgJ2ZhbGxzIHRocm91Z2gnIHRvIHByb2dyZXNzaXZlbHlcblx0XHRcdFx0Ly8gaGlnaGVyIHByZWNlZGVuY2Ugb3BlcmF0b3JzLCB1bnRpbCBpdCBldmVudHVhbGx5IG1hdGNoZXMgKG9yIGZhaWxzIHRvXG5cdFx0XHRcdC8vIG1hdGNoKSBhICdwcmltYXJ5JyAtIGEgbGl0ZXJhbCBvciBhIHJlZmVyZW5jZS4gVGhpcyB3YXksIHRoZSBhYnN0cmFjdCBzeW50YXhcblx0XHRcdFx0Ly8gdHJlZSBoYXMgZXZlcnl0aGluZyBpbiBpdHMgcHJvcGVyIHBsYWNlLCBpLmUuIDIgKyAzICogNCA9PT0gMTQsIG5vdCAyMC5cblx0XHRcdFx0cmV0dXJuIGdldENvbmRpdGlvbmFsKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmxhdHRlbkV4cHJlc3Npb246IGZsYXR0ZW5FeHByZXNzaW9uLFxuXHRcdFx0Z2V0TGluZVBvczogZnVuY3Rpb24oIGNoYXIgKSB7XG5cdFx0XHRcdHZhciBsaW5lTnVtID0gMCxcblx0XHRcdFx0XHRsaW5lU3RhcnQgPSAwLFxuXHRcdFx0XHRcdGNvbHVtbk51bTtcblx0XHRcdFx0d2hpbGUgKCBjaGFyID49IHRoaXMubGluZUVuZHNbIGxpbmVOdW0gXSApIHtcblx0XHRcdFx0XHRsaW5lU3RhcnQgPSB0aGlzLmxpbmVFbmRzWyBsaW5lTnVtIF07XG5cdFx0XHRcdFx0bGluZU51bSArPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbHVtbk51bSA9IGNoYXIgLSBsaW5lU3RhcnQ7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0bGluZU51bSArIDEsXG5cdFx0XHRcdFx0Y29sdW1uTnVtICsgMSxcblx0XHRcdFx0XHRjaGFyXG5cdFx0XHRcdF07XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3I6IGZ1bmN0aW9uKCBtZXNzYWdlICkge1xuXHRcdFx0XHR2YXIgcG9zLCBsaW5lTnVtLCBjb2x1bW5OdW0sIGxpbmUsIGFubm90YXRpb24sIGVycm9yO1xuXHRcdFx0XHRwb3MgPSB0aGlzLmdldExpbmVQb3MoIHRoaXMucG9zICk7XG5cdFx0XHRcdGxpbmVOdW0gPSBwb3NbIDAgXTtcblx0XHRcdFx0Y29sdW1uTnVtID0gcG9zWyAxIF07XG5cdFx0XHRcdGxpbmUgPSB0aGlzLmxpbmVzWyBwb3NbIDAgXSAtIDEgXTtcblx0XHRcdFx0YW5ub3RhdGlvbiA9IGxpbmUgKyAnXFxuJyArIG5ldyBBcnJheSggcG9zWyAxIF0gKS5qb2luKCAnICcgKSArICdeLS0tLSc7XG5cdFx0XHRcdGVycm9yID0gbmV3IFBhcnNlRXJyb3IoIG1lc3NhZ2UgKyAnIGF0IGxpbmUgJyArIGxpbmVOdW0gKyAnIGNoYXJhY3RlciAnICsgY29sdW1uTnVtICsgJzpcXG4nICsgYW5ub3RhdGlvbiApO1xuXHRcdFx0XHRlcnJvci5saW5lID0gcG9zWyAwIF07XG5cdFx0XHRcdGVycm9yLmNoYXJhY3RlciA9IHBvc1sgMSBdO1xuXHRcdFx0XHRlcnJvci5zaG9ydE1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0sXG5cdFx0XHRtYXRjaFN0cmluZzogZnVuY3Rpb24oIHN0cmluZyApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnN0ci5zdWJzdHIoIHRoaXMucG9zLCBzdHJpbmcubGVuZ3RoICkgPT09IHN0cmluZyApIHtcblx0XHRcdFx0XHR0aGlzLnBvcyArPSBzdHJpbmcubGVuZ3RoO1xuXHRcdFx0XHRcdHJldHVybiBzdHJpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRtYXRjaFBhdHRlcm46IGZ1bmN0aW9uKCBwYXR0ZXJuICkge1xuXHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdGlmICggbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoIHRoaXMucmVtYWluaW5nKCkgKSApIHtcblx0XHRcdFx0XHR0aGlzLnBvcyArPSBtYXRjaFsgMCBdLmxlbmd0aDtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hbIDEgXSB8fCBtYXRjaFsgMCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YWxsb3dXaGl0ZXNwYWNlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5tYXRjaFBhdHRlcm4oIGxlYWRpbmdXaGl0ZXNwYWNlICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVtYWluaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RyLnN1YnN0cmluZyggdGhpcy5wb3MgKTtcblx0XHRcdH0sXG5cdFx0XHRuZXh0Q2hhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN0ci5jaGFyQXQoIHRoaXMucG9zICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRQYXJzZXIuZXh0ZW5kID0gZnVuY3Rpb24oIHByb3RvICkge1xuXHRcdFx0dmFyIFBhcmVudCA9IHRoaXMsXG5cdFx0XHRcdENoaWxkLCBrZXk7XG5cdFx0XHRDaGlsZCA9IGZ1bmN0aW9uKCBzdHIsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdFBhcnNlci5jYWxsKCB0aGlzLCBzdHIsIG9wdGlvbnMgKTtcblx0XHRcdH07XG5cdFx0XHRDaGlsZC5wcm90b3R5cGUgPSBjcmVhdGUoIFBhcmVudC5wcm90b3R5cGUgKTtcblx0XHRcdGZvciAoIGtleSBpbiBwcm90byApIHtcblx0XHRcdFx0aWYgKCBoYXNPd25Qcm9wZXJ0eS5jYWxsKCBwcm90bywga2V5ICkgKSB7XG5cdFx0XHRcdFx0Q2hpbGQucHJvdG90eXBlWyBrZXkgXSA9IHByb3RvWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Q2hpbGQuZXh0ZW5kID0gUGFyc2VyLmV4dGVuZDtcblx0XHRcdHJldHVybiBDaGlsZDtcblx0XHR9O1xuXHRcdGNpcmN1bGFyLlBhcnNlciA9IFBhcnNlcjtcblx0XHRyZXR1cm4gUGFyc2VyO1xuXHR9KCBjaXJjdWxhciwgY3JlYXRlLCBoYXNPd24sIGNvbmRpdGlvbmFsLCBmbGF0dGVuRXhwcmVzc2lvbiApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvbXVzdGFjaGUvZGVsaW1pdGVyQ2hhbmdlLmpzICovXG5cdHZhciBkZWxpbWl0ZXJDaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuID0gL15bXlxccz1dKy8sXG5cdFx0XHR3aGl0ZXNwYWNlUGF0dGVybiA9IC9eXFxzKy87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIG9wZW5pbmcsIGNsb3Npbmc7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc9JyApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIG5ldyBvcGVuaW5nIGRlbGltaXRlclxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0b3BlbmluZyA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGRlbGltaXRlckNoYW5nZVBhdHRlcm4gKTtcblx0XHRcdGlmICggIW9wZW5pbmcgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIChpbiBmYWN0LCBpdCdzIG5lY2Vzc2FyeS4uLilcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFBhdHRlcm4oIHdoaXRlc3BhY2VQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Y2xvc2luZyA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGRlbGltaXRlckNoYW5nZVBhdHRlcm4gKTtcblx0XHRcdGlmICggIWNsb3NpbmcgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBjbG9zaW5nICc9J1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPScgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdG9wZW5pbmcsXG5cdFx0XHRcdGNsb3Npbmdcblx0XHRcdF07XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvbXVzdGFjaGUvZGVsaW1pdGVyVHlwZXMuanMgKi9cblx0dmFyIGRlbGltaXRlclR5cGVzID0gWyB7XG5cdFx0ZGVsaW1pdGVyczogJ2RlbGltaXRlcnMnLFxuXHRcdGlzVHJpcGxlOiBmYWxzZSxcblx0XHRpc1N0YXRpYzogZmFsc2Vcblx0fSwge1xuXHRcdGRlbGltaXRlcnM6ICd0cmlwbGVEZWxpbWl0ZXJzJyxcblx0XHRpc1RyaXBsZTogdHJ1ZSxcblx0XHRpc1N0YXRpYzogZmFsc2Vcblx0fSwge1xuXHRcdGRlbGltaXRlcnM6ICdzdGF0aWNEZWxpbWl0ZXJzJyxcblx0XHRpc1RyaXBsZTogZmFsc2UsXG5cdFx0aXNTdGF0aWM6IHRydWVcblx0fSwge1xuXHRcdGRlbGltaXRlcnM6ICdzdGF0aWNUcmlwbGVEZWxpbWl0ZXJzJyxcblx0XHRpc1RyaXBsZTogdHJ1ZSxcblx0XHRpc1N0YXRpYzogdHJ1ZVxuXHR9IF07XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS90eXBlLmpzICovXG5cdHZhciB0eXBlID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0dmFyIG11c3RhY2hlVHlwZXMgPSB7XG5cdFx0XHQnIyc6IHR5cGVzLlNFQ1RJT04sXG5cdFx0XHQnXic6IHR5cGVzLklOVkVSVEVELFxuXHRcdFx0Jy8nOiB0eXBlcy5DTE9TSU5HLFxuXHRcdFx0Jz4nOiB0eXBlcy5QQVJUSUFMLFxuXHRcdFx0JyEnOiB0eXBlcy5DT01NRU5ULFxuXHRcdFx0JyYnOiB0eXBlcy5UUklQTEVcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHR5cGUgPSBtdXN0YWNoZVR5cGVzWyBwYXJzZXIuc3RyLmNoYXJBdCggcGFyc2VyLnBvcyApIF07XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5wb3MgKz0gMTtcblx0XHRcdHJldHVybiB0eXBlO1xuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS9oYW5kbGViYXJzQmxvY2tDb2Rlcy5qcyAqL1xuXHR2YXIgaGFuZGxlYmFyc0Jsb2NrQ29kZXMgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0J2VhY2gnOiB0eXBlcy5TRUNUSU9OX0VBQ0gsXG5cdFx0XHQnaWYnOiB0eXBlcy5TRUNUSU9OX0lGLFxuXHRcdFx0J2lmLXdpdGgnOiB0eXBlcy5TRUNUSU9OX0lGX1dJVEgsXG5cdFx0XHQnd2l0aCc6IHR5cGVzLlNFQ1RJT05fV0lUSCxcblx0XHRcdCd1bmxlc3MnOiB0eXBlcy5TRUNUSU9OX1VOTEVTU1xuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogZW1wdHkvbGVnYWN5LmpzICovXG5cdHZhciBsZWdhY3kgPSBudWxsO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvbXVzdGFjaGUvY29udGVudC5qcyAqL1xuXHR2YXIgY29udGVudCA9IGZ1bmN0aW9uKCB0eXBlcywgbXVzdGFjaGVUeXBlLCBoYW5kbGViYXJzQmxvY2tDb2RlcyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgaW5kZXhSZWZQYXR0ZXJuID0gL15cXHMqOlxccyooW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKS8sXG5cdFx0XHRhcnJheU1lbWJlclBhdHRlcm4gPSAvXlswLTldWzEtOV0qJC8sXG5cdFx0XHRoYW5kbGViYXJzQmxvY2tQYXR0ZXJuID0gbmV3IFJlZ0V4cCggJ14oJyArIE9iamVjdC5rZXlzKCBoYW5kbGViYXJzQmxvY2tDb2RlcyApLmpvaW4oICd8JyApICsgJylcXFxcYicgKSxcblx0XHRcdGxlZ2FsUmVmZXJlbmNlO1xuXHRcdGxlZ2FsUmVmZXJlbmNlID0gL15bYS16QS1aJF8wLTldKyg/OihcXC5bYS16QS1aJF8wLTldKyl8KFxcW1thLXpBLVokXzAtOV0rXFxdKSkqJC87XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiggcGFyc2VyLCBkZWxpbWl0ZXJUeXBlICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBwb3MsIG11c3RhY2hlLCB0eXBlLCBibG9jaywgZXhwcmVzc2lvbiwgaSwgcmVtYWluaW5nLCBpbmRleCwgZGVsaW1pdGVycztcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdG11c3RhY2hlID0ge307XG5cdFx0XHRkZWxpbWl0ZXJzID0gcGFyc2VyWyBkZWxpbWl0ZXJUeXBlLmRlbGltaXRlcnMgXTtcblx0XHRcdGlmICggZGVsaW1pdGVyVHlwZS5pc1N0YXRpYyApIHtcblx0XHRcdFx0bXVzdGFjaGUucyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBEZXRlcm1pbmUgbXVzdGFjaGUgdHlwZVxuXHRcdFx0aWYgKCBkZWxpbWl0ZXJUeXBlLmlzVHJpcGxlICkge1xuXHRcdFx0XHRtdXN0YWNoZS50ID0gdHlwZXMuVFJJUExFO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2UgbmVlZCB0byB0ZXN0IGZvciBleHByZXNzaW9ucyBiZWZvcmUgd2UgdGVzdCBmb3IgbXVzdGFjaGUgdHlwZSwgYmVjYXVzZVxuXHRcdFx0XHQvLyBhbiBleHByZXNzaW9uIHRoYXQgYmVnaW5zICchJyBsb29rcyBhIGxvdCBsaWtlIGEgY29tbWVudFxuXHRcdFx0XHRpZiAoIHBhcnNlci5yZW1haW5pbmcoKVsgMCBdID09PSAnIScgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGV4cHJlc3Npb24gPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdFx0XHRcdC8vIFdhcyBpdCBhY3R1YWxseSBhbiBleHByZXNzaW9uLCBvciBhIGNvbW1lbnQgYmxvY2sgaW4gZGlzZ3Vpc2U/XG5cdFx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0XHRpZiAoIHBhcnNlci5yZW1haW5pbmcoKS5pbmRleE9mKCBkZWxpbWl0ZXJzWyAxIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0ZXhwcmVzc2lvbiA9IG51bGw7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRtdXN0YWNoZS50ID0gdHlwZXMuSU5URVJQT0xBVE9SO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7fVxuXHRcdFx0XHRcdGlmICggIWV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdFx0XHRpbmRleCA9IHBhcnNlci5yZW1haW5pbmcoKS5pbmRleE9mKCBkZWxpbWl0ZXJzWyAxIF0gKTtcblx0XHRcdFx0XHRcdGlmICggfmluZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgKFxcJycgKyBkZWxpbWl0ZXJzWyAxIF0gKyAnXFwnKScgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHQ6IHR5cGVzLkNPTU1FTlRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIWV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdFx0dHlwZSA9IG11c3RhY2hlVHlwZSggcGFyc2VyICk7XG5cdFx0XHRcdFx0bXVzdGFjaGUudCA9IHR5cGUgfHwgdHlwZXMuSU5URVJQT0xBVE9SO1xuXHRcdFx0XHRcdC8vIGRlZmF1bHRcblx0XHRcdFx0XHQvLyBTZWUgaWYgdGhlcmUncyBhbiBleHBsaWNpdCBzZWN0aW9uIHR5cGUgZS5nLiB7eyN3aXRofX0uLi57ey93aXRofX1cblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IHR5cGVzLlNFQ1RJT04gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGJsb2NrID0gcGFyc2VyLm1hdGNoUGF0dGVybiggaGFuZGxlYmFyc0Jsb2NrUGF0dGVybiApICkge1xuXHRcdFx0XHRcdFx0XHRtdXN0YWNoZS5uID0gYmxvY2s7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gdHlwZXMuQ09NTUVOVCB8fCB0eXBlID09PSB0eXBlcy5DTE9TSU5HICkge1xuXHRcdFx0XHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0XHRcdFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZiggZGVsaW1pdGVyc1sgMSBdICk7XG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0bXVzdGFjaGUuciA9IHJlbWFpbmluZy5zdWJzdHIoIDAsIGluZGV4ICkuc3BsaXQoICcgJyApWyAwIF07XG5cdFx0XHRcdFx0XHRcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBtdXN0YWNoZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggIWV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2Vcblx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHQvLyBnZXQgZXhwcmVzc2lvblxuXHRcdFx0XHRleHByZXNzaW9uID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYSBwYXJ0aWFsLCBpdCBtYXkgaGF2ZSBhIGNvbnRleHQgKGUuZy4gYHt7Pml0ZW0gZm9vfX1gKS4gVGhlc2Vcblx0XHRcdFx0Ly8gY2FzZXMgaW52b2x2ZSBhIGJpdCBvZiBhIGhhY2sgLSB3ZSB3YW50IHRvIHR1cm4gaXQgaW50byB0aGUgZXF1aXZhbGVudCBvZlxuXHRcdFx0XHQvLyBge3sjd2l0aCBmb299fXt7Pml0ZW19fXt7L3dpdGh9fWAsIGJ1dCB0byBnZXQgdGhlcmUgd2UgdGVtcG9yYXJpbHkgYXBwZW5kXG5cdFx0XHRcdC8vIGEgJ2NvbnRleHRQYXJ0aWFsRXhwcmVzc2lvbicgdG8gdGhlIG11c3RhY2hlLCBhbmQgcHJvY2VzcyB0aGUgY29udGV4dCBpbnN0ZWFkIG9mXG5cdFx0XHRcdC8vIHRoZSByZWZlcmVuY2Vcblx0XHRcdFx0dmFyIHRlbXA7XG5cdFx0XHRcdGlmICggbXVzdGFjaGUudCA9PT0gdHlwZXMuUEFSVElBTCAmJiBleHByZXNzaW9uICYmICggdGVtcCA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpICkgKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUgPSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0UGFydGlhbEV4cHJlc3Npb246IGV4cHJlc3Npb25cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGV4cHJlc3Npb24gPSB0ZW1wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFdpdGggY2VydGFpbiB2YWxpZCByZWZlcmVuY2VzIHRoYXQgYXJlbid0IHZhbGlkIGV4cHJlc3Npb25zLFxuXHRcdFx0XHQvLyBlLmcuIHt7MS5mb299fSwgd2UgaGF2ZSBhIHByb2JsZW06IGl0IGxvb2tzIGxpa2Ugd2UndmUgZ290IGFuXG5cdFx0XHRcdC8vIGV4cHJlc3Npb24sIGJ1dCB0aGUgZXhwcmVzc2lvbiBkaWRuJ3QgY29uc3VtZSB0aGUgZW50aXJlXG5cdFx0XHRcdC8vIHJlZmVyZW5jZS4gU28gd2UgbmVlZCB0byBjaGVjayB0aGF0IHRoZSBtdXN0YWNoZSBkZWxpbWl0ZXJzXG5cdFx0XHRcdC8vIGFwcGVhciBuZXh0LCB1bmxlc3MgdGhlcmUncyBhbiBpbmRleCByZWZlcmVuY2UgKGkuZS4gYSBjb2xvbilcblx0XHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0XHRpZiAoIHJlbWFpbmluZy5zdWJzdHIoIDAsIGRlbGltaXRlcnNbIDEgXS5sZW5ndGggKSAhPT0gZGVsaW1pdGVyc1sgMSBdICYmIHJlbWFpbmluZy5jaGFyQXQoIDAgKSAhPT0gJzonICkge1xuXHRcdFx0XHRcdHBvcyA9IHBhcnNlci5wb3M7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdFx0XHRpbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKCBkZWxpbWl0ZXJzWyAxIF0gKTtcblx0XHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdG11c3RhY2hlLnIgPSByZW1haW5pbmcuc3Vic3RyKCAwLCBpbmRleCApLnRyaW0oKTtcblx0XHRcdFx0XHRcdC8vIENoZWNrIGl0J3MgYSBsZWdhbCByZWZlcmVuY2Vcblx0XHRcdFx0XHRcdGlmICggIWxlZ2FsUmVmZXJlbmNlLnRlc3QoIG11c3RhY2hlLnIgKSApIHtcblx0XHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgYSBsZWdhbCBNdXN0YWNoZSByZWZlcmVuY2UnICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXHRcdFx0XHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJzZXIucG9zID0gcG9zO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWZpbmVFeHByZXNzaW9uKCBwYXJzZXIsIGV4cHJlc3Npb24sIG11c3RhY2hlICk7XG5cdFx0XHQvLyBpZiB0aGVyZSB3YXMgY29udGV4dCwgcHJvY2VzcyB0aGUgZXhwcmVzc2lvbiBub3cgYW5kIHNhdmUgaXQgZm9yIGxhdGVyXG5cdFx0XHRpZiAoIG11c3RhY2hlLmNvbnRleHRQYXJ0aWFsRXhwcmVzc2lvbiApIHtcblx0XHRcdFx0bXVzdGFjaGUuY29udGV4dFBhcnRpYWxFeHByZXNzaW9uID0gWyByZWZpbmVFeHByZXNzaW9uKCBwYXJzZXIsIG11c3RhY2hlLmNvbnRleHRQYXJ0aWFsRXhwcmVzc2lvbiwge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLlBBUlRJQUxcblx0XHRcdFx0fSApIF07XG5cdFx0XHR9XG5cdFx0XHQvLyBvcHRpb25hbCBpbmRleCByZWZlcmVuY2Vcblx0XHRcdGlmICggaSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGluZGV4UmVmUGF0dGVybiApICkge1xuXHRcdFx0XHRtdXN0YWNoZS5pID0gaTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtdXN0YWNoZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVmaW5lRXhwcmVzc2lvbiggcGFyc2VyLCBleHByZXNzaW9uLCBtdXN0YWNoZSApIHtcblx0XHRcdHZhciByZWZlcmVuY2VFeHByZXNzaW9uO1xuXHRcdFx0aWYgKCBleHByZXNzaW9uICkge1xuXHRcdFx0XHR3aGlsZSAoIGV4cHJlc3Npb24udCA9PT0gdHlwZXMuQlJBQ0tFVEVEICYmIGV4cHJlc3Npb24ueCApIHtcblx0XHRcdFx0XHRleHByZXNzaW9uID0gZXhwcmVzc2lvbi54O1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGludGVnZXJzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGFycmF5IG1lbWJlcnMgcmVmZXJlbmNlcyxcblx0XHRcdFx0Ly8gcmF0aGVyIHRoYW4gYXMgZXhwcmVzc2lvbnMgaW4gdGhlaXIgb3duIHJpZ2h0XG5cdFx0XHRcdGlmICggZXhwcmVzc2lvbi50ID09PSB0eXBlcy5SRUZFUkVOQ0UgKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUuciA9IGV4cHJlc3Npb24ubjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIGV4cHJlc3Npb24udCA9PT0gdHlwZXMuTlVNQkVSX0xJVEVSQUwgJiYgYXJyYXlNZW1iZXJQYXR0ZXJuLnRlc3QoIGV4cHJlc3Npb24udiApICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUuciA9IGV4cHJlc3Npb24udjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCByZWZlcmVuY2VFeHByZXNzaW9uID0gZ2V0UmVmZXJlbmNlRXhwcmVzc2lvbiggcGFyc2VyLCBleHByZXNzaW9uICkgKSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS5yeCA9IHJlZmVyZW5jZUV4cHJlc3Npb247XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG11c3RhY2hlLnggPSBwYXJzZXIuZmxhdHRlbkV4cHJlc3Npb24oIGV4cHJlc3Npb24gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBUT0RPIHJlZmFjdG9yIHRoaXMhIGl0J3MgYmV3aWxkZXJpbmdcblx0XHRmdW5jdGlvbiBnZXRSZWZlcmVuY2VFeHByZXNzaW9uKCBwYXJzZXIsIGV4cHJlc3Npb24gKSB7XG5cdFx0XHR2YXIgbWVtYmVycyA9IFtdLFxuXHRcdFx0XHRyZWZpbmVtZW50O1xuXHRcdFx0d2hpbGUgKCBleHByZXNzaW9uLnQgPT09IHR5cGVzLk1FTUJFUiAmJiBleHByZXNzaW9uLnIudCA9PT0gdHlwZXMuUkVGSU5FTUVOVCApIHtcblx0XHRcdFx0cmVmaW5lbWVudCA9IGV4cHJlc3Npb24ucjtcblx0XHRcdFx0aWYgKCByZWZpbmVtZW50LnggKSB7XG5cdFx0XHRcdFx0aWYgKCByZWZpbmVtZW50LngudCA9PT0gdHlwZXMuUkVGRVJFTkNFICkge1xuXHRcdFx0XHRcdFx0bWVtYmVycy51bnNoaWZ0KCByZWZpbmVtZW50LnggKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWVtYmVycy51bnNoaWZ0KCBwYXJzZXIuZmxhdHRlbkV4cHJlc3Npb24oIHJlZmluZW1lbnQueCApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1lbWJlcnMudW5zaGlmdCggcmVmaW5lbWVudC5uICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ueDtcblx0XHRcdH1cblx0XHRcdGlmICggZXhwcmVzc2lvbi50ICE9PSB0eXBlcy5SRUZFUkVOQ0UgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cjogZXhwcmVzc2lvbi5uLFxuXHRcdFx0XHRtOiBtZW1iZXJzXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHR5cGVzLCB0eXBlLCBoYW5kbGViYXJzQmxvY2tDb2RlcywgbGVnYWN5ICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS5qcyAqL1xuXHR2YXIgbXVzdGFjaGUgPSBmdW5jdGlvbiggdHlwZXMsIGRlbGltaXRlckNoYW5nZSwgZGVsaW1pdGVyVHlwZXMsIG11c3RhY2hlQ29udGVudCwgaGFuZGxlYmFyc0Jsb2NrQ29kZXMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGRlbGltaXRlckNoYW5nZVRva2VuID0ge1xuXHRcdFx0dDogdHlwZXMuREVMSU1DSEFOR0UsXG5cdFx0XHRleGNsdWRlOiB0cnVlXG5cdFx0fTtcblx0XHRfX2V4cG9ydCA9IGdldE11c3RhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0TXVzdGFjaGUoIHBhcnNlciApIHtcblx0XHRcdHZhciB0eXBlcztcblx0XHRcdC8vIElmIHdlJ3JlIGluc2lkZSBhIDxzY3JpcHQ+IG9yIDxzdHlsZT4gdGFnLCBhbmQgd2UncmUgbm90XG5cdFx0XHQvLyBpbnRlcnBvbGF0aW5nLCBidWcgb3V0XG5cdFx0XHRpZiAoIHBhcnNlci5pbnRlcnBvbGF0ZVsgcGFyc2VyLmluc2lkZSBdID09PSBmYWxzZSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHR0eXBlcyA9IGRlbGltaXRlclR5cGVzLnNsaWNlKCkuc29ydCggZnVuY3Rpb24gY29tcGFyZSggYSwgYiApIHtcblx0XHRcdFx0Ly8gU29ydCBpbiBvcmRlciBvZiBkZXNjZW5kaW5nIG9wZW5pbmcgZGVsaW1pdGVyIGxlbmd0aCAobG9uZ2VyIGZpcnN0KSxcblx0XHRcdFx0Ly8gdG8gcHJvdGVjdCBhZ2FpbnN0IG9wZW5pbmcgZGVsaW1pdGVycyBiZWluZyBzdWJzdHJpbmdzIG9mIGVhY2ggb3RoZXJcblx0XHRcdFx0cmV0dXJuIHBhcnNlclsgYi5kZWxpbWl0ZXJzIF1bIDAgXS5sZW5ndGggLSBwYXJzZXJbIGEuZGVsaW1pdGVycyBdWyAwIF0ubGVuZ3RoO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHIoIHR5cGUgKSB7XG5cdFx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGdldE11c3RhY2hlT2ZUeXBlKCBwYXJzZXIsIHR5cGUgKSB8fCByKCB0eXBlcy5zaGlmdCgpICk7XG5cdFx0XHRcdH1cblx0XHRcdH0oIHR5cGVzLnNoaWZ0KCkgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRNdXN0YWNoZU9mVHlwZSggcGFyc2VyLCBkZWxpbWl0ZXJUeXBlICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBtdXN0YWNoZSwgZGVsaW1pdGVycywgY2hpbGRyZW4sIGV4cGVjdGVkQ2xvc2UsIGVsc2VDaGlsZHJlbiwgY3VycmVudENoaWxkcmVuLCBjaGlsZDtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdGRlbGltaXRlcnMgPSBwYXJzZXJbIGRlbGltaXRlclR5cGUuZGVsaW1pdGVycyBdO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBkZWxpbWl0ZXJzWyAwIF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBkZWxpbWl0ZXIgY2hhbmdlP1xuXHRcdFx0aWYgKCBtdXN0YWNoZSA9IGRlbGltaXRlckNoYW5nZSggcGFyc2VyICkgKSB7XG5cdFx0XHRcdC8vIGZpbmQgY2xvc2luZyBkZWxpbWl0ZXIgb3IgYWJvcnQuLi5cblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBkZWxpbWl0ZXJzWyAxIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyAuLi50aGVuIG1ha2UgdGhlIHN3aXRjaFxuXHRcdFx0XHRwYXJzZXJbIGRlbGltaXRlclR5cGUuZGVsaW1pdGVycyBdID0gbXVzdGFjaGU7XG5cdFx0XHRcdHJldHVybiBkZWxpbWl0ZXJDaGFuZ2VUb2tlbjtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdG11c3RhY2hlID0gbXVzdGFjaGVDb250ZW50KCBwYXJzZXIsIGRlbGltaXRlclR5cGUgKTtcblx0XHRcdGlmICggbXVzdGFjaGUgPT09IG51bGwgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBjbG9zaW5nIGRlbGltaXRlclxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBkZWxpbWl0ZXJzWyAxIF0gKSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgXFwnJyArIGRlbGltaXRlcnNbIDEgXSArICdcXCcgYWZ0ZXIgcmVmZXJlbmNlJyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBtdXN0YWNoZS50ID09PSB0eXBlcy5DT01NRU5UICkge1xuXHRcdFx0XHRtdXN0YWNoZS5leGNsdWRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggbXVzdGFjaGUudCA9PT0gdHlwZXMuQ0xPU0lORyApIHtcblx0XHRcdFx0cGFyc2VyLnNlY3Rpb25EZXB0aCAtPSAxO1xuXHRcdFx0XHRpZiAoIHBhcnNlci5zZWN0aW9uRGVwdGggPCAwICkge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdBdHRlbXB0ZWQgdG8gY2xvc2UgYSBzZWN0aW9uIHRoYXQgd2FzblxcJ3Qgb3BlbicgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gcGFydGlhbHMgd2l0aCBjb250ZXh0XG5cdFx0XHRpZiAoIG11c3RhY2hlLmNvbnRleHRQYXJ0aWFsRXhwcmVzc2lvbiApIHtcblx0XHRcdFx0bXVzdGFjaGUuZiA9IG11c3RhY2hlLmNvbnRleHRQYXJ0aWFsRXhwcmVzc2lvbjtcblx0XHRcdFx0bXVzdGFjaGUudCA9IHR5cGVzLlNFQ1RJT047XG5cdFx0XHRcdG11c3RhY2hlLm4gPSAnd2l0aCc7XG5cdFx0XHRcdGRlbGV0ZSBtdXN0YWNoZS5jb250ZXh0UGFydGlhbEV4cHJlc3Npb247XG5cdFx0XHR9IGVsc2UgaWYgKCBpc1NlY3Rpb24oIG11c3RhY2hlICkgKSB7XG5cdFx0XHRcdHBhcnNlci5zZWN0aW9uRGVwdGggKz0gMTtcblx0XHRcdFx0Y2hpbGRyZW4gPSBbXTtcblx0XHRcdFx0Y3VycmVudENoaWxkcmVuID0gY2hpbGRyZW47XG5cdFx0XHRcdGV4cGVjdGVkQ2xvc2UgPSBtdXN0YWNoZS5uO1xuXHRcdFx0XHR3aGlsZSAoIGNoaWxkID0gcGFyc2VyLnJlYWQoKSApIHtcblx0XHRcdFx0XHRpZiAoIGNoaWxkLnQgPT09IHR5cGVzLkNMT1NJTkcgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGV4cGVjdGVkQ2xvc2UgJiYgY2hpbGQuciAhPT0gZXhwZWN0ZWRDbG9zZSApIHtcblx0XHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQge3svJyArIGV4cGVjdGVkQ2xvc2UgKyAnfX0nICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8ge3tlbHNlfX0gdGFncyByZXF1aXJlIHNwZWNpYWwgdHJlYXRtZW50XG5cdFx0XHRcdFx0aWYgKCBjaGlsZC50ID09PSB0eXBlcy5JTlRFUlBPTEFUT1IgJiYgY2hpbGQuciA9PT0gJ2Vsc2UnICkge1xuXHRcdFx0XHRcdFx0Ly8gbm8ge3tlbHNlfX0gYWxsb3dlZCBpbiB7eyN1bmxlc3N9fVxuXHRcdFx0XHRcdFx0aWYgKCBtdXN0YWNoZS5uID09PSAndW5sZXNzJyApIHtcblx0XHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAne3tlbHNlfX0gbm90IGFsbG93ZWQgaW4ge3sjdW5sZXNzfX0nICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50Q2hpbGRyZW4gPSBlbHNlQ2hpbGRyZW4gPSBbXTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1cnJlbnRDaGlsZHJlbi5wdXNoKCBjaGlsZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY2hpbGRyZW4ubGVuZ3RoICkge1xuXHRcdFx0XHRcdG11c3RhY2hlLmYgPSBjaGlsZHJlbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsc2VDaGlsZHJlbiAmJiBlbHNlQ2hpbGRyZW4ubGVuZ3RoICkge1xuXHRcdFx0XHRcdG11c3RhY2hlLmwgPSBlbHNlQ2hpbGRyZW47XG5cdFx0XHRcdFx0aWYgKCBtdXN0YWNoZS5uID09PSAnd2l0aCcgKSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS5uID0gJ2lmLXdpdGgnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnAgPSBwYXJzZXIuZ2V0TGluZVBvcyggc3RhcnQgKTtcblx0XHRcdH1cblx0XHRcdC8vIFJlcGxhY2UgYmxvY2sgbmFtZSB3aXRoIGNvZGVcblx0XHRcdGlmICggbXVzdGFjaGUubiApIHtcblx0XHRcdFx0bXVzdGFjaGUubiA9IGhhbmRsZWJhcnNCbG9ja0NvZGVzWyBtdXN0YWNoZS5uIF07XG5cdFx0XHR9IGVsc2UgaWYgKCBtdXN0YWNoZS50ID09PSB0eXBlcy5JTlZFUlRFRCApIHtcblx0XHRcdFx0bXVzdGFjaGUudCA9IHR5cGVzLlNFQ1RJT047XG5cdFx0XHRcdG11c3RhY2hlLm4gPSB0eXBlcy5TRUNUSU9OX1VOTEVTUztcblx0XHRcdH1cblx0XHRcdHJldHVybiBtdXN0YWNoZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1NlY3Rpb24oIG11c3RhY2hlICkge1xuXHRcdFx0cmV0dXJuIG11c3RhY2hlLnQgPT09IHR5cGVzLlNFQ1RJT04gfHwgbXVzdGFjaGUudCA9PT0gdHlwZXMuSU5WRVJURUQ7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdHlwZXMsIGRlbGltaXRlckNoYW5nZSwgZGVsaW1pdGVyVHlwZXMsIGNvbnRlbnQsIGhhbmRsZWJhcnNCbG9ja0NvZGVzICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9jb21tZW50LmpzICovXG5cdHZhciBjb21tZW50ID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0dmFyIE9QRU5fQ09NTUVOVCA9ICc8IS0tJyxcblx0XHRcdENMT1NFX0NPTU1FTlQgPSAnLS0+Jztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgY29udGVudCwgcmVtYWluaW5nLCBlbmRJbmRleCwgY29tbWVudDtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggT1BFTl9DT01NRU5UICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0ZW5kSW5kZXggPSByZW1haW5pbmcuaW5kZXhPZiggQ0xPU0VfQ09NTUVOVCApO1xuXHRcdFx0aWYgKCBlbmRJbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0lsbGVnYWwgSFRNTCAtIGV4cGVjdGVkIGNsb3NpbmcgY29tbWVudCBzZXF1ZW5jZSAoXFwnLS0+XFwnKScgKTtcblx0XHRcdH1cblx0XHRcdGNvbnRlbnQgPSByZW1haW5pbmcuc3Vic3RyKCAwLCBlbmRJbmRleCApO1xuXHRcdFx0cGFyc2VyLnBvcyArPSBlbmRJbmRleCArIDM7XG5cdFx0XHRjb21tZW50ID0ge1xuXHRcdFx0XHR0OiB0eXBlcy5DT01NRU5ULFxuXHRcdFx0XHRjOiBjb250ZW50XG5cdFx0XHR9O1xuXHRcdFx0aWYgKCBwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMgKSB7XG5cdFx0XHRcdGNvbW1lbnQucCA9IHBhcnNlci5nZXRMaW5lUG9zKCBzdGFydCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbW1lbnQ7XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBjb25maWcvdm9pZEVsZW1lbnROYW1lcy5qcyAqL1xuXHR2YXIgdm9pZEVsZW1lbnROYW1lcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHZvaWRFbGVtZW50TmFtZXMgPSAvXig/OmFyZWF8YmFzZXxicnxjb2x8Y29tbWFuZHxkb2N0eXBlfGVtYmVkfGhyfGltZ3xpbnB1dHxrZXlnZW58bGlua3xtZXRhfHBhcmFtfHNvdXJjZXx0cmFja3x3YnIpJC9pO1xuXHRcdHJldHVybiB2b2lkRWxlbWVudE5hbWVzO1xuXHR9KCk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy91dGlscy9nZXRMb3dlc3RJbmRleC5qcyAqL1xuXHR2YXIgZ2V0TG93ZXN0SW5kZXggPSBmdW5jdGlvbiggaGF5c3RhY2ssIG5lZWRsZXMgKSB7XG5cdFx0dmFyIGksIGluZGV4LCBsb3dlc3Q7XG5cdFx0aSA9IG5lZWRsZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0aW5kZXggPSBoYXlzdGFjay5pbmRleE9mKCBuZWVkbGVzWyBpIF0gKTtcblx0XHRcdC8vIHNob3J0IGNpcmN1aXRcblx0XHRcdGlmICggIWluZGV4ICkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmICggIWxvd2VzdCB8fCBpbmRleCA8IGxvd2VzdCApIHtcblx0XHRcdFx0bG93ZXN0ID0gaW5kZXg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBsb3dlc3QgfHwgLTE7XG5cdH07XG5cblx0Lyogc2hhcmVkL2RlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMuanMgKi9cblx0dmFyIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgaHRtbEVudGl0aWVzLCBjb250cm9sQ2hhcmFjdGVycywgZW50aXR5UGF0dGVybjtcblx0XHRodG1sRW50aXRpZXMgPSB7XG5cdFx0XHRxdW90OiAzNCxcblx0XHRcdGFtcDogMzgsXG5cdFx0XHRhcG9zOiAzOSxcblx0XHRcdGx0OiA2MCxcblx0XHRcdGd0OiA2Mixcblx0XHRcdG5ic3A6IDE2MCxcblx0XHRcdGlleGNsOiAxNjEsXG5cdFx0XHRjZW50OiAxNjIsXG5cdFx0XHRwb3VuZDogMTYzLFxuXHRcdFx0Y3VycmVuOiAxNjQsXG5cdFx0XHR5ZW46IDE2NSxcblx0XHRcdGJydmJhcjogMTY2LFxuXHRcdFx0c2VjdDogMTY3LFxuXHRcdFx0dW1sOiAxNjgsXG5cdFx0XHRjb3B5OiAxNjksXG5cdFx0XHRvcmRmOiAxNzAsXG5cdFx0XHRsYXF1bzogMTcxLFxuXHRcdFx0bm90OiAxNzIsXG5cdFx0XHRzaHk6IDE3Myxcblx0XHRcdHJlZzogMTc0LFxuXHRcdFx0bWFjcjogMTc1LFxuXHRcdFx0ZGVnOiAxNzYsXG5cdFx0XHRwbHVzbW46IDE3Nyxcblx0XHRcdHN1cDI6IDE3OCxcblx0XHRcdHN1cDM6IDE3OSxcblx0XHRcdGFjdXRlOiAxODAsXG5cdFx0XHRtaWNybzogMTgxLFxuXHRcdFx0cGFyYTogMTgyLFxuXHRcdFx0bWlkZG90OiAxODMsXG5cdFx0XHRjZWRpbDogMTg0LFxuXHRcdFx0c3VwMTogMTg1LFxuXHRcdFx0b3JkbTogMTg2LFxuXHRcdFx0cmFxdW86IDE4Nyxcblx0XHRcdGZyYWMxNDogMTg4LFxuXHRcdFx0ZnJhYzEyOiAxODksXG5cdFx0XHRmcmFjMzQ6IDE5MCxcblx0XHRcdGlxdWVzdDogMTkxLFxuXHRcdFx0QWdyYXZlOiAxOTIsXG5cdFx0XHRBYWN1dGU6IDE5Myxcblx0XHRcdEFjaXJjOiAxOTQsXG5cdFx0XHRBdGlsZGU6IDE5NSxcblx0XHRcdEF1bWw6IDE5Nixcblx0XHRcdEFyaW5nOiAxOTcsXG5cdFx0XHRBRWxpZzogMTk4LFxuXHRcdFx0Q2NlZGlsOiAxOTksXG5cdFx0XHRFZ3JhdmU6IDIwMCxcblx0XHRcdEVhY3V0ZTogMjAxLFxuXHRcdFx0RWNpcmM6IDIwMixcblx0XHRcdEV1bWw6IDIwMyxcblx0XHRcdElncmF2ZTogMjA0LFxuXHRcdFx0SWFjdXRlOiAyMDUsXG5cdFx0XHRJY2lyYzogMjA2LFxuXHRcdFx0SXVtbDogMjA3LFxuXHRcdFx0RVRIOiAyMDgsXG5cdFx0XHROdGlsZGU6IDIwOSxcblx0XHRcdE9ncmF2ZTogMjEwLFxuXHRcdFx0T2FjdXRlOiAyMTEsXG5cdFx0XHRPY2lyYzogMjEyLFxuXHRcdFx0T3RpbGRlOiAyMTMsXG5cdFx0XHRPdW1sOiAyMTQsXG5cdFx0XHR0aW1lczogMjE1LFxuXHRcdFx0T3NsYXNoOiAyMTYsXG5cdFx0XHRVZ3JhdmU6IDIxNyxcblx0XHRcdFVhY3V0ZTogMjE4LFxuXHRcdFx0VWNpcmM6IDIxOSxcblx0XHRcdFV1bWw6IDIyMCxcblx0XHRcdFlhY3V0ZTogMjIxLFxuXHRcdFx0VEhPUk46IDIyMixcblx0XHRcdHN6bGlnOiAyMjMsXG5cdFx0XHRhZ3JhdmU6IDIyNCxcblx0XHRcdGFhY3V0ZTogMjI1LFxuXHRcdFx0YWNpcmM6IDIyNixcblx0XHRcdGF0aWxkZTogMjI3LFxuXHRcdFx0YXVtbDogMjI4LFxuXHRcdFx0YXJpbmc6IDIyOSxcblx0XHRcdGFlbGlnOiAyMzAsXG5cdFx0XHRjY2VkaWw6IDIzMSxcblx0XHRcdGVncmF2ZTogMjMyLFxuXHRcdFx0ZWFjdXRlOiAyMzMsXG5cdFx0XHRlY2lyYzogMjM0LFxuXHRcdFx0ZXVtbDogMjM1LFxuXHRcdFx0aWdyYXZlOiAyMzYsXG5cdFx0XHRpYWN1dGU6IDIzNyxcblx0XHRcdGljaXJjOiAyMzgsXG5cdFx0XHRpdW1sOiAyMzksXG5cdFx0XHRldGg6IDI0MCxcblx0XHRcdG50aWxkZTogMjQxLFxuXHRcdFx0b2dyYXZlOiAyNDIsXG5cdFx0XHRvYWN1dGU6IDI0Myxcblx0XHRcdG9jaXJjOiAyNDQsXG5cdFx0XHRvdGlsZGU6IDI0NSxcblx0XHRcdG91bWw6IDI0Nixcblx0XHRcdGRpdmlkZTogMjQ3LFxuXHRcdFx0b3NsYXNoOiAyNDgsXG5cdFx0XHR1Z3JhdmU6IDI0OSxcblx0XHRcdHVhY3V0ZTogMjUwLFxuXHRcdFx0dWNpcmM6IDI1MSxcblx0XHRcdHV1bWw6IDI1Mixcblx0XHRcdHlhY3V0ZTogMjUzLFxuXHRcdFx0dGhvcm46IDI1NCxcblx0XHRcdHl1bWw6IDI1NSxcblx0XHRcdE9FbGlnOiAzMzgsXG5cdFx0XHRvZWxpZzogMzM5LFxuXHRcdFx0U2Nhcm9uOiAzNTIsXG5cdFx0XHRzY2Fyb246IDM1Myxcblx0XHRcdFl1bWw6IDM3Nixcblx0XHRcdGZub2Y6IDQwMixcblx0XHRcdGNpcmM6IDcxMCxcblx0XHRcdHRpbGRlOiA3MzIsXG5cdFx0XHRBbHBoYTogOTEzLFxuXHRcdFx0QmV0YTogOTE0LFxuXHRcdFx0R2FtbWE6IDkxNSxcblx0XHRcdERlbHRhOiA5MTYsXG5cdFx0XHRFcHNpbG9uOiA5MTcsXG5cdFx0XHRaZXRhOiA5MTgsXG5cdFx0XHRFdGE6IDkxOSxcblx0XHRcdFRoZXRhOiA5MjAsXG5cdFx0XHRJb3RhOiA5MjEsXG5cdFx0XHRLYXBwYTogOTIyLFxuXHRcdFx0TGFtYmRhOiA5MjMsXG5cdFx0XHRNdTogOTI0LFxuXHRcdFx0TnU6IDkyNSxcblx0XHRcdFhpOiA5MjYsXG5cdFx0XHRPbWljcm9uOiA5MjcsXG5cdFx0XHRQaTogOTI4LFxuXHRcdFx0UmhvOiA5MjksXG5cdFx0XHRTaWdtYTogOTMxLFxuXHRcdFx0VGF1OiA5MzIsXG5cdFx0XHRVcHNpbG9uOiA5MzMsXG5cdFx0XHRQaGk6IDkzNCxcblx0XHRcdENoaTogOTM1LFxuXHRcdFx0UHNpOiA5MzYsXG5cdFx0XHRPbWVnYTogOTM3LFxuXHRcdFx0YWxwaGE6IDk0NSxcblx0XHRcdGJldGE6IDk0Nixcblx0XHRcdGdhbW1hOiA5NDcsXG5cdFx0XHRkZWx0YTogOTQ4LFxuXHRcdFx0ZXBzaWxvbjogOTQ5LFxuXHRcdFx0emV0YTogOTUwLFxuXHRcdFx0ZXRhOiA5NTEsXG5cdFx0XHR0aGV0YTogOTUyLFxuXHRcdFx0aW90YTogOTUzLFxuXHRcdFx0a2FwcGE6IDk1NCxcblx0XHRcdGxhbWJkYTogOTU1LFxuXHRcdFx0bXU6IDk1Nixcblx0XHRcdG51OiA5NTcsXG5cdFx0XHR4aTogOTU4LFxuXHRcdFx0b21pY3JvbjogOTU5LFxuXHRcdFx0cGk6IDk2MCxcblx0XHRcdHJobzogOTYxLFxuXHRcdFx0c2lnbWFmOiA5NjIsXG5cdFx0XHRzaWdtYTogOTYzLFxuXHRcdFx0dGF1OiA5NjQsXG5cdFx0XHR1cHNpbG9uOiA5NjUsXG5cdFx0XHRwaGk6IDk2Nixcblx0XHRcdGNoaTogOTY3LFxuXHRcdFx0cHNpOiA5NjgsXG5cdFx0XHRvbWVnYTogOTY5LFxuXHRcdFx0dGhldGFzeW06IDk3Nyxcblx0XHRcdHVwc2loOiA5NzgsXG5cdFx0XHRwaXY6IDk4Mixcblx0XHRcdGVuc3A6IDgxOTQsXG5cdFx0XHRlbXNwOiA4MTk1LFxuXHRcdFx0dGhpbnNwOiA4MjAxLFxuXHRcdFx0enduajogODIwNCxcblx0XHRcdHp3ajogODIwNSxcblx0XHRcdGxybTogODIwNixcblx0XHRcdHJsbTogODIwNyxcblx0XHRcdG5kYXNoOiA4MjExLFxuXHRcdFx0bWRhc2g6IDgyMTIsXG5cdFx0XHRsc3F1bzogODIxNixcblx0XHRcdHJzcXVvOiA4MjE3LFxuXHRcdFx0c2JxdW86IDgyMTgsXG5cdFx0XHRsZHF1bzogODIyMCxcblx0XHRcdHJkcXVvOiA4MjIxLFxuXHRcdFx0YmRxdW86IDgyMjIsXG5cdFx0XHRkYWdnZXI6IDgyMjQsXG5cdFx0XHREYWdnZXI6IDgyMjUsXG5cdFx0XHRidWxsOiA4MjI2LFxuXHRcdFx0aGVsbGlwOiA4MjMwLFxuXHRcdFx0cGVybWlsOiA4MjQwLFxuXHRcdFx0cHJpbWU6IDgyNDIsXG5cdFx0XHRQcmltZTogODI0Myxcblx0XHRcdGxzYXF1bzogODI0OSxcblx0XHRcdHJzYXF1bzogODI1MCxcblx0XHRcdG9saW5lOiA4MjU0LFxuXHRcdFx0ZnJhc2w6IDgyNjAsXG5cdFx0XHRldXJvOiA4MzY0LFxuXHRcdFx0aW1hZ2U6IDg0NjUsXG5cdFx0XHR3ZWllcnA6IDg0NzIsXG5cdFx0XHRyZWFsOiA4NDc2LFxuXHRcdFx0dHJhZGU6IDg0ODIsXG5cdFx0XHRhbGVmc3ltOiA4NTAxLFxuXHRcdFx0bGFycjogODU5Mixcblx0XHRcdHVhcnI6IDg1OTMsXG5cdFx0XHRyYXJyOiA4NTk0LFxuXHRcdFx0ZGFycjogODU5NSxcblx0XHRcdGhhcnI6IDg1OTYsXG5cdFx0XHRjcmFycjogODYyOSxcblx0XHRcdGxBcnI6IDg2NTYsXG5cdFx0XHR1QXJyOiA4NjU3LFxuXHRcdFx0ckFycjogODY1OCxcblx0XHRcdGRBcnI6IDg2NTksXG5cdFx0XHRoQXJyOiA4NjYwLFxuXHRcdFx0Zm9yYWxsOiA4NzA0LFxuXHRcdFx0cGFydDogODcwNixcblx0XHRcdGV4aXN0OiA4NzA3LFxuXHRcdFx0ZW1wdHk6IDg3MDksXG5cdFx0XHRuYWJsYTogODcxMSxcblx0XHRcdGlzaW46IDg3MTIsXG5cdFx0XHRub3RpbjogODcxMyxcblx0XHRcdG5pOiA4NzE1LFxuXHRcdFx0cHJvZDogODcxOSxcblx0XHRcdHN1bTogODcyMSxcblx0XHRcdG1pbnVzOiA4NzIyLFxuXHRcdFx0bG93YXN0OiA4NzI3LFxuXHRcdFx0cmFkaWM6IDg3MzAsXG5cdFx0XHRwcm9wOiA4NzMzLFxuXHRcdFx0aW5maW46IDg3MzQsXG5cdFx0XHRhbmc6IDg3MzYsXG5cdFx0XHRhbmQ6IDg3NDMsXG5cdFx0XHRvcjogODc0NCxcblx0XHRcdGNhcDogODc0NSxcblx0XHRcdGN1cDogODc0Nixcblx0XHRcdCdpbnQnOiA4NzQ3LFxuXHRcdFx0dGhlcmU0OiA4NzU2LFxuXHRcdFx0c2ltOiA4NzY0LFxuXHRcdFx0Y29uZzogODc3Myxcblx0XHRcdGFzeW1wOiA4Nzc2LFxuXHRcdFx0bmU6IDg4MDAsXG5cdFx0XHRlcXVpdjogODgwMSxcblx0XHRcdGxlOiA4ODA0LFxuXHRcdFx0Z2U6IDg4MDUsXG5cdFx0XHRzdWI6IDg4MzQsXG5cdFx0XHRzdXA6IDg4MzUsXG5cdFx0XHRuc3ViOiA4ODM2LFxuXHRcdFx0c3ViZTogODgzOCxcblx0XHRcdHN1cGU6IDg4MzksXG5cdFx0XHRvcGx1czogODg1Myxcblx0XHRcdG90aW1lczogODg1NSxcblx0XHRcdHBlcnA6IDg4NjksXG5cdFx0XHRzZG90OiA4OTAxLFxuXHRcdFx0bGNlaWw6IDg5NjgsXG5cdFx0XHRyY2VpbDogODk2OSxcblx0XHRcdGxmbG9vcjogODk3MCxcblx0XHRcdHJmbG9vcjogODk3MSxcblx0XHRcdGxhbmc6IDkwMDEsXG5cdFx0XHRyYW5nOiA5MDAyLFxuXHRcdFx0bG96OiA5Njc0LFxuXHRcdFx0c3BhZGVzOiA5ODI0LFxuXHRcdFx0Y2x1YnM6IDk4MjcsXG5cdFx0XHRoZWFydHM6IDk4MjksXG5cdFx0XHRkaWFtczogOTgzMFxuXHRcdH07XG5cdFx0Y29udHJvbENoYXJhY3RlcnMgPSBbXG5cdFx0XHQ4MzY0LFxuXHRcdFx0MTI5LFxuXHRcdFx0ODIxOCxcblx0XHRcdDQwMixcblx0XHRcdDgyMjIsXG5cdFx0XHQ4MjMwLFxuXHRcdFx0ODIyNCxcblx0XHRcdDgyMjUsXG5cdFx0XHQ3MTAsXG5cdFx0XHQ4MjQwLFxuXHRcdFx0MzUyLFxuXHRcdFx0ODI0OSxcblx0XHRcdDMzOCxcblx0XHRcdDE0MSxcblx0XHRcdDM4MSxcblx0XHRcdDE0Myxcblx0XHRcdDE0NCxcblx0XHRcdDgyMTYsXG5cdFx0XHQ4MjE3LFxuXHRcdFx0ODIyMCxcblx0XHRcdDgyMjEsXG5cdFx0XHQ4MjI2LFxuXHRcdFx0ODIxMSxcblx0XHRcdDgyMTIsXG5cdFx0XHQ3MzIsXG5cdFx0XHQ4NDgyLFxuXHRcdFx0MzUzLFxuXHRcdFx0ODI1MCxcblx0XHRcdDMzOSxcblx0XHRcdDE1Nyxcblx0XHRcdDM4Mixcblx0XHRcdDM3NlxuXHRcdF07XG5cdFx0ZW50aXR5UGF0dGVybiA9IG5ldyBSZWdFeHAoICcmKCM/KD86eFtcXFxcd1xcXFxkXSt8XFxcXGQrfCcgKyBPYmplY3Qua2V5cyggaHRtbEVudGl0aWVzICkuam9pbiggJ3wnICkgKyAnKSk7PycsICdnJyApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyggaHRtbCApIHtcblx0XHRcdHJldHVybiBodG1sLnJlcGxhY2UoIGVudGl0eVBhdHRlcm4sIGZ1bmN0aW9uKCBtYXRjaCwgZW50aXR5ICkge1xuXHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0Ly8gSGFuZGxlIG5hbWVkIGVudGl0aWVzXG5cdFx0XHRcdGlmICggZW50aXR5WyAwIF0gIT09ICcjJyApIHtcblx0XHRcdFx0XHRjb2RlID0gaHRtbEVudGl0aWVzWyBlbnRpdHkgXTtcblx0XHRcdFx0fSBlbHNlIGlmICggZW50aXR5WyAxIF0gPT09ICd4JyApIHtcblx0XHRcdFx0XHRjb2RlID0gcGFyc2VJbnQoIGVudGl0eS5zdWJzdHJpbmcoIDIgKSwgMTYgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb2RlID0gcGFyc2VJbnQoIGVudGl0eS5zdWJzdHJpbmcoIDEgKSwgMTAgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFjb2RlICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSggdmFsaWRhdGVDb2RlKCBjb2RlICkgKTtcblx0XHRcdH0gKTtcblx0XHR9O1xuXHRcdC8vIHNvbWUgY29kZSBwb2ludHMgYXJlIHZlcmJvdGVuLiBJZiB3ZSB3ZXJlIGluc2VydGluZyBIVE1MLCB0aGUgYnJvd3NlciB3b3VsZCByZXBsYWNlIHRoZSBpbGxlZ2FsXG5cdFx0Ly8gY29kZSBwb2ludHMgd2l0aCBhbHRlcm5hdGl2ZXMgaW4gc29tZSBjYXNlcyAtIHNpbmNlIHdlJ3JlIGJ5cGFzc2luZyB0aGF0IG1lY2hhbmlzbSwgd2UgbmVlZFxuXHRcdC8vIHRvIHJlcGxhY2UgdGhlbSBvdXJzZWx2ZXNcblx0XHQvL1xuXHRcdC8vIFNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DaGFyYWN0ZXJfZW5jb2RpbmdzX2luX0hUTUwjSWxsZWdhbF9jaGFyYWN0ZXJzXG5cdFx0ZnVuY3Rpb24gdmFsaWRhdGVDb2RlKCBjb2RlICkge1xuXHRcdFx0aWYgKCAhY29kZSApIHtcblx0XHRcdFx0cmV0dXJuIDY1NTMzO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbGluZSBmZWVkIGJlY29tZXMgZ2VuZXJpYyB3aGl0ZXNwYWNlXG5cdFx0XHRpZiAoIGNvZGUgPT09IDEwICkge1xuXHRcdFx0XHRyZXR1cm4gMzI7XG5cdFx0XHR9XG5cdFx0XHQvLyBBU0NJSSByYW5nZS4gKFdoeSBzb21lb25lIHdvdWxkIHVzZSBIVE1MIGVudGl0aWVzIGZvciBBU0NJSSBjaGFyYWN0ZXJzIEkgZG9uJ3Qga25vdywgYnV0Li4uKVxuXHRcdFx0aWYgKCBjb2RlIDwgMTI4ICkge1xuXHRcdFx0XHRyZXR1cm4gY29kZTtcblx0XHRcdH1cblx0XHRcdC8vIGNvZGUgcG9pbnRzIDEyOC0xNTkgYXJlIGRlYWx0IHdpdGggbGVuaWVudGx5IGJ5IGJyb3dzZXJzLCBidXQgdGhleSdyZSBpbmNvcnJlY3QuIFdlIG5lZWRcblx0XHRcdC8vIHRvIGNvcnJlY3QgdGhlIG1pc3Rha2Ugb3Igd2UnbGwgZW5kIHVwIHdpdGggbWlzc2luZyDigqwgc2lnbnMgYW5kIHNvIG9uXG5cdFx0XHRpZiAoIGNvZGUgPD0gMTU5ICkge1xuXHRcdFx0XHRyZXR1cm4gY29udHJvbENoYXJhY3RlcnNbIGNvZGUgLSAxMjggXTtcblx0XHRcdH1cblx0XHRcdC8vIGJhc2ljIG11bHRpbGluZ3VhbCBwbGFuZVxuXHRcdFx0aWYgKCBjb2RlIDwgNTUyOTYgKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVVRGLTE2IHN1cnJvZ2F0ZSBoYWx2ZXNcblx0XHRcdGlmICggY29kZSA8PSA1NzM0MyApIHtcblx0XHRcdFx0cmV0dXJuIDY1NTMzO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmVzdCBvZiB0aGUgYmFzaWMgbXVsdGlsaW5ndWFsIHBsYW5lXG5cdFx0XHRpZiAoIGNvZGUgPD0gNjU1MzUgKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDY1NTMzO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGxlZ2FjeSApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvdGV4dC5qcyAqL1xuXHR2YXIgdGV4dCA9IGZ1bmN0aW9uKCBnZXRMb3dlc3RJbmRleCwgZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIGluZGV4LCByZW1haW5pbmcsIGRpc2FsbG93ZWQsIGJhcnJpZXI7XG5cdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRiYXJyaWVyID0gcGFyc2VyLmluc2lkZSA/ICc8LycgKyBwYXJzZXIuaW5zaWRlIDogJzwnO1xuXHRcdFx0aWYgKCBwYXJzZXIuaW5zaWRlICYmICFwYXJzZXIuaW50ZXJwb2xhdGVbIHBhcnNlci5pbnNpZGUgXSApIHtcblx0XHRcdFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZiggYmFycmllciApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGlzYWxsb3dlZCA9IFtcblx0XHRcdFx0XHRwYXJzZXIuZGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRcdHBhcnNlci50cmlwbGVEZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdFx0cGFyc2VyLnN0YXRpY0RlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0XHRwYXJzZXIuc3RhdGljVHJpcGxlRGVsaW1pdGVyc1sgMCBdXG5cdFx0XHRcdF07XG5cdFx0XHRcdC8vIGh0dHA6Ly9kZXZlbG9wZXJzLndoYXR3Zy5vcmcvc3ludGF4Lmh0bWwjc3ludGF4LWF0dHJpYnV0ZXNcblx0XHRcdFx0aWYgKCBwYXJzZXIuaW5BdHRyaWJ1dGUgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0Ly8gd2UncmUgaW5zaWRlIGFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZVxuXHRcdFx0XHRcdGRpc2FsbG93ZWQucHVzaCggJ1wiJywgJ1xcJycsICc9JywgJzwnLCAnPicsICdgJyApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJzZXIuaW5BdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0Ly8gcXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZVxuXHRcdFx0XHRcdGRpc2FsbG93ZWQucHVzaCggcGFyc2VyLmluQXR0cmlidXRlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGlzYWxsb3dlZC5wdXNoKCBiYXJyaWVyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXggPSBnZXRMb3dlc3RJbmRleCggcmVtYWluaW5nLCBkaXNhbGxvd2VkICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFpbmRleCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0aW5kZXggPSByZW1haW5pbmcubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblx0XHRcdHJldHVybiBwYXJzZXIuaW5zaWRlID8gcmVtYWluaW5nLnN1YnN0ciggMCwgaW5kZXggKSA6IGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoIHJlbWFpbmluZy5zdWJzdHIoIDAsIGluZGV4ICkgKTtcblx0XHR9O1xuXHR9KCBnZXRMb3dlc3RJbmRleCwgZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvZWxlbWVudC9jbG9zaW5nVGFnLmpzICovXG5cdHZhciBjbG9zaW5nVGFnID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0dmFyIGNsb3NpbmdUYWdQYXR0ZXJuID0gL14oW2EtekEtWl17MSx9Oj9bYS16QS1aMC05XFwtXSopXFxzKlxcPi87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgdGFnO1xuXHRcdFx0Ly8gYXJlIHdlIGxvb2tpbmcgYXQgYSBjbG9zaW5nIHRhZz9cblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzwvJyApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICggdGFnID0gcGFyc2VyLm1hdGNoUGF0dGVybiggY2xvc2luZ1RhZ1BhdHRlcm4gKSApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5DTE9TSU5HX1RBRyxcblx0XHRcdFx0XHRlOiB0YWdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8vIFdlIGhhdmUgYW4gaWxsZWdhbCBjbG9zaW5nIHRhZywgcmVwb3J0IGl0XG5cdFx0XHRwYXJzZXIucG9zIC09IDI7XG5cdFx0XHRwYXJzZXIuZXJyb3IoICdJbGxlZ2FsIGNsb3NpbmcgdGFnJyApO1xuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9lbGVtZW50L2F0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgYXR0cmlidXRlID0gZnVuY3Rpb24oIGdldExvd2VzdEluZGV4LCBnZXRNdXN0YWNoZSwgZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgYXR0cmlidXRlTmFtZVBhdHRlcm4gPSAvXlteXFxzXCInPlxcLz1dKy8sXG5cdFx0XHR1bnF1b3RlZEF0dHJpYnV0ZVZhbHVlVGV4dFBhdHRlcm4gPSAvXlteXFxzXCInPTw+YF0rLztcblx0XHRfX2V4cG9ydCA9IGdldEF0dHJpYnV0ZTtcblxuXHRcdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZSggcGFyc2VyICkge1xuXHRcdFx0dmFyIGF0dHIsIG5hbWUsIHZhbHVlO1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0bmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGF0dHJpYnV0ZU5hbWVQYXR0ZXJuICk7XG5cdFx0XHRpZiAoICFuYW1lICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGF0dHIgPSB7XG5cdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdH07XG5cdFx0XHR2YWx1ZSA9IGdldEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIgKTtcblx0XHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRcdGF0dHIudmFsdWUgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhdHRyO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIHZhbHVlU3RhcnQsIHN0YXJ0RGVwdGgsIHZhbHVlO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPScgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdHZhbHVlU3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0c3RhcnREZXB0aCA9IHBhcnNlci5zZWN0aW9uRGVwdGg7XG5cdFx0XHR2YWx1ZSA9IGdldFF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIsICdcXCcnICkgfHwgZ2V0UXVvdGVkQXR0cmlidXRlVmFsdWUoIHBhcnNlciwgJ1wiJyApIHx8IGdldFVucXVvdGVkQXR0cmlidXRlVmFsdWUoIHBhcnNlciApO1xuXHRcdFx0aWYgKCBwYXJzZXIuc2VjdGlvbkRlcHRoICE9PSBzdGFydERlcHRoICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gdmFsdWVTdGFydDtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnQW4gYXR0cmlidXRlIHZhbHVlIG11c3QgY29udGFpbiBhcyBtYW55IG9wZW5pbmcgc2VjdGlvbiB0YWdzIGFzIGNsb3Npbmcgc2VjdGlvbiB0YWdzJyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICggIXZhbHVlLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgdmFsdWVbIDAgXSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHJldHVybiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKCB2YWx1ZVsgMCBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIHRleHQsIGhheXN0YWNrLCBuZWVkbGVzLCBpbmRleDtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHRleHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCB1bnF1b3RlZEF0dHJpYnV0ZVZhbHVlVGV4dFBhdHRlcm4gKTtcblx0XHRcdGlmICggIXRleHQgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aGF5c3RhY2sgPSB0ZXh0O1xuXHRcdFx0bmVlZGxlcyA9IFtcblx0XHRcdFx0cGFyc2VyLmRlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0cGFyc2VyLnRyaXBsZURlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0cGFyc2VyLnN0YXRpY0RlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0cGFyc2VyLnN0YXRpY1RyaXBsZURlbGltaXRlcnNbIDAgXVxuXHRcdFx0XTtcblx0XHRcdGlmICggKCBpbmRleCA9IGdldExvd2VzdEluZGV4KCBoYXlzdGFjaywgbmVlZGxlcyApICkgIT09IC0xICkge1xuXHRcdFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHIoIDAsIGluZGV4ICk7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydCArIHRleHQubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyICkge1xuXHRcdFx0dmFyIHRva2VucywgdG9rZW47XG5cdFx0XHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSB0cnVlO1xuXHRcdFx0dG9rZW5zID0gW107XG5cdFx0XHR0b2tlbiA9IGdldE11c3RhY2hlKCBwYXJzZXIgKSB8fCBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlVG9rZW4oIHBhcnNlciApO1xuXHRcdFx0d2hpbGUgKCB0b2tlbiAhPT0gbnVsbCApIHtcblx0XHRcdFx0dG9rZW5zLnB1c2goIHRva2VuICk7XG5cdFx0XHRcdHRva2VuID0gZ2V0TXVzdGFjaGUoIHBhcnNlciApIHx8IGdldFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbiggcGFyc2VyICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICF0b2tlbnMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRva2Vucztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRRdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyLCBxdW90ZU1hcmsgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIHRva2VucywgdG9rZW47XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHF1b3RlTWFyayApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHF1b3RlTWFyaztcblx0XHRcdHRva2VucyA9IFtdO1xuXHRcdFx0dG9rZW4gPSBnZXRNdXN0YWNoZSggcGFyc2VyICkgfHwgZ2V0UXVvdGVkU3RyaW5nVG9rZW4oIHBhcnNlciwgcXVvdGVNYXJrICk7XG5cdFx0XHR3aGlsZSAoIHRva2VuICE9PSBudWxsICkge1xuXHRcdFx0XHR0b2tlbnMucHVzaCggdG9rZW4gKTtcblx0XHRcdFx0dG9rZW4gPSBnZXRNdXN0YWNoZSggcGFyc2VyICkgfHwgZ2V0UXVvdGVkU3RyaW5nVG9rZW4oIHBhcnNlciwgcXVvdGVNYXJrICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHF1b3RlTWFyayApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmluQXR0cmlidXRlID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdG9rZW5zO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFF1b3RlZFN0cmluZ1Rva2VuKCBwYXJzZXIsIHF1b3RlTWFyayApIHtcblx0XHRcdHZhciBzdGFydCwgaW5kZXgsIGhheXN0YWNrLCBuZWVkbGVzO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0aGF5c3RhY2sgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRuZWVkbGVzID0gW1xuXHRcdFx0XHRxdW90ZU1hcmssXG5cdFx0XHRcdHBhcnNlci5kZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdHBhcnNlci50cmlwbGVEZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdHBhcnNlci5zdGF0aWNEZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdHBhcnNlci5zdGF0aWNUcmlwbGVEZWxpbWl0ZXJzWyAwIF1cblx0XHRcdF07XG5cdFx0XHRpbmRleCA9IGdldExvd2VzdEluZGV4KCBoYXlzdGFjaywgbmVlZGxlcyApO1xuXHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ1F1b3RlZCBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBoYXZlIGEgY2xvc2luZyBxdW90ZScgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIWluZGV4ICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG5cdFx0XHRyZXR1cm4gaGF5c3RhY2suc3Vic3RyKCAwLCBpbmRleCApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGdldExvd2VzdEluZGV4LCBtdXN0YWNoZSwgZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyApO1xuXG5cdC8qIHV0aWxzL3BhcnNlSlNPTi5qcyAqL1xuXHR2YXIgcGFyc2VKU09OID0gZnVuY3Rpb24oIFBhcnNlciwgZ2V0U3RyaW5nTGl0ZXJhbCwgZ2V0S2V5ICkge1xuXG5cdFx0dmFyIEpzb25QYXJzZXIsIHNwZWNpYWxzLCBzcGVjaWFsc1BhdHRlcm4sIG51bWJlclBhdHRlcm4sIHBsYWNlaG9sZGVyUGF0dGVybiwgcGxhY2Vob2xkZXJBdFN0YXJ0UGF0dGVybiwgb25seVdoaXRlc3BhY2U7XG5cdFx0c3BlY2lhbHMgPSB7XG5cdFx0XHQndHJ1ZSc6IHRydWUsXG5cdFx0XHQnZmFsc2UnOiBmYWxzZSxcblx0XHRcdCd1bmRlZmluZWQnOiB1bmRlZmluZWQsXG5cdFx0XHQnbnVsbCc6IG51bGxcblx0XHR9O1xuXHRcdHNwZWNpYWxzUGF0dGVybiA9IG5ldyBSZWdFeHAoICdeKD86JyArIE9iamVjdC5rZXlzKCBzcGVjaWFscyApLmpvaW4oICd8JyApICsgJyknICk7XG5cdFx0bnVtYmVyUGF0dGVybiA9IC9eKD86WystXT8pKD86KD86KD86MHxbMS05XVxcZCopP1xcLlxcZCspfCg/Oig/OjB8WzEtOV1cXGQqKVxcLil8KD86MHxbMS05XVxcZCopKSg/OltlRV1bKy1dP1xcZCspPy87XG5cdFx0cGxhY2Vob2xkZXJQYXR0ZXJuID0gL1xcJFxceyhbXlxcfV0rKVxcfS9nO1xuXHRcdHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4gPSAvXlxcJFxceyhbXlxcfV0rKVxcfS87XG5cdFx0b25seVdoaXRlc3BhY2UgPSAvXlxccyokLztcblx0XHRKc29uUGFyc2VyID0gUGFyc2VyLmV4dGVuZCgge1xuXHRcdFx0aW5pdDogZnVuY3Rpb24oIHN0ciwgb3B0aW9ucyApIHtcblx0XHRcdFx0dGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcblx0XHRcdFx0dGhpcy5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdH0sXG5cdFx0XHRwb3N0UHJvY2VzczogZnVuY3Rpb24oIHJlc3VsdCApIHtcblx0XHRcdFx0aWYgKCByZXN1bHQubGVuZ3RoICE9PSAxIHx8ICFvbmx5V2hpdGVzcGFjZS50ZXN0KCB0aGlzLmxlZnRvdmVyICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR2YWx1ZTogcmVzdWx0WyAwIF0udlxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGNvbnZlcnRlcnM6IFtcblxuXHRcdFx0XHRmdW5jdGlvbiBnZXRQbGFjZWhvbGRlciggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciBwbGFjZWhvbGRlcjtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIudmFsdWVzICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBsYWNlaG9sZGVyID0gcGFyc2VyLm1hdGNoUGF0dGVybiggcGxhY2Vob2xkZXJBdFN0YXJ0UGF0dGVybiApO1xuXHRcdFx0XHRcdGlmICggcGxhY2Vob2xkZXIgJiYgcGFyc2VyLnZhbHVlcy5oYXNPd25Qcm9wZXJ0eSggcGxhY2Vob2xkZXIgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHY6IHBhcnNlci52YWx1ZXNbIHBsYWNlaG9sZGVyIF1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBnZXRTcGVjaWFsKCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIHNwZWNpYWw7XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsID0gcGFyc2VyLm1hdGNoUGF0dGVybiggc3BlY2lhbHNQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiBzcGVjaWFsc1sgc3BlY2lhbCBdXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0TnVtYmVyKCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIG51bWJlcjtcblx0XHRcdFx0XHRpZiAoIG51bWJlciA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIG51bWJlclBhdHRlcm4gKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHY6ICtudW1iZXJcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBnZXRTdHJpbmcoIHBhcnNlciApIHtcblx0XHRcdFx0XHR2YXIgc3RyaW5nTGl0ZXJhbCA9IGdldFN0cmluZ0xpdGVyYWwoIHBhcnNlciApLFxuXHRcdFx0XHRcdFx0dmFsdWVzO1xuXHRcdFx0XHRcdGlmICggc3RyaW5nTGl0ZXJhbCAmJiAoIHZhbHVlcyA9IHBhcnNlci52YWx1ZXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHY6IHN0cmluZ0xpdGVyYWwudi5yZXBsYWNlKCBwbGFjZWhvbGRlclBhdHRlcm4sIGZ1bmN0aW9uKCBtYXRjaCwgJDEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICQxIGluIHZhbHVlcyA/IHZhbHVlc1sgJDEgXSA6ICQxO1xuXHRcdFx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBzdHJpbmdMaXRlcmFsO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBnZXRPYmplY3QoIHBhcnNlciApIHtcblx0XHRcdFx0XHR2YXIgcmVzdWx0LCBwYWlyO1xuXHRcdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ3snICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnfScgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHY6IHJlc3VsdFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCBwYWlyID0gZ2V0S2V5VmFsdWVQYWlyKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0XHRcdHJlc3VsdFsgcGFpci5rZXkgXSA9IHBhaXIudmFsdWU7XG5cdFx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ30nICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0djogcmVzdWx0XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICcsJyApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIGdldEFycmF5KCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCwgdmFsdWVUb2tlbjtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICdbJyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCA9IFtdO1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ10nICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiByZXN1bHRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggdmFsdWVUb2tlbiA9IHBhcnNlci5yZWFkKCkgKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCggdmFsdWVUb2tlbi52ICk7XG5cdFx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ10nICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0djogcmVzdWx0XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICcsJyApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdF1cblx0XHR9ICk7XG5cblx0XHRmdW5jdGlvbiBnZXRLZXlWYWx1ZVBhaXIoIHBhcnNlciApIHtcblx0XHRcdHZhciBrZXksIHZhbHVlVG9rZW4sIHBhaXI7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRrZXkgPSBnZXRLZXkoIHBhcnNlciApO1xuXHRcdFx0aWYgKCAha2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhaXIgPSB7XG5cdFx0XHRcdGtleToga2V5XG5cdFx0XHR9O1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnOicgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHR2YWx1ZVRva2VuID0gcGFyc2VyLnJlYWQoKTtcblx0XHRcdGlmICggIXZhbHVlVG9rZW4gKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFpci52YWx1ZSA9IHZhbHVlVG9rZW4udjtcblx0XHRcdHJldHVybiBwYWlyO1xuXHRcdH1cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHN0ciwgdmFsdWVzICkge1xuXHRcdFx0dmFyIHBhcnNlciA9IG5ldyBKc29uUGFyc2VyKCBzdHIsIHtcblx0XHRcdFx0dmFsdWVzOiB2YWx1ZXNcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBwYXJzZXIucmVzdWx0O1xuXHRcdH07XG5cdH0oIFBhcnNlciwgc3RyaW5nTGl0ZXJhbCwga2V5ICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9lbGVtZW50L3Byb2Nlc3NEaXJlY3RpdmUuanMgKi9cblx0dmFyIHByb2Nlc3NEaXJlY3RpdmUgPSBmdW5jdGlvbiggUGFyc2VyLCBjb25kaXRpb25hbCwgZmxhdHRlbkV4cHJlc3Npb24sIHBhcnNlSlNPTiApIHtcblxuXHRcdHZhciBtZXRob2RDYWxsUGF0dGVybiA9IC9eKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKilcXCgvLFxuXHRcdFx0RXhwcmVzc2lvblBhcnNlcjtcblx0XHRFeHByZXNzaW9uUGFyc2VyID0gUGFyc2VyLmV4dGVuZCgge1xuXHRcdFx0Y29udmVydGVyczogWyBjb25kaXRpb25hbCBdXG5cdFx0fSApO1xuXHRcdC8vIFRPRE8gY2xlYW4gdGhpcyB1cCwgaXQncyBzaG9ja2luZ1xuXHRcdHJldHVybiBmdW5jdGlvbiggdG9rZW5zICkge1xuXHRcdFx0dmFyIHJlc3VsdCwgbWF0Y2gsIHBhcnNlciwgYXJncywgdG9rZW4sIGNvbG9uSW5kZXgsIGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZUFyZ3MsIHBhcnNlZDtcblx0XHRcdGlmICggdHlwZW9mIHRva2VucyA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGlmICggbWF0Y2ggPSBtZXRob2RDYWxsUGF0dGVybi5leGVjKCB0b2tlbnMgKSApIHtcblx0XHRcdFx0XHRyZXN1bHQgPSB7XG5cdFx0XHRcdFx0XHRtOiBtYXRjaFsgMSBdXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRhcmdzID0gJ1snICsgdG9rZW5zLnNsaWNlKCByZXN1bHQubS5sZW5ndGggKyAxLCAtMSApICsgJ10nO1xuXHRcdFx0XHRcdHBhcnNlciA9IG5ldyBFeHByZXNzaW9uUGFyc2VyKCBhcmdzICk7XG5cdFx0XHRcdFx0cmVzdWx0LmEgPSBmbGF0dGVuRXhwcmVzc2lvbiggcGFyc2VyLnJlc3VsdFsgMCBdICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRva2Vucy5pbmRleE9mKCAnOicgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRva2Vucy50cmltKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dG9rZW5zID0gWyB0b2tlbnMgXTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdFx0ZGlyZWN0aXZlTmFtZSA9IFtdO1xuXHRcdFx0ZGlyZWN0aXZlQXJncyA9IFtdO1xuXHRcdFx0aWYgKCB0b2tlbnMgKSB7XG5cdFx0XHRcdHdoaWxlICggdG9rZW5zLmxlbmd0aCApIHtcblx0XHRcdFx0XHR0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIHRva2VuID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdGNvbG9uSW5kZXggPSB0b2tlbi5pbmRleE9mKCAnOicgKTtcblx0XHRcdFx0XHRcdGlmICggY29sb25JbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCggdG9rZW4gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIGlzIHRoZSBjb2xvbiB0aGUgZmlyc3QgY2hhcmFjdGVyP1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbG9uSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gbm9cblx0XHRcdFx0XHRcdFx0XHRkaXJlY3RpdmVOYW1lLnB1c2goIHRva2VuLnN1YnN0ciggMCwgY29sb25JbmRleCApICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYW55dGhpbmcgYWZ0ZXIgdGhlIGNvbG9uIGluIHRoaXMgdG9rZW4sIHRyZWF0XG5cdFx0XHRcdFx0XHRcdC8vIGl0IGFzIHRoZSBmaXJzdCB0b2tlbiBvZiB0aGUgZGlyZWN0aXZlQXJncyBmcmFnbWVudFxuXHRcdFx0XHRcdFx0XHRpZiAoIHRva2VuLmxlbmd0aCA+IGNvbG9uSW5kZXggKyAxICkge1xuXHRcdFx0XHRcdFx0XHRcdGRpcmVjdGl2ZUFyZ3NbIDAgXSA9IHRva2VuLnN1YnN0cmluZyggY29sb25JbmRleCArIDEgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKCB0b2tlbiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRkaXJlY3RpdmVBcmdzID0gZGlyZWN0aXZlQXJncy5jb25jYXQoIHRva2VucyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZGlyZWN0aXZlTmFtZS5sZW5ndGggKSB7XG5cdFx0XHRcdHJlc3VsdCA9ICcnO1xuXHRcdFx0fSBlbHNlIGlmICggZGlyZWN0aXZlQXJncy5sZW5ndGggfHwgdHlwZW9mIGRpcmVjdGl2ZU5hbWUgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRyZXN1bHQgPSB7XG5cdFx0XHRcdFx0Ly8gVE9ETyBpcyB0aGlzIHJlYWxseSBuZWNlc3Nhcnk/IGp1c3QgdXNlIHRoZSBhcnJheVxuXHRcdFx0XHRcdG46IGRpcmVjdGl2ZU5hbWUubGVuZ3RoID09PSAxICYmIHR5cGVvZiBkaXJlY3RpdmVOYW1lWyAwIF0gPT09ICdzdHJpbmcnID8gZGlyZWN0aXZlTmFtZVsgMCBdIDogZGlyZWN0aXZlTmFtZVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIGRpcmVjdGl2ZUFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBkaXJlY3RpdmVBcmdzWyAwIF0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHBhcnNlZCA9IHBhcnNlSlNPTiggJ1snICsgZGlyZWN0aXZlQXJnc1sgMCBdICsgJ10nICk7XG5cdFx0XHRcdFx0cmVzdWx0LmEgPSBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiBkaXJlY3RpdmVBcmdzWyAwIF0udHJpbSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc3VsdC5kID0gZGlyZWN0aXZlQXJncztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0ID0gZGlyZWN0aXZlTmFtZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0fSggUGFyc2VyLCBjb25kaXRpb25hbCwgZmxhdHRlbkV4cHJlc3Npb24sIHBhcnNlSlNPTiApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvZWxlbWVudC5qcyAqL1xuXHR2YXIgZWxlbWVudCA9IGZ1bmN0aW9uKCB0eXBlcywgdm9pZEVsZW1lbnROYW1lcywgZ2V0TXVzdGFjaGUsIGdldENvbW1lbnQsIGdldFRleHQsIGdldENsb3NpbmdUYWcsIGdldEF0dHJpYnV0ZSwgcHJvY2Vzc0RpcmVjdGl2ZSApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgdGFnTmFtZVBhdHRlcm4gPSAvXlthLXpBLVpdezEsfTo/W2EtekEtWjAtOVxcLV0qLyxcblx0XHRcdHZhbGlkVGFnTmFtZUZvbGxvd2VyID0gL15bXFxzXFxuXFwvPl0vLFxuXHRcdFx0b25QYXR0ZXJuID0gL15vbi8sXG5cdFx0XHRwcm94eUV2ZW50UGF0dGVybiA9IC9eb24tKFthLXpBLVpcXFxcKlxcXFwuJF9dW2EtekEtWlxcXFwqXFxcXC4kXzAtOVxcLV0rKSQvLFxuXHRcdFx0cmVzZXJ2ZWRFdmVudE5hbWVzID0gL14oPzpjaGFuZ2V8cmVzZXR8dGVhcmRvd258dXBkYXRlfGNvbnN0cnVjdHxjb25maWd8aW5pdHxyZW5kZXJ8dW5yZW5kZXJ8ZGV0YWNofGluc2VydCkkLyxcblx0XHRcdGRpcmVjdGl2ZXMgPSB7XG5cdFx0XHRcdCdpbnRyby1vdXRybyc6ICd0MCcsXG5cdFx0XHRcdGludHJvOiAndDEnLFxuXHRcdFx0XHRvdXRybzogJ3QyJyxcblx0XHRcdFx0ZGVjb3JhdG9yOiAnbydcblx0XHRcdH0sXG5cdFx0XHRleGNsdWRlID0ge1xuXHRcdFx0XHRleGNsdWRlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0Y29udmVydGVycywgZGlzYWxsb3dlZENvbnRlbnRzO1xuXHRcdC8vIERpZmZlcmVudCBzZXQgb2YgY29udmVydGVycywgYmVjYXVzZSB0aGlzIHRpbWUgd2UncmUgbG9va2luZyBmb3IgY2xvc2luZyB0YWdzXG5cdFx0Y29udmVydGVycyA9IFtcblx0XHRcdGdldE11c3RhY2hlLFxuXHRcdFx0Z2V0Q29tbWVudCxcblx0XHRcdGdldEVsZW1lbnQsXG5cdFx0XHRnZXRUZXh0LFxuXHRcdFx0Z2V0Q2xvc2luZ1RhZ1xuXHRcdF07XG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL2RldmVsb3BlcnMud2hhdHdnLm9yZy9zeW50YXguaHRtbCNzeW50YXgtdGFnLW9taXNzaW9uXG5cdFx0ZGlzYWxsb3dlZENvbnRlbnRzID0ge1xuXHRcdFx0bGk6IFsgJ2xpJyBdLFxuXHRcdFx0ZHQ6IFtcblx0XHRcdFx0J2R0Jyxcblx0XHRcdFx0J2RkJ1xuXHRcdFx0XSxcblx0XHRcdGRkOiBbXG5cdFx0XHRcdCdkdCcsXG5cdFx0XHRcdCdkZCdcblx0XHRcdF0sXG5cdFx0XHRwOiAnYWRkcmVzcyBhcnRpY2xlIGFzaWRlIGJsb2NrcXVvdGUgZGl2IGRsIGZpZWxkc2V0IGZvb3RlciBmb3JtIGgxIGgyIGgzIGg0IGg1IGg2IGhlYWRlciBoZ3JvdXAgaHIgbWFpbiBtZW51IG5hdiBvbCBwIHByZSBzZWN0aW9uIHRhYmxlIHVsJy5zcGxpdCggJyAnICksXG5cdFx0XHRydDogW1xuXHRcdFx0XHQncnQnLFxuXHRcdFx0XHQncnAnXG5cdFx0XHRdLFxuXHRcdFx0cnA6IFtcblx0XHRcdFx0J3J0Jyxcblx0XHRcdFx0J3JwJ1xuXHRcdFx0XSxcblx0XHRcdG9wdGdyb3VwOiBbICdvcHRncm91cCcgXSxcblx0XHRcdG9wdGlvbjogW1xuXHRcdFx0XHQnb3B0aW9uJyxcblx0XHRcdFx0J29wdGdyb3VwJ1xuXHRcdFx0XSxcblx0XHRcdHRoZWFkOiBbXG5cdFx0XHRcdCd0Ym9keScsXG5cdFx0XHRcdCd0Zm9vdCdcblx0XHRcdF0sXG5cdFx0XHR0Ym9keTogW1xuXHRcdFx0XHQndGJvZHknLFxuXHRcdFx0XHQndGZvb3QnXG5cdFx0XHRdLFxuXHRcdFx0dGZvb3Q6IFsgJ3Rib2R5JyBdLFxuXHRcdFx0dHI6IFtcblx0XHRcdFx0J3RyJyxcblx0XHRcdFx0J3Rib2R5J1xuXHRcdFx0XSxcblx0XHRcdHRkOiBbXG5cdFx0XHRcdCd0ZCcsXG5cdFx0XHRcdCd0aCcsXG5cdFx0XHRcdCd0cidcblx0XHRcdF0sXG5cdFx0XHR0aDogW1xuXHRcdFx0XHQndGQnLFxuXHRcdFx0XHQndGgnLFxuXHRcdFx0XHQndHInXG5cdFx0XHRdXG5cdFx0fTtcblx0XHRfX2V4cG9ydCA9IGdldEVsZW1lbnQ7XG5cblx0XHRmdW5jdGlvbiBnZXRFbGVtZW50KCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGVsZW1lbnQsIGxvd2VyQ2FzZU5hbWUsIGRpcmVjdGl2ZU5hbWUsIG1hdGNoLCBhZGRQcm94eUV2ZW50LCBhdHRyaWJ1dGUsIGRpcmVjdGl2ZSwgc2VsZkNsb3NpbmcsIGNoaWxkcmVuLCBjaGlsZDtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdGlmICggcGFyc2VyLmluc2lkZSB8fCBwYXJzZXIuaW5BdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPCcgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiB0aGlzIGlzIGEgY2xvc2luZyB0YWcsIGFib3J0IHN0cmFpZ2h0IGF3YXlcblx0XHRcdGlmICggcGFyc2VyLm5leHRDaGFyKCkgPT09ICcvJyApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRlbGVtZW50ID0ge1xuXHRcdFx0XHR0OiB0eXBlcy5FTEVNRU5UXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCBwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMgKSB7XG5cdFx0XHRcdGVsZW1lbnQucCA9IHBhcnNlci5nZXRMaW5lUG9zKCBzdGFydCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICchJyApICkge1xuXHRcdFx0XHRlbGVtZW50LnkgPSAxO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZWxlbWVudCBuYW1lXG5cdFx0XHRlbGVtZW50LmUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCB0YWdOYW1lUGF0dGVybiApO1xuXHRcdFx0aWYgKCAhZWxlbWVudC5lICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgd2hpdGVzcGFjZSwgY2xvc2luZyBzb2xpZHVzIG9yICc+J1xuXHRcdFx0aWYgKCAhdmFsaWRUYWdOYW1lRm9sbG93ZXIudGVzdCggcGFyc2VyLm5leHRDaGFyKCkgKSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnSWxsZWdhbCB0YWcgbmFtZScgKTtcblx0XHRcdH1cblx0XHRcdGFkZFByb3h5RXZlbnQgPSBmdW5jdGlvbiggbmFtZSwgZGlyZWN0aXZlICkge1xuXHRcdFx0XHR2YXIgZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZS5uIHx8IGRpcmVjdGl2ZTtcblx0XHRcdFx0aWYgKCByZXNlcnZlZEV2ZW50TmFtZXMudGVzdCggZGlyZWN0aXZlTmFtZSApICkge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgLT0gZGlyZWN0aXZlTmFtZS5sZW5ndGg7XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnQ2Fubm90IHVzZSByZXNlcnZlZCBldmVudCBuYW1lcyAoY2hhbmdlLCByZXNldCwgdGVhcmRvd24sIHVwZGF0ZSwgY29uc3RydWN0LCBjb25maWcsIGluaXQsIHJlbmRlciwgdW5yZW5kZXIsIGRldGFjaCwgaW5zZXJ0KScgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbGVtZW50LnZbIG5hbWUgXSA9IGRpcmVjdGl2ZTtcblx0XHRcdH07XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHQvLyBkaXJlY3RpdmVzIGFuZCBhdHRyaWJ1dGVzXG5cdFx0XHR3aGlsZSAoIGF0dHJpYnV0ZSA9IGdldE11c3RhY2hlKCBwYXJzZXIgKSB8fCBnZXRBdHRyaWJ1dGUoIHBhcnNlciApICkge1xuXHRcdFx0XHQvLyByZWd1bGFyIGF0dHJpYnV0ZXNcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUubmFtZSApIHtcblx0XHRcdFx0XHQvLyBpbnRybywgb3V0cm8sIGRlY29yYXRvclxuXHRcdFx0XHRcdGlmICggZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZXNbIGF0dHJpYnV0ZS5uYW1lIF0gKSB7XG5cdFx0XHRcdFx0XHRlbGVtZW50WyBkaXJlY3RpdmVOYW1lIF0gPSBwcm9jZXNzRGlyZWN0aXZlKCBhdHRyaWJ1dGUudmFsdWUgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaCA9IHByb3h5RXZlbnRQYXR0ZXJuLmV4ZWMoIGF0dHJpYnV0ZS5uYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFlbGVtZW50LnYgKVxuXHRcdFx0XHRcdFx0XHRlbGVtZW50LnYgPSB7fTtcblx0XHRcdFx0XHRcdGRpcmVjdGl2ZSA9IHByb2Nlc3NEaXJlY3RpdmUoIGF0dHJpYnV0ZS52YWx1ZSApO1xuXHRcdFx0XHRcdFx0YWRkUHJveHlFdmVudCggbWF0Y2hbIDEgXSwgZGlyZWN0aXZlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICggIXBhcnNlci5zYW5pdGl6ZUV2ZW50QXR0cmlidXRlcyB8fCAhb25QYXR0ZXJuLnRlc3QoIGF0dHJpYnV0ZS5uYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggIWVsZW1lbnQuYSApXG5cdFx0XHRcdFx0XHRcdFx0ZWxlbWVudC5hID0ge307XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQuYVsgYXR0cmlidXRlLm5hbWUgXSA9IGF0dHJpYnV0ZS52YWx1ZSB8fCAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoICFlbGVtZW50Lm0gKVxuXHRcdFx0XHRcdFx0ZWxlbWVudC5tID0gW107XG5cdFx0XHRcdFx0ZWxlbWVudC5tLnB1c2goIGF0dHJpYnV0ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3Npbmcgc29saWR1c1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gc2VsZi1jbG9zaW5nIHNvbGlkdXM/XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJy8nICkgKSB7XG5cdFx0XHRcdHNlbGZDbG9zaW5nID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIGNsb3NpbmcgYW5nbGUgYnJhY2tldFxuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPicgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRsb3dlckNhc2VOYW1lID0gZWxlbWVudC5lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRpZiAoICFzZWxmQ2xvc2luZyAmJiAhdm9pZEVsZW1lbnROYW1lcy50ZXN0KCBlbGVtZW50LmUgKSApIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gaWYgd2Ugb3BlbiBhIHNjcmlwdCBlbGVtZW50LCBmdXJ0aGVyIHRhZ3Mgc2hvdWxkXG5cdFx0XHRcdC8vIGJlIGlnbm9yZWQgdW5sZXNzIHRoZXkncmUgYSBjbG9zaW5nIHNjcmlwdCBlbGVtZW50XG5cdFx0XHRcdGlmICggbG93ZXJDYXNlTmFtZSA9PT0gJ3NjcmlwdCcgfHwgbG93ZXJDYXNlTmFtZSA9PT0gJ3N0eWxlJyApIHtcblx0XHRcdFx0XHRwYXJzZXIuaW5zaWRlID0gbG93ZXJDYXNlTmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHR3aGlsZSAoIGNhbkNvbnRhaW4oIGxvd2VyQ2FzZU5hbWUsIHBhcnNlci5yZW1haW5pbmcoKSApICYmICggY2hpbGQgPSBwYXJzZXIucmVhZCggY29udmVydGVycyApICkgKSB7XG5cdFx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gY2xvc2luZyBzZWN0aW9uIHRhZ1xuXHRcdFx0XHRcdGlmICggY2hpbGQudCA9PT0gdHlwZXMuQ0xPU0lORyApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGNoaWxkLnQgPT09IHR5cGVzLkNMT1NJTkdfVEFHICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNoaWxkcmVuLnB1c2goIGNoaWxkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjaGlsZHJlbi5sZW5ndGggKSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5mID0gY2hpbGRyZW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHBhcnNlci5pbnNpZGUgPSBudWxsO1xuXHRcdFx0aWYgKCBwYXJzZXIuc2FuaXRpemVFbGVtZW50cyAmJiBwYXJzZXIuc2FuaXRpemVFbGVtZW50cy5pbmRleE9mKCBsb3dlckNhc2VOYW1lICkgIT09IC0xICkge1xuXHRcdFx0XHRyZXR1cm4gZXhjbHVkZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNhbkNvbnRhaW4oIG5hbWUsIHJlbWFpbmluZyApIHtcblx0XHRcdHZhciBtYXRjaCwgZGlzYWxsb3dlZDtcblx0XHRcdG1hdGNoID0gL148KFthLXpBLVpdW2EtekEtWjAtOV0qKS8uZXhlYyggcmVtYWluaW5nICk7XG5cdFx0XHRkaXNhbGxvd2VkID0gZGlzYWxsb3dlZENvbnRlbnRzWyBuYW1lIF07XG5cdFx0XHRpZiAoICFtYXRjaCB8fCAhZGlzYWxsb3dlZCApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gIX5kaXNhbGxvd2VkLmluZGV4T2YoIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHR5cGVzLCB2b2lkRWxlbWVudE5hbWVzLCBtdXN0YWNoZSwgY29tbWVudCwgdGV4dCwgY2xvc2luZ1RhZywgYXR0cmlidXRlLCBwcm9jZXNzRGlyZWN0aXZlICk7XG5cblx0LyogcGFyc2UvdXRpbHMvdHJpbVdoaXRlc3BhY2UuanMgKi9cblx0dmFyIHRyaW1XaGl0ZXNwYWNlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbGVhZGluZ1doaXRlc3BhY2UgPSAvXlsgXFx0XFxmXFxyXFxuXSsvLFxuXHRcdFx0dHJhaWxpbmdXaGl0ZXNwYWNlID0gL1sgXFx0XFxmXFxyXFxuXSskLztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGl0ZW1zLCBsZWFkaW5nLCB0cmFpbGluZyApIHtcblx0XHRcdHZhciBpdGVtO1xuXHRcdFx0aWYgKCBsZWFkaW5nICkge1xuXHRcdFx0XHRpdGVtID0gaXRlbXNbIDAgXTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0aXRlbSA9IGl0ZW0ucmVwbGFjZSggbGVhZGluZ1doaXRlc3BhY2UsICcnICk7XG5cdFx0XHRcdFx0aWYgKCAhaXRlbSApIHtcblx0XHRcdFx0XHRcdGl0ZW1zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyAwIF0gPSBpdGVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCB0cmFpbGluZyApIHtcblx0XHRcdFx0aXRlbSA9IGl0ZW1zWyBpdGVtcy5sZW5ndGggLSAxIF07XG5cdFx0XHRcdGlmICggdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdGl0ZW0gPSBpdGVtLnJlcGxhY2UoIHRyYWlsaW5nV2hpdGVzcGFjZSwgJycgKTtcblx0XHRcdFx0XHRpZiAoICFpdGVtICkge1xuXHRcdFx0XHRcdFx0aXRlbXMucG9wKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpdGVtcy5sZW5ndGggLSAxIF0gPSBpdGVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oKTtcblxuXHQvKiBwYXJzZS91dGlscy9zdHJpcFN0YW5kYWxvbmVzLmpzICovXG5cdHZhciBzdHJpcFN0YW5kYWxvbmVzID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBsZWFkaW5nTGluZWJyZWFrID0gL15cXHMqXFxyP1xcbi8sXG5cdFx0XHR0cmFpbGluZ0xpbmVicmVhayA9IC9cXHI/XFxuXFxzKiQvO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIGl0ZW1zICkge1xuXHRcdFx0dmFyIGksIGN1cnJlbnQsIGJhY2tPbmUsIGJhY2tUd28sIGxhc3RTZWN0aW9uSXRlbTtcblx0XHRcdGZvciAoIGkgPSAxOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdGN1cnJlbnQgPSBpdGVtc1sgaSBdO1xuXHRcdFx0XHRiYWNrT25lID0gaXRlbXNbIGkgLSAxIF07XG5cdFx0XHRcdGJhY2tUd28gPSBpdGVtc1sgaSAtIDIgXTtcblx0XHRcdFx0Ly8gaWYgd2UncmUgYXQgdGhlIGVuZCBvZiBhIFt0ZXh0XVtjb21tZW50XVt0ZXh0XSBzZXF1ZW5jZS4uLlxuXHRcdFx0XHRpZiAoIGlzU3RyaW5nKCBjdXJyZW50ICkgJiYgaXNDb21tZW50KCBiYWNrT25lICkgJiYgaXNTdHJpbmcoIGJhY2tUd28gKSApIHtcblx0XHRcdFx0XHQvLyAuLi4gYW5kIHRoZSBjb21tZW50IGlzIGEgc3RhbmRhbG9uZSAoaS5lLiBsaW5lIGJyZWFrcyBlaXRoZXIgc2lkZSkuLi5cblx0XHRcdFx0XHRpZiAoIHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoIGJhY2tUd28gKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoIGN1cnJlbnQgKSApIHtcblx0XHRcdFx0XHRcdC8vIC4uLiB0aGVuIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIGFmdGVyIHRoZSBmaXJzdCBsaW5lIGJyZWFrXG5cdFx0XHRcdFx0XHRpdGVtc1sgaSAtIDIgXSA9IGJhY2tUd28ucmVwbGFjZSggdHJhaWxpbmdMaW5lYnJlYWssICdcXG4nICk7XG5cdFx0XHRcdFx0XHQvLyBhbmQgdGhlIGxlYWRpbmcgbGluZSBicmVhayBvZiB0aGUgc2Vjb25kIHRleHQgdG9rZW5cblx0XHRcdFx0XHRcdGl0ZW1zWyBpIF0gPSBjdXJyZW50LnJlcGxhY2UoIGxlYWRpbmdMaW5lYnJlYWssICcnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIHRoZSBjdXJyZW50IGl0ZW0gaXMgYSBzZWN0aW9uLCBhbmQgaXQgaXMgcHJlY2VkZWQgYnkgYSBsaW5lYnJlYWssIGFuZFxuXHRcdFx0XHQvLyBpdHMgZmlyc3QgaXRlbSBpcyBhIGxpbmVicmVhay4uLlxuXHRcdFx0XHRpZiAoIGlzU2VjdGlvbiggY3VycmVudCApICYmIGlzU3RyaW5nKCBiYWNrT25lICkgKSB7XG5cdFx0XHRcdFx0aWYgKCB0cmFpbGluZ0xpbmVicmVhay50ZXN0KCBiYWNrT25lICkgJiYgaXNTdHJpbmcoIGN1cnJlbnQuZlsgMCBdICkgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KCBjdXJyZW50LmZbIDAgXSApICkge1xuXHRcdFx0XHRcdFx0aXRlbXNbIGkgLSAxIF0gPSBiYWNrT25lLnJlcGxhY2UoIHRyYWlsaW5nTGluZWJyZWFrLCAnXFxuJyApO1xuXHRcdFx0XHRcdFx0Y3VycmVudC5mWyAwIF0gPSBjdXJyZW50LmZbIDAgXS5yZXBsYWNlKCBsZWFkaW5nTGluZWJyZWFrLCAnJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiB0aGUgbGFzdCBpdGVtIHdhcyBhIHNlY3Rpb24sIGFuZCBpdCBpcyBmb2xsb3dlZCBieSBhIGxpbmVicmVhaywgYW5kXG5cdFx0XHRcdC8vIGl0cyBsYXN0IGl0ZW0gaXMgYSBsaW5lYnJlYWsuLi5cblx0XHRcdFx0aWYgKCBpc1N0cmluZyggY3VycmVudCApICYmIGlzU2VjdGlvbiggYmFja09uZSApICkge1xuXHRcdFx0XHRcdGxhc3RTZWN0aW9uSXRlbSA9IGJhY2tPbmUuZlsgYmFja09uZS5mLmxlbmd0aCAtIDEgXTtcblx0XHRcdFx0XHRpZiAoIGlzU3RyaW5nKCBsYXN0U2VjdGlvbkl0ZW0gKSAmJiB0cmFpbGluZ0xpbmVicmVhay50ZXN0KCBsYXN0U2VjdGlvbkl0ZW0gKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoIGN1cnJlbnQgKSApIHtcblx0XHRcdFx0XHRcdGJhY2tPbmUuZlsgYmFja09uZS5mLmxlbmd0aCAtIDEgXSA9IGxhc3RTZWN0aW9uSXRlbS5yZXBsYWNlKCB0cmFpbGluZ0xpbmVicmVhaywgJ1xcbicgKTtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIF0gPSBjdXJyZW50LnJlcGxhY2UoIGxlYWRpbmdMaW5lYnJlYWssICcnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGlzU3RyaW5nKCBpdGVtICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0NvbW1lbnQoIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gaXRlbS50ID09PSB0eXBlcy5DT01NRU5UIHx8IGl0ZW0udCA9PT0gdHlwZXMuREVMSU1DSEFOR0U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNTZWN0aW9uKCBpdGVtICkge1xuXHRcdFx0cmV0dXJuICggaXRlbS50ID09PSB0eXBlcy5TRUNUSU9OIHx8IGl0ZW0udCA9PT0gdHlwZXMuSU5WRVJURUQgKSAmJiBpdGVtLmY7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdHlwZXMgKTtcblxuXHQvKiB1dGlscy9lc2NhcGVSZWdFeHAuanMgKi9cblx0dmFyIGVzY2FwZVJlZ0V4cCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHBhdHRlcm4gPSAvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZztcblx0XHRyZXR1cm4gZnVuY3Rpb24gZXNjYXBlUmVnRXhwKCBzdHIgKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoIHBhdHRlcm4sICdcXFxcJCYnICk7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHBhcnNlL19wYXJzZS5qcyAqL1xuXHR2YXIgcGFyc2UgPSBmdW5jdGlvbiggdHlwZXMsIFBhcnNlciwgbXVzdGFjaGUsIGNvbW1lbnQsIGVsZW1lbnQsIHRleHQsIHRyaW1XaGl0ZXNwYWNlLCBzdHJpcFN0YW5kYWxvbmVzLCBlc2NhcGVSZWdFeHAgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIFN0YW5kYXJkUGFyc2VyLCBwYXJzZSwgY29udGlndW91c1doaXRlc3BhY2UgPSAvWyBcXHRcXGZcXHJcXG5dKy9nLFxuXHRcdFx0cHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudHMgPSAvXig/OnByZXxzY3JpcHR8c3R5bGV8dGV4dGFyZWEpJC9pLFxuXHRcdFx0bGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccysvLFxuXHRcdFx0dHJhaWxpbmdXaGl0ZXNwYWNlID0gL1xccyskLztcblx0XHRTdGFuZGFyZFBhcnNlciA9IFBhcnNlci5leHRlbmQoIHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCBzdHIsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdC8vIGNvbmZpZ1xuXHRcdFx0XHRzZXREZWxpbWl0ZXJzKCBvcHRpb25zLCB0aGlzICk7XG5cdFx0XHRcdHRoaXMuc2VjdGlvbkRlcHRoID0gMDtcblx0XHRcdFx0dGhpcy5pbnRlcnBvbGF0ZSA9IHtcblx0XHRcdFx0XHRzY3JpcHQ6ICFvcHRpb25zLmludGVycG9sYXRlIHx8IG9wdGlvbnMuaW50ZXJwb2xhdGUuc2NyaXB0ICE9PSBmYWxzZSxcblx0XHRcdFx0XHRzdHlsZTogIW9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgb3B0aW9ucy5pbnRlcnBvbGF0ZS5zdHlsZSAhPT0gZmFsc2Vcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCBvcHRpb25zLnNhbml0aXplID09PSB0cnVlICkge1xuXHRcdFx0XHRcdG9wdGlvbnMuc2FuaXRpemUgPSB7XG5cdFx0XHRcdFx0XHQvLyBibGFja2xpc3QgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1jYWphL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvY2FqYS9sYW5nL2h0bWwvaHRtbDQtZWxlbWVudHMtd2hpdGVsaXN0Lmpzb25cblx0XHRcdFx0XHRcdGVsZW1lbnRzOiAnYXBwbGV0IGJhc2UgYmFzZWZvbnQgYm9keSBmcmFtZSBmcmFtZXNldCBoZWFkIGh0bWwgaXNpbmRleCBsaW5rIG1ldGEgbm9mcmFtZXMgbm9zY3JpcHQgb2JqZWN0IHBhcmFtIHNjcmlwdCBzdHlsZSB0aXRsZScuc3BsaXQoICcgJyApLFxuXHRcdFx0XHRcdFx0ZXZlbnRBdHRyaWJ1dGVzOiB0cnVlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnNhbml0aXplRWxlbWVudHMgPSBvcHRpb25zLnNhbml0aXplICYmIG9wdGlvbnMuc2FuaXRpemUuZWxlbWVudHM7XG5cdFx0XHRcdHRoaXMuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgPSBvcHRpb25zLnNhbml0aXplICYmIG9wdGlvbnMuc2FuaXRpemUuZXZlbnRBdHRyaWJ1dGVzO1xuXHRcdFx0XHR0aGlzLmluY2x1ZGVMaW5lUG9zaXRpb25zID0gb3B0aW9ucy5pbmNsdWRlTGluZVBvc2l0aW9ucztcblx0XHRcdH0sXG5cdFx0XHRwb3N0UHJvY2VzczogZnVuY3Rpb24oIGl0ZW1zLCBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuc2VjdGlvbkRlcHRoID4gMCApIHtcblx0XHRcdFx0XHR0aGlzLmVycm9yKCAnQSBzZWN0aW9uIHdhcyBsZWZ0IG9wZW4nICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2xlYW51cCggaXRlbXMsIG9wdGlvbnMuc3RyaXBDb21tZW50cyAhPT0gZmFsc2UsIG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlLCAhb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsICFvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSwgb3B0aW9ucy5yZXdyaXRlRWxzZSAhPT0gZmFsc2UgKTtcblx0XHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdFx0fSxcblx0XHRcdGNvbnZlcnRlcnM6IFtcblx0XHRcdFx0bXVzdGFjaGUsXG5cdFx0XHRcdGNvbW1lbnQsXG5cdFx0XHRcdGVsZW1lbnQsXG5cdFx0XHRcdHRleHRcblx0XHRcdF1cblx0XHR9ICk7XG5cdFx0cGFyc2UgPSBmdW5jdGlvbiggdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sgMSBdO1xuXHRcdFx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKVxuXHRcdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHR2YXIgcmVzdWx0LCByZW1haW5pbmcsIHBhcnRpYWxzLCBuYW1lLCBzdGFydE1hdGNoLCBlbmRNYXRjaCwgaW5saW5lUGFydGlhbFN0YXJ0LCBpbmxpbmVQYXJ0aWFsRW5kO1xuXHRcdFx0c2V0RGVsaW1pdGVycyggb3B0aW9ucyApO1xuXHRcdFx0aW5saW5lUGFydGlhbFN0YXJ0ID0gbmV3IFJlZ0V4cCggJzwhLS1cXFxccyonICsgZXNjYXBlUmVnRXhwKCBvcHRpb25zLmRlbGltaXRlcnNbIDAgXSApICsgJ1xcXFxzKj5cXFxccyooW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKVxcXFxzKicgKyBlc2NhcGVSZWdFeHAoIG9wdGlvbnMuZGVsaW1pdGVyc1sgMSBdICkgKyAnXFxcXHMqLS0+JyApO1xuXHRcdFx0aW5saW5lUGFydGlhbEVuZCA9IG5ldyBSZWdFeHAoICc8IS0tXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCggb3B0aW9ucy5kZWxpbWl0ZXJzWyAwIF0gKSArICdcXFxccypcXFxcL1xcXFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCggb3B0aW9ucy5kZWxpbWl0ZXJzWyAxIF0gKSArICdcXFxccyotLT4nICk7XG5cdFx0XHRyZXN1bHQgPSB7XG5cdFx0XHRcdHY6IDFcblx0XHRcdH07XG5cdFx0XHRpZiAoIGlubGluZVBhcnRpYWxTdGFydC50ZXN0KCB0ZW1wbGF0ZSApICkge1xuXHRcdFx0XHRyZW1haW5pbmcgPSB0ZW1wbGF0ZTtcblx0XHRcdFx0dGVtcGxhdGUgPSAnJztcblx0XHRcdFx0d2hpbGUgKCBzdGFydE1hdGNoID0gaW5saW5lUGFydGlhbFN0YXJ0LmV4ZWMoIHJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdG5hbWUgPSBzdGFydE1hdGNoWyAxIF07XG5cdFx0XHRcdFx0dGVtcGxhdGUgKz0gcmVtYWluaW5nLnN1YnN0ciggMCwgc3RhcnRNYXRjaC5pbmRleCApO1xuXHRcdFx0XHRcdHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoIHN0YXJ0TWF0Y2guaW5kZXggKyBzdGFydE1hdGNoWyAwIF0ubGVuZ3RoICk7XG5cdFx0XHRcdFx0ZW5kTWF0Y2ggPSBpbmxpbmVQYXJ0aWFsRW5kLmV4ZWMoIHJlbWFpbmluZyApO1xuXHRcdFx0XHRcdGlmICggIWVuZE1hdGNoIHx8IGVuZE1hdGNoWyAxIF0gIT09IG5hbWUgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdJbmxpbmUgcGFydGlhbHMgbXVzdCBoYXZlIGEgY2xvc2luZyBkZWxpbWl0ZXIsIGFuZCBjYW5ub3QgYmUgbmVzdGVkLiBFeHBlY3RlZCBjbG9zaW5nIGZvciBcIicgKyBuYW1lICsgJ1wiLCBidXQgJyArICggZW5kTWF0Y2ggPyAnaW5zdGVhZCBmb3VuZCBcIicgKyBlbmRNYXRjaFsgMSBdICsgJ1wiJyA6ICcgbm8gY2xvc2luZyBmb3VuZCcgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQoIHBhcnRpYWxzIHx8ICggcGFydGlhbHMgPSB7fSApIClbIG5hbWUgXSA9IG5ldyBTdGFuZGFyZFBhcnNlciggcmVtYWluaW5nLnN1YnN0ciggMCwgZW5kTWF0Y2guaW5kZXggKSwgb3B0aW9ucyApLnJlc3VsdDtcblx0XHRcdFx0XHRyZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKCBlbmRNYXRjaC5pbmRleCArIGVuZE1hdGNoWyAwIF0ubGVuZ3RoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGVtcGxhdGUgKz0gcmVtYWluaW5nO1xuXHRcdFx0XHRyZXN1bHQucCA9IHBhcnRpYWxzO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnQgPSBuZXcgU3RhbmRhcmRQYXJzZXIoIHRlbXBsYXRlLCBvcHRpb25zICkucmVzdWx0O1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gcGFyc2U7XG5cblx0XHRmdW5jdGlvbiBjbGVhbnVwKCBpdGVtcywgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZSwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlLCByZXdyaXRlRWxzZSApIHtcblx0XHRcdHZhciBpLCBpdGVtLCBwcmV2aW91c0l0ZW0sIG5leHRJdGVtLCBwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHVubGVzc0Jsb2NrLCBrZXk7XG5cdFx0XHQvLyBGaXJzdCBwYXNzIC0gcmVtb3ZlIHN0YW5kYWxvbmVzIGFuZCBjb21tZW50cyBldGNcblx0XHRcdHN0cmlwU3RhbmRhbG9uZXMoIGl0ZW1zICk7XG5cdFx0XHRpID0gaXRlbXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtc1sgaSBdO1xuXHRcdFx0XHQvLyBSZW1vdmUgZGVsaW1pdGVyIGNoYW5nZXMsIHVuc2FmZSBlbGVtZW50cyBldGNcblx0XHRcdFx0aWYgKCBpdGVtLmV4Y2x1ZGUgKSB7XG5cdFx0XHRcdFx0aXRlbXMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0cmlwQ29tbWVudHMgJiYgaXRlbS50ID09PSB0eXBlcy5DT01NRU5UICkge1xuXHRcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiBuZWNlc3NhcnksIHJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG5cdFx0XHR0cmltV2hpdGVzcGFjZSggaXRlbXMsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlLCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2UgKTtcblx0XHRcdGkgPSBpdGVtcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aXRlbSA9IGl0ZW1zWyBpIF07XG5cdFx0XHRcdC8vIFJlY3Vyc2Vcblx0XHRcdFx0aWYgKCBpdGVtLmYgKSB7XG5cdFx0XHRcdFx0cHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgfHwgaXRlbS50ID09PSB0eXBlcy5FTEVNRU5UICYmIHByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnRzLnRlc3QoIGl0ZW0uZSApO1xuXHRcdFx0XHRcdGlmICggIXByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ICkge1xuXHRcdFx0XHRcdFx0cHJldmlvdXNJdGVtID0gaXRlbXNbIGkgLSAxIF07XG5cdFx0XHRcdFx0XHRuZXh0SXRlbSA9IGl0ZW1zWyBpICsgMSBdO1xuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIHByZXZpb3VzIGl0ZW0gd2FzIGEgdGV4dCBpdGVtIHdpdGggdHJhaWxpbmcgd2hpdGVzcGFjZSxcblx0XHRcdFx0XHRcdC8vIHJlbW92ZSBsZWFkaW5nIHdoaXRlc3BhY2UgaW5zaWRlIHRoZSBmcmFnbWVudFxuXHRcdFx0XHRcdFx0aWYgKCAhcHJldmlvdXNJdGVtIHx8IHR5cGVvZiBwcmV2aW91c0l0ZW0gPT09ICdzdHJpbmcnICYmIHRyYWlsaW5nV2hpdGVzcGFjZS50ZXN0KCBwcmV2aW91c0l0ZW0gKSApIHtcblx0XHRcdFx0XHRcdFx0cmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBhbmQgdmljZSB2ZXJzYVxuXHRcdFx0XHRcdFx0aWYgKCAhbmV4dEl0ZW0gfHwgdHlwZW9mIG5leHRJdGVtID09PSAnc3RyaW5nJyAmJiBsZWFkaW5nV2hpdGVzcGFjZS50ZXN0KCBuZXh0SXRlbSApICkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNsZWFudXAoIGl0ZW0uZiwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZXdyaXRlRWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFNwbGl0IGlmLWVsc2UgYmxvY2tzIGludG8gdHdvIChhbiBpZiwgYW5kIGFuIHVubGVzcylcblx0XHRcdFx0aWYgKCBpdGVtLmwgKSB7XG5cdFx0XHRcdFx0Y2xlYW51cCggaXRlbS5sLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZXdyaXRlRWxzZSApO1xuXHRcdFx0XHRcdGlmICggcmV3cml0ZUVsc2UgKSB7XG5cdFx0XHRcdFx0XHR1bmxlc3NCbG9jayA9IHtcblx0XHRcdFx0XHRcdFx0dDogNCxcblx0XHRcdFx0XHRcdFx0bjogdHlwZXMuU0VDVElPTl9VTkxFU1MsXG5cdFx0XHRcdFx0XHRcdGY6IGl0ZW0ubFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdC8vIGNvcHkgdGhlIGNvbmRpdGlvbmFsIGJhc2VkIG9uIGl0cyB0eXBlXG5cdFx0XHRcdFx0XHRpZiAoIGl0ZW0uciApIHtcblx0XHRcdFx0XHRcdFx0dW5sZXNzQmxvY2suciA9IGl0ZW0ucjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggaXRlbS54ICkge1xuXHRcdFx0XHRcdFx0XHR1bmxlc3NCbG9jay54ID0gaXRlbS54O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBpdGVtLnJ4ICkge1xuXHRcdFx0XHRcdFx0XHR1bmxlc3NCbG9jay5yeCA9IGl0ZW0ucng7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoIGkgKyAxLCAwLCB1bmxlc3NCbG9jayApO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIGl0ZW0ubDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gQ2xlYW4gdXAgZWxlbWVudCBhdHRyaWJ1dGVzXG5cdFx0XHRcdGlmICggaXRlbS5hICkge1xuXHRcdFx0XHRcdGZvciAoIGtleSBpbiBpdGVtLmEgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGl0ZW0uYS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgdHlwZW9mIGl0ZW0uYVsga2V5IF0gIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0XHRjbGVhbnVwKCBpdGVtLmFbIGtleSBdLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZXdyaXRlRWxzZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gZmluYWwgcGFzcyAtIGZ1c2UgdGV4dCBub2RlcyB0b2dldGhlclxuXHRcdFx0aSA9IGl0ZW1zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBpdGVtc1sgaSBdID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBpdGVtc1sgaSArIDEgXSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRpdGVtc1sgaSBdID0gaXRlbXNbIGkgXSArIGl0ZW1zWyBpICsgMSBdO1xuXHRcdFx0XHRcdFx0aXRlbXMuc3BsaWNlKCBpICsgMSwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICFwcmVzZXJ2ZVdoaXRlc3BhY2UgKSB7XG5cdFx0XHRcdFx0XHRpdGVtc1sgaSBdID0gaXRlbXNbIGkgXS5yZXBsYWNlKCBjb250aWd1b3VzV2hpdGVzcGFjZSwgJyAnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggaXRlbXNbIGkgXSA9PT0gJycgKSB7XG5cdFx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXREZWxpbWl0ZXJzKCBzb3VyY2UgKSB7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gYXJndW1lbnRzWyAxIF07XG5cdFx0XHRpZiAoIHRhcmdldCA9PT0gdm9pZCAwIClcblx0XHRcdFx0dGFyZ2V0ID0gc291cmNlO1xuXHRcdFx0dGFyZ2V0LmRlbGltaXRlcnMgPSBzb3VyY2UuZGVsaW1pdGVycyB8fCBbXG5cdFx0XHRcdCd7eycsXG5cdFx0XHRcdCd9fSdcblx0XHRcdF07XG5cdFx0XHR0YXJnZXQudHJpcGxlRGVsaW1pdGVycyA9IHNvdXJjZS50cmlwbGVEZWxpbWl0ZXJzIHx8IFtcblx0XHRcdFx0J3t7eycsXG5cdFx0XHRcdCd9fX0nXG5cdFx0XHRdO1xuXHRcdFx0dGFyZ2V0LnN0YXRpY0RlbGltaXRlcnMgPSBzb3VyY2Uuc3RhdGljRGVsaW1pdGVycyB8fCBbXG5cdFx0XHRcdCdbWycsXG5cdFx0XHRcdCddXSdcblx0XHRcdF07XG5cdFx0XHR0YXJnZXQuc3RhdGljVHJpcGxlRGVsaW1pdGVycyA9IHNvdXJjZS5zdGF0aWNUcmlwbGVEZWxpbWl0ZXJzIHx8IFtcblx0XHRcdFx0J1tbWycsXG5cdFx0XHRcdCddXV0nXG5cdFx0XHRdO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHR5cGVzLCBQYXJzZXIsIG11c3RhY2hlLCBjb21tZW50LCBlbGVtZW50LCB0ZXh0LCB0cmltV2hpdGVzcGFjZSwgc3RyaXBTdGFuZGFsb25lcywgZXNjYXBlUmVnRXhwICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvZ3JvdXBzL29wdGlvbkdyb3VwLmpzICovXG5cdHZhciBvcHRpb25Hcm91cCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU9wdGlvbkdyb3VwKCBrZXlzLCBjb25maWcgKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSBrZXlzLm1hcCggY29uZmlnICk7XG5cdFx0XHRrZXlzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXksIGkgKSB7XG5cdFx0XHRcdGdyb3VwWyBrZXkgXSA9IGdyb3VwWyBpIF07XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gZ3JvdXA7XG5cdFx0fTtcblx0fSggbGVnYWN5ICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvZ3JvdXBzL3BhcnNlT3B0aW9ucy5qcyAqL1xuXHR2YXIgcGFyc2VPcHRpb25zID0gZnVuY3Rpb24oIG9wdGlvbkdyb3VwICkge1xuXG5cdFx0dmFyIGtleXMsIHBhcnNlT3B0aW9ucztcblx0XHRrZXlzID0gW1xuXHRcdFx0J3ByZXNlcnZlV2hpdGVzcGFjZScsXG5cdFx0XHQnc2FuaXRpemUnLFxuXHRcdFx0J3N0cmlwQ29tbWVudHMnLFxuXHRcdFx0J2RlbGltaXRlcnMnLFxuXHRcdFx0J3RyaXBsZURlbGltaXRlcnMnLFxuXHRcdFx0J2ludGVycG9sYXRlJ1xuXHRcdF07XG5cdFx0cGFyc2VPcHRpb25zID0gb3B0aW9uR3JvdXAoIGtleXMsIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4ga2V5O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gcGFyc2VPcHRpb25zO1xuXHR9KCBvcHRpb25Hcm91cCApO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL3RlbXBsYXRlL3BhcnNlci5qcyAqL1xuXHR2YXIgcGFyc2VyID0gZnVuY3Rpb24oIGVycm9ycywgaXNDbGllbnQsIHBhcnNlLCBjcmVhdGUsIHBhcnNlT3B0aW9ucyApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB7XG5cdFx0XHRwYXJzZTogZG9QYXJzZSxcblx0XHRcdGZyb21JZDogZnJvbUlkLFxuXHRcdFx0aXNIYXNoZWRJZDogaXNIYXNoZWRJZCxcblx0XHRcdGlzUGFyc2VkOiBpc1BhcnNlZCxcblx0XHRcdGdldFBhcnNlT3B0aW9uczogZ2V0UGFyc2VPcHRpb25zLFxuXHRcdFx0Y3JlYXRlSGVscGVyOiBjcmVhdGVIZWxwZXJcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlSGVscGVyKCBwYXJzZU9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgaGVscGVyID0gY3JlYXRlKCBwYXJzZXIgKTtcblx0XHRcdGhlbHBlci5wYXJzZSA9IGZ1bmN0aW9uKCB0ZW1wbGF0ZSwgb3B0aW9ucyApIHtcblx0XHRcdFx0cmV0dXJuIGRvUGFyc2UoIHRlbXBsYXRlLCBvcHRpb25zIHx8IHBhcnNlT3B0aW9ucyApO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBoZWxwZXI7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZG9QYXJzZSggdGVtcGxhdGUsIHBhcnNlT3B0aW9ucyApIHtcblx0XHRcdGlmICggIXBhcnNlICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGVycm9ycy5taXNzaW5nUGFyc2VyICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFyc2UoIHRlbXBsYXRlLCBwYXJzZU9wdGlvbnMgfHwgdGhpcy5vcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZnJvbUlkKCBpZCwgb3B0aW9ucyApIHtcblx0XHRcdHZhciB0ZW1wbGF0ZTtcblx0XHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDYW5ub3QgcmV0cmlldmUgdGVtcGxhdGUgIycgKyBpZCArICcgYXMgUmFjdGl2ZSBpcyBub3QgcnVubmluZyBpbiBhIGJyb3dzZXIuJyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpc0hhc2hlZElkKCBpZCApICkge1xuXHRcdFx0XHRpZCA9IGlkLnN1YnN0cmluZyggMSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhKCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBpZCApICkgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NvdWxkIG5vdCBmaW5kIHRlbXBsYXRlIGVsZW1lbnQgd2l0aCBpZCAjJyArIGlkICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRlbXBsYXRlLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ1NDUklQVCcgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RlbXBsYXRlIGVsZW1lbnQgd2l0aCBpZCAjJyArIGlkICsgJywgbXVzdCBiZSBhIDxzY3JpcHQ+IGVsZW1lbnQnICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGVtcGxhdGUuaW5uZXJIVE1MO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzSGFzaGVkSWQoIGlkICkge1xuXHRcdFx0cmV0dXJuIGlkICYmIGlkLmNoYXJBdCggMCApID09PSAnIyc7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNQYXJzZWQoIHRlbXBsYXRlICkge1xuXHRcdFx0cmV0dXJuICEoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRQYXJzZU9wdGlvbnMoIHJhY3RpdmUgKSB7XG5cdFx0XHQvLyBDb3VsZCBiZSBSYWN0aXZlIG9yIGEgQ29tcG9uZW50XG5cdFx0XHRpZiAoIHJhY3RpdmUuZGVmYXVsdHMgKSB7XG5cdFx0XHRcdHJhY3RpdmUgPSByYWN0aXZlLmRlZmF1bHRzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcnNlT3B0aW9ucy5yZWR1Y2UoIGZ1bmN0aW9uKCB2YWwsIGtleSApIHtcblx0XHRcdFx0dmFsWyBrZXkgXSA9IHJhY3RpdmVbIGtleSBdO1xuXHRcdFx0XHRyZXR1cm4gdmFsO1xuXHRcdFx0fSwge30gKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnNlcjtcblx0fSggZXJyb3JzLCBpc0NsaWVudCwgcGFyc2UsIGNyZWF0ZSwgcGFyc2VPcHRpb25zICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvdGVtcGxhdGUvdGVtcGxhdGUuanMgKi9cblx0dmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oIHBhcnNlciwgcGFyc2UgKSB7XG5cblx0XHR2YXIgdGVtcGxhdGVDb25maWcgPSB7XG5cdFx0XHRuYW1lOiAndGVtcGxhdGUnLFxuXHRcdFx0ZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHZhciB0ZW1wbGF0ZTtcblx0XHRcdFx0Ly8gb25seSBhc3NpZ24gaWYgZXhpc3RzXG5cdFx0XHRcdGlmICggJ3RlbXBsYXRlJyBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRcdHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdHByb3RvLnRlbXBsYXRlID0gdGVtcGxhdGU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHByb3RvLnRlbXBsYXRlID0gcGFyc2VJZlN0cmluZyggdGVtcGxhdGUsIHByb3RvICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aW5pdDogZnVuY3Rpb24gaW5pdCggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICkge1xuXHRcdFx0XHR2YXIgdGVtcGxhdGUsIGZuO1xuXHRcdFx0XHQvLyBUT0RPIGJlY2F1c2Ugb2YgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgd2UgbWlnaHQganVzdCBiZSBhYmxlIHRvIHVzZVxuXHRcdFx0XHQvLyByYWN0aXZlLnRlbXBsYXRlLCBhbmQgbm90IGJvdGhlciBwYXNzaW5nIHRocm91Z2ggdGhlIFBhcmVudCBvYmplY3QuXG5cdFx0XHRcdC8vIEF0IHByZXNlbnQgdGhhdCBicmVha3MgdGhlIHRlc3QgbW9ja3MnIGV4cGVjdGF0aW9uc1xuXHRcdFx0XHR0ZW1wbGF0ZSA9ICd0ZW1wbGF0ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGVtcGxhdGUgOiBQYXJlbnQucHJvdG90eXBlLnRlbXBsYXRlO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRmbiA9IHRlbXBsYXRlO1xuXHRcdFx0XHRcdHRlbXBsYXRlID0gZ2V0RHluYW1pY1RlbXBsYXRlKCByYWN0aXZlLCBmbiApO1xuXHRcdFx0XHRcdHJhY3RpdmUuX2NvbmZpZy50ZW1wbGF0ZSA9IHtcblx0XHRcdFx0XHRcdGZuOiBmbixcblx0XHRcdFx0XHRcdHJlc3VsdDogdGVtcGxhdGVcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRlbXBsYXRlID0gcGFyc2VJZlN0cmluZyggdGVtcGxhdGUsIHJhY3RpdmUgKTtcblx0XHRcdFx0Ly8gVE9ETyB0aGUgbmFtaW5nIG9mIHRoaXMgaXMgY29uZnVzaW5nIC0gcmFjdGl2ZS50ZW1wbGF0ZSByZWZlcnMgdG8gWy4uLl0sXG5cdFx0XHRcdC8vIGJ1dCBDb21wb25lbnQucHJvdG90eXBlLnRlbXBsYXRlIHJlZmVycyB0byB7djoxLHQ6W10scDpbXX0uLi5cblx0XHRcdFx0Ly8gaXQncyB1bm5lY2Vzc2FyeSwgYmVjYXVzZSB0aGUgZGV2ZWxvcGVyIG5ldmVyIG5lZWRzIHRvIGFjY2Vzc1xuXHRcdFx0XHQvLyByYWN0aXZlLnRlbXBsYXRlXG5cdFx0XHRcdHJhY3RpdmUudGVtcGxhdGUgPSB0ZW1wbGF0ZS50O1xuXHRcdFx0XHRpZiAoIHRlbXBsYXRlLnAgKSB7XG5cdFx0XHRcdFx0ZXh0ZW5kUGFydGlhbHMoIHJhY3RpdmUucGFydGlhbHMsIHRlbXBsYXRlLnAgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlc2V0OiBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHJlc2V0VmFsdWUoIHJhY3RpdmUgKSxcblx0XHRcdFx0XHRwYXJzZWQ7XG5cdFx0XHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0XHRcdHBhcnNlZCA9IHBhcnNlSWZTdHJpbmcoIHJlc3VsdCwgcmFjdGl2ZSApO1xuXHRcdFx0XHRcdHJhY3RpdmUudGVtcGxhdGUgPSBwYXJzZWQudDtcblx0XHRcdFx0XHRleHRlbmRQYXJ0aWFscyggcmFjdGl2ZS5wYXJ0aWFscywgcGFyc2VkLnAsIHRydWUgKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXNldFZhbHVlKCByYWN0aXZlICkge1xuXHRcdFx0dmFyIGluaXRpYWwgPSByYWN0aXZlLl9jb25maWcudGVtcGxhdGUsXG5cdFx0XHRcdHJlc3VsdDtcblx0XHRcdC8vIElmIHRoaXMgaXNuJ3QgYSBkeW5hbWljIHRlbXBsYXRlLCB0aGVyZSdzIG5vdGhpbmcgdG8gZG9cblx0XHRcdGlmICggIWluaXRpYWwgfHwgIWluaXRpYWwuZm4gKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHJlc3VsdCA9IGdldER5bmFtaWNUZW1wbGF0ZSggcmFjdGl2ZSwgaW5pdGlhbC5mbiApO1xuXHRcdFx0Ly8gVE9ETyBkZWVwIGVxdWFsaXR5IGNoZWNrIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmUtcmVuZGVyaW5nXG5cdFx0XHQvLyBpbiB0aGUgY2FzZSBvZiBhbHJlYWR5LXBhcnNlZCB0ZW1wbGF0ZXNcblx0XHRcdGlmICggcmVzdWx0ICE9PSBpbml0aWFsLnJlc3VsdCApIHtcblx0XHRcdFx0aW5pdGlhbC5yZXN1bHQgPSByZXN1bHQ7XG5cdFx0XHRcdHJlc3VsdCA9IHBhcnNlSWZTdHJpbmcoIHJlc3VsdCwgcmFjdGl2ZSApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldER5bmFtaWNUZW1wbGF0ZSggcmFjdGl2ZSwgZm4gKSB7XG5cdFx0XHR2YXIgaGVscGVyID0gcGFyc2VyLmNyZWF0ZUhlbHBlciggcGFyc2VyLmdldFBhcnNlT3B0aW9ucyggcmFjdGl2ZSApICk7XG5cdFx0XHRyZXR1cm4gZm4uY2FsbCggcmFjdGl2ZSwgcmFjdGl2ZS5kYXRhLCBoZWxwZXIgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUlmU3RyaW5nKCB0ZW1wbGF0ZSwgcmFjdGl2ZSApIHtcblx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0Ly8gSUQgb2YgYW4gZWxlbWVudCBjb250YWluaW5nIHRoZSB0ZW1wbGF0ZT9cblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZVsgMCBdID09PSAnIycgKSB7XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSBwYXJzZXIuZnJvbUlkKCB0ZW1wbGF0ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRlbXBsYXRlID0gcGFyc2UoIHRlbXBsYXRlLCBwYXJzZXIuZ2V0UGFyc2VPcHRpb25zKCByYWN0aXZlICkgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHRlbXBsYXRlLnYgIT09IDEgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ01pc21hdGNoZWQgdGVtcGxhdGUgdmVyc2lvbiEgUGxlYXNlIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiBSYWN0aXZlLmpzIGluIHlvdXIgYnVpbGQgcHJvY2VzcyBhcyB3ZWxsIGFzIGluIHlvdXIgYXBwJyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRlbXBsYXRlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGV4dGVuZFBhcnRpYWxzKCBleGlzdGluZ1BhcnRpYWxzLCBuZXdQYXJ0aWFscywgb3ZlcndyaXRlICkge1xuXHRcdFx0aWYgKCAhbmV3UGFydGlhbHMgKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHQvLyBUT0RPIHRoZXJlJ3MgYW4gYW1iaWd1aXR5IGhlcmUgLSB3ZSBuZWVkIHRvIG92ZXJ3cml0ZSBpbiB0aGUgYHJlc2V0KClgXG5cdFx0XHQvLyBjYXNlLCBidXQgbm90IGluaXRpYWxseS4uLlxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBuZXdQYXJ0aWFscyApIHtcblx0XHRcdFx0aWYgKCBvdmVyd3JpdGUgfHwgIWV4aXN0aW5nUGFydGlhbHMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdGV4aXN0aW5nUGFydGlhbHNbIGtleSBdID0gbmV3UGFydGlhbHNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0ZW1wbGF0ZUNvbmZpZztcblx0fSggcGFyc2VyLCBwYXJzZSApO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL1JlZ2lzdHJ5LmpzICovXG5cdHZhciBSZWdpc3RyeSA9IGZ1bmN0aW9uKCBjcmVhdGUgKSB7XG5cblx0XHRmdW5jdGlvbiBSZWdpc3RyeSggbmFtZSwgdXNlRGVmYXVsdHMgKSB7XG5cdFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdFx0dGhpcy51c2VEZWZhdWx0cyA9IHVzZURlZmF1bHRzO1xuXHRcdH1cblx0XHRSZWdpc3RyeS5wcm90b3R5cGUgPSB7XG5cdFx0XHRjb25zdHJ1Y3RvcjogUmVnaXN0cnksXG5cdFx0XHRleHRlbmQ6IGZ1bmN0aW9uKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICkge1xuXHRcdFx0XHR0aGlzLmNvbmZpZ3VyZSggdGhpcy51c2VEZWZhdWx0cyA/IFBhcmVudC5kZWZhdWx0cyA6IFBhcmVudCwgdGhpcy51c2VEZWZhdWx0cyA/IHByb3RvIDogcHJvdG8uY29uc3RydWN0b3IsIG9wdGlvbnMgKTtcblx0XHRcdH0sXG5cdFx0XHRpbml0OiBmdW5jdGlvbiggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICkge1xuXHRcdFx0XHR0aGlzLmNvbmZpZ3VyZSggdGhpcy51c2VEZWZhdWx0cyA/IFBhcmVudC5kZWZhdWx0cyA6IFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdFx0fSxcblx0XHRcdGNvbmZpZ3VyZTogZnVuY3Rpb24oIFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zICkge1xuXHRcdFx0XHR2YXIgbmFtZSA9IHRoaXMubmFtZSxcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBuYW1lIF0sXG5cdFx0XHRcdFx0cmVnaXN0cnk7XG5cdFx0XHRcdHJlZ2lzdHJ5ID0gY3JlYXRlKCBQYXJlbnRbIG5hbWUgXSApO1xuXHRcdFx0XHRmb3IgKCB2YXIga2V5IGluIG9wdGlvbiApIHtcblx0XHRcdFx0XHRyZWdpc3RyeVsga2V5IF0gPSBvcHRpb25bIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gcmVnaXN0cnk7XG5cdFx0XHR9LFxuXHRcdFx0cmVzZXQ6IGZ1bmN0aW9uKCByYWN0aXZlICkge1xuXHRcdFx0XHR2YXIgcmVnaXN0cnkgPSByYWN0aXZlWyB0aGlzLm5hbWUgXTtcblx0XHRcdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblx0XHRcdFx0T2JqZWN0LmtleXMoIHJlZ2lzdHJ5ICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgaXRlbSA9IHJlZ2lzdHJ5WyBrZXkgXTtcblx0XHRcdFx0XHRpZiAoIGl0ZW0uX2ZuICkge1xuXHRcdFx0XHRcdFx0aWYgKCBpdGVtLl9mbi5pc093bmVyICkge1xuXHRcdFx0XHRcdFx0XHRyZWdpc3RyeVsga2V5IF0gPSBpdGVtLl9mbjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSByZWdpc3RyeVsga2V5IF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZE93bmVyOiBmdW5jdGlvbiggcmFjdGl2ZSwga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gcmFjdGl2ZVsgdGhpcy5uYW1lIF0uaGFzT3duUHJvcGVydHkoIGtleSApID8gcmFjdGl2ZSA6IHRoaXMuZmluZENvbnN0cnVjdG9yKCByYWN0aXZlLmNvbnN0cnVjdG9yLCBrZXkgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kQ29uc3RydWN0b3I6IGZ1bmN0aW9uKCBjb25zdHJ1Y3Rvciwga2V5ICkge1xuXHRcdFx0XHRpZiAoICFjb25zdHJ1Y3RvciApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNvbnN0cnVjdG9yWyB0aGlzLm5hbWUgXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgPyBjb25zdHJ1Y3RvciA6IHRoaXMuZmluZENvbnN0cnVjdG9yKCBjb25zdHJ1Y3Rvci5fcGFyZW50LCBrZXkgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kOiBmdW5jdGlvbiggcmFjdGl2ZSwga2V5ICkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0cmV0dXJuIHJlY3Vyc2VGaW5kKCByYWN0aXZlLCBmdW5jdGlvbiggciApIHtcblx0XHRcdFx0XHRyZXR1cm4gclsgdGhpcyQwLm5hbWUgXVsga2V5IF07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kSW5zdGFuY2U6IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXkgKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHRyZXR1cm4gcmVjdXJzZUZpbmQoIHJhY3RpdmUsIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdHJldHVybiByWyB0aGlzJDAubmFtZSBdWyBrZXkgXSA/IHIgOiB2b2lkIDA7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVjdXJzZUZpbmQoIHJhY3RpdmUsIGZuICkge1xuXHRcdFx0dmFyIGZpbmQsIHBhcmVudDtcblx0XHRcdGlmICggZmluZCA9IGZuKCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdHJldHVybiBmaW5kO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhcmFjdGl2ZS5pc29sYXRlZCAmJiAoIHBhcmVudCA9IHJhY3RpdmUuX3BhcmVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gcmVjdXJzZUZpbmQoIHBhcmVudCwgZm4gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIFJlZ2lzdHJ5O1xuXHR9KCBjcmVhdGUsIGxlZ2FjeSApO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL2dyb3Vwcy9yZWdpc3RyaWVzLmpzICovXG5cdHZhciByZWdpc3RyaWVzID0gZnVuY3Rpb24oIG9wdGlvbkdyb3VwLCBSZWdpc3RyeSApIHtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0XHQnYWRhcHRvcnMnLFxuXHRcdFx0XHQnY29tcG9uZW50cycsXG5cdFx0XHRcdCdjb21wdXRlZCcsXG5cdFx0XHRcdCdkZWNvcmF0b3JzJyxcblx0XHRcdFx0J2Vhc2luZycsXG5cdFx0XHRcdCdldmVudHMnLFxuXHRcdFx0XHQnaW50ZXJwb2xhdG9ycycsXG5cdFx0XHRcdCdwYXJ0aWFscycsXG5cdFx0XHRcdCd0cmFuc2l0aW9ucydcblx0XHRcdF0sXG5cdFx0XHRyZWdpc3RyaWVzID0gb3B0aW9uR3JvdXAoIGtleXMsIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgUmVnaXN0cnkoIGtleSwga2V5ID09PSAnY29tcHV0ZWQnICk7XG5cdFx0XHR9ICk7XG5cdFx0cmV0dXJuIHJlZ2lzdHJpZXM7XG5cdH0oIG9wdGlvbkdyb3VwLCBSZWdpc3RyeSApO1xuXG5cdC8qIHV0aWxzL25vb3AuanMgKi9cblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qIHV0aWxzL3dyYXBQcm90b3R5cGVNZXRob2QuanMgKi9cblx0dmFyIHdyYXBQcm90b3R5cGVNZXRob2QgPSBmdW5jdGlvbiggbm9vcCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIHdyYXAoIHBhcmVudCwgbmFtZSwgbWV0aG9kICkge1xuXHRcdFx0aWYgKCAhL19zdXBlci8udGVzdCggbWV0aG9kICkgKSB7XG5cdFx0XHRcdHJldHVybiBtZXRob2Q7XG5cdFx0XHR9XG5cdFx0XHR2YXIgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBTdXBlcigpIHtcblx0XHRcdFx0dmFyIHN1cGVyTWV0aG9kID0gZ2V0U3VwZXJNZXRob2QoIHdyYXBwZXIuX3BhcmVudCwgbmFtZSApLFxuXHRcdFx0XHRcdGhhc1N1cGVyID0gJ19zdXBlcicgaW4gdGhpcyxcblx0XHRcdFx0XHRvbGRTdXBlciA9IHRoaXMuX3N1cGVyLFxuXHRcdFx0XHRcdHJlc3VsdDtcblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBzdXBlck1ldGhvZDtcblx0XHRcdFx0cmVzdWx0ID0gbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0aWYgKCBoYXNTdXBlciApIHtcblx0XHRcdFx0XHR0aGlzLl9zdXBlciA9IG9sZFN1cGVyO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9zdXBlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fTtcblx0XHRcdHdyYXBwZXIuX3BhcmVudCA9IHBhcmVudDtcblx0XHRcdHdyYXBwZXIuX21ldGhvZCA9IG1ldGhvZDtcblx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRTdXBlck1ldGhvZCggcGFyZW50LCBuYW1lICkge1xuXHRcdFx0dmFyIG1ldGhvZDtcblx0XHRcdGlmICggbmFtZSBpbiBwYXJlbnQgKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHBhcmVudFsgbmFtZSBdO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRtZXRob2QgPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtZXRob2QgPSBmdW5jdGlvbiByZXR1cm5WYWx1ZSgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZXRob2QgPSBub29wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1ldGhvZDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBub29wICk7XG5cblx0LyogY29uZmlnL2RlcHJlY2F0ZS5qcyAqL1xuXHR2YXIgZGVwcmVjYXRlID0gZnVuY3Rpb24oIHdhcm4sIGlzQXJyYXkgKSB7XG5cblx0XHRmdW5jdGlvbiBkZXByZWNhdGUoIG9wdGlvbnMsIGRlcHJlY2F0ZWQsIGNvcnJlY3QgKSB7XG5cdFx0XHRpZiAoIGRlcHJlY2F0ZWQgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCAhKCBjb3JyZWN0IGluIG9wdGlvbnMgKSApIHtcblx0XHRcdFx0XHR3YXJuKCBnZXRNZXNzYWdlKCBkZXByZWNhdGVkLCBjb3JyZWN0ICkgKTtcblx0XHRcdFx0XHRvcHRpb25zWyBjb3JyZWN0IF0gPSBvcHRpb25zWyBkZXByZWNhdGVkIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBnZXRNZXNzYWdlKCBkZXByZWNhdGVkLCBjb3JyZWN0LCB0cnVlICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldE1lc3NhZ2UoIGRlcHJlY2F0ZWQsIGNvcnJlY3QsIGlzRXJyb3IgKSB7XG5cdFx0XHRyZXR1cm4gJ29wdGlvbnMuJyArIGRlcHJlY2F0ZWQgKyAnIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIG9wdGlvbnMuJyArIGNvcnJlY3QgKyAnLicgKyAoIGlzRXJyb3IgPyAnIFlvdSBjYW5ub3Qgc3BlY2lmeSBib3RoIG9wdGlvbnMsIHBsZWFzZSB1c2Ugb3B0aW9ucy4nICsgY29ycmVjdCArICcuJyA6ICcnICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVwcmVjYXRlRXZlbnREZWZpbml0aW9ucyggb3B0aW9ucyApIHtcblx0XHRcdGRlcHJlY2F0ZSggb3B0aW9ucywgJ2V2ZW50RGVmaW5pdGlvbnMnLCAnZXZlbnRzJyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlcHJlY2F0ZUFkYXB0b3JzKCBvcHRpb25zICkge1xuXHRcdFx0Ly8gVXNpbmcgZXh0ZW5kIHdpdGggQ29tcG9uZW50IGluc3RlYWQgb2Ygb3B0aW9ucyxcblx0XHRcdC8vIGxpa2UgSHVtYW4uZXh0ZW5kKCBTcGlkZXIgKSBtZWFucyBhZGFwdG9ycyBhcyBhIHJlZ2lzdHJ5XG5cdFx0XHQvLyBnZXRzIGNvcGllZCB0byBvcHRpb25zLiBTbyB3ZSBoYXZlIHRvIGNoZWNrIGlmIGFjdHVhbGx5IGFuIGFycmF5XG5cdFx0XHRpZiAoIGlzQXJyYXkoIG9wdGlvbnMuYWRhcHRvcnMgKSApIHtcblx0XHRcdFx0ZGVwcmVjYXRlKCBvcHRpb25zLCAnYWRhcHRvcnMnLCAnYWRhcHQnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmdW5jdGlvbiBkZXByZWNhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHRcdFx0ZGVwcmVjYXRlKCBvcHRpb25zLCAnYmVmb3JlSW5pdCcsICdvbmNvbnN0cnVjdCcgKTtcblx0XHRcdGRlcHJlY2F0ZSggb3B0aW9ucywgJ2luaXQnLCAnb25yZW5kZXInICk7XG5cdFx0XHRkZXByZWNhdGUoIG9wdGlvbnMsICdjb21wbGV0ZScsICdvbmNvbXBsZXRlJyApO1xuXHRcdFx0ZGVwcmVjYXRlRXZlbnREZWZpbml0aW9ucyggb3B0aW9ucyApO1xuXHRcdFx0ZGVwcmVjYXRlQWRhcHRvcnMoIG9wdGlvbnMgKTtcblx0XHR9O1xuXHR9KCB3YXJuLCBpc0FycmF5ICk7XG5cblx0LyogY29uZmlnL2NvbmZpZy5qcyAqL1xuXHR2YXIgY29uZmlnID0gZnVuY3Rpb24oIGNzcywgZGF0YSwgZGVmYXVsdHMsIHRlbXBsYXRlLCBwYXJzZU9wdGlvbnMsIHJlZ2lzdHJpZXMsIHdyYXBQcm90b3R5cGUsIGRlcHJlY2F0ZSApIHtcblxuXHRcdHZhciBjdXN0b20sIG9wdGlvbnMsIGNvbmZpZywgYmxhY2tsaXN0ZWQ7XG5cdFx0Ly8gd291bGQgYmUgbmljZSB0byBub3QgaGF2ZSB0aGVzZSBoZXJlLFxuXHRcdC8vIHRoZXkgZ2V0IGFkZGVkIGR1cmluZyBpbml0aWFsaXNlLCBzbyBmb3Igbm93IHdlIGhhdmVcblx0XHQvLyB0byBtYWtlIHN1cmUgbm90IHRvIHRyeSBhbmQgZXh0ZW5kIHRoZW0uXG5cdFx0Ly8gUG9zc2libHksIHdlIGNvdWxkIHJlLW9yZGVyIGFuZCBub3QgYWRkIHRpbGwgbGF0ZXJcblx0XHQvLyBpbiBwcm9jZXNzLlxuXHRcdGJsYWNrbGlzdGVkID0ge1xuXHRcdFx0J19wYXJlbnQnOiB0cnVlLFxuXHRcdFx0J19jb21wb25lbnQnOiB0cnVlXG5cdFx0fTtcblx0XHRjdXN0b20gPSB7XG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuXHRcdFx0Y3NzOiBjc3Ncblx0XHR9O1xuXHRcdG9wdGlvbnMgPSBPYmplY3Qua2V5cyggZGVmYXVsdHMgKS5maWx0ZXIoIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4gIXJlZ2lzdHJpZXNbIGtleSBdICYmICFjdXN0b21bIGtleSBdICYmICFwYXJzZU9wdGlvbnNbIGtleSBdO1xuXHRcdH0gKTtcblx0XHQvLyB0aGlzIGRlZmluZXMgdGhlIG9yZGVyOlxuXHRcdGNvbmZpZyA9IFtdLmNvbmNhdCggY3VzdG9tLmRhdGEsIHBhcnNlT3B0aW9ucywgb3B0aW9ucywgcmVnaXN0cmllcywgY3VzdG9tLnRlbXBsYXRlLCBjdXN0b20uY3NzICk7XG5cdFx0Zm9yICggdmFyIGtleSBpbiBjdXN0b20gKSB7XG5cdFx0XHRjb25maWdbIGtleSBdID0gY3VzdG9tWyBrZXkgXTtcblx0XHR9XG5cdFx0Ly8gZm9yIGl0ZXJhdGlvblxuXHRcdGNvbmZpZy5rZXlzID0gT2JqZWN0LmtleXMoIGRlZmF1bHRzICkuY29uY2F0KCByZWdpc3RyaWVzLm1hcCggZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRyZXR1cm4gci5uYW1lO1xuXHRcdH0gKSApLmNvbmNhdCggWyAnY3NzJyBdICk7XG5cdFx0Ly8gYWRkIHRoZXNlIHRvIGJsYWNrbGlzdGVkIGtleSdzIHRoYXQgd2UgZG9uJ3QgZG91YmxlIGV4dGVuZFxuXHRcdGNvbmZpZy5rZXlzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4gYmxhY2tsaXN0ZWRbIGtleSBdID0gdHJ1ZTtcblx0XHR9ICk7XG5cdFx0Y29uZmlnLnBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9ucztcblx0XHRjb25maWcucmVnaXN0cmllcyA9IHJlZ2lzdHJpZXM7XG5cblx0XHRmdW5jdGlvbiBjdXN0b21Db25maWcoIG1ldGhvZCwga2V5LCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICkge1xuXHRcdFx0Y3VzdG9tWyBrZXkgXVsgbWV0aG9kIF0oIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHR9XG5cdFx0Y29uZmlnLmV4dGVuZCA9IGZ1bmN0aW9uKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICkge1xuXHRcdFx0Y29uZmlndXJlKCAnZXh0ZW5kJywgUGFyZW50LCBwcm90bywgb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0Y29uZmlnLmluaXQgPSBmdW5jdGlvbiggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICkge1xuXHRcdFx0Y29uZmlndXJlKCAnaW5pdCcsIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpc1N0YW5kYXJkRGVmYXVsdEtleSgga2V5ICkge1xuXHRcdFx0cmV0dXJuIGtleSBpbiBkZWZhdWx0cyAmJiAhKCBrZXkgaW4gY29uZmlnLnBhcnNlT3B0aW9ucyApICYmICEoIGtleSBpbiBjdXN0b20gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb25maWd1cmUoIG1ldGhvZCwgUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApIHtcblx0XHRcdGRlcHJlY2F0ZSggb3B0aW9ucyApO1xuXHRcdFx0Y3VzdG9tQ29uZmlnKCBtZXRob2QsICdkYXRhJywgUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApO1xuXHRcdFx0Y29uZmlnLnBhcnNlT3B0aW9ucy5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRpZiAoIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRcdGluc3RhbmNlWyBrZXkgXSA9IG9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGlmICggaXNTdGFuZGFyZERlZmF1bHRLZXkoIGtleSApICkge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IG9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHRcdGluc3RhbmNlWyBrZXkgXSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBQcm90b3R5cGUoIFBhcmVudC5wcm90b3R5cGUsIGtleSwgdmFsdWUgKSA6IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjb25maWcucmVnaXN0cmllcy5mb3JFYWNoKCBmdW5jdGlvbiggcmVnaXN0cnkgKSB7XG5cdFx0XHRcdHJlZ2lzdHJ5WyBtZXRob2QgXSggUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApO1xuXHRcdFx0fSApO1xuXHRcdFx0Y3VzdG9tQ29uZmlnKCBtZXRob2QsICd0ZW1wbGF0ZScsIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHRcdGN1c3RvbUNvbmZpZyggbWV0aG9kLCAnY3NzJywgUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApO1xuXHRcdFx0ZXh0ZW5kT3RoZXJNZXRob2RzKCBQYXJlbnQucHJvdG90eXBlLCBpbnN0YW5jZSwgb3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGV4dGVuZE90aGVyTWV0aG9kcyggcGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApIHtcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCAhKCBrZXkgaW4gYmxhY2tsaXN0ZWQgKSAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHR2YXIgbWVtYmVyID0gb3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdFx0Ly8gaWYgdGhpcyBpcyBhIG1ldGhvZCB0aGF0IG92ZXJ3cml0ZXMgYSBtZXRob2QsIHdyYXAgaXQ6XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgbWVtYmVyID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0bWVtYmVyID0gd3JhcFByb3RvdHlwZSggcGFyZW50LCBrZXksIG1lbWJlciApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpbnN0YW5jZVsga2V5IF0gPSBtZW1iZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uZmlnLnJlc2V0ID0gZnVuY3Rpb24oIHJhY3RpdmUgKSB7XG5cdFx0XHRyZXR1cm4gY29uZmlnLmZpbHRlciggZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHRcdHJldHVybiBjLnJlc2V0ICYmIGMucmVzZXQoIHJhY3RpdmUgKTtcblx0XHRcdH0gKS5tYXAoIGZ1bmN0aW9uKCBjICkge1xuXHRcdFx0XHRyZXR1cm4gYy5uYW1lO1xuXHRcdFx0fSApO1xuXHRcdH07XG5cdFx0Y29uZmlnLmdldENvbnN0cnVjdFRhcmdldCA9IGZ1bmN0aW9uKCByYWN0aXZlLCBvcHRpb25zICkge1xuXHRcdFx0aWYgKCBvcHRpb25zLm9uY29uc3RydWN0ICkge1xuXHRcdFx0XHQvLyBwcmV0ZW5kIHRoaXMgb2JqZWN0IGxpdGVyYWwgaXMgdGhlIHJhY3RpdmUgaW5zdGFuY2Vcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRvbmNvbnN0cnVjdDogd3JhcFByb3RvdHlwZSggcmFjdGl2ZSwgJ29uY29uc3RydWN0Jywgb3B0aW9ucy5vbmNvbnN0cnVjdCApLmJpbmQoIHJhY3RpdmUgKSxcblx0XHRcdFx0XHRmaXJlOiByYWN0aXZlLmZpcmUuYmluZCggcmFjdGl2ZSApXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcmFjdGl2ZTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBjb25maWc7XG5cdH0oIGNzcywgZGF0YSwgb3B0aW9ucywgdGVtcGxhdGUsIHBhcnNlT3B0aW9ucywgcmVnaXN0cmllcywgd3JhcFByb3RvdHlwZU1ldGhvZCwgZGVwcmVjYXRlICk7XG5cblx0Lyogc2hhcmVkL2ludGVycG9sYXRlLmpzICovXG5cdHZhciBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgd2FybiwgaW50ZXJwb2xhdG9ycywgY29uZmlnICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKCBmcm9tLCB0bywgcmFjdGl2ZSwgdHlwZSApIHtcblx0XHRcdGlmICggZnJvbSA9PT0gdG8gKSB7XG5cdFx0XHRcdHJldHVybiBzbmFwKCB0byApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlICkge1xuXHRcdFx0XHR2YXIgaW50ZXJwb2wgPSBjb25maWcucmVnaXN0cmllcy5pbnRlcnBvbGF0b3JzLmZpbmQoIHJhY3RpdmUsIHR5cGUgKTtcblx0XHRcdFx0aWYgKCBpbnRlcnBvbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gaW50ZXJwb2woIGZyb20sIHRvICkgfHwgc25hcCggdG8gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR3YXJuKCAnTWlzc2luZyBcIicgKyB0eXBlICsgJ1wiIGludGVycG9sYXRvci4gWW91IG1heSBuZWVkIHRvIGRvd25sb2FkIGEgcGx1Z2luIGZyb20gW1RPRE9dJyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGludGVycG9sYXRvcnMubnVtYmVyKCBmcm9tLCB0byApIHx8IGludGVycG9sYXRvcnMuYXJyYXkoIGZyb20sIHRvICkgfHwgaW50ZXJwb2xhdG9ycy5vYmplY3QoIGZyb20sIHRvICkgfHwgc25hcCggdG8gKTtcblx0XHR9O1xuXHRcdGNpcmN1bGFyLmludGVycG9sYXRlID0gaW50ZXJwb2xhdGU7XG5cdFx0X19leHBvcnQgPSBpbnRlcnBvbGF0ZTtcblxuXHRcdGZ1bmN0aW9uIHNuYXAoIHRvICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdG87XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGNpcmN1bGFyLCB3YXJuLCBpbnRlcnBvbGF0b3JzLCBjb25maWcgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9hbmltYXRlL0FuaW1hdGlvbi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRhbmltYXRlX0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCB3YXJuLCBydW5sb29wLCBpbnRlcnBvbGF0ZSApIHtcblxuXHRcdHZhciBBbmltYXRpb24gPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHZhciBrZXk7XG5cdFx0XHR0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cdFx0XHQvLyBmcm9tIGFuZCB0b1xuXHRcdFx0Zm9yICgga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0dGhpc1sga2V5IF0gPSBvcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5pbnRlcnBvbGF0b3IgPSBpbnRlcnBvbGF0ZSggdGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLnJvb3QsIHRoaXMuaW50ZXJwb2xhdG9yICk7XG5cdFx0XHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXHRcdFx0dGhpcy50aWNrKCk7XG5cdFx0fTtcblx0XHRBbmltYXRpb24ucHJvdG90eXBlID0ge1xuXHRcdFx0dGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGFwc2VkLCB0LCB2YWx1ZSwgdGltZU5vdywgaW5kZXgsIGtleXBhdGg7XG5cdFx0XHRcdGtleXBhdGggPSB0aGlzLmtleXBhdGg7XG5cdFx0XHRcdGlmICggdGhpcy5ydW5uaW5nICkge1xuXHRcdFx0XHRcdHRpbWVOb3cgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRcdGVsYXBzZWQgPSB0aW1lTm93IC0gdGhpcy5zdGFydFRpbWU7XG5cdFx0XHRcdFx0aWYgKCBlbGFwc2VkID49IHRoaXMuZHVyYXRpb24gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGtleXBhdGggIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHRoaXMucm9vdCApO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCgga2V5cGF0aCwgdGhpcy50byApO1xuXHRcdFx0XHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLnN0ZXAgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RlcCggMSwgdGhpcy50byApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5jb21wbGV0ZSggdGhpcy50byApO1xuXHRcdFx0XHRcdFx0aW5kZXggPSB0aGlzLnJvb3QuX2FuaW1hdGlvbnMuaW5kZXhPZiggdGhpcyApO1xuXHRcdFx0XHRcdFx0Ly8gVE9ETyBpbnZlc3RpZ2F0ZSB3aHkgdGhpcyBoYXBwZW5zXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0d2FybiggJ0FuaW1hdGlvbiB3YXMgbm90IGZvdW5kJyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5yb290Ll9hbmltYXRpb25zLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ID0gdGhpcy5lYXNpbmcgPyB0aGlzLmVhc2luZyggZWxhcHNlZCAvIHRoaXMuZHVyYXRpb24gKSA6IGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uO1xuXHRcdFx0XHRcdGlmICgga2V5cGF0aCAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gdGhpcy5pbnRlcnBvbGF0b3IoIHQgKTtcblx0XHRcdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHRoaXMucm9vdCApO1xuXHRcdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHRoaXMuc3RlcCApIHtcblx0XHRcdFx0XHRcdHRoaXMuc3RlcCggdCwgdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0XHRpbmRleCA9IHRoaXMucm9vdC5fYW5pbWF0aW9ucy5pbmRleE9mKCB0aGlzICk7XG5cdFx0XHRcdC8vIFRPRE8gaW52ZXN0aWdhdGUgd2h5IHRoaXMgaGFwcGVuc1xuXHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHR3YXJuKCAnQW5pbWF0aW9uIHdhcyBub3QgZm91bmQnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5yb290Ll9hbmltYXRpb25zLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBBbmltYXRpb247XG5cdH0oIHdhcm4sIHJ1bmxvb3AsIGludGVycG9sYXRlICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvYW5pbWF0ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRhbmltYXRlID0gZnVuY3Rpb24oIGlzRXF1YWwsIFByb21pc2UsIG5vcm1hbGlzZUtleXBhdGgsIGFuaW1hdGlvbnMsIEFuaW1hdGlvbiApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge30sXG5cdFx0XHRub0FuaW1hdGlvbiA9IHtcblx0XHRcdFx0c3RvcDogbm9vcFxuXHRcdFx0fTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFJhY3RpdmUkYW5pbWF0ZSgga2V5cGF0aCwgdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgcHJvbWlzZSwgZnVsZmlsUHJvbWlzZSwgaywgYW5pbWF0aW9uLCBhbmltYXRpb25zLCBlYXNpbmcsIGR1cmF0aW9uLCBzdGVwLCBjb21wbGV0ZSwgbWFrZVZhbHVlQ29sbGVjdG9yLCBjdXJyZW50VmFsdWVzLCBjb2xsZWN0VmFsdWUsIGR1bW15LCBkdW1teU9wdGlvbnM7XG5cdFx0XHRwcm9taXNlID0gbmV3IFByb21pc2UoIGZ1bmN0aW9uKCBmdWxmaWwgKSB7XG5cdFx0XHRcdGZ1bGZpbFByb21pc2UgPSBmdWxmaWw7XG5cdFx0XHR9ICk7XG5cdFx0XHQvLyBhbmltYXRlIG11bHRpcGxlIGtleXBhdGhzXG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoID09PSAnb2JqZWN0JyApIHtcblx0XHRcdFx0b3B0aW9ucyA9IHRvIHx8IHt9O1xuXHRcdFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcblx0XHRcdFx0ZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuXHRcdFx0XHRhbmltYXRpb25zID0gW107XG5cdFx0XHRcdC8vIHdlIGRvbid0IHdhbnQgdG8gcGFzcyB0aGUgYHN0ZXBgIGFuZCBgY29tcGxldGVgIGhhbmRsZXJzLCBhcyB0aGV5IHdpbGxcblx0XHRcdFx0Ly8gcnVuIGZvciBlYWNoIGFuaW1hdGlvbiEgU28gaW5zdGVhZCB3ZSdsbCBzdG9yZSB0aGUgaGFuZGxlcnMgYW5kIGNyZWF0ZVxuXHRcdFx0XHQvLyBvdXIgb3duLi4uXG5cdFx0XHRcdHN0ZXAgPSBvcHRpb25zLnN0ZXA7XG5cdFx0XHRcdGNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcblx0XHRcdFx0aWYgKCBzdGVwIHx8IGNvbXBsZXRlICkge1xuXHRcdFx0XHRcdGN1cnJlbnRWYWx1ZXMgPSB7fTtcblx0XHRcdFx0XHRvcHRpb25zLnN0ZXAgPSBudWxsO1xuXHRcdFx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBudWxsO1xuXHRcdFx0XHRcdG1ha2VWYWx1ZUNvbGxlY3RvciA9IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB0LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudFZhbHVlc1sga2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggayBpbiBrZXlwYXRoICkge1xuXHRcdFx0XHRcdGlmICgga2V5cGF0aC5oYXNPd25Qcm9wZXJ0eSggayApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGVwIHx8IGNvbXBsZXRlICkge1xuXHRcdFx0XHRcdFx0XHRjb2xsZWN0VmFsdWUgPSBtYWtlVmFsdWVDb2xsZWN0b3IoIGsgKTtcblx0XHRcdFx0XHRcdFx0b3B0aW9ucyA9IHtcblx0XHRcdFx0XHRcdFx0XHRlYXNpbmc6IGVhc2luZyxcblx0XHRcdFx0XHRcdFx0XHRkdXJhdGlvbjogZHVyYXRpb25cblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0aWYgKCBzdGVwICkge1xuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMuc3RlcCA9IGNvbGxlY3RWYWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGNvbXBsZXRlID8gY29sbGVjdFZhbHVlIDogbm9vcDtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbnMucHVzaCggYW5pbWF0ZSggdGhpcywgaywga2V5cGF0aFsgayBdLCBvcHRpb25zICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gQ3JlYXRlIGEgZHVtbXkgYW5pbWF0aW9uLCB0byBmYWNpbGl0YXRlIHN0ZXAvY29tcGxldGVcblx0XHRcdFx0Ly8gY2FsbGJhY2tzLCBhbmQgUHJvbWlzZSBmdWxmaWxtZW50XG5cdFx0XHRcdGR1bW15T3B0aW9ucyA9IHtcblx0XHRcdFx0XHRlYXNpbmc6IGVhc2luZyxcblx0XHRcdFx0XHRkdXJhdGlvbjogZHVyYXRpb25cblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCBzdGVwICkge1xuXHRcdFx0XHRcdGR1bW15T3B0aW9ucy5zdGVwID0gZnVuY3Rpb24oIHQgKSB7XG5cdFx0XHRcdFx0XHRzdGVwKCB0LCBjdXJyZW50VmFsdWVzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNvbXBsZXRlICkge1xuXHRcdFx0XHRcdHByb21pc2UudGhlbiggZnVuY3Rpb24oIHQgKSB7XG5cdFx0XHRcdFx0XHRjb21wbGV0ZSggdCwgY3VycmVudFZhbHVlcyApO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkdW1teU9wdGlvbnMuY29tcGxldGUgPSBmdWxmaWxQcm9taXNlO1xuXHRcdFx0XHRkdW1teSA9IGFuaW1hdGUoIHRoaXMsIG51bGwsIG51bGwsIGR1bW15T3B0aW9ucyApO1xuXHRcdFx0XHRhbmltYXRpb25zLnB1c2goIGR1bW15ICk7XG5cdFx0XHRcdHByb21pc2Uuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBhbmltYXRpb247XG5cdFx0XHRcdFx0d2hpbGUgKCBhbmltYXRpb24gPSBhbmltYXRpb25zLnBvcCgpICkge1xuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBkdW1teSApIHtcblx0XHRcdFx0XHRcdGR1bW15LnN0b3AoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYW5pbWF0ZSBhIHNpbmdsZSBrZXlwYXRoXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGlmICggb3B0aW9ucy5jb21wbGV0ZSApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBvcHRpb25zLmNvbXBsZXRlICk7XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gZnVsZmlsUHJvbWlzZTtcblx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGUoIHRoaXMsIGtleXBhdGgsIHRvLCBvcHRpb25zICk7XG5cdFx0XHRwcm9taXNlLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gYW5pbWF0ZSggcm9vdCwga2V5cGF0aCwgdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgZWFzaW5nLCBkdXJhdGlvbiwgYW5pbWF0aW9uLCBmcm9tO1xuXHRcdFx0aWYgKCBrZXlwYXRoICkge1xuXHRcdFx0XHRrZXlwYXRoID0gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBrZXlwYXRoICE9PSBudWxsICkge1xuXHRcdFx0XHRmcm9tID0gcm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjYW5jZWwgYW55IGV4aXN0aW5nIGFuaW1hdGlvblxuXHRcdFx0Ly8gVE9ETyB3aGF0IGFib3V0IHVwc3RyZWFtL2Rvd25zdHJlYW0ga2V5cGF0aHM/XG5cdFx0XHRhbmltYXRpb25zLmFib3J0KCBrZXlwYXRoLCByb290ICk7XG5cdFx0XHQvLyBkb24ndCBib3RoZXIgYW5pbWF0aW5nIHZhbHVlcyB0aGF0IHN0YXkgdGhlIHNhbWVcblx0XHRcdGlmICggaXNFcXVhbCggZnJvbSwgdG8gKSApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmNvbXBsZXRlICkge1xuXHRcdFx0XHRcdG9wdGlvbnMuY29tcGxldGUoIG9wdGlvbnMudG8gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbm9BbmltYXRpb247XG5cdFx0XHR9XG5cdFx0XHQvLyBlYXNpbmcgZnVuY3Rpb25cblx0XHRcdGlmICggb3B0aW9ucy5lYXNpbmcgKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVhc2luZyA9IHJvb3QuZWFzaW5nWyBvcHRpb25zLmVhc2luZyBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdHlwZW9mIGVhc2luZyAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRlYXNpbmcgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBkdXJhdGlvblxuXHRcdFx0ZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID09PSB1bmRlZmluZWQgPyA0MDAgOiBvcHRpb25zLmR1cmF0aW9uO1xuXHRcdFx0Ly8gVE9ETyBzdG9yZSBrZXlzLCB1c2UgYW4gaW50ZXJuYWwgc2V0IG1ldGhvZFxuXHRcdFx0YW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbigge1xuXHRcdFx0XHRrZXlwYXRoOiBrZXlwYXRoLFxuXHRcdFx0XHRmcm9tOiBmcm9tLFxuXHRcdFx0XHR0bzogdG8sXG5cdFx0XHRcdHJvb3Q6IHJvb3QsXG5cdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcblx0XHRcdFx0ZWFzaW5nOiBlYXNpbmcsXG5cdFx0XHRcdGludGVycG9sYXRvcjogb3B0aW9ucy5pbnRlcnBvbGF0b3IsXG5cdFx0XHRcdC8vIFRPRE8gd3JhcCBjYWxsYmFja3MgaWYgbmVjZXNzYXJ5LCB0byB1c2UgaW5zdGFuY2UgYXMgY29udGV4dFxuXHRcdFx0XHRzdGVwOiBvcHRpb25zLnN0ZXAsXG5cdFx0XHRcdGNvbXBsZXRlOiBvcHRpb25zLmNvbXBsZXRlXG5cdFx0XHR9ICk7XG5cdFx0XHRhbmltYXRpb25zLmFkZCggYW5pbWF0aW9uICk7XG5cdFx0XHRyb290Ll9hbmltYXRpb25zLnB1c2goIGFuaW1hdGlvbiApO1xuXHRcdFx0cmV0dXJuIGFuaW1hdGlvbjtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBpc0VxdWFsLCBQcm9taXNlLCBub3JtYWxpc2VLZXlwYXRoLCBhbmltYXRpb25zLCBSYWN0aXZlJGFuaW1hdGVfQW5pbWF0aW9uICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZGV0YWNoLmpzICovXG5cdHZhciBSYWN0aXZlJGRldGFjaCA9IGZ1bmN0aW9uKCBIb29rLCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgZGV0YWNoSG9vayA9IG5ldyBIb29rKCAnZGV0YWNoJyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGRldGFjaCgpIHtcblx0XHRcdGlmICggdGhpcy5kZXRhY2hlZCApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZGV0YWNoZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZWwgKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZGV0YWNoZWQgPSB0aGlzLmZyYWdtZW50LmRldGFjaCgpO1xuXHRcdFx0ZGV0YWNoSG9vay5maXJlKCB0aGlzICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kZXRhY2hlZDtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciBSYWN0aXZlJGZpbmQgPSBmdW5jdGlvbiBSYWN0aXZlJGZpbmQoIHNlbGVjdG9yICkge1xuXHRcdGlmICggIXRoaXMuZWwgKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0fTtcblxuXHQvKiB1dGlscy9tYXRjaGVzLmpzICovXG5cdHZhciBtYXRjaGVzID0gZnVuY3Rpb24oIGlzQ2xpZW50LCB2ZW5kb3JzLCBjcmVhdGVFbGVtZW50ICkge1xuXG5cdFx0dmFyIG1hdGNoZXMsIGRpdiwgbWV0aG9kTmFtZXMsIHVucHJlZml4ZWQsIHByZWZpeGVkLCBpLCBqLCBtYWtlRnVuY3Rpb247XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRtYXRjaGVzID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGl2ID0gY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0XHRcdG1ldGhvZE5hbWVzID0gW1xuXHRcdFx0XHQnbWF0Y2hlcycsXG5cdFx0XHRcdCdtYXRjaGVzU2VsZWN0b3InXG5cdFx0XHRdO1xuXHRcdFx0bWFrZUZ1bmN0aW9uID0gZnVuY3Rpb24oIG1ldGhvZE5hbWUgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggbm9kZSwgc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGVbIG1ldGhvZE5hbWUgXSggc2VsZWN0b3IgKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRpID0gbWV0aG9kTmFtZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gJiYgIW1hdGNoZXMgKSB7XG5cdFx0XHRcdHVucHJlZml4ZWQgPSBtZXRob2ROYW1lc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGRpdlsgdW5wcmVmaXhlZCBdICkge1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBtYWtlRnVuY3Rpb24oIHVucHJlZml4ZWQgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRqID0gdmVuZG9ycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0XHRwcmVmaXhlZCA9IHZlbmRvcnNbIGkgXSArIHVucHJlZml4ZWQuc3Vic3RyKCAwLCAxICkudG9VcHBlckNhc2UoKSArIHVucHJlZml4ZWQuc3Vic3RyaW5nKCAxICk7XG5cdFx0XHRcdFx0XHRpZiAoIGRpdlsgcHJlZml4ZWQgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcyA9IG1ha2VGdW5jdGlvbiggcHJlZml4ZWQgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBJRTguLi5cblx0XHRcdGlmICggIW1hdGNoZXMgKSB7XG5cdFx0XHRcdG1hdGNoZXMgPSBmdW5jdGlvbiggbm9kZSwgc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0dmFyIG5vZGVzLCBwYXJlbnROb2RlLCBpO1xuXHRcdFx0XHRcdHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0aWYgKCAhcGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdC8vIGVtcHR5IGR1bW15IDxkaXY+XG5cdFx0XHRcdFx0XHRkaXYuaW5uZXJIVE1MID0gJyc7XG5cdFx0XHRcdFx0XHRwYXJlbnROb2RlID0gZGl2O1xuXHRcdFx0XHRcdFx0bm9kZSA9IG5vZGUuY2xvbmVOb2RlKCk7XG5cdFx0XHRcdFx0XHRkaXYuYXBwZW5kQ2hpbGQoIG5vZGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bm9kZXMgPSBwYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IG5vZGVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggbm9kZXNbIGkgXSA9PT0gbm9kZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0oIGlzQ2xpZW50LCB2ZW5kb3JzLCBjcmVhdGVFbGVtZW50ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS90ZXN0LmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfdGVzdCA9IGZ1bmN0aW9uKCBtYXRjaGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBpdGVtLCBub0RpcnR5ICkge1xuXHRcdFx0dmFyIGl0ZW1NYXRjaGVzID0gdGhpcy5faXNDb21wb25lbnRRdWVyeSA/ICF0aGlzLnNlbGVjdG9yIHx8IGl0ZW0ubmFtZSA9PT0gdGhpcy5zZWxlY3RvciA6IG1hdGNoZXMoIGl0ZW0ubm9kZSwgdGhpcy5zZWxlY3RvciApO1xuXHRcdFx0aWYgKCBpdGVtTWF0Y2hlcyApIHtcblx0XHRcdFx0dGhpcy5wdXNoKCBpdGVtLm5vZGUgfHwgaXRlbS5pbnN0YW5jZSApO1xuXHRcdFx0XHRpZiAoICFub0RpcnR5ICkge1xuXHRcdFx0XHRcdHRoaXMuX21ha2VEaXJ0eSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIG1hdGNoZXMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L2NhbmNlbC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X2NhbmNlbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsaXZlUXVlcmllcywgc2VsZWN0b3IsIGluZGV4O1xuXHRcdGxpdmVRdWVyaWVzID0gdGhpcy5fcm9vdFsgdGhpcy5faXNDb21wb25lbnRRdWVyeSA/ICdsaXZlQ29tcG9uZW50UXVlcmllcycgOiAnbGl2ZVF1ZXJpZXMnIF07XG5cdFx0c2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuXHRcdGluZGV4ID0gbGl2ZVF1ZXJpZXMuaW5kZXhPZiggc2VsZWN0b3IgKTtcblx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdGxpdmVRdWVyaWVzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdGxpdmVRdWVyaWVzWyBzZWxlY3RvciBdID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9zb3J0QnlJdGVtUG9zaXRpb24uanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlJdGVtUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFuY2VzdHJ5QSwgYW5jZXN0cnlCLCBvbGRlc3RBLCBvbGRlc3RCLCBtdXR1YWxBbmNlc3RvciwgaW5kZXhBLCBpbmRleEIsIGZyYWdtZW50cywgZnJhZ21lbnRBLCBmcmFnbWVudEI7XG5cdFx0XHRhbmNlc3RyeUEgPSBnZXRBbmNlc3RyeSggYS5jb21wb25lbnQgfHwgYS5fcmFjdGl2ZS5wcm94eSApO1xuXHRcdFx0YW5jZXN0cnlCID0gZ2V0QW5jZXN0cnkoIGIuY29tcG9uZW50IHx8IGIuX3JhY3RpdmUucHJveHkgKTtcblx0XHRcdG9sZGVzdEEgPSBhbmNlc3RyeUFbIGFuY2VzdHJ5QS5sZW5ndGggLSAxIF07XG5cdFx0XHRvbGRlc3RCID0gYW5jZXN0cnlCWyBhbmNlc3RyeUIubGVuZ3RoIC0gMSBdO1xuXHRcdFx0Ly8gcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIGVuZCBvZiBib3RoIGFuY2VzdHJpZXMgYXMgbG9uZyBhcyB0aGV5IGFyZSBpZGVudGljYWxcblx0XHRcdC8vIC0gdGhlIGZpbmFsIG9uZSByZW1vdmVkIGlzIHRoZSBjbG9zZXN0IG11dHVhbCBhbmNlc3RvclxuXHRcdFx0d2hpbGUgKCBvbGRlc3RBICYmIG9sZGVzdEEgPT09IG9sZGVzdEIgKSB7XG5cdFx0XHRcdGFuY2VzdHJ5QS5wb3AoKTtcblx0XHRcdFx0YW5jZXN0cnlCLnBvcCgpO1xuXHRcdFx0XHRtdXR1YWxBbmNlc3RvciA9IG9sZGVzdEE7XG5cdFx0XHRcdG9sZGVzdEEgPSBhbmNlc3RyeUFbIGFuY2VzdHJ5QS5sZW5ndGggLSAxIF07XG5cdFx0XHRcdG9sZGVzdEIgPSBhbmNlc3RyeUJbIGFuY2VzdHJ5Qi5sZW5ndGggLSAxIF07XG5cdFx0XHR9XG5cdFx0XHQvLyBub3cgdGhhdCB3ZSBoYXZlIHRoZSBtdXR1YWwgYW5jZXN0b3IsIHdlIGNhbiBmaW5kIHdoaWNoIGlzIGVhcmxpZXN0XG5cdFx0XHRvbGRlc3RBID0gb2xkZXN0QS5jb21wb25lbnQgfHwgb2xkZXN0QTtcblx0XHRcdG9sZGVzdEIgPSBvbGRlc3RCLmNvbXBvbmVudCB8fCBvbGRlc3RCO1xuXHRcdFx0ZnJhZ21lbnRBID0gb2xkZXN0QS5wYXJlbnRGcmFnbWVudDtcblx0XHRcdGZyYWdtZW50QiA9IG9sZGVzdEIucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHQvLyBpZiBib3RoIGl0ZW1zIHNoYXJlIGEgcGFyZW50IGZyYWdtZW50LCBvdXIgam9iIGlzIGVhc3lcblx0XHRcdGlmICggZnJhZ21lbnRBID09PSBmcmFnbWVudEIgKSB7XG5cdFx0XHRcdGluZGV4QSA9IGZyYWdtZW50QS5pdGVtcy5pbmRleE9mKCBvbGRlc3RBICk7XG5cdFx0XHRcdGluZGV4QiA9IGZyYWdtZW50Qi5pdGVtcy5pbmRleE9mKCBvbGRlc3RCICk7XG5cdFx0XHRcdC8vIGlmIGl0J3MgdGhlIHNhbWUgaW5kZXgsIGl0IG1lYW5zIG9uZSBjb250YWlucyB0aGUgb3RoZXIsXG5cdFx0XHRcdC8vIHNvIHdlIHNlZSB3aGljaCBoYXMgdGhlIGxvbmdlc3QgYW5jZXN0cnlcblx0XHRcdFx0cmV0dXJuIGluZGV4QSAtIGluZGV4QiB8fCBhbmNlc3RyeUEubGVuZ3RoIC0gYW5jZXN0cnlCLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdC8vIGlmIG11dHVhbCBhbmNlc3RvciBpcyBhIHNlY3Rpb24sIHdlIGZpcnN0IHRlc3QgdG8gc2VlIHdoaWNoIHNlY3Rpb25cblx0XHRcdC8vIGZyYWdtZW50IGNvbWVzIGZpcnN0XG5cdFx0XHRpZiAoIGZyYWdtZW50cyA9IG11dHVhbEFuY2VzdG9yLmZyYWdtZW50cyApIHtcblx0XHRcdFx0aW5kZXhBID0gZnJhZ21lbnRzLmluZGV4T2YoIGZyYWdtZW50QSApO1xuXHRcdFx0XHRpbmRleEIgPSBmcmFnbWVudHMuaW5kZXhPZiggZnJhZ21lbnRCICk7XG5cdFx0XHRcdHJldHVybiBpbmRleEEgLSBpbmRleEIgfHwgYW5jZXN0cnlBLmxlbmd0aCAtIGFuY2VzdHJ5Qi5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdBbiB1bmV4cGVjdGVkIGNvbmRpdGlvbiB3YXMgbWV0IHdoaWxlIGNvbXBhcmluZyB0aGUgcG9zaXRpb24gb2YgdHdvIGNvbXBvbmVudHMuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3MhJyApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRQYXJlbnQoIGl0ZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRpZiAoIHBhcmVudEZyYWdtZW50ID0gaXRlbS5wYXJlbnRGcmFnbWVudCApIHtcblx0XHRcdFx0cmV0dXJuIHBhcmVudEZyYWdtZW50Lm93bmVyO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpdGVtLmNvbXBvbmVudCAmJiAoIHBhcmVudEZyYWdtZW50ID0gaXRlbS5jb21wb25lbnQucGFyZW50RnJhZ21lbnQgKSApIHtcblx0XHRcdFx0cmV0dXJuIHBhcmVudEZyYWdtZW50Lm93bmVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEFuY2VzdHJ5KCBpdGVtICkge1xuXHRcdFx0dmFyIGFuY2VzdHJ5LCBhbmNlc3Rvcjtcblx0XHRcdGFuY2VzdHJ5ID0gWyBpdGVtIF07XG5cdFx0XHRhbmNlc3RvciA9IGdldFBhcmVudCggaXRlbSApO1xuXHRcdFx0d2hpbGUgKCBhbmNlc3RvciApIHtcblx0XHRcdFx0YW5jZXN0cnkucHVzaCggYW5jZXN0b3IgKTtcblx0XHRcdFx0YW5jZXN0b3IgPSBnZXRQYXJlbnQoIGFuY2VzdG9yICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYW5jZXN0cnk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvc29ydEJ5RG9jdW1lbnRQb3NpdGlvbi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnRCeURvY3VtZW50UG9zaXRpb24gPSBmdW5jdGlvbiggc29ydEJ5SXRlbVBvc2l0aW9uICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBub2RlLCBvdGhlck5vZGUgKSB7XG5cdFx0XHR2YXIgYml0bWFzaztcblx0XHRcdGlmICggbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApIHtcblx0XHRcdFx0Yml0bWFzayA9IG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIG90aGVyTm9kZSApO1xuXHRcdFx0XHRyZXR1cm4gYml0bWFzayAmIDIgPyAxIDogLTE7XG5cdFx0XHR9XG5cdFx0XHQvLyBJbiBvbGQgSUUsIHdlIGNhbiBwaWdneSBiYWNrIG9uIHRoZSBtZWNoYW5pc20gZm9yXG5cdFx0XHQvLyBjb21wYXJpbmcgY29tcG9uZW50IHBvc2l0aW9uc1xuXHRcdFx0cmV0dXJuIHNvcnRCeUl0ZW1Qb3NpdGlvbiggbm9kZSwgb3RoZXJOb2RlICk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnRCeUl0ZW1Qb3NpdGlvbiApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvc29ydC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnQgPSBmdW5jdGlvbiggc29ydEJ5RG9jdW1lbnRQb3NpdGlvbiwgc29ydEJ5SXRlbVBvc2l0aW9uICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zb3J0KCB0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gc29ydEJ5SXRlbVBvc2l0aW9uIDogc29ydEJ5RG9jdW1lbnRQb3NpdGlvbiApO1xuXHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydEJ5RG9jdW1lbnRQb3NpdGlvbiwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnRCeUl0ZW1Qb3NpdGlvbiApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvZGlydHkuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9kaXJ0eSA9IGZ1bmN0aW9uKCBydW5sb29wICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRpZiAoICF0aGlzLl9kaXJ0eSApIHtcblx0XHRcdFx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXHRcdFx0XHQvLyBPbmNlIHRoZSBET00gaGFzIGJlZW4gdXBkYXRlZCwgZW5zdXJlIHRoZSBxdWVyeVxuXHRcdFx0XHQvLyBpcyBjb3JyZWN0bHkgb3JkZXJlZFxuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcyQwLl9zb3J0KCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBydW5sb29wICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9yZW1vdmUuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9yZW1vdmUgPSBmdW5jdGlvbiggbm9kZU9yQ29tcG9uZW50ICkge1xuXHRcdHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZiggdGhpcy5faXNDb21wb25lbnRRdWVyeSA/IG5vZGVPckNvbXBvbmVudC5pbnN0YW5jZSA6IG5vZGVPckNvbXBvbmVudCApO1xuXHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0dGhpcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvX21ha2VRdWVyeS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X19tYWtlUXVlcnkgPSBmdW5jdGlvbiggZGVmaW5lUHJvcGVydGllcywgdGVzdCwgY2FuY2VsLCBzb3J0LCBkaXJ0eSwgcmVtb3ZlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIG1ha2VRdWVyeSggcmFjdGl2ZSwgc2VsZWN0b3IsIGxpdmUsIGlzQ29tcG9uZW50UXVlcnkgKSB7XG5cdFx0XHR2YXIgcXVlcnkgPSBbXTtcblx0XHRcdGRlZmluZVByb3BlcnRpZXMoIHF1ZXJ5LCB7XG5cdFx0XHRcdHNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0dmFsdWU6IHNlbGVjdG9yXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxpdmU6IHtcblx0XHRcdFx0XHR2YWx1ZTogbGl2ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfaXNDb21wb25lbnRRdWVyeToge1xuXHRcdFx0XHRcdHZhbHVlOiBpc0NvbXBvbmVudFF1ZXJ5XG5cdFx0XHRcdH0sXG5cdFx0XHRcdF90ZXN0OiB7XG5cdFx0XHRcdFx0dmFsdWU6IHRlc3Rcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0aWYgKCAhbGl2ZSApIHtcblx0XHRcdFx0cmV0dXJuIHF1ZXJ5O1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyggcXVlcnksIHtcblx0XHRcdFx0Y2FuY2VsOiB7XG5cdFx0XHRcdFx0dmFsdWU6IGNhbmNlbFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfcm9vdDoge1xuXHRcdFx0XHRcdHZhbHVlOiByYWN0aXZlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9zb3J0OiB7XG5cdFx0XHRcdFx0dmFsdWU6IHNvcnRcblx0XHRcdFx0fSxcblx0XHRcdFx0X21ha2VEaXJ0eToge1xuXHRcdFx0XHRcdHZhbHVlOiBkaXJ0eVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfcmVtb3ZlOiB7XG5cdFx0XHRcdFx0dmFsdWU6IHJlbW92ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfZGlydHk6IHtcblx0XHRcdFx0XHR2YWx1ZTogZmFsc2UsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHF1ZXJ5O1xuXHRcdH07XG5cdH0oIGRlZmluZVByb3BlcnRpZXMsIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV90ZXN0LCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfY2FuY2VsLCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydCwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X2RpcnR5LCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfcmVtb3ZlICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRmaW5kQWxsID0gZnVuY3Rpb24oIG1ha2VRdWVyeSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGZpbmRBbGwoIHNlbGVjdG9yLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGxpdmVRdWVyaWVzLCBxdWVyeTtcblx0XHRcdGlmICggIXRoaXMuZWwgKSB7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0bGl2ZVF1ZXJpZXMgPSB0aGlzLl9saXZlUXVlcmllcztcblx0XHRcdC8vIFNob3J0Y3V0OiBpZiB3ZSdyZSBtYWludGFpbmluZyBhIGxpdmUgcXVlcnkgd2l0aCB0aGlzXG5cdFx0XHQvLyBzZWxlY3Rvciwgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSB0aGUgcGFyYWxsZWwgRE9NXG5cdFx0XHRpZiAoIHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbIHNlbGVjdG9yIF0gKSB7XG5cdFx0XHRcdC8vIEVpdGhlciByZXR1cm4gdGhlIGV4YWN0IHNhbWUgcXVlcnksIG9yIChpZiBub3QgbGl2ZSkgYSBzbmFwc2hvdFxuXHRcdFx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmxpdmUgPyBxdWVyeSA6IHF1ZXJ5LnNsaWNlKCk7XG5cdFx0XHR9XG5cdFx0XHRxdWVyeSA9IG1ha2VRdWVyeSggdGhpcywgc2VsZWN0b3IsICEhb3B0aW9ucy5saXZlLCBmYWxzZSApO1xuXHRcdFx0Ly8gQWRkIHRoaXMgdG8gdGhlIGxpc3Qgb2YgbGl2ZSBxdWVyaWVzIFJhY3RpdmUgbmVlZHMgdG8gbWFpbnRhaW4sXG5cdFx0XHQvLyBpZiBhcHBsaWNhYmxlXG5cdFx0XHRpZiAoIHF1ZXJ5LmxpdmUgKSB7XG5cdFx0XHRcdGxpdmVRdWVyaWVzLnB1c2goIHNlbGVjdG9yICk7XG5cdFx0XHRcdGxpdmVRdWVyaWVzWyAnXycgKyBzZWxlY3RvciBdID0gcXVlcnk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0cmV0dXJuIHF1ZXJ5O1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9fbWFrZVF1ZXJ5ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZmluZEFsbENvbXBvbmVudHMuanMgKi9cblx0dmFyIFJhY3RpdmUkZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiggbWFrZVF1ZXJ5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGxpdmVRdWVyaWVzLCBxdWVyeTtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0bGl2ZVF1ZXJpZXMgPSB0aGlzLl9saXZlQ29tcG9uZW50UXVlcmllcztcblx0XHRcdC8vIFNob3J0Y3V0OiBpZiB3ZSdyZSBtYWludGFpbmluZyBhIGxpdmUgcXVlcnkgd2l0aCB0aGlzXG5cdFx0XHQvLyBzZWxlY3Rvciwgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSB0aGUgcGFyYWxsZWwgRE9NXG5cdFx0XHRpZiAoIHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbIHNlbGVjdG9yIF0gKSB7XG5cdFx0XHRcdC8vIEVpdGhlciByZXR1cm4gdGhlIGV4YWN0IHNhbWUgcXVlcnksIG9yIChpZiBub3QgbGl2ZSkgYSBzbmFwc2hvdFxuXHRcdFx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmxpdmUgPyBxdWVyeSA6IHF1ZXJ5LnNsaWNlKCk7XG5cdFx0XHR9XG5cdFx0XHRxdWVyeSA9IG1ha2VRdWVyeSggdGhpcywgc2VsZWN0b3IsICEhb3B0aW9ucy5saXZlLCB0cnVlICk7XG5cdFx0XHQvLyBBZGQgdGhpcyB0byB0aGUgbGlzdCBvZiBsaXZlIHF1ZXJpZXMgUmFjdGl2ZSBuZWVkcyB0byBtYWludGFpbixcblx0XHRcdC8vIGlmIGFwcGxpY2FibGVcblx0XHRcdGlmICggcXVlcnkubGl2ZSApIHtcblx0XHRcdFx0bGl2ZVF1ZXJpZXMucHVzaCggc2VsZWN0b3IgKTtcblx0XHRcdFx0bGl2ZVF1ZXJpZXNbICdfJyArIHNlbGVjdG9yIF0gPSBxdWVyeTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0cmV0dXJuIHF1ZXJ5O1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9fbWFrZVF1ZXJ5ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZmluZENvbXBvbmVudC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRmaW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQ29tcG9uZW50KCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApO1xuXHR9O1xuXG5cdC8qIHV0aWxzL2dldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcy5qcyAqL1xuXHR2YXIgZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIHN0YXJNYXBzID0ge307XG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGtleXBhdGggc3VjaCBhcyAnZm9vLmJhci5iYXonLCBhbmQgcmV0dXJuc1xuXHRcdC8vIGFsbCB0aGUgdmFyaWFudHMgb2YgdGhhdCBrZXlwYXRoIHRoYXQgaW5jbHVkZSBhIHdpbGRjYXJkIGluIHBsYWNlXG5cdFx0Ly8gb2YgYSBrZXksIHN1Y2ggYXMgJ2Zvby5iYXIuKicsICdmb28uKi5iYXonLCAnZm9vLiouKicgYW5kIHNvIG9uLlxuXHRcdC8vIFRoZXNlIGFyZSB0aGVuIGNoZWNrZWQgYWdhaW5zdCB0aGUgZGVwZW5kYW50cyBtYXAgKHJhY3RpdmUudmlld21vZGVsLmRlcHNNYXApXG5cdFx0Ly8gdG8gc2VlIGlmIGFueSBwYXR0ZXJuIG9ic2VydmVycyBhcmUgZG93bnN0cmVhbSBvZiBvbmUgb3IgbW9yZSBvZlxuXHRcdC8vIHRoZXNlIHdpbGRjYXJkIGtleXBhdGhzIChlLmcuICdmb28uYmFyLiouc3RhdHVzJylcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcygga2V5cGF0aCApIHtcblx0XHRcdHZhciBrZXlzLCBzdGFyTWFwLCBtYXBwZXIsIGksIHJlc3VsdCwgd2lsZGNhcmRLZXlwYXRoO1xuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0aWYgKCAhKCBzdGFyTWFwID0gc3Rhck1hcHNbIGtleXMubGVuZ3RoIF0gKSApIHtcblx0XHRcdFx0c3Rhck1hcCA9IGdldFN0YXJNYXAoIGtleXMubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRcdG1hcHBlciA9IGZ1bmN0aW9uKCBzdGFyLCBpICkge1xuXHRcdFx0XHRyZXR1cm4gc3RhciA/ICcqJyA6IGtleXNbIGkgXTtcblx0XHRcdH07XG5cdFx0XHRpID0gc3Rhck1hcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0d2lsZGNhcmRLZXlwYXRoID0gc3Rhck1hcFsgaSBdLm1hcCggbWFwcGVyICkuam9pbiggJy4nICk7XG5cdFx0XHRcdGlmICggIXJlc3VsdC5oYXNPd25Qcm9wZXJ0eSggd2lsZGNhcmRLZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goIHdpbGRjYXJkS2V5cGF0aCApO1xuXHRcdFx0XHRcdHJlc3VsdFsgd2lsZGNhcmRLZXlwYXRoIF0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFsbCB0aGUgcG9zc2libGUgdHJ1ZS9mYWxzZSBjb21iaW5hdGlvbnMgZm9yXG5cdFx0Ly8gYSBnaXZlbiBudW1iZXIgLSBlLmcuIGZvciB0d28sIHRoZSBwb3NzaWJsZSBjb21iaW5hdGlvbnMgYXJlXG5cdFx0Ly8gWyB0cnVlLCB0cnVlIF0sIFsgdHJ1ZSwgZmFsc2UgXSwgWyBmYWxzZSwgdHJ1ZSBdLCBbIGZhbHNlLCBmYWxzZSBdLlxuXHRcdC8vIEl0IGRvZXMgc28gYnkgZ2V0dGluZyBhbGwgdGhlIGJpbmFyeSB2YWx1ZXMgYmV0d2VlbiAwIGFuZCBlLmcuIDExXG5cdFx0ZnVuY3Rpb24gZ2V0U3Rhck1hcCggbnVtICkge1xuXHRcdFx0dmFyIG9uZXMgPSAnJyxcblx0XHRcdFx0bWF4LCBiaW5hcnksIHN0YXJNYXAsIG1hcHBlciwgaTtcblx0XHRcdGlmICggIXN0YXJNYXBzWyBudW0gXSApIHtcblx0XHRcdFx0c3Rhck1hcCA9IFtdO1xuXHRcdFx0XHR3aGlsZSAoIG9uZXMubGVuZ3RoIDwgbnVtICkge1xuXHRcdFx0XHRcdG9uZXMgKz0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXggPSBwYXJzZUludCggb25lcywgMiApO1xuXHRcdFx0XHRtYXBwZXIgPSBmdW5jdGlvbiggZGlnaXQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRpZ2l0ID09PSAnMSc7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDw9IG1heDsgaSArPSAxICkge1xuXHRcdFx0XHRcdGJpbmFyeSA9IGkudG9TdHJpbmcoIDIgKTtcblx0XHRcdFx0XHR3aGlsZSAoIGJpbmFyeS5sZW5ndGggPCBudW0gKSB7XG5cdFx0XHRcdFx0XHRiaW5hcnkgPSAnMCcgKyBiaW5hcnk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0YXJNYXBbIGkgXSA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCggYmluYXJ5LCBtYXBwZXIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFyTWFwc1sgbnVtIF0gPSBzdGFyTWFwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0YXJNYXBzWyBudW0gXTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL2ZpcmVFdmVudC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfZmlyZUV2ZW50ID0gZnVuY3Rpb24oIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIGZpcmVFdmVudCggcmFjdGl2ZSwgZXZlbnROYW1lICkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDIgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0aWYgKCAhZXZlbnROYW1lICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFvcHRpb25zLmV2ZW50ICkge1xuXHRcdFx0XHRvcHRpb25zLmV2ZW50ID0ge1xuXHRcdFx0XHRcdG5hbWU6IGV2ZW50TmFtZSxcblx0XHRcdFx0XHRjb250ZXh0OiByYWN0aXZlLmRhdGEsXG5cdFx0XHRcdFx0a2V5cGF0aDogJycsXG5cdFx0XHRcdFx0Ly8gdW50aWwgZXZlbnQgbm90IGluY2x1ZGVkIGFzIGFyZ3VtZW50IGRlZmF1bHRcblx0XHRcdFx0XHRfbm9Bcmc6IHRydWVcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbnMuZXZlbnQubmFtZSA9IGV2ZW50TmFtZTtcblx0XHRcdH1cblx0XHRcdHZhciBldmVudE5hbWVzID0gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKCBldmVudE5hbWUgKTtcblx0XHRcdGZpcmVFdmVudEFzKCByYWN0aXZlLCBldmVudE5hbWVzLCBvcHRpb25zLmV2ZW50LCBvcHRpb25zLmFyZ3MsIHRydWUgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZmlyZUV2ZW50QXMoIHJhY3RpdmUsIGV2ZW50TmFtZXMsIGV2ZW50LCBhcmdzICkge1xuXHRcdFx0dmFyIGluaXRpYWxGaXJlID0gYXJndW1lbnRzWyA0IF07XG5cdFx0XHRpZiAoIGluaXRpYWxGaXJlID09PSB2b2lkIDAgKVxuXHRcdFx0XHRpbml0aWFsRmlyZSA9IGZhbHNlO1xuXHRcdFx0dmFyIHN1YnNjcmliZXJzLCBpLCBidWJibGUgPSB0cnVlO1xuXHRcdFx0aWYgKCBldmVudCApIHtcblx0XHRcdFx0cmFjdGl2ZS5ldmVudCA9IGV2ZW50O1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggaSA9IGV2ZW50TmFtZXMubGVuZ3RoOyBpID49IDA7IGktLSApIHtcblx0XHRcdFx0c3Vic2NyaWJlcnMgPSByYWN0aXZlLl9zdWJzWyBldmVudE5hbWVzWyBpIF0gXTtcblx0XHRcdFx0aWYgKCBzdWJzY3JpYmVycyApIHtcblx0XHRcdFx0XHRidWJibGUgPSBub3RpZnlTdWJzY3JpYmVycyggcmFjdGl2ZSwgc3Vic2NyaWJlcnMsIGV2ZW50LCBhcmdzICkgJiYgYnViYmxlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGV2ZW50ICkge1xuXHRcdFx0XHRkZWxldGUgcmFjdGl2ZS5ldmVudDtcblx0XHRcdH1cblx0XHRcdGlmICggcmFjdGl2ZS5fcGFyZW50ICYmIGJ1YmJsZSApIHtcblx0XHRcdFx0aWYgKCBpbml0aWFsRmlyZSAmJiByYWN0aXZlLmNvbXBvbmVudCApIHtcblx0XHRcdFx0XHR2YXIgZnVsbE5hbWUgPSByYWN0aXZlLmNvbXBvbmVudC5uYW1lICsgJy4nICsgZXZlbnROYW1lc1sgZXZlbnROYW1lcy5sZW5ndGggLSAxIF07XG5cdFx0XHRcdFx0ZXZlbnROYW1lcyA9IGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyggZnVsbE5hbWUgKTtcblx0XHRcdFx0XHRpZiAoIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0ZXZlbnQuY29tcG9uZW50ID0gcmFjdGl2ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmlyZUV2ZW50QXMoIHJhY3RpdmUuX3BhcmVudCwgZXZlbnROYW1lcywgZXZlbnQsIGFyZ3MgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBub3RpZnlTdWJzY3JpYmVycyggcmFjdGl2ZSwgc3Vic2NyaWJlcnMsIGV2ZW50LCBhcmdzICkge1xuXHRcdFx0dmFyIG9yaWdpbmFsRXZlbnQgPSBudWxsLFxuXHRcdFx0XHRzdG9wRXZlbnQgPSBmYWxzZTtcblx0XHRcdGlmICggZXZlbnQgJiYgIWV2ZW50Ll9ub0FyZyApIHtcblx0XHRcdFx0YXJncyA9IFsgZXZlbnQgXS5jb25jYXQoIGFyZ3MgKTtcblx0XHRcdH1cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbGVuID0gc3Vic2NyaWJlcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdGlmICggc3Vic2NyaWJlcnNbIGkgXS5hcHBseSggcmFjdGl2ZSwgYXJncyApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRzdG9wRXZlbnQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGV2ZW50ICYmICFldmVudC5fbm9BcmcgJiYgc3RvcEV2ZW50ICYmICggb3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsICkgKSB7XG5cdFx0XHRcdG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQgJiYgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbiAmJiBvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICFzdG9wRXZlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZmlyZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRmaXJlID0gZnVuY3Rpb24oIGZpcmVFdmVudCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGZpcmUoIGV2ZW50TmFtZSApIHtcblx0XHRcdHZhciBvcHRpb25zID0ge1xuXHRcdFx0XHRhcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxIClcblx0XHRcdH07XG5cdFx0XHRmaXJlRXZlbnQoIHRoaXMsIGV2ZW50TmFtZSwgb3B0aW9ucyApO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2ZpcmVFdmVudCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2dldC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRnZXQgPSBmdW5jdGlvbiggbm9ybWFsaXNlS2V5cGF0aCwgcmVzb2x2ZVJlZiApIHtcblxuXHRcdHZhciBvcHRpb25zID0ge1xuXHRcdFx0Y2FwdHVyZTogdHJ1ZVxuXHRcdH07XG5cdFx0Ly8gdG9wLWxldmVsIGNhbGxzIHNob3VsZCBiZSBpbnRlcmNlcHRlZFxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGdldCgga2V5cGF0aCApIHtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHR2YWx1ZSA9IHRoaXMudmlld21vZGVsLmdldCgga2V5cGF0aCwgb3B0aW9ucyApO1xuXHRcdFx0Ly8gQ3JlYXRlIGludGVyLWNvbXBvbmVudCBiaW5kaW5nLCBpZiBuZWNlc3Nhcnlcblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9wYXJlbnQgJiYgIXRoaXMuaXNvbGF0ZWQgKSB7XG5cdFx0XHRcdGlmICggcmVzb2x2ZVJlZiggdGhpcywga2V5cGF0aCwgdGhpcy5mcmFnbWVudCApICkge1xuXHRcdFx0XHRcdC8vIGNyZWF0ZXMgYmluZGluZyBhcyBzaWRlLWVmZmVjdCwgaWYgYXBwcm9wcmlhdGVcblx0XHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblx0fSggbm9ybWFsaXNlS2V5cGF0aCwgcmVzb2x2ZVJlZiApO1xuXG5cdC8qIHV0aWxzL2dldEVsZW1lbnQuanMgKi9cblx0dmFyIGdldEVsZW1lbnQgPSBmdW5jdGlvbiBnZXRFbGVtZW50KCBpbnB1dCApIHtcblx0XHR2YXIgb3V0cHV0O1xuXHRcdGlmICggIWlucHV0IHx8IHR5cGVvZiBpbnB1dCA9PT0gJ2Jvb2xlYW4nICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFkb2N1bWVudCB8fCAhaW5wdXQgKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0Ly8gV2UgYWxyZWFkeSBoYXZlIGEgRE9NIG5vZGUgLSBubyB3b3JrIHRvIGRvLiAoRHVjayB0eXBpbmcgYWxlcnQhKVxuXHRcdGlmICggaW5wdXQubm9kZVR5cGUgKSB7XG5cdFx0XHRyZXR1cm4gaW5wdXQ7XG5cdFx0fVxuXHRcdC8vIEdldCBub2RlIGZyb20gc3RyaW5nXG5cdFx0aWYgKCB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0Ly8gdHJ5IElEIGZpcnN0XG5cdFx0XHRvdXRwdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggaW5wdXQgKTtcblx0XHRcdC8vIHRoZW4gYXMgc2VsZWN0b3IsIGlmIHBvc3NpYmxlXG5cdFx0XHRpZiAoICFvdXRwdXQgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3RvciApIHtcblx0XHRcdFx0b3V0cHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggaW5wdXQgKTtcblx0XHRcdH1cblx0XHRcdC8vIGRpZCBpdCB3b3JrP1xuXHRcdFx0aWYgKCBvdXRwdXQgJiYgb3V0cHV0Lm5vZGVUeXBlICkge1xuXHRcdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBJZiB3ZSd2ZSBiZWVuIGdpdmVuIGEgY29sbGVjdGlvbiAoalF1ZXJ5LCBaZXB0byBldGMpLCBleHRyYWN0IHRoZSBmaXJzdCBpdGVtXG5cdFx0aWYgKCBpbnB1dFsgMCBdICYmIGlucHV0WyAwIF0ubm9kZVR5cGUgKSB7XG5cdFx0XHRyZXR1cm4gaW5wdXRbIDAgXTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvaW5zZXJ0LmpzICovXG5cdHZhciBSYWN0aXZlJGluc2VydCA9IGZ1bmN0aW9uKCBIb29rLCBnZXRFbGVtZW50ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBpbnNlcnRIb29rID0gbmV3IEhvb2soICdpbnNlcnQnICk7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBSYWN0aXZlJGluc2VydCggdGFyZ2V0LCBhbmNob3IgKSB7XG5cdFx0XHRpZiAoICF0aGlzLmZyYWdtZW50LnJlbmRlcmVkICkge1xuXHRcdFx0XHQvLyBUT0RPIGNyZWF0ZSwgYW5kIGxpbmsgdG8sIGRvY3VtZW50YXRpb24gZXhwbGFpbmluZyB0aGlzXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RoZSBBUEkgaGFzIGNoYW5nZWQgLSB5b3UgbXVzdCBjYWxsIGByYWN0aXZlLnJlbmRlcih0YXJnZXRbLCBhbmNob3JdKWAgdG8gcmVuZGVyIHlvdXIgUmFjdGl2ZSBpbnN0YW5jZS4gT25jZSByZW5kZXJlZCB5b3UgY2FuIHVzZSBgcmFjdGl2ZS5pbnNlcnQoKWAuJyApO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0ID0gZ2V0RWxlbWVudCggdGFyZ2V0ICk7XG5cdFx0XHRhbmNob3IgPSBnZXRFbGVtZW50KCBhbmNob3IgKSB8fCBudWxsO1xuXHRcdFx0aWYgKCAhdGFyZ2V0ICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdZb3UgbXVzdCBzcGVjaWZ5IGEgdmFsaWQgdGFyZ2V0IHRvIGluc2VydCBpbnRvJyApO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggdGhpcy5kZXRhY2goKSwgYW5jaG9yICk7XG5cdFx0XHR0aGlzLmVsID0gdGFyZ2V0O1xuXHRcdFx0KCB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fIHx8ICggdGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyA9IFtdICkgKS5wdXNoKCB0aGlzICk7XG5cdFx0XHR0aGlzLmRldGFjaGVkID0gbnVsbDtcblx0XHRcdGZpcmVJbnNlcnRIb29rKCB0aGlzICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGZpcmVJbnNlcnRIb29rKCByYWN0aXZlICkge1xuXHRcdFx0aW5zZXJ0SG9vay5maXJlKCByYWN0aXZlICk7XG5cdFx0XHRyYWN0aXZlLmZpbmRBbGxDb21wb25lbnRzKCAnKicgKS5mb3JFYWNoKCBmdW5jdGlvbiggY2hpbGQgKSB7XG5cdFx0XHRcdGZpcmVJbnNlcnRIb29rKCBjaGlsZC5pbnN0YW5jZSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2ssIGdldEVsZW1lbnQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9tZXJnZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRtZXJnZSA9IGZ1bmN0aW9uKCBydW5sb29wLCBpc0FycmF5LCBub3JtYWxpc2VLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkbWVyZ2UoIGtleXBhdGgsIGFycmF5LCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGN1cnJlbnRBcnJheSwgcHJvbWlzZTtcblx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHRjdXJyZW50QXJyYXkgPSB0aGlzLnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdC8vIElmIGVpdGhlciB0aGUgZXhpc3RpbmcgdmFsdWUgb3IgdGhlIG5ldyB2YWx1ZSBpc24ndCBhblxuXHRcdFx0Ly8gYXJyYXksIGp1c3QgZG8gYSByZWd1bGFyIHNldFxuXHRcdFx0aWYgKCAhaXNBcnJheSggY3VycmVudEFycmF5ICkgfHwgIWlzQXJyYXkoIGFycmF5ICkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnNldCgga2V5cGF0aCwgYXJyYXksIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wbGV0ZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTWFuYWdlIHRyYW5zaXRpb25zXG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0dGhpcy52aWV3bW9kZWwubWVyZ2UoIGtleXBhdGgsIGN1cnJlbnRBcnJheSwgYXJyYXksIG9wdGlvbnMgKTtcblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHQvLyBhdHRhY2ggY2FsbGJhY2sgYXMgZnVsZmlsbWVudCBoYW5kbGVyLCBpZiBzcGVjaWZpZWRcblx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBsZXRlICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIG9wdGlvbnMuY29tcGxldGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIGlzQXJyYXksIG5vcm1hbGlzZUtleXBhdGggKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlL09ic2VydmVyLmpzICovXG5cdHZhciBSYWN0aXZlJG9ic2VydmVfT2JzZXJ2ZXIgPSBmdW5jdGlvbiggcnVubG9vcCwgaXNFcXVhbCApIHtcblxuXHRcdHZhciBPYnNlcnZlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0dGhpcy5kZWZlciA9IG9wdGlvbnMuZGVmZXI7XG5cdFx0XHQvLyBkZWZhdWx0IHRvIHJvb3QgYXMgY29udGV4dCwgYnV0IGFsbG93IGl0IHRvIGJlIG92ZXJyaWRkZW5cblx0XHRcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID8gb3B0aW9ucy5jb250ZXh0IDogcmFjdGl2ZTtcblx0XHR9O1xuXHRcdE9ic2VydmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCBpbW1lZGlhdGUgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLnJvb3QuZ2V0KCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0aWYgKCBpbW1lZGlhdGUgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5vbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0aWYgKCAhaXNFcXVhbCggdmFsdWUsIHRoaXMudmFsdWUgKSApIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLmRlZmVyICYmIHRoaXMucmVhZHkgKSB7XG5cdFx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzJDAudXBkYXRlKCk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gUHJldmVudCBpbmZpbml0ZSBsb29wc1xuXHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmNhbGxiYWNrLmNhbGwoIHRoaXMuY29udGV4dCwgdGhpcy52YWx1ZSwgdGhpcy5vbGRWYWx1ZSwgdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdHRoaXMub2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gT2JzZXJ2ZXI7XG5cdH0oIHJ1bmxvb3AsIGlzRXF1YWwgKTtcblxuXHQvKiBzaGFyZWQvZ2V0TWF0Y2hpbmdLZXlwYXRocy5qcyAqL1xuXHR2YXIgZ2V0TWF0Y2hpbmdLZXlwYXRocyA9IGZ1bmN0aW9uKCBpc0FycmF5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldE1hdGNoaW5nS2V5cGF0aHMoIHJhY3RpdmUsIHBhdHRlcm4gKSB7XG5cdFx0XHR2YXIga2V5cywga2V5LCBtYXRjaGluZ0tleXBhdGhzO1xuXHRcdFx0a2V5cyA9IHBhdHRlcm4uc3BsaXQoICcuJyApO1xuXHRcdFx0bWF0Y2hpbmdLZXlwYXRocyA9IFsgJycgXTtcblx0XHRcdHdoaWxlICgga2V5ID0ga2V5cy5zaGlmdCgpICkge1xuXHRcdFx0XHRpZiAoIGtleSA9PT0gJyonICkge1xuXHRcdFx0XHRcdC8vIGV4cGFuZCB0byBmaW5kIGFsbCB2YWxpZCBjaGlsZCBrZXlwYXRoc1xuXHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBtYXRjaGluZ0tleXBhdGhzLnJlZHVjZSggZXhwYW5kLCBbXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggbWF0Y2hpbmdLZXlwYXRoc1sgMCBdID09PSAnJyApIHtcblx0XHRcdFx0XHRcdC8vIGZpcnN0IGtleVxuXHRcdFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRoc1sgMCBdID0ga2V5O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gbWF0Y2hpbmdLZXlwYXRocy5tYXAoIGNvbmNhdGVuYXRlKCBrZXkgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoaW5nS2V5cGF0aHM7XG5cblx0XHRcdGZ1bmN0aW9uIGV4cGFuZCggbWF0Y2hpbmdLZXlwYXRocywga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBrZXksIGNoaWxkS2V5cGF0aDtcblx0XHRcdFx0dmFsdWUgPSByYWN0aXZlLnZpZXdtb2RlbC53cmFwcGVkWyBrZXlwYXRoIF0gPyByYWN0aXZlLnZpZXdtb2RlbC53cmFwcGVkWyBrZXlwYXRoIF0uZ2V0KCkgOiByYWN0aXZlLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRmb3IgKCBrZXkgaW4gdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgKCBrZXkgIT09ICdfcmFjdGl2ZScgfHwgIWlzQXJyYXkoIHZhbHVlICkgKSApIHtcblx0XHRcdFx0XHRcdC8vIGZvciBiZW5lZml0IG9mIElFOFxuXHRcdFx0XHRcdFx0Y2hpbGRLZXlwYXRoID0ga2V5cGF0aCA/IGtleXBhdGggKyAnLicgKyBrZXkgOiBrZXk7XG5cdFx0XHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzLnB1c2goIGNoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hpbmdLZXlwYXRocztcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY29uY2F0ZW5hdGUoIGtleSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBrZXlwYXRoID8ga2V5cGF0aCArICcuJyArIGtleSA6IGtleTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBpc0FycmF5ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb2JzZXJ2ZS9nZXRQYXR0ZXJuLmpzICovXG5cdHZhciBSYWN0aXZlJG9ic2VydmVfZ2V0UGF0dGVybiA9IGZ1bmN0aW9uKCBnZXRNYXRjaGluZ0tleXBhdGhzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldFBhdHRlcm4oIHJhY3RpdmUsIHBhdHRlcm4gKSB7XG5cdFx0XHR2YXIgbWF0Y2hpbmdLZXlwYXRocywgdmFsdWVzO1xuXHRcdFx0bWF0Y2hpbmdLZXlwYXRocyA9IGdldE1hdGNoaW5nS2V5cGF0aHMoIHJhY3RpdmUsIHBhdHRlcm4gKTtcblx0XHRcdHZhbHVlcyA9IHt9O1xuXHRcdFx0bWF0Y2hpbmdLZXlwYXRocy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFsdWVzWyBrZXlwYXRoIF0gPSByYWN0aXZlLmdldCgga2V5cGF0aCApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHR9O1xuXHR9KCBnZXRNYXRjaGluZ0tleXBhdGhzICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb2JzZXJ2ZS9QYXR0ZXJuT2JzZXJ2ZXIuanMgKi9cblx0dmFyIFJhY3RpdmUkb2JzZXJ2ZV9QYXR0ZXJuT2JzZXJ2ZXIgPSBmdW5jdGlvbiggcnVubG9vcCwgaXNFcXVhbCwgZ2V0UGF0dGVybiApIHtcblxuXHRcdHZhciBQYXR0ZXJuT2JzZXJ2ZXIsIHdpbGRjYXJkID0gL1xcKi8sXG5cdFx0XHRzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0XHRQYXR0ZXJuT2JzZXJ2ZXIgPSBmdW5jdGlvbiggcmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuXHRcdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0dGhpcy5kZWZlciA9IG9wdGlvbnMuZGVmZXI7XG5cdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0dGhpcy5yZWdleCA9IG5ldyBSZWdFeHAoICdeJyArIGtleXBhdGgucmVwbGFjZSggL1xcLi9nLCAnXFxcXC4nICkucmVwbGFjZSggL1xcKi9nLCAnKFteXFxcXC5dKyknICkgKyAnJCcgKTtcblx0XHRcdHRoaXMudmFsdWVzID0ge307XG5cdFx0XHRpZiAoIHRoaXMuZGVmZXIgKSB7XG5cdFx0XHRcdHRoaXMucHJveGllcyA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZGVmYXVsdCB0byByb290IGFzIGNvbnRleHQsIGJ1dCBhbGxvdyBpdCB0byBiZSBvdmVycmlkZGVuXG5cdFx0XHR0aGlzLmNvbnRleHQgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA/IG9wdGlvbnMuY29udGV4dCA6IHJhY3RpdmU7XG5cdFx0fTtcblx0XHRQYXR0ZXJuT2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0aW5pdDogZnVuY3Rpb24oIGltbWVkaWF0ZSApIHtcblx0XHRcdFx0dmFyIHZhbHVlcywga2V5cGF0aDtcblx0XHRcdFx0dmFsdWVzID0gZ2V0UGF0dGVybiggdGhpcy5yb290LCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0aWYgKCBpbW1lZGlhdGUgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGZvciAoIGtleXBhdGggaW4gdmFsdWVzICkge1xuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZXMuaGFzT3duUHJvcGVydHkoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0dmFyIHZhbHVlcztcblx0XHRcdFx0aWYgKCB3aWxkY2FyZC50ZXN0KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0dmFsdWVzID0gZ2V0UGF0dGVybiggdGhpcy5yb290LCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0Zm9yICgga2V5cGF0aCBpbiB2YWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHZhbHVlcy5oYXNPd25Qcm9wZXJ0eSgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gYXJyYXkgbXV0YXRpb24gc2hvdWxkIG5vdCB0cmlnZ2VyIGBhcnJheS4qYFxuXHRcdFx0XHQvLyBwYXR0ZXJuIG9ic2VydmVyIHdpdGggYGFycmF5Lmxlbmd0aGBcblx0XHRcdFx0aWYgKCB0aGlzLnJvb3Qudmlld21vZGVsLmltcGxpY2l0Q2hhbmdlc1sga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRoaXMuZGVmZXIgJiYgdGhpcy5yZWFkeSApIHtcblx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLmdldFByb3h5KCBrZXlwYXRoICkudXBkYXRlKCk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnJlYWxseVVwZGF0ZSgga2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHJlYWxseVVwZGF0ZTogZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwga2V5cywgYXJncztcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHQvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BzXG5cdFx0XHRcdGlmICggdGhpcy51cGRhdGluZyApIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlc1sga2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRpZiAoICFpc0VxdWFsKCB2YWx1ZSwgdGhpcy52YWx1ZXNbIGtleXBhdGggXSApIHx8ICF0aGlzLnJlYWR5ICkge1xuXHRcdFx0XHRcdGtleXMgPSBzbGljZS5jYWxsKCB0aGlzLnJlZ2V4LmV4ZWMoIGtleXBhdGggKSwgMSApO1xuXHRcdFx0XHRcdGFyZ3MgPSBbXG5cdFx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHRcdHRoaXMudmFsdWVzWyBrZXlwYXRoIF0sXG5cdFx0XHRcdFx0XHRrZXlwYXRoXG5cdFx0XHRcdFx0XS5jb25jYXQoIGtleXMgKTtcblx0XHRcdFx0XHR0aGlzLmNhbGxiYWNrLmFwcGx5KCB0aGlzLmNvbnRleHQsIGFyZ3MgKTtcblx0XHRcdFx0XHR0aGlzLnZhbHVlc1sga2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdGdldFByb3h5OiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0XHRpZiAoICF0aGlzLnByb3hpZXNbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHR0aGlzLnByb3hpZXNbIGtleXBhdGggXSA9IHtcblx0XHRcdFx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYucmVhbGx5VXBkYXRlKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcm94aWVzWyBrZXlwYXRoIF07XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gUGF0dGVybk9ic2VydmVyO1xuXHR9KCBydW5sb29wLCBpc0VxdWFsLCBSYWN0aXZlJG9ic2VydmVfZ2V0UGF0dGVybiApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29ic2VydmUvZ2V0T2JzZXJ2ZXJGYWNhZGUuanMgKi9cblx0dmFyIFJhY3RpdmUkb2JzZXJ2ZV9nZXRPYnNlcnZlckZhY2FkZSA9IGZ1bmN0aW9uKCBub3JtYWxpc2VLZXlwYXRoLCBPYnNlcnZlciwgUGF0dGVybk9ic2VydmVyICkge1xuXG5cdFx0dmFyIHdpbGRjYXJkID0gL1xcKi8sXG5cdFx0XHRlbXB0eU9iamVjdCA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRPYnNlcnZlckZhY2FkZSggcmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgb2JzZXJ2ZXIsIGlzUGF0dGVybk9ic2VydmVyLCBjYW5jZWxsZWQ7XG5cdFx0XHRrZXlwYXRoID0gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApO1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwgZW1wdHlPYmplY3Q7XG5cdFx0XHQvLyBwYXR0ZXJuIG9ic2VydmVycyBhcmUgdHJlYXRlZCBkaWZmZXJlbnRseVxuXHRcdFx0aWYgKCB3aWxkY2FyZC50ZXN0KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdG9ic2VydmVyID0gbmV3IFBhdHRlcm5PYnNlcnZlciggcmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKTtcblx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5wdXNoKCBvYnNlcnZlciApO1xuXHRcdFx0XHRpc1BhdHRlcm5PYnNlcnZlciA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvYnNlcnZlciA9IG5ldyBPYnNlcnZlciggcmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdHJhY3RpdmUudmlld21vZGVsLnJlZ2lzdGVyKCBrZXlwYXRoLCBvYnNlcnZlciwgaXNQYXR0ZXJuT2JzZXJ2ZXIgPyAncGF0dGVybk9ic2VydmVycycgOiAnb2JzZXJ2ZXJzJyApO1xuXHRcdFx0b2JzZXJ2ZXIuaW5pdCggb3B0aW9ucy5pbml0ICk7XG5cdFx0XHQvLyBUaGlzIGZsYWcgYWxsb3dzIG9ic2VydmVycyB0byBpbml0aWFsaXNlIGV2ZW4gd2l0aCB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRvYnNlcnZlci5yZWFkeSA9IHRydWU7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHRpZiAoIGNhbmNlbGxlZCApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBpc1BhdHRlcm5PYnNlcnZlciApIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gcmFjdGl2ZS52aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5pbmRleE9mKCBvYnNlcnZlciApO1xuXHRcdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC51bnJlZ2lzdGVyKCBrZXlwYXRoLCBvYnNlcnZlciwgJ3BhdHRlcm5PYnNlcnZlcnMnICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnVucmVnaXN0ZXIoIGtleXBhdGgsIG9ic2VydmVyLCAnb2JzZXJ2ZXJzJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYW5jZWxsZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIG5vcm1hbGlzZUtleXBhdGgsIFJhY3RpdmUkb2JzZXJ2ZV9PYnNlcnZlciwgUmFjdGl2ZSRvYnNlcnZlX1BhdHRlcm5PYnNlcnZlciApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29ic2VydmUuanMgKi9cblx0dmFyIFJhY3RpdmUkb2JzZXJ2ZSA9IGZ1bmN0aW9uKCBpc09iamVjdCwgZ2V0T2JzZXJ2ZXJGYWNhZGUgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRvYnNlcnZlKCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBvYnNlcnZlcnMsIG1hcCwga2V5cGF0aHMsIGk7XG5cdFx0XHQvLyBBbGxvdyBhIG1hcCBvZiBrZXlwYXRocyB0byBoYW5kbGVyc1xuXHRcdFx0aWYgKCBpc09iamVjdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRvcHRpb25zID0gY2FsbGJhY2s7XG5cdFx0XHRcdG1hcCA9IGtleXBhdGg7XG5cdFx0XHRcdG9ic2VydmVycyA9IFtdO1xuXHRcdFx0XHRmb3IgKCBrZXlwYXRoIGluIG1hcCApIHtcblx0XHRcdFx0XHRpZiAoIG1hcC5oYXNPd25Qcm9wZXJ0eSgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBtYXBbIGtleXBhdGggXTtcblx0XHRcdFx0XHRcdG9ic2VydmVycy5wdXNoKCB0aGlzLm9ic2VydmUoIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBvYnNlcnZlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRvYnNlcnZlcnMucG9wKCkuY2FuY2VsKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gQWxsb3cgYHJhY3RpdmUub2JzZXJ2ZSggY2FsbGJhY2sgKWAgLSBpLmUuIG9ic2VydmUgZW50aXJlIG1vZGVsXG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRvcHRpb25zID0gY2FsbGJhY2s7XG5cdFx0XHRcdGNhbGxiYWNrID0ga2V5cGF0aDtcblx0XHRcdFx0a2V5cGF0aCA9ICcnO1xuXHRcdFx0XHRyZXR1cm4gZ2V0T2JzZXJ2ZXJGYWNhZGUoIHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHRrZXlwYXRocyA9IGtleXBhdGguc3BsaXQoICcgJyApO1xuXHRcdFx0Ly8gU2luZ2xlIGtleXBhdGhcblx0XHRcdGlmICgga2V5cGF0aHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZ2V0T2JzZXJ2ZXJGYWNhZGUoIHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBNdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQga2V5cGF0aHNcblx0XHRcdG9ic2VydmVycyA9IFtdO1xuXHRcdFx0aSA9IGtleXBhdGhzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRrZXlwYXRoID0ga2V5cGF0aHNbIGkgXTtcblx0XHRcdFx0aWYgKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdG9ic2VydmVycy5wdXNoKCBnZXRPYnNlcnZlckZhY2FkZSggdGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHdoaWxlICggb2JzZXJ2ZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdG9ic2VydmVycy5wb3AoKS5jYW5jZWwoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fSggaXNPYmplY3QsIFJhY3RpdmUkb2JzZXJ2ZV9nZXRPYnNlcnZlckZhY2FkZSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC90cmltLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF90cmltID0gZnVuY3Rpb24oIHN0ciApIHtcblx0XHRyZXR1cm4gc3RyLnRyaW0oKTtcblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbm90RW1wdHlTdHJpbmcuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX25vdEVtcHR5U3RyaW5nID0gZnVuY3Rpb24oIHN0ciApIHtcblx0XHRyZXR1cm4gc3RyICE9PSAnJztcblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vZmYuanMgKi9cblx0dmFyIFJhY3RpdmUkb2ZmID0gZnVuY3Rpb24oIHRyaW0sIG5vdEVtcHR5U3RyaW5nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkb2ZmKCBldmVudE5hbWUsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgZXZlbnROYW1lcztcblx0XHRcdC8vIGlmIG5vIGFyZ3VtZW50cyBzcGVjaWZpZWQsIHJlbW92ZSBhbGwgY2FsbGJhY2tzXG5cdFx0XHRpZiAoICFldmVudE5hbWUgKSB7XG5cdFx0XHRcdC8vIFRPRE8gdXNlIHRoaXMgY29kZSBpbnN0ZWFkLCBvbmNlIHRoZSBmb2xsb3dpbmcgaXNzdWUgaGFzIGJlZW4gcmVzb2x2ZWRcblx0XHRcdFx0Ly8gaW4gUGhhbnRvbUpTICh0ZXN0cyBhcmUgdW5wYXNzYWJsZSBvdGhlcndpc2UhKVxuXHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTg1NlxuXHRcdFx0XHQvLyBkZWZpbmVQcm9wZXJ0eSggdGhpcywgJ19zdWJzJywgeyB2YWx1ZTogY3JlYXRlKCBudWxsICksIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcblx0XHRcdFx0Zm9yICggZXZlbnROYW1lIGluIHRoaXMuX3N1YnMgKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3N1YnNbIGV2ZW50TmFtZSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGV2ZW50IG5hbWVzXG5cdFx0XHRcdGV2ZW50TmFtZXMgPSBldmVudE5hbWUuc3BsaXQoICcgJyApLm1hcCggdHJpbSApLmZpbHRlciggbm90RW1wdHlTdHJpbmcgKTtcblx0XHRcdFx0ZXZlbnROYW1lcy5mb3JFYWNoKCBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuXHRcdFx0XHRcdHZhciBzdWJzY3JpYmVycywgaW5kZXg7XG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBzdWJzY3JpYmVycyBmb3IgdGhpcyBldmVudC4uLlxuXHRcdFx0XHRcdGlmICggc3Vic2NyaWJlcnMgPSB0aGlzJDAuX3N1YnNbIGV2ZW50TmFtZSBdICkge1xuXHRcdFx0XHRcdFx0Ly8gLi4uaWYgYSBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCBvbmx5IHJlbW92ZSB0aGF0XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRpbmRleCA9IHN1YnNjcmliZXJzLmluZGV4T2YoIGNhbGxiYWNrICk7XG5cdFx0XHRcdFx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHRcdHN1YnNjcmliZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcyQwLl9zdWJzWyBldmVudE5hbWUgXSA9IFtdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfdHJpbSwgUmFjdGl2ZSRzaGFyZWRfbm90RW1wdHlTdHJpbmcgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vbi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvbiA9IGZ1bmN0aW9uKCB0cmltLCBub3RFbXB0eVN0cmluZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJG9uKCBldmVudE5hbWUsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdGxpc3RlbmVycywgbiwgZXZlbnROYW1lcztcblx0XHRcdC8vIGFsbG93IG11dGxpcGxlIGxpc3RlbmVycyB0byBiZSBib3VuZCBpbiBvbmUgZ29cblx0XHRcdGlmICggdHlwZW9mIGV2ZW50TmFtZSA9PT0gJ29iamVjdCcgKSB7XG5cdFx0XHRcdGxpc3RlbmVycyA9IFtdO1xuXHRcdFx0XHRmb3IgKCBuIGluIGV2ZW50TmFtZSApIHtcblx0XHRcdFx0XHRpZiAoIGV2ZW50TmFtZS5oYXNPd25Qcm9wZXJ0eSggbiApICkge1xuXHRcdFx0XHRcdFx0bGlzdGVuZXJzLnB1c2goIHRoaXMub24oIG4sIGV2ZW50TmFtZVsgbiBdICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIGxpc3RlbmVyO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBsaXN0ZW5lciA9IGxpc3RlbmVycy5wb3AoKSApIHtcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXIuY2FuY2VsKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gSGFuZGxlIG11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lc1xuXHRcdFx0ZXZlbnROYW1lcyA9IGV2ZW50TmFtZS5zcGxpdCggJyAnICkubWFwKCB0cmltICkuZmlsdGVyKCBub3RFbXB0eVN0cmluZyApO1xuXHRcdFx0ZXZlbnROYW1lcy5mb3JFYWNoKCBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuXHRcdFx0XHQoIHRoaXMkMC5fc3Vic1sgZXZlbnROYW1lIF0gfHwgKCB0aGlzJDAuX3N1YnNbIGV2ZW50TmFtZSBdID0gW10gKSApLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYub2ZmKCBldmVudE5hbWUsIGNhbGxiYWNrICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfdHJpbSwgUmFjdGl2ZSRzaGFyZWRfbm90RW1wdHlTdHJpbmcgKTtcblxuXHQvKiBzaGFyZWQvZ2V0TmV3SW5kaWNlcy5qcyAqL1xuXHR2YXIgZ2V0TmV3SW5kaWNlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4gYXJyYXksIHRoZSBuYW1lIG9mIGEgbXV0YXRvciBtZXRob2QsIGFuZCB0aGVcblx0XHQvLyBhcmd1bWVudHMgdG8gY2FsbCB0aGF0IG11dGF0b3IgbWV0aG9kIHdpdGgsIGFuZCByZXR1cm5zIGFuIGFycmF5IHRoYXRcblx0XHQvLyBtYXBzIHRoZSBvbGQgaW5kaWNlcyB0byB0aGVpciBuZXcgaW5kaWNlcy5cblx0XHQvLyBTbyBpZiB5b3UgaGFkIHNvbWV0aGluZyBsaWtlIHRoaXMuLi5cblx0XHQvL1xuXHRcdC8vICAgICBhcnJheSA9IFsgJ2EnLCAnYicsICdjJywgJ2QnIF07XG5cdFx0Ly8gICAgIGFycmF5LnB1c2goICdlJyApO1xuXHRcdC8vXG5cdFx0Ly8gLi4ueW91J2QgZ2V0IGBbIDAsIDEsIDIsIDMgXWAgLSBpbiBvdGhlciB3b3Jkcywgbm9uZSBvZiB0aGUgb2xkIGluZGljZXNcblx0XHQvLyBoYXZlIGNoYW5nZWQuIElmIHlvdSB0aGVuIGRpZCB0aGlzLi4uXG5cdFx0Ly9cblx0XHQvLyAgICAgYXJyYXkudW5zaGlmdCggJ3onICk7XG5cdFx0Ly9cblx0XHQvLyAuLi50aGUgaW5kaWNlcyB3b3VsZCBiZSBgWyAxLCAyLCAzLCA0LCA1IF1gIC0gZXZlcnkgaXRlbSBoYXMgYmVlbiBtb3ZlZFxuXHRcdC8vIG9uZSBoaWdoZXIgdG8gbWFrZSByb29tIGZvciB0aGUgJ3onLiBJZiB5b3UgcmVtb3ZlZCBhbiBpdGVtLCB0aGUgbmV3IGluZGV4XG5cdFx0Ly8gd291bGQgYmUgLTEuLi5cblx0XHQvL1xuXHRcdC8vICAgICBhcnJheS5zcGxpY2UoIDIsIDIgKTtcblx0XHQvL1xuXHRcdC8vIC4uLnRoaXMgd291bGQgcmVzdWx0IGluIFsgMCwgMSwgLTEsIC0xLCAyLCAzIF0uXG5cdFx0Ly9cblx0XHQvLyBUaGlzIGluZm9ybWF0aW9uIGlzIHVzZWQgdG8gZW5hYmxlIGZhc3QsIG5vbi1kZXN0cnVjdGl2ZSBzaHVmZmxpbmcgb2YgbGlzdFxuXHRcdC8vIHNlY3Rpb25zIHdoZW4geW91IGRvIGUuZy4gYHJhY3RpdmUuc3BsaWNlKCAnaXRlbXMnLCAyLCAyICk7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBnZXROZXdJbmRpY2VzKCBhcnJheSwgbWV0aG9kTmFtZSwgYXJncyApIHtcblx0XHRcdHZhciBzcGxpY2VBcmd1bWVudHMsIGxlbiwgbmV3SW5kaWNlcyA9IFtdLFxuXHRcdFx0XHRyZW1vdmVTdGFydCwgcmVtb3ZlRW5kLCBiYWxhbmNlLCBpO1xuXHRcdFx0c3BsaWNlQXJndW1lbnRzID0gZ2V0U3BsaWNlRXF1aXZhbGVudCggYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MgKTtcblx0XHRcdGlmICggIXNwbGljZUFyZ3VtZW50cyApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRsZW4gPSBhcnJheS5sZW5ndGg7XG5cdFx0XHRiYWxhbmNlID0gc3BsaWNlQXJndW1lbnRzLmxlbmd0aCAtIDIgLSBzcGxpY2VBcmd1bWVudHNbIDEgXTtcblx0XHRcdHJlbW92ZVN0YXJ0ID0gTWF0aC5taW4oIGxlbiwgc3BsaWNlQXJndW1lbnRzWyAwIF0gKTtcblx0XHRcdHJlbW92ZUVuZCA9IHJlbW92ZVN0YXJ0ICsgc3BsaWNlQXJndW1lbnRzWyAxIF07XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHJlbW92ZVN0YXJ0OyBpICs9IDEgKSB7XG5cdFx0XHRcdG5ld0luZGljZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBpIDwgcmVtb3ZlRW5kOyBpICs9IDEgKSB7XG5cdFx0XHRcdG5ld0luZGljZXMucHVzaCggLTEgKTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGkgKyBiYWxhbmNlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3SW5kaWNlcztcblx0XHR9O1xuXHRcdC8vIFRoZSBwb3AsIHB1c2gsIHNoaWZ0IGFuIHVuc2hpZnQgbWV0aG9kcyBjYW4gYWxsIGJlIHJlcHJlc2VudGVkXG5cdFx0Ly8gYXMgYW4gZXF1aXZhbGVudCBzcGxpY2Vcblx0XHRmdW5jdGlvbiBnZXRTcGxpY2VFcXVpdmFsZW50KCBhcnJheSwgbWV0aG9kTmFtZSwgYXJncyApIHtcblx0XHRcdHN3aXRjaCAoIG1ldGhvZE5hbWUgKSB7XG5cdFx0XHRcdGNhc2UgJ3NwbGljZSc6XG5cdFx0XHRcdFx0aWYgKCBhcmdzWyAwIF0gIT09IHVuZGVmaW5lZCAmJiBhcmdzWyAwIF0gPCAwICkge1xuXHRcdFx0XHRcdFx0YXJnc1sgMCBdID0gYXJyYXkubGVuZ3RoICsgTWF0aC5tYXgoIGFyZ3NbIDAgXSwgLWFycmF5Lmxlbmd0aCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIGFyZ3MubGVuZ3RoIDwgMiApIHtcblx0XHRcdFx0XHRcdGFyZ3MucHVzaCggMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBlbnN1cmUgd2Ugb25seSByZW1vdmUgZWxlbWVudHMgdGhhdCBleGlzdFxuXHRcdFx0XHRcdGFyZ3NbIDEgXSA9IE1hdGgubWluKCBhcmdzWyAxIF0sIGFycmF5Lmxlbmd0aCAtIGFyZ3NbIDAgXSApO1xuXHRcdFx0XHRcdHJldHVybiBhcmdzO1xuXHRcdFx0XHRjYXNlICdzb3J0Jzpcblx0XHRcdFx0Y2FzZSAncmV2ZXJzZSc6XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdGNhc2UgJ3BvcCc6XG5cdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdFx0XHRhcnJheS5sZW5ndGggLSAxLFxuXHRcdFx0XHRcdFx0XHQxXG5cdFx0XHRcdFx0XHRdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0Y2FzZSAncHVzaCc6XG5cdFx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRcdGFycmF5Lmxlbmd0aCxcblx0XHRcdFx0XHRcdDBcblx0XHRcdFx0XHRdLmNvbmNhdCggYXJncyApO1xuXHRcdFx0XHRjYXNlICdzaGlmdCc6XG5cdFx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHQxXG5cdFx0XHRcdFx0XTtcblx0XHRcdFx0Y2FzZSAndW5zaGlmdCc6XG5cdFx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHQwXG5cdFx0XHRcdFx0XS5jb25jYXQoIGFyZ3MgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VBcnJheU1ldGhvZC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kID0gZnVuY3Rpb24oIGlzQXJyYXksIHJ1bmxvb3AsIGdldE5ld0luZGljZXMgKSB7XG5cblx0XHR2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIG1ldGhvZE5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBTTElDRSQwID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRcdFx0XHR2YXIgYXJncyA9IFNMSUNFJDAuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cdFx0XHRcdHZhciBhcnJheSwgbmV3SW5kaWNlcyA9IFtdLFxuXHRcdFx0XHRcdGxlbiwgcHJvbWlzZSwgcmVzdWx0O1xuXHRcdFx0XHRhcnJheSA9IHRoaXMuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdGxlbiA9IGFycmF5Lmxlbmd0aDtcblx0XHRcdFx0aWYgKCAhaXNBcnJheSggYXJyYXkgKSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDYWxsZWQgcmFjdGl2ZS4nICsgbWV0aG9kTmFtZSArICcoXFwnJyArIGtleXBhdGggKyAnXFwnKSwgYnV0IFxcJycgKyBrZXlwYXRoICsgJ1xcJyBkb2VzIG5vdCByZWZlciB0byBhbiBhcnJheScgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXdJbmRpY2VzID0gZ2V0TmV3SW5kaWNlcyggYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MgKTtcblx0XHRcdFx0cmVzdWx0ID0gYXJyYXlQcm90b1sgbWV0aG9kTmFtZSBdLmFwcGx5KCBhcnJheSwgYXJncyApO1xuXHRcdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApLnRoZW4oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0aWYgKCAhIW5ld0luZGljZXMgKSB7XG5cdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwuc21hcnRVcGRhdGUoIGtleXBhdGgsIGFycmF5LCBuZXdJbmRpY2VzICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwubWFyaygga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCBpc0FycmF5LCBydW5sb29wLCBnZXROZXdJbmRpY2VzICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcG9wLmpzICovXG5cdHZhciBSYWN0aXZlJHBvcCA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAncG9wJyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9wdXNoLmpzICovXG5cdHZhciBSYWN0aXZlJHB1c2ggPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3B1c2gnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIGdsb2JhbC9jc3MuanMgKi9cblx0dmFyIGdsb2JhbF9jc3MgPSBmdW5jdGlvbiggY2lyY3VsYXIsIGlzQ2xpZW50LCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgY3NzLCB1cGRhdGUsIHJ1bmxvb3AsIHN0eWxlRWxlbWVudCwgaGVhZCwgc3R5bGVTaGVldCwgaW5Eb20sIHByZWZpeCA9ICcvKiBSYWN0aXZlLmpzIGNvbXBvbmVudCBzdHlsZXMgKi9cXG4nLFxuXHRcdFx0Y29tcG9uZW50c0luUGFnZSA9IHt9LFxuXHRcdFx0c3R5bGVzID0gW107XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRjc3MgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cnVubG9vcCA9IGNpcmN1bGFyLnJ1bmxvb3A7XG5cdFx0XHR9ICk7XG5cdFx0XHRzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnc3R5bGUnICk7XG5cdFx0XHRzdHlsZUVsZW1lbnQudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cdFx0XHRoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdoZWFkJyApWyAwIF07XG5cdFx0XHRpbkRvbSA9IGZhbHNlO1xuXHRcdFx0Ly8gSW50ZXJuZXQgRXhwbG9kZXIgd29uJ3QgbGV0IHlvdSB1c2Ugc3R5bGVTaGVldC5pbm5lckhUTUwgLSB3ZSBoYXZlIHRvXG5cdFx0XHQvLyB1c2Ugc3R5bGVTaGVldC5jc3NUZXh0IGluc3RlYWRcblx0XHRcdHN0eWxlU2hlZXQgPSBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldDtcblx0XHRcdHVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgY3NzO1xuXHRcdFx0XHRpZiAoIHN0eWxlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0Y3NzID0gcHJlZml4ICsgc3R5bGVzLmpvaW4oICcgJyApO1xuXHRcdFx0XHRcdGlmICggc3R5bGVTaGVldCApIHtcblx0XHRcdFx0XHRcdHN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3R5bGVFbGVtZW50LmlubmVySFRNTCA9IGNzcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhaW5Eb20gKSB7XG5cdFx0XHRcdFx0XHRoZWFkLmFwcGVuZENoaWxkKCBzdHlsZUVsZW1lbnQgKTtcblx0XHRcdFx0XHRcdGluRG9tID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGluRG9tICkge1xuXHRcdFx0XHRcdGhlYWQucmVtb3ZlQ2hpbGQoIHN0eWxlRWxlbWVudCApO1xuXHRcdFx0XHRcdGluRG9tID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRjc3MgPSB7XG5cdFx0XHRcdGFkZDogZnVuY3Rpb24oIENvbXBvbmVudCApIHtcblx0XHRcdFx0XHRpZiAoICFDb21wb25lbnQuY3NzICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICFjb21wb25lbnRzSW5QYWdlWyBDb21wb25lbnQuX2d1aWQgXSApIHtcblx0XHRcdFx0XHRcdC8vIHdlIGNyZWF0ZSB0aGlzIGNvdW50ZXIgc28gdGhhdCB3ZSBjYW4gaW4vZGVjcmVtZW50IGl0IGFzXG5cdFx0XHRcdFx0XHQvLyBpbnN0YW5jZXMgYXJlIGFkZGVkIGFuZCByZW1vdmVkLiBXaGVuIGFsbCBjb21wb25lbnRzIGFyZVxuXHRcdFx0XHRcdFx0Ly8gcmVtb3ZlZCwgdGhlIHN0eWxlIGlzIHRvb1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50c0luUGFnZVsgQ29tcG9uZW50Ll9ndWlkIF0gPSAwO1xuXHRcdFx0XHRcdFx0c3R5bGVzLnB1c2goIENvbXBvbmVudC5jc3MgKTtcblx0XHRcdFx0XHRcdHVwZGF0ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb21wb25lbnRzSW5QYWdlWyBDb21wb25lbnQuX2d1aWQgXSArPSAxO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCBDb21wb25lbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhQ29tcG9uZW50LmNzcyApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29tcG9uZW50c0luUGFnZVsgQ29tcG9uZW50Ll9ndWlkIF0gLT0gMTtcblx0XHRcdFx0XHRpZiAoICFjb21wb25lbnRzSW5QYWdlWyBDb21wb25lbnQuX2d1aWQgXSApIHtcblx0XHRcdFx0XHRcdHJlbW92ZUZyb21BcnJheSggc3R5bGVzLCBDb21wb25lbnQuY3NzICk7XG5cdFx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggdXBkYXRlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gY3NzO1xuXHR9KCBjaXJjdWxhciwgaXNDbGllbnQsIHJlbW92ZUZyb21BcnJheSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRyZW5kZXIgPSBmdW5jdGlvbiggY3NzLCBIb29rLCBnZXRFbGVtZW50LCBydW5sb29wICkge1xuXG5cdFx0dmFyIHJlbmRlckhvb2sgPSBuZXcgSG9vayggJ3JlbmRlcicgKSxcblx0XHRcdGNvbXBsZXRlSG9vayA9IG5ldyBIb29rKCAnY29tcGxldGUnICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkcmVuZGVyKCB0YXJnZXQsIGFuY2hvciApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHByb21pc2UsIGluc3RhbmNlcywgdHJhbnNpdGlvbnNFbmFibGVkO1xuXHRcdFx0Ly8gaWYgYG5vSW50cm9gIGlzIGB0cnVlYCwgdGVtcG9yYXJpbHkgZGlzYWJsZSB0cmFuc2l0aW9uc1xuXHRcdFx0dHJhbnNpdGlvbnNFbmFibGVkID0gdGhpcy50cmFuc2l0aW9uc0VuYWJsZWQ7XG5cdFx0XHRpZiAoIHRoaXMubm9JbnRybyApIHtcblx0XHRcdFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG5cdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiByZW5kZXJIb29rLmZpcmUoIHRoaXMkMCApO1xuXHRcdFx0fSwgdHJ1ZSApO1xuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50LnJlbmRlcmVkICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdZb3UgY2Fubm90IGNhbGwgcmFjdGl2ZS5yZW5kZXIoKSBvbiBhbiBhbHJlYWR5IHJlbmRlcmVkIGluc3RhbmNlISBDYWxsIHJhY3RpdmUudW5yZW5kZXIoKSBmaXJzdCcgKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldCA9IGdldEVsZW1lbnQoIHRhcmdldCApIHx8IHRoaXMuZWw7XG5cdFx0XHRhbmNob3IgPSBnZXRFbGVtZW50KCBhbmNob3IgKSB8fCB0aGlzLmFuY2hvcjtcblx0XHRcdHRoaXMuZWwgPSB0YXJnZXQ7XG5cdFx0XHR0aGlzLmFuY2hvciA9IGFuY2hvcjtcblx0XHRcdC8vIEFkZCBDU1MsIGlmIGFwcGxpY2FibGVcblx0XHRcdGlmICggdGhpcy5jb25zdHJ1Y3Rvci5jc3MgKSB7XG5cdFx0XHRcdGNzcy5hZGQoIHRoaXMuY29uc3RydWN0b3IgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGFyZ2V0ICkge1xuXHRcdFx0XHRpZiAoICEoIGluc3RhbmNlcyA9IHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gKSApIHtcblx0XHRcdFx0XHR0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fID0gWyB0aGlzIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aW5zdGFuY2VzLnB1c2goIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGFuY2hvciApIHtcblx0XHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCB0aGlzLmZyYWdtZW50LnJlbmRlcigpLCBhbmNob3IgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIHRoaXMuZnJhZ21lbnQucmVuZGVyKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gdHJhbnNpdGlvbnNFbmFibGVkO1xuXHRcdFx0Ly8gSXQgaXMgbm93IG1vcmUgcHJvYmxlbWF0aWMgdG8ga25vdyBpZiB0aGUgY29tcGxldGUgaG9va1xuXHRcdFx0Ly8gd291bGQgZmlyZS4gTWV0aG9kIGNoZWNraW5nIGlzIHN0cmFpZ2h0LWZvcndhcmQsIGJ1dCB3b3VsZFxuXHRcdFx0Ly8gYWxzbyByZXF1aXJlIHByZWZsaWdodGluZyBldmVudCBzdWJzY3JpcHRpb25zLiBXaGljaCBzZWVtc1xuXHRcdFx0Ly8gbGlrZSBtb3JlIHdvcmsgdGhlbiBqdXN0IGxldHRpbmcgdGhlIHByb21pc2UgaGFwcGVuLlxuXHRcdFx0Ly8gQnV0IHBlcmhhcHMgSSdtIHdyb25nIGFib3V0IHRoYXQuLi5cblx0XHRcdHByb21pc2UudGhlbiggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBjb21wbGV0ZUhvb2suZmlyZSggdGhpcyQwICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBnbG9iYWxfY3NzLCBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rLCBnZXRFbGVtZW50LCBydW5sb29wICk7XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvYnViYmxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGJ1YmJsZSA9IGZ1bmN0aW9uIEZyYWdtZW50JGJ1YmJsZSgpIHtcblx0XHR0aGlzLmRpcnR5VmFsdWUgPSB0aGlzLmRpcnR5QXJncyA9IHRydWU7XG5cdFx0aWYgKCB0aGlzLmJvdW5kICYmIHR5cGVvZiB0aGlzLm93bmVyLmJ1YmJsZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHRoaXMub3duZXIuYnViYmxlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2RldGFjaC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRkZXRhY2ggPSBmdW5jdGlvbiBGcmFnbWVudCRkZXRhY2goKSB7XG5cdFx0dmFyIGRvY0ZyYWc7XG5cdFx0aWYgKCB0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdHJldHVybiB0aGlzLml0ZW1zWyAwIF0uZGV0YWNoKCk7XG5cdFx0fVxuXHRcdGRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0dGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdHZhciBub2RlID0gaXRlbS5kZXRhY2goKTtcblx0XHRcdC8vIFRPRE8gVGhlIGlmIHsuLi59IHdhc24ndCBwcmV2aW91c2x5IHJlcXVpcmVkIC0gaXQgaXMgbm93LCBiZWNhdXNlIHdlJ3JlXG5cdFx0XHQvLyBmb3JjaWJseSBkZXRhY2hpbmcgZXZlcnl0aGluZyB0byByZW9yZGVyIHNlY3Rpb25zIGFmdGVyIGFuIHVwZGF0ZS4gVGhhdCdzXG5cdFx0XHQvLyBhIG5vbi1pZGVhbCBicnV0ZSBmb3JjZSBhcHByb2FjaCwgaW1wbGVtZW50ZWQgdG8gZ2V0IGFsbCB0aGUgdGVzdHMgdG8gcGFzc1xuXHRcdFx0Ly8gLSBhcyBzb29uIGFzIGl0J3MgcmVwbGFjZWQgd2l0aCBzb21ldGhpbmcgbW9yZSBlbGVnYW50LCB0aGlzIHNob3VsZFxuXHRcdFx0Ly8gcmV2ZXJ0IHRvIGBkb2NGcmFnLmFwcGVuZENoaWxkKCBpdGVtLmRldGFjaCgpIClgXG5cdFx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoIG5vZGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIGRvY0ZyYWc7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kID0gZnVuY3Rpb24gRnJhZ21lbnQkZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIGxlbiwgaXRlbSwgcXVlcnlSZXN1bHQ7XG5cdFx0aWYgKCB0aGlzLml0ZW1zICkge1xuXHRcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGl0ZW0uZmluZCAmJiAoIHF1ZXJ5UmVzdWx0ID0gaXRlbS5maW5kKCBzZWxlY3RvciApICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kQWxsID0gZnVuY3Rpb24gRnJhZ21lbnQkZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHZhciBpLCBsZW4sIGl0ZW07XG5cdFx0aWYgKCB0aGlzLml0ZW1zICkge1xuXHRcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGl0ZW0uZmluZEFsbCApIHtcblx0XHRcdFx0XHRpdGVtLmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBxdWVyeTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9maW5kQWxsQ29tcG9uZW50cy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0dmFyIGksIGxlbiwgaXRlbTtcblx0XHRpZiAoIHRoaXMuaXRlbXMgKSB7XG5cdFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zWyBpIF07XG5cdFx0XHRcdGlmICggaXRlbS5maW5kQWxsQ29tcG9uZW50cyApIHtcblx0XHRcdFx0XHRpdGVtLmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcXVlcnk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmluZENvbXBvbmVudC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gRnJhZ21lbnQkZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGxlbiwgaSwgaXRlbSwgcXVlcnlSZXN1bHQ7XG5cdFx0aWYgKCB0aGlzLml0ZW1zICkge1xuXHRcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGl0ZW0uZmluZENvbXBvbmVudCAmJiAoIHF1ZXJ5UmVzdWx0ID0gaXRlbS5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmluZE5leHROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmROZXh0Tm9kZSA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmROZXh0Tm9kZSggaXRlbSApIHtcblx0XHR2YXIgaW5kZXggPSBpdGVtLmluZGV4LFxuXHRcdFx0bm9kZTtcblx0XHRpZiAoIHRoaXMuaXRlbXNbIGluZGV4ICsgMSBdICkge1xuXHRcdFx0bm9kZSA9IHRoaXMuaXRlbXNbIGluZGV4ICsgMSBdLmZpcnN0Tm9kZSgpO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMub3duZXIgPT09IHRoaXMucm9vdCApIHtcblx0XHRcdGlmICggIXRoaXMub3duZXIuY29tcG9uZW50ICkge1xuXHRcdFx0XHQvLyBUT0RPIGJ1dCBzb21ldGhpbmcgZWxzZSBjb3VsZCBoYXZlIGJlZW4gYXBwZW5kZWQgdG9cblx0XHRcdFx0Ly8gdGhpcy5yb290LmVsLCBubz9cblx0XHRcdFx0bm9kZSA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlID0gdGhpcy5vd25lci5jb21wb25lbnQuZmluZE5leHROb2RlKCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5vZGUgPSB0aGlzLm93bmVyLmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9maXJzdE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmlyc3ROb2RlID0gZnVuY3Rpb24gRnJhZ21lbnQkZmlyc3ROb2RlKCkge1xuXHRcdGlmICggdGhpcy5pdGVtcyAmJiB0aGlzLml0ZW1zWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pdGVtc1sgMCBdLmZpcnN0Tm9kZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9nZXROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGdldE5vZGUgPSBmdW5jdGlvbiBGcmFnbWVudCRnZXROb2RlKCkge1xuXHRcdHZhciBmcmFnbWVudCA9IHRoaXM7XG5cdFx0ZG8ge1xuXHRcdFx0aWYgKCBmcmFnbWVudC5wRWxlbWVudCApIHtcblx0XHRcdFx0cmV0dXJuIGZyYWdtZW50LnBFbGVtZW50Lm5vZGU7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoIGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50ICk7XG5cdFx0cmV0dXJuIHRoaXMucm9vdC5kZXRhY2hlZCB8fCB0aGlzLnJvb3QuZWw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZ2V0VmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZ2V0VmFsdWUgPSBmdW5jdGlvbiggcGFyc2VKU09OICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBlbXB0eSA9IHt9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gRnJhZ21lbnQkZ2V0VmFsdWUoKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sgMCBdO1xuXHRcdFx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKVxuXHRcdFx0XHRvcHRpb25zID0gZW1wdHk7XG5cdFx0XHR2YXIgYXNBcmdzLCB2YWx1ZXMsIHNvdXJjZSwgcGFyc2VkLCBjYWNoZWRSZXN1bHQsIGRpcnR5RmxhZywgcmVzdWx0O1xuXHRcdFx0YXNBcmdzID0gb3B0aW9ucy5hcmdzO1xuXHRcdFx0Y2FjaGVkUmVzdWx0ID0gYXNBcmdzID8gJ2FyZ3NMaXN0JyA6ICd2YWx1ZSc7XG5cdFx0XHRkaXJ0eUZsYWcgPSBhc0FyZ3MgPyAnZGlydHlBcmdzJyA6ICdkaXJ0eVZhbHVlJztcblx0XHRcdGlmICggdGhpc1sgZGlydHlGbGFnIF0gKSB7XG5cdFx0XHRcdHNvdXJjZSA9IHByb2Nlc3NJdGVtcyggdGhpcy5pdGVtcywgdmFsdWVzID0ge30sIHRoaXMucm9vdC5fZ3VpZCApO1xuXHRcdFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oIGFzQXJncyA/ICdbJyArIHNvdXJjZSArICddJyA6IHNvdXJjZSwgdmFsdWVzICk7XG5cdFx0XHRcdGlmICggIXBhcnNlZCApIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBhc0FyZ3MgPyBbIHRoaXMudG9TdHJpbmcoKSBdIDogdGhpcy50b1N0cmluZygpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc3VsdCA9IHBhcnNlZC52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzWyBjYWNoZWRSZXN1bHQgXSA9IHJlc3VsdDtcblx0XHRcdFx0dGhpc1sgZGlydHlGbGFnIF0gPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzWyBjYWNoZWRSZXN1bHQgXTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc0l0ZW1zKCBpdGVtcywgdmFsdWVzLCBndWlkLCBjb3VudGVyICkge1xuXHRcdFx0Y291bnRlciA9IGNvdW50ZXIgfHwgMDtcblx0XHRcdHJldHVybiBpdGVtcy5tYXAoIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHR2YXIgcGxhY2Vob2xkZXJJZCwgd3JhcHBlZCwgdmFsdWU7XG5cdFx0XHRcdGlmICggaXRlbS50ZXh0ICkge1xuXHRcdFx0XHRcdHJldHVybiBpdGVtLnRleHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBpdGVtLmZyYWdtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gaXRlbS5mcmFnbWVudHMubWFwKCBmdW5jdGlvbiggZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvY2Vzc0l0ZW1zKCBmcmFnbWVudC5pdGVtcywgdmFsdWVzLCBndWlkLCBjb3VudGVyICk7XG5cdFx0XHRcdFx0fSApLmpvaW4oICcnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGxhY2Vob2xkZXJJZCA9IGd1aWQgKyAnLScgKyBjb3VudGVyKys7XG5cdFx0XHRcdGlmICggd3JhcHBlZCA9IGl0ZW0ucm9vdC52aWV3bW9kZWwud3JhcHBlZFsgaXRlbS5rZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB3cmFwcGVkLnZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gaXRlbS5nZXRWYWx1ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlc1sgcGxhY2Vob2xkZXJJZCBdID0gdmFsdWU7XG5cdFx0XHRcdHJldHVybiAnJHsnICsgcGxhY2Vob2xkZXJJZCArICd9Jztcblx0XHRcdH0gKS5qb2luKCAnJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHBhcnNlSlNPTiApO1xuXG5cdC8qIHV0aWxzL2VzY2FwZUh0bWwuanMgKi9cblx0dmFyIGVzY2FwZUh0bWwgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBsZXNzVGhhbiA9IC88L2c7XG5cdFx0dmFyIGdyZWF0ZXJUaGFuID0gLz4vZztcblx0XHR2YXIgYW1wID0gLyYvZztcblx0XHRyZXR1cm4gZnVuY3Rpb24gZXNjYXBlSHRtbCggc3RyICkge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKCBhbXAsICcmYW1wOycgKS5yZXBsYWNlKCBsZXNzVGhhbiwgJyZsdDsnICkucmVwbGFjZSggZ3JlYXRlclRoYW4sICcmZ3Q7JyApO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB1dGlscy9kZXRhY2hOb2RlLmpzICovXG5cdHZhciBkZXRhY2hOb2RlID0gZnVuY3Rpb24gZGV0YWNoTm9kZSggbm9kZSApIHtcblx0XHRpZiAoIG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL2RldGFjaC5qcyAqL1xuXHR2YXIgZGV0YWNoID0gZnVuY3Rpb24oIGRldGFjaE5vZGUgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZGV0YWNoTm9kZSggdGhpcy5ub2RlICk7XG5cdFx0fTtcblx0fSggZGV0YWNoTm9kZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVGV4dC5qcyAqL1xuXHR2YXIgVGV4dCA9IGZ1bmN0aW9uKCB0eXBlcywgZXNjYXBlSHRtbCwgZGV0YWNoICkge1xuXG5cdFx0dmFyIFRleHQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLlRFWFQ7XG5cdFx0XHR0aGlzLnRleHQgPSBvcHRpb25zLnRlbXBsYXRlO1xuXHRcdH07XG5cdFx0VGV4dC5wcm90b3R5cGUgPSB7XG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpcnN0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCB0aGlzLnRleHQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fSxcblx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbiggZXNjYXBlICkge1xuXHRcdFx0XHRyZXR1cm4gZXNjYXBlID8gZXNjYXBlSHRtbCggdGhpcy50ZXh0ICkgOiB0aGlzLnRleHQ7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRpZiAoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZGV0YWNoKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBUZXh0O1xuXHR9KCB0eXBlcywgZXNjYXBlSHRtbCwgZGV0YWNoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvdW5iaW5kLmpzICovXG5cdHZhciB1bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQoKSB7XG5cdFx0aWYgKCB0aGlzLnJlZ2lzdGVyZWQgKSB7XG5cdFx0XHQvLyB0aGlzIHdhcyByZWdpc3RlcmVkIGFzIGEgZGVwZW5kYW50XG5cdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMucmVzb2x2ZXIgKSB7XG5cdFx0XHR0aGlzLnJlc29sdmVyLnVuYmluZCgpO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9NdXN0YWNoZS9nZXRWYWx1ZS5qcyAqL1xuXHR2YXIgZ2V0VmFsdWUgPSBmdW5jdGlvbiBNdXN0YWNoZSRnZXRWYWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC91dGlscy9zdGFydHNXaXRoS2V5cGF0aC5qcyAqL1xuXHR2YXIgc3RhcnRzV2l0aEtleXBhdGggPSBmdW5jdGlvbiBzdGFydHNXaXRoS2V5cGF0aCggdGFyZ2V0LCBrZXlwYXRoICkge1xuXHRcdHJldHVybiB0YXJnZXQgJiYga2V5cGF0aCAmJiB0YXJnZXQuc3Vic3RyKCAwLCBrZXlwYXRoLmxlbmd0aCArIDEgKSA9PT0ga2V5cGF0aCArICcuJztcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC91dGlscy9nZXROZXdLZXlwYXRoLmpzICovXG5cdHZhciBnZXROZXdLZXlwYXRoID0gZnVuY3Rpb24oIHN0YXJ0c1dpdGhLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldE5ld0tleXBhdGgoIHRhcmdldEtleXBhdGgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHQvLyBleGFjdCBtYXRjaFxuXHRcdFx0aWYgKCB0YXJnZXRLZXlwYXRoID09PSBvbGRLZXlwYXRoICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3S2V5cGF0aCAhPT0gdW5kZWZpbmVkID8gbmV3S2V5cGF0aCA6IG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBwYXJ0aWFsIG1hdGNoIGJhc2VkIG9uIGxlYWRpbmcga2V5cGF0aCBzZWdtZW50c1xuXHRcdFx0aWYgKCBzdGFydHNXaXRoS2V5cGF0aCggdGFyZ2V0S2V5cGF0aCwgb2xkS2V5cGF0aCApICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3S2V5cGF0aCA9PT0gbnVsbCA/IG5ld0tleXBhdGggOiB0YXJnZXRLZXlwYXRoLnJlcGxhY2UoIG9sZEtleXBhdGggKyAnLicsIG5ld0tleXBhdGggKyAnLicgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBzdGFydHNXaXRoS2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL1Jlc29sdmVycy9SZWZlcmVuY2VSZXNvbHZlci5qcyAqL1xuXHR2YXIgUmVmZXJlbmNlUmVzb2x2ZXIgPSBmdW5jdGlvbiggcnVubG9vcCwgcmVzb2x2ZVJlZiwgZ2V0TmV3S2V5cGF0aCApIHtcblxuXHRcdHZhciBSZWZlcmVuY2VSZXNvbHZlciA9IGZ1bmN0aW9uKCBvd25lciwgcmVmLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBrZXlwYXRoO1xuXHRcdFx0dGhpcy5yZWYgPSByZWY7XG5cdFx0XHR0aGlzLnJlc29sdmVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLnJvb3QgPSBvd25lci5yb290O1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IG93bmVyLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0a2V5cGF0aCA9IHJlc29sdmVSZWYoIG93bmVyLnJvb3QsIHJlZiwgb3duZXIucGFyZW50RnJhZ21lbnQgKTtcblx0XHRcdGlmICgga2V5cGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnJlc29sdmUoIGtleXBhdGggKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJ1bmxvb3AuYWRkVW5yZXNvbHZlZCggdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0UmVmZXJlbmNlUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0cmVzb2x2ZTogZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0XHR0aGlzLmNhbGxiYWNrKCBrZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yZXNvbHZlKCB0aGlzLnJlZiApO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGtleXBhdGg7XG5cdFx0XHRcdGlmICggdGhpcy5rZXlwYXRoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0a2V5cGF0aCA9IGdldE5ld0tleXBhdGgoIHRoaXMua2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRcdC8vIHdhcyBhIG5ldyBrZXlwYXRoIGNyZWF0ZWQ/XG5cdFx0XHRcdFx0aWYgKCBrZXlwYXRoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHQvLyByZXNvbHZlIGl0XG5cdFx0XHRcdFx0XHR0aGlzLnJlc29sdmUoIGtleXBhdGggKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLnJlc29sdmVkICkge1xuXHRcdFx0XHRcdHJ1bmxvb3AucmVtb3ZlVW5yZXNvbHZlZCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gUmVmZXJlbmNlUmVzb2x2ZXI7XG5cdH0oIHJ1bmxvb3AsIHJlc29sdmVSZWYsIGdldE5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvU3BlY2lhbFJlc29sdmVyLmpzICovXG5cdHZhciBTcGVjaWFsUmVzb2x2ZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBTcGVjaWFsUmVzb2x2ZXIgPSBmdW5jdGlvbiggb3duZXIsIHJlZiwgY2FsbGJhY2sgKSB7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gb3duZXIucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLnJlZiA9IHJlZjtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMucmViaW5kKCk7XG5cdFx0fTtcblx0XHRTcGVjaWFsUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0cmViaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJlZiA9IHRoaXMucmVmLFxuXHRcdFx0XHRcdGZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdFx0aWYgKCByZWYgPT09ICdAa2V5cGF0aCcgKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCBmcmFnbWVudCApIHtcblx0XHRcdFx0XHRcdGlmICggISFmcmFnbWVudC5jb250ZXh0ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jYWxsYmFjayggJ0AnICsgZnJhZ21lbnQuY29udGV4dCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggcmVmID09PSAnQGluZGV4JyB8fCByZWYgPT09ICdAa2V5JyApIHtcblx0XHRcdFx0XHR3aGlsZSAoIGZyYWdtZW50ICkge1xuXHRcdFx0XHRcdFx0aWYgKCBmcmFnbWVudC5pbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jYWxsYmFjayggJ0AnICsgZnJhZ21lbnQuaW5kZXggKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdVbmtub3duIHNwZWNpYWwgcmVmZXJlbmNlIFwiJyArIHJlZiArICdcIiAtIHZhbGlkIHJlZmVyZW5jZXMgYXJlIEBpbmRleCwgQGtleSBhbmQgQGtleXBhdGgnICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHt9XG5cdFx0fTtcblx0XHRyZXR1cm4gU3BlY2lhbFJlc29sdmVyO1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL0luZGV4UmVzb2x2ZXIuanMgKi9cblx0dmFyIEluZGV4UmVzb2x2ZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBJbmRleFJlc29sdmVyID0gZnVuY3Rpb24oIG93bmVyLCByZWYsIGNhbGxiYWNrICkge1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IG93bmVyLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5yZWYgPSByZWY7XG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR0aGlzLnJlYmluZCgpO1xuXHRcdH07XG5cdFx0SW5kZXhSZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmVmID0gdGhpcy5yZWYsXG5cdFx0XHRcdFx0aW5kZXhSZWZzID0gdGhpcy5wYXJlbnRGcmFnbWVudC5pbmRleFJlZnMsXG5cdFx0XHRcdFx0aW5kZXggPSBpbmRleFJlZnNbIHJlZiBdO1xuXHRcdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5jYWxsYmFjayggJ0AnICsgaW5kZXggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7fVxuXHRcdH07XG5cdFx0cmV0dXJuIEluZGV4UmVzb2x2ZXI7XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIuanMgKi9cblx0dmFyIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyID0gZnVuY3Rpb24oIFJlZmVyZW5jZVJlc29sdmVyLCBTcGVjaWFsUmVzb2x2ZXIsIEluZGV4UmVzb2x2ZXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoIG93bmVyLCByZWYsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIGluZGV4UmVmcywgaW5kZXg7XG5cdFx0XHRpZiAoIHJlZi5jaGFyQXQoIDAgKSA9PT0gJ0AnICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFNwZWNpYWxSZXNvbHZlciggb3duZXIsIHJlZiwgY2FsbGJhY2sgKTtcblx0XHRcdH1cblx0XHRcdGluZGV4UmVmcyA9IG93bmVyLnBhcmVudEZyYWdtZW50LmluZGV4UmVmcztcblx0XHRcdGlmICggaW5kZXhSZWZzICYmICggaW5kZXggPSBpbmRleFJlZnNbIHJlZiBdICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBJbmRleFJlc29sdmVyKCBvd25lciwgcmVmLCBjYWxsYmFjayApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBSZWZlcmVuY2VSZXNvbHZlciggb3duZXIsIHJlZiwgY2FsbGJhY2sgKTtcblx0XHR9O1xuXHR9KCBSZWZlcmVuY2VSZXNvbHZlciwgU3BlY2lhbFJlc29sdmVyLCBJbmRleFJlc29sdmVyICk7XG5cblx0Lyogc2hhcmVkL2dldEZ1bmN0aW9uRnJvbVN0cmluZy5qcyAqL1xuXHR2YXIgZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgY2FjaGUgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nKCBzdHIsIGkgKSB7XG5cdFx0XHR2YXIgZm4sIGFyZ3M7XG5cdFx0XHRpZiAoIGNhY2hlWyBzdHIgXSApIHtcblx0XHRcdFx0cmV0dXJuIGNhY2hlWyBzdHIgXTtcblx0XHRcdH1cblx0XHRcdGFyZ3MgPSBbXTtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRhcmdzWyBpIF0gPSAnXycgKyBpO1xuXHRcdFx0fVxuXHRcdFx0Zm4gPSBuZXcgRnVuY3Rpb24oIGFyZ3Muam9pbiggJywnICksICdyZXR1cm4oJyArIHN0ciArICcpJyApO1xuXHRcdFx0Y2FjaGVbIHN0ciBdID0gZm47XG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL1Jlc29sdmVycy9FeHByZXNzaW9uUmVzb2x2ZXIuanMgKi9cblx0dmFyIEV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uKCBkZWZpbmVQcm9wZXJ0eSwgaXNOdW1lcmljLCBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciwgZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBFeHByZXNzaW9uUmVzb2x2ZXIsIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcblx0XHRFeHByZXNzaW9uUmVzb2x2ZXIgPSBmdW5jdGlvbiggb3duZXIsIHBhcmVudEZyYWdtZW50LCBleHByZXNzaW9uLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciByZXNvbHZlciA9IHRoaXMsXG5cdFx0XHRcdHJhY3RpdmUsIGluZGV4UmVmcztcblx0XHRcdHJhY3RpdmUgPSBvd25lci5yb290O1xuXHRcdFx0cmVzb2x2ZXIucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHRyZXNvbHZlci5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuXHRcdFx0cmVzb2x2ZXIuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHJlc29sdmVyLm93bmVyID0gb3duZXI7XG5cdFx0XHRyZXNvbHZlci5zdHIgPSBleHByZXNzaW9uLnM7XG5cdFx0XHRyZXNvbHZlci5rZXlwYXRocyA9IFtdO1xuXHRcdFx0aW5kZXhSZWZzID0gcGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzO1xuXHRcdFx0Ly8gQ3JlYXRlIHJlc29sdmVycyBmb3IgZWFjaCByZWZlcmVuY2Vcblx0XHRcdHJlc29sdmVyLnBlbmRpbmcgPSBleHByZXNzaW9uLnIubGVuZ3RoO1xuXHRcdFx0cmVzb2x2ZXIucmVmUmVzb2x2ZXJzID0gZXhwcmVzc2lvbi5yLm1hcCggZnVuY3Rpb24oIHJlZiwgaSApIHtcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKCByZXNvbHZlciwgcmVmLCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXNvbHZlci5yZXNvbHZlKCBpLCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gKTtcblx0XHRcdHJlc29sdmVyLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdHJlc29sdmVyLmJ1YmJsZSgpO1xuXHRcdH07XG5cdFx0RXhwcmVzc2lvblJlc29sdmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMucmVhZHkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudW5pcXVlU3RyaW5nID0gZ2V0VW5pcXVlU3RyaW5nKCB0aGlzLnN0ciwgdGhpcy5rZXlwYXRocyApO1xuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBnZXRLZXlwYXRoKCB0aGlzLnVuaXF1ZVN0cmluZyApO1xuXHRcdFx0XHR0aGlzLmNyZWF0ZUV2YWx1YXRvcigpO1xuXHRcdFx0XHR0aGlzLmNhbGxiYWNrKCB0aGlzLmtleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmVzb2x2ZXI7XG5cdFx0XHRcdHdoaWxlICggcmVzb2x2ZXIgPSB0aGlzLnJlZlJlc29sdmVycy5wb3AoKSApIHtcblx0XHRcdFx0XHRyZXNvbHZlci51bmJpbmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlc29sdmU6IGZ1bmN0aW9uKCBpbmRleCwga2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5rZXlwYXRoc1sgaW5kZXggXSA9IGtleXBhdGg7XG5cdFx0XHRcdHRoaXMuYnViYmxlKCk7XG5cdFx0XHR9LFxuXHRcdFx0Y3JlYXRlRXZhbHVhdG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdFx0XHRjb21wdXRhdGlvbiwgdmFsdWVHZXR0ZXJzLCBzaWduYXR1cmUsIGtleXBhdGgsIGZuO1xuXHRcdFx0XHRjb21wdXRhdGlvbiA9IHRoaXMucm9vdC52aWV3bW9kZWwuY29tcHV0YXRpb25zWyB0aGlzLmtleXBhdGggXTtcblx0XHRcdFx0Ly8gb25seSBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldCFcblx0XHRcdFx0aWYgKCAhY29tcHV0YXRpb24gKSB7XG5cdFx0XHRcdFx0Zm4gPSBnZXRGdW5jdGlvbkZyb21TdHJpbmcoIHRoaXMuc3RyLCB0aGlzLnJlZlJlc29sdmVycy5sZW5ndGggKTtcblx0XHRcdFx0XHR2YWx1ZUdldHRlcnMgPSB0aGlzLmtleXBhdGhzLm1hcCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRcdFx0XHRpZiAoIGtleXBhdGggPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vICdzcGVjaWFsJyBrZXlwYXRocyBlbmNvZGUgYSB2YWx1ZVxuXHRcdFx0XHRcdFx0aWYgKCBrZXlwYXRoWyAwIF0gPT09ICdAJyApIHtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBrZXlwYXRoLnNsaWNlKCAxICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBpc051bWVyaWMoIHZhbHVlICkgPyBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gK3ZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9IDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzJDAucm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gd3JhcEZ1bmN0aW9uKCB2YWx1ZSwgc2VsZi5yb290ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0c2lnbmF0dXJlID0ge1xuXHRcdFx0XHRcdFx0ZGVwczogdGhpcy5rZXlwYXRocy5maWx0ZXIoIGlzVmFsaWREZXBlbmRlbmN5ICksXG5cdFx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYXJncyA9IHZhbHVlR2V0dGVycy5tYXAoIGNhbGwgKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBudWxsLCBhcmdzICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRjb21wdXRhdGlvbiA9IHRoaXMucm9vdC52aWV3bW9kZWwuY29tcHV0ZSggdGhpcy5rZXlwYXRoLCBzaWduYXR1cmUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLm1hcmsoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHQvLyBUT0RPIG9ubHkgYnViYmxlIG9uY2UsIG5vIG1hdHRlciBob3cgbWFueSByZWZlcmVuY2VzIGFyZSBhZmZlY3RlZCBieSB0aGUgcmViaW5kXG5cdFx0XHRcdHRoaXMucmVmUmVzb2x2ZXJzLmZvckVhY2goIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdHJldHVybiByLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdF9fZXhwb3J0ID0gRXhwcmVzc2lvblJlc29sdmVyO1xuXG5cdFx0ZnVuY3Rpb24gY2FsbCggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUuY2FsbCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFVuaXF1ZVN0cmluZyggc3RyLCBrZXlwYXRocyApIHtcblx0XHRcdC8vIGdldCBzdHJpbmcgdGhhdCBpcyB1bmlxdWUgdG8gdGhpcyBleHByZXNzaW9uXG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoIC9fKFswLTldKykvZywgZnVuY3Rpb24oIG1hdGNoLCAkMSApIHtcblx0XHRcdFx0dmFyIGtleXBhdGgsIHZhbHVlO1xuXHRcdFx0XHRrZXlwYXRoID0ga2V5cGF0aHNbICQxIF07XG5cdFx0XHRcdGlmICgga2V5cGF0aCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiAndW5kZWZpbmVkJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGtleXBhdGhbIDAgXSA9PT0gJ0AnICkge1xuXHRcdFx0XHRcdHZhbHVlID0ga2V5cGF0aC5zbGljZSggMSApO1xuXHRcdFx0XHRcdHJldHVybiBpc051bWVyaWMoIHZhbHVlICkgPyB2YWx1ZSA6ICdcIicgKyB2YWx1ZSArICdcIic7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGtleXBhdGg7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0S2V5cGF0aCggdW5pcXVlU3RyaW5nICkge1xuXHRcdFx0Ly8gU2FuaXRpemUgYnkgcmVtb3ZpbmcgYW55IHBlcmlvZHMgb3Igc3F1YXJlIGJyYWNrZXRzLiBPdGhlcndpc2Vcblx0XHRcdC8vIHdlIGNhbid0IHNwbGl0IHRoZSBrZXlwYXRoIGludG8ga2V5cyFcblx0XHRcdHJldHVybiAnJHsnICsgdW5pcXVlU3RyaW5nLnJlcGxhY2UoIC9bXFwuXFxbXFxdXS9nLCAnLScgKSArICd9Jztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1ZhbGlkRGVwZW5kZW5jeSgga2V5cGF0aCApIHtcblx0XHRcdHJldHVybiBrZXlwYXRoICE9PSB1bmRlZmluZWQgJiYga2V5cGF0aFsgMCBdICE9PSAnQCc7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gd3JhcEZ1bmN0aW9uKCBmbiwgcmFjdGl2ZSApIHtcblx0XHRcdHZhciB3cmFwcGVkLCBwcm9wLCBrZXk7XG5cdFx0XHRpZiAoIGZuLl9ub1dyYXAgKSB7XG5cdFx0XHRcdHJldHVybiBmbjtcblx0XHRcdH1cblx0XHRcdHByb3AgPSAnX19yYWN0aXZlXycgKyByYWN0aXZlLl9ndWlkO1xuXHRcdFx0d3JhcHBlZCA9IGZuWyBwcm9wIF07XG5cdFx0XHRpZiAoIHdyYXBwZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3cmFwcGVkO1xuXHRcdFx0fSBlbHNlIGlmICggL3RoaXMvLnRlc3QoIGZuLnRvU3RyaW5nKCkgKSApIHtcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoIGZuLCBwcm9wLCB7XG5cdFx0XHRcdFx0dmFsdWU6IGJpbmQuY2FsbCggZm4sIHJhY3RpdmUgKVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdC8vIEFkZCBwcm9wZXJ0aWVzL21ldGhvZHMgdG8gd3JhcHBlZCBmdW5jdGlvblxuXHRcdFx0XHRmb3IgKCBrZXkgaW4gZm4gKSB7XG5cdFx0XHRcdFx0aWYgKCBmbi5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0XHRmblsgcHJvcCBdWyBrZXkgXSA9IGZuWyBrZXkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZuWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSggZm4sICdfX3JhY3RpdmVfbm93cmFwJywge1xuXHRcdFx0XHR2YWx1ZTogZm5cblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBmbi5fX3JhY3RpdmVfbm93cmFwO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGRlZmluZVByb3BlcnR5LCBpc051bWVyaWMsIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyLCBnZXRGdW5jdGlvbkZyb21TdHJpbmcsIGxlZ2FjeSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL1Jlc29sdmVycy9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIvTWVtYmVyUmVzb2x2ZXIuanMgKi9cblx0dmFyIE1lbWJlclJlc29sdmVyID0gZnVuY3Rpb24oIHR5cGVzLCBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciwgRXhwcmVzc2lvblJlc29sdmVyICkge1xuXG5cdFx0dmFyIE1lbWJlclJlc29sdmVyID0gZnVuY3Rpb24oIHRlbXBsYXRlLCByZXNvbHZlciwgcGFyZW50RnJhZ21lbnQgKSB7XG5cdFx0XHR2YXIgbWVtYmVyID0gdGhpcyxcblx0XHRcdFx0a2V5cGF0aDtcblx0XHRcdG1lbWJlci5yZXNvbHZlciA9IHJlc29sdmVyO1xuXHRcdFx0bWVtYmVyLnJvb3QgPSByZXNvbHZlci5yb290O1xuXHRcdFx0bWVtYmVyLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRtZW1iZXIudmlld21vZGVsID0gcmVzb2x2ZXIucm9vdC52aWV3bW9kZWw7XG5cdFx0XHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdG1lbWJlci52YWx1ZSA9IHRlbXBsYXRlO1xuXHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUudCA9PT0gdHlwZXMuUkVGRVJFTkNFICkge1xuXHRcdFx0XHRtZW1iZXIucmVmUmVzb2x2ZXIgPSBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciggdGhpcywgdGVtcGxhdGUubiwgZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0bWVtYmVyLnJlc29sdmUoIGtleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3IEV4cHJlc3Npb25SZXNvbHZlciggcmVzb2x2ZXIsIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZSwgZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0bWVtYmVyLnJlc29sdmUoIGtleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0TWVtYmVyUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0cmVzb2x2ZTogZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdGlmICggdGhpcy5rZXlwYXRoICkge1xuXHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0dGhpcy5iaW5kKCk7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZXIuYnViYmxlKCk7XG5cdFx0XHR9LFxuXHRcdFx0YmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMudmlld21vZGVsLnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdGlmICggdGhpcy5yZWZSZXNvbHZlciApIHtcblx0XHRcdFx0XHR0aGlzLnJlZlJlc29sdmVyLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZXIuYnViYmxlKCk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmtleXBhdGggKSB7XG5cdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwudW5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzLnVucmVzb2x2ZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy51bnJlc29sdmVkLnVuYmluZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnJlZlJlc29sdmVyICkge1xuXHRcdFx0XHRcdHRoaXMucmVmUmVzb2x2ZXIuZm9yY2VSZXNvbHV0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBNZW1iZXJSZXNvbHZlcjtcblx0fSggdHlwZXMsIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyLCBFeHByZXNzaW9uUmVzb2x2ZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyL1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlci5qcyAqL1xuXHR2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24oIHJlc29sdmVSZWYsIFJlZmVyZW5jZVJlc29sdmVyLCBNZW1iZXJSZXNvbHZlciApIHtcblxuXHRcdHZhciBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIgPSBmdW5jdGlvbiggbXVzdGFjaGUsIHRlbXBsYXRlLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHJlc29sdmVyID0gdGhpcyxcblx0XHRcdFx0cmFjdGl2ZSwgcmVmLCBrZXlwYXRoLCBwYXJlbnRGcmFnbWVudDtcblx0XHRcdHJlc29sdmVyLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQgPSBtdXN0YWNoZS5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHJlc29sdmVyLnJvb3QgPSByYWN0aXZlID0gbXVzdGFjaGUucm9vdDtcblx0XHRcdHJlc29sdmVyLm11c3RhY2hlID0gbXVzdGFjaGU7XG5cdFx0XHRyZXNvbHZlci5yZWYgPSByZWYgPSB0ZW1wbGF0ZS5yO1xuXHRcdFx0cmVzb2x2ZXIuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHJlc29sdmVyLnVucmVzb2x2ZWQgPSBbXTtcblx0XHRcdC8vIEZpbmQgYmFzZSBrZXlwYXRoXG5cdFx0XHRpZiAoIGtleXBhdGggPSByZXNvbHZlUmVmKCByYWN0aXZlLCByZWYsIHBhcmVudEZyYWdtZW50ICkgKSB7XG5cdFx0XHRcdHJlc29sdmVyLmJhc2UgPSBrZXlwYXRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzb2x2ZXIuYmFzZVJlc29sdmVyID0gbmV3IFJlZmVyZW5jZVJlc29sdmVyKCB0aGlzLCByZWYsIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJlc29sdmVyLmJhc2UgPSBrZXlwYXRoO1xuXHRcdFx0XHRcdHJlc29sdmVyLmJhc2VSZXNvbHZlciA9IG51bGw7XG5cdFx0XHRcdFx0cmVzb2x2ZXIuYnViYmxlKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIEZpbmQgdmFsdWVzIGZvciBtZW1iZXJzLCBvciBtYXJrIHRoZW0gYXMgdW5yZXNvbHZlZFxuXHRcdFx0cmVzb2x2ZXIubWVtYmVycyA9IHRlbXBsYXRlLm0ubWFwKCBmdW5jdGlvbiggdGVtcGxhdGUgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgTWVtYmVyUmVzb2x2ZXIoIHRlbXBsYXRlLCB0aGlzJDAsIHBhcmVudEZyYWdtZW50ICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXNvbHZlci5yZWFkeSA9IHRydWU7XG5cdFx0XHRyZXNvbHZlci5idWJibGUoKTtcblx0XHR9O1xuXHRcdFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRnZXRLZXlwYXRoOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMubWVtYmVycy5tYXAoIGdldFZhbHVlICk7XG5cdFx0XHRcdGlmICggIXZhbHVlcy5ldmVyeSggaXNEZWZpbmVkICkgfHwgdGhpcy5iYXNlUmVzb2x2ZXIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuYmFzZSArICcuJyArIHZhbHVlcy5qb2luKCAnLicgKTtcblx0XHRcdH0sXG5cdFx0XHRidWJibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLnJlYWR5IHx8IHRoaXMuYmFzZVJlc29sdmVyICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmNhbGxiYWNrKCB0aGlzLmdldEtleXBhdGgoKSApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHZhciBjaGFuZ2VkO1xuXHRcdFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaCggZnVuY3Rpb24oIG1lbWJlcnMgKSB7XG5cdFx0XHRcdFx0aWYgKCBtZW1iZXJzLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0aWYgKCBjaGFuZ2VkICkge1xuXHRcdFx0XHRcdHRoaXMuYnViYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMuYmFzZVJlc29sdmVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmFzZSA9IHRoaXMucmVmO1xuXHRcdFx0XHRcdHRoaXMuYmFzZVJlc29sdmVyLnVuYmluZCgpO1xuXHRcdFx0XHRcdHRoaXMuYmFzZVJlc29sdmVyID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaCggZnVuY3Rpb24oIG0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG0uZm9yY2VSZXNvbHV0aW9uKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWUoIG1lbWJlciApIHtcblx0XHRcdHJldHVybiBtZW1iZXIudmFsdWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNEZWZpbmVkKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSAhPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCBtZW1iZXIgKSB7XG5cdFx0XHRtZW1iZXIudW5iaW5kKCk7XG5cdFx0fVxuXHRcdHJldHVybiBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXI7XG5cdH0oIHJlc29sdmVSZWYsIFJlZmVyZW5jZVJlc29sdmVyLCBNZW1iZXJSZXNvbHZlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL011c3RhY2hlL2luaXRpYWxpc2UuanMgKi9cblx0dmFyIGluaXRpYWxpc2UgPSBmdW5jdGlvbiggdHlwZXMsIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyLCBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIsIEV4cHJlc3Npb25SZXNvbHZlciApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBNdXN0YWNoZSRpbml0KCBtdXN0YWNoZSwgb3B0aW9ucyApIHtcblx0XHRcdHZhciByZWYsIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZTtcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblx0XHRcdG11c3RhY2hlLnJvb3QgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuXHRcdFx0bXVzdGFjaGUucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcblx0XHRcdG11c3RhY2hlLnBFbGVtZW50ID0gcGFyZW50RnJhZ21lbnQucEVsZW1lbnQ7XG5cdFx0XHRtdXN0YWNoZS50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0XHRtdXN0YWNoZS5pbmRleCA9IG9wdGlvbnMuaW5kZXggfHwgMDtcblx0XHRcdG11c3RhY2hlLmlzU3RhdGljID0gb3B0aW9ucy50ZW1wbGF0ZS5zO1xuXHRcdFx0bXVzdGFjaGUudHlwZSA9IG9wdGlvbnMudGVtcGxhdGUudDtcblx0XHRcdG11c3RhY2hlLnJlZ2lzdGVyZWQgPSBmYWxzZTtcblx0XHRcdC8vIGlmIHRoaXMgaXMgYSBzaW1wbGUgbXVzdGFjaGUsIHdpdGggYSByZWZlcmVuY2UsIHdlIGp1c3QgbmVlZCB0byByZXNvbHZlXG5cdFx0XHQvLyB0aGUgcmVmZXJlbmNlIHRvIGEga2V5cGF0aFxuXHRcdFx0aWYgKCByZWYgPSB0ZW1wbGF0ZS5yICkge1xuXHRcdFx0XHRtdXN0YWNoZS5yZXNvbHZlciA9IG5ldyBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciggbXVzdGFjaGUsIHJlZiwgcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgaXQncyBhbiBleHByZXNzaW9uLCB3ZSBoYXZlIGEgYml0IG1vcmUgd29yayB0byBkb1xuXHRcdFx0aWYgKCBvcHRpb25zLnRlbXBsYXRlLnggKSB7XG5cdFx0XHRcdG11c3RhY2hlLnJlc29sdmVyID0gbmV3IEV4cHJlc3Npb25SZXNvbHZlciggbXVzdGFjaGUsIHBhcmVudEZyYWdtZW50LCBvcHRpb25zLnRlbXBsYXRlLngsIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbiApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvcHRpb25zLnRlbXBsYXRlLnJ4ICkge1xuXHRcdFx0XHRtdXN0YWNoZS5yZXNvbHZlciA9IG5ldyBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIoIG11c3RhY2hlLCBvcHRpb25zLnRlbXBsYXRlLnJ4LCByZXNvbHZlQW5kUmViaW5kQ2hpbGRyZW4gKTtcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGludmVydGVkIHNlY3Rpb25zXG5cdFx0XHRpZiAoIG11c3RhY2hlLnRlbXBsYXRlLm4gPT09IHR5cGVzLlNFQ1RJT05fVU5MRVNTICYmICFtdXN0YWNoZS5oYXNPd25Qcm9wZXJ0eSggJ3ZhbHVlJyApICkge1xuXHRcdFx0XHRtdXN0YWNoZS5zZXRWYWx1ZSggdW5kZWZpbmVkICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGtleXBhdGggKSB7XG5cdFx0XHRcdG11c3RhY2hlLnJlc29sdmUoIGtleXBhdGggKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuKCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgb2xkS2V5cGF0aCA9IG11c3RhY2hlLmtleXBhdGg7XG5cdFx0XHRcdGlmICggbmV3S2V5cGF0aCAhPT0gb2xkS2V5cGF0aCApIHtcblx0XHRcdFx0XHRtdXN0YWNoZS5yZXNvbHZlKCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdFx0aWYgKCBvbGRLZXlwYXRoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS5mcmFnbWVudHMgJiYgbXVzdGFjaGUuZnJhZ21lbnRzLmZvckVhY2goIGZ1bmN0aW9uKCBmICkge1xuXHRcdFx0XHRcdFx0XHRmLnJlYmluZCggbnVsbCwgbnVsbCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHR5cGVzLCBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciwgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLCBFeHByZXNzaW9uUmVzb2x2ZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9NdXN0YWNoZS9yZXNvbHZlLmpzICovXG5cdHZhciByZXNvbHZlID0gZnVuY3Rpb24oIGlzTnVtZXJpYyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBNdXN0YWNoZSRyZXNvbHZlKCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIHdhc1Jlc29sdmVkLCB2YWx1ZSwgdHdvd2F5QmluZGluZztcblx0XHRcdC8vICdTcGVjaWFsJyBrZXlwYXRocywgZS5nLiBAZm9vIG9yIEA3LCBlbmNvZGUgYSB2YWx1ZVxuXHRcdFx0aWYgKCBrZXlwYXRoICYmIGtleXBhdGhbIDAgXSA9PT0gJ0AnICkge1xuXHRcdFx0XHR2YWx1ZSA9IGtleXBhdGguc2xpY2UoIDEgKTtcblx0XHRcdFx0aWYgKCBpc051bWVyaWMoIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSArdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdFx0dGhpcy5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgd2UgcmVzb2x2ZWQgcHJldmlvdXNseSwgd2UgbmVlZCB0byB1bnJlZ2lzdGVyXG5cdFx0XHRpZiAoIHRoaXMucmVnaXN0ZXJlZCApIHtcblx0XHRcdFx0Ly8gdW5kZWZpbmVkIG9yIG51bGxcblx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC51bnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHRcdFx0dGhpcy5yZWdpc3RlcmVkID0gZmFsc2U7XG5cdFx0XHRcdHdhc1Jlc29sdmVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHQvLyBJZiB0aGUgbmV3IGtleXBhdGggZXhpc3RzLCB3ZSBuZWVkIHRvIHJlZ2lzdGVyXG5cdFx0XHQvLyB3aXRoIHRoZSB2aWV3bW9kZWxcblx0XHRcdGlmICgga2V5cGF0aCAhPSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIHVuZGVmaW5lZCBvciBudWxsXG5cdFx0XHRcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5yZWdpc3Rlcigga2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0XHR0aGlzLnJlZ2lzdGVyZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRWl0aGVyIHdheSB3ZSBuZWVkIHRvIHF1ZXVlIHVwIGEgcmVuZGVyIChgdmFsdWVgXG5cdFx0XHQvLyB3aWxsIGJlIGB1bmRlZmluZWRgIGlmIHRoZXJlJ3Mgbm8ga2V5cGF0aClcblx0XHRcdHRoaXMuc2V0VmFsdWUoIHZhbHVlICk7XG5cdFx0XHQvLyBUd28td2F5IGJpbmRpbmdzIG5lZWQgdG8gcG9pbnQgdG8gdGhlaXIgbmV3IHRhcmdldCBrZXlwYXRoXG5cdFx0XHRpZiAoIHdhc1Jlc29sdmVkICYmICggdHdvd2F5QmluZGluZyA9IHRoaXMudHdvd2F5QmluZGluZyApICkge1xuXHRcdFx0XHR0d293YXlCaW5kaW5nLnJlYm91bmQoKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBpc051bWVyaWMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9NdXN0YWNoZS9yZWJpbmQuanMgKi9cblx0dmFyIHJlYmluZCA9IGZ1bmN0aW9uIE11c3RhY2hlJHJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdC8vIENoaWxkcmVuIGZpcnN0XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50cyApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goIGZ1bmN0aW9uKCBmICkge1xuXHRcdFx0XHRyZXR1cm4gZi5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHQvLyBFeHByZXNzaW9uIG11c3RhY2hlP1xuXHRcdGlmICggdGhpcy5yZXNvbHZlciApIHtcblx0XHRcdHRoaXMucmVzb2x2ZXIucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvTXVzdGFjaGUvX011c3RhY2hlLmpzICovXG5cdHZhciBNdXN0YWNoZSA9IGZ1bmN0aW9uKCBnZXRWYWx1ZSwgaW5pdCwgcmVzb2x2ZSwgcmViaW5kICkge1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldFZhbHVlOiBnZXRWYWx1ZSxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZXNvbHZlOiByZXNvbHZlLFxuXHRcdFx0cmViaW5kOiByZWJpbmRcblx0XHR9O1xuXHR9KCBnZXRWYWx1ZSwgaW5pdGlhbGlzZSwgcmVzb2x2ZSwgcmViaW5kICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9JbnRlcnBvbGF0b3IuanMgKi9cblx0dmFyIEludGVycG9sYXRvciA9IGZ1bmN0aW9uKCB0eXBlcywgcnVubG9vcCwgZXNjYXBlSHRtbCwgZGV0YWNoTm9kZSwgaXNFcXVhbCwgdW5iaW5kLCBNdXN0YWNoZSwgZGV0YWNoICkge1xuXG5cdFx0dmFyIEludGVycG9sYXRvciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuSU5URVJQT0xBVE9SO1xuXHRcdFx0TXVzdGFjaGUuaW5pdCggdGhpcywgb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0SW50ZXJwb2xhdG9yLnByb3RvdHlwZSA9IHtcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMubm9kZS5kYXRhID0gdGhpcy52YWx1ZSA9PSB1bmRlZmluZWQgPyAnJyA6IHRoaXMudmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcblx0XHRcdHJlYmluZDogTXVzdGFjaGUucmViaW5kLFxuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMubm9kZSApIHtcblx0XHRcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggdGhpcy52YWx1ZSAhPSB1bmRlZmluZWQgPyB0aGlzLnZhbHVlIDogJycgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbiggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0aWYgKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRcdGRldGFjaE5vZGUoIHRoaXMubm9kZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuXHRcdFx0Ly8gVEVNUFxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIHdyYXBwZXI7XG5cdFx0XHRcdC8vIFRPRE8gaXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGFwcHJvYWNoIHRoaXM/XG5cdFx0XHRcdGlmICggd3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFsgdGhpcy5rZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGUgKSB7XG5cdFx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXcoIHRoaXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmaXJzdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fSxcblx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbiggZXNjYXBlICkge1xuXHRcdFx0XHR2YXIgc3RyaW5nID0gdGhpcy52YWx1ZSAhPSB1bmRlZmluZWQgPyAnJyArIHRoaXMudmFsdWUgOiAnJztcblx0XHRcdFx0cmV0dXJuIGVzY2FwZSA/IGVzY2FwZUh0bWwoIHN0cmluZyApIDogc3RyaW5nO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIEludGVycG9sYXRvcjtcblx0fSggdHlwZXMsIHJ1bmxvb3AsIGVzY2FwZUh0bWwsIGRldGFjaE5vZGUsIGlzRXF1YWwsIHVuYmluZCwgTXVzdGFjaGUsIGRldGFjaCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvYnViYmxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kYnViYmxlID0gZnVuY3Rpb24gU2VjdGlvbiRidWJibGUoKSB7XG5cdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2RldGFjaC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGRldGFjaCA9IGZ1bmN0aW9uIFNlY3Rpb24kZGV0YWNoKCkge1xuXHRcdHZhciBkb2NGcmFnO1xuXHRcdGlmICggdGhpcy5mcmFnbWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnRzWyAwIF0uZGV0YWNoKCk7XG5cdFx0fVxuXHRcdGRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKCBpdGVtLmRldGFjaCgpICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiBkb2NGcmFnO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmQgPSBmdW5jdGlvbiBTZWN0aW9uJGZpbmQoIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCBsZW4sIHF1ZXJ5UmVzdWx0O1xuXHRcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0aWYgKCBxdWVyeVJlc3VsdCA9IHRoaXMuZnJhZ21lbnRzWyBpIF0uZmluZCggc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kQWxsID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0dmFyIGksIGxlbjtcblx0XHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnRzWyBpIF0uZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZmluZEFsbENvbXBvbmVudHMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIFNlY3Rpb24kZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHR2YXIgaSwgbGVuO1xuXHRcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudHNbIGkgXS5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZmluZENvbXBvbmVudC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiBTZWN0aW9uJGZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCBsZW4sIHF1ZXJ5UmVzdWx0O1xuXHRcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0aWYgKCBxdWVyeVJlc3VsdCA9IHRoaXMuZnJhZ21lbnRzWyBpIF0uZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2ZpbmROZXh0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmROZXh0Tm9kZSA9IGZ1bmN0aW9uIFNlY3Rpb24kZmluZE5leHROb2RlKCBmcmFnbWVudCApIHtcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnRzWyBmcmFnbWVudC5pbmRleCArIDEgXSApIHtcblx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50c1sgZnJhZ21lbnQuaW5kZXggKyAxIF0uZmlyc3ROb2RlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmlyc3ROb2RlID0gZnVuY3Rpb24gU2VjdGlvbiRmaXJzdE5vZGUoKSB7XG5cdFx0dmFyIGxlbiwgaSwgbm9kZTtcblx0XHRpZiAoIGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCApIHtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdGlmICggbm9kZSA9IHRoaXMuZnJhZ21lbnRzWyBpIF0uZmlyc3ROb2RlKCkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9zaHVmZmxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kc2h1ZmZsZSA9IGZ1bmN0aW9uKCB0eXBlcywgcnVubG9vcCwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gU2VjdGlvbiRzaHVmZmxlKCBuZXdJbmRpY2VzICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgc2VjdGlvbiA9IHRoaXMsXG5cdFx0XHRcdHBhcmVudEZyYWdtZW50LCBmaXJzdENoYW5nZSwgaSwgbmV3TGVuZ3RoLCByZWJvdW5kRnJhZ21lbnRzLCBmcmFnbWVudE9wdGlvbnMsIGZyYWdtZW50O1xuXHRcdFx0Ly8gc2hvcnQgY2lyY3VpdCBhbnkgZG91YmxlLXVwZGF0ZXMsIGFuZCBlbnN1cmUgdGhhdCB0aGlzIGlzbid0IGFwcGxpZWQgdG9cblx0XHRcdC8vIG5vbi1saXN0IHNlY3Rpb25zXG5cdFx0XHRpZiAoIHRoaXMuc2h1ZmZsaW5nIHx8IHRoaXMudW5ib3VuZCB8fCB0aGlzLnN1YnR5cGUgJiYgdGhpcy5zdWJ0eXBlICE9PSB0eXBlcy5TRUNUSU9OX0VBQ0ggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMuc2h1ZmZsaW5nID0gdHJ1ZTtcblx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMkMC5zaHVmZmxpbmcgPSBmYWxzZTtcblx0XHRcdH0gKTtcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHJlYm91bmRGcmFnbWVudHMgPSBbXTtcblx0XHRcdC8vIGZpcnN0LCByZWJpbmQgZXhpc3RpbmcgZnJhZ21lbnRzXG5cdFx0XHRuZXdJbmRpY2VzLmZvckVhY2goIGZ1bmN0aW9uIHJlYmluZElmTmVjZXNzYXJ5KCBuZXdJbmRleCwgb2xkSW5kZXggKSB7XG5cdFx0XHRcdHZhciBmcmFnbWVudCwgYnksIG9sZEtleXBhdGgsIG5ld0tleXBhdGg7XG5cdFx0XHRcdGlmICggbmV3SW5kZXggPT09IG9sZEluZGV4ICkge1xuXHRcdFx0XHRcdHJlYm91bmRGcmFnbWVudHNbIG5ld0luZGV4IF0gPSBzZWN0aW9uLmZyYWdtZW50c1sgb2xkSW5kZXggXTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnJhZ21lbnQgPSBzZWN0aW9uLmZyYWdtZW50c1sgb2xkSW5kZXggXTtcblx0XHRcdFx0aWYgKCBmaXJzdENoYW5nZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGZpcnN0Q2hhbmdlID0gb2xkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gZG9lcyB0aGlzIGZyYWdtZW50IG5lZWQgdG8gYmUgdG9ybiBkb3duP1xuXHRcdFx0XHRpZiAoIG5ld0luZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIucHVzaCggZnJhZ21lbnQgKTtcblx0XHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpdCBuZWVkcyB0byBiZSByZWJvdW5kIHRvIGEgbmV3IGluZGV4XG5cdFx0XHRcdGJ5ID0gbmV3SW5kZXggLSBvbGRJbmRleDtcblx0XHRcdFx0b2xkS2V5cGF0aCA9IHNlY3Rpb24ua2V5cGF0aCArICcuJyArIG9sZEluZGV4O1xuXHRcdFx0XHRuZXdLZXlwYXRoID0gc2VjdGlvbi5rZXlwYXRoICsgJy4nICsgbmV3SW5kZXg7XG5cdFx0XHRcdGZyYWdtZW50LnJlYmluZCggc2VjdGlvbi50ZW1wbGF0ZS5pLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRmcmFnbWVudC5pbmRleCA9IG5ld0luZGV4O1xuXHRcdFx0XHRyZWJvdW5kRnJhZ21lbnRzWyBuZXdJbmRleCBdID0gZnJhZ21lbnQ7XG5cdFx0XHR9ICk7XG5cdFx0XHRuZXdMZW5ndGggPSB0aGlzLnJvb3QuZ2V0KCB0aGlzLmtleXBhdGggKS5sZW5ndGg7XG5cdFx0XHQvLyBJZiBub3RoaW5nIGNoYW5nZWQgd2l0aCB0aGUgZXhpc3RpbmcgZnJhZ21lbnRzLCB0aGVuIHdlIHN0YXJ0IGFkZGluZ1xuXHRcdFx0Ly8gbmV3IGZyYWdtZW50cyBhdCB0aGUgZW5kLi4uXG5cdFx0XHRpZiAoIGZpcnN0Q2hhbmdlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIC4uLnVubGVzcyB0aGVyZSBhcmUgbm8gbmV3IGZyYWdtZW50cyB0byBhZGRcblx0XHRcdFx0aWYgKCB0aGlzLmxlbmd0aCA9PT0gbmV3TGVuZ3RoICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmaXJzdENoYW5nZSA9IHRoaXMubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5sZW5ndGggPSB0aGlzLmZyYWdtZW50cy5sZW5ndGggPSBuZXdMZW5ndGg7XG5cdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUHJlcGFyZSBuZXcgZnJhZ21lbnQgb3B0aW9uc1xuXHRcdFx0ZnJhZ21lbnRPcHRpb25zID0ge1xuXHRcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZS5mLFxuXHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCB0aGlzLnRlbXBsYXRlLmkgKSB7XG5cdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleFJlZiA9IHRoaXMudGVtcGxhdGUuaTtcblx0XHRcdH1cblx0XHRcdC8vIEFkZCBhcyBtYW55IG5ldyBmcmFnbWVudHMgYXMgd2UgbmVlZCB0bywgb3IgYWRkIGJhY2sgZXhpc3Rpbmdcblx0XHRcdC8vIChkZXRhY2hlZCkgZnJhZ21lbnRzXG5cdFx0XHRmb3IgKCBpID0gZmlyc3RDaGFuZ2U7IGkgPCBuZXdMZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSByZWJvdW5kRnJhZ21lbnRzWyBpIF07XG5cdFx0XHRcdGlmICggIWZyYWdtZW50ICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnRzWyBpIF0gPSBmcmFnbWVudDtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCB0eXBlcywgcnVubG9vcCwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHJlbmRlciA9IGZ1bmN0aW9uIFNlY3Rpb24kcmVuZGVyKCkge1xuXHRcdHZhciBkb2NGcmFnO1xuXHRcdGRvY0ZyYWcgPSB0aGlzLmRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gZG9jRnJhZztcblx0fTtcblxuXHQvKiB1dGlscy9pc0FycmF5TGlrZS5qcyAqL1xuXHR2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBwYXR0ZXJuID0gL15cXFtvYmplY3QgKD86QXJyYXl8RmlsZUxpc3QpXFxdJC8sXG5cdFx0XHR0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0b1N0cmluZy5jYWxsKCBvYmogKSApO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3NldFZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kc2V0VmFsdWUgPSBmdW5jdGlvbiggdHlwZXMsIGlzQXJyYXlMaWtlLCBpc09iamVjdCwgcnVubG9vcCwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBTZWN0aW9uJHNldFZhbHVlKCB2YWx1ZSApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHdyYXBwZXIsIGZyYWdtZW50T3B0aW9ucztcblx0XHRcdGlmICggdGhpcy51cGRhdGluZyApIHtcblx0XHRcdFx0Ly8gSWYgYSBjaGlsZCBvZiB0aGlzIHNlY3Rpb24gY2F1c2VzIGEgcmUtZXZhbHVhdGlvbiAtIGZvciBleGFtcGxlLCBhblxuXHRcdFx0XHQvLyBleHByZXNzaW9uIHJlZmVycyB0byBhIGZ1bmN0aW9uIHRoYXQgbXV0YXRlcyB0aGUgYXJyYXkgdGhhdCB0aGlzXG5cdFx0XHRcdC8vIHNlY3Rpb24gZGVwZW5kcyBvbiAtIHdlJ2xsIGVuZCB1cCB3aXRoIGEgZG91YmxlIHJlbmRlcmluZyBidWcgKHNlZVxuXHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzLzc0OCkuIFRoaXMgcHJldmVudHMgaXQuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0Ly8gd2l0aCBzZWN0aW9ucywgd2UgbmVlZCB0byBnZXQgdGhlIGZha2UgdmFsdWUgaWYgd2UgaGF2ZSBhIHdyYXBwZWQgb2JqZWN0XG5cdFx0XHRpZiAoIHdyYXBwZXIgPSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRbIHRoaXMua2V5cGF0aCBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiBhbnkgZnJhZ21lbnRzIGFyZSBhd2FpdGluZyBjcmVhdGlvbiBhZnRlciBhIHNwbGljZSxcblx0XHRcdC8vIHRoaXMgaXMgdGhlIHBsYWNlIHRvIGRvIGl0XG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUubGVuZ3RoICkge1xuXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUuZixcblx0XHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdFx0cEVsZW1lbnQ6IHRoaXMucEVsZW1lbnQsXG5cdFx0XHRcdFx0b3duZXI6IHRoaXMsXG5cdFx0XHRcdFx0aW5kZXhSZWY6IHRoaXMudGVtcGxhdGUuaVxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmZvckVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdFx0XHR2YXIgZnJhZ21lbnQ7XG5cdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSB0aGlzJDAua2V5cGF0aCArICcuJyArIGluZGV4O1xuXHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGluZGV4O1xuXHRcdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHR0aGlzJDAuZnJhZ21lbnRzVG9SZW5kZXIucHVzaCggdGhpcyQwLmZyYWdtZW50c1sgaW5kZXggXSA9IGZyYWdtZW50ICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5sZW5ndGggPSAwO1xuXHRcdFx0fSBlbHNlIGlmICggcmVldmFsdWF0ZVNlY3Rpb24oIHRoaXMsIHZhbHVlICkgKSB7XG5cdFx0XHRcdHRoaXMuYnViYmxlKCk7XG5cdFx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXcoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlU2VjdGlvbiggc2VjdGlvbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgZnJhZ21lbnRPcHRpb25zID0ge1xuXHRcdFx0XHR0ZW1wbGF0ZTogc2VjdGlvbi50ZW1wbGF0ZS5mLFxuXHRcdFx0XHRyb290OiBzZWN0aW9uLnJvb3QsXG5cdFx0XHRcdHBFbGVtZW50OiBzZWN0aW9uLnBhcmVudEZyYWdtZW50LnBFbGVtZW50LFxuXHRcdFx0XHRvd25lcjogc2VjdGlvblxuXHRcdFx0fTtcblx0XHRcdC8vIElmIHdlIGFscmVhZHkga25vdyB0aGUgc2VjdGlvbiB0eXBlLCBncmVhdFxuXHRcdFx0Ly8gVE9ETyBjYW4gdGhpcyBiZSBvcHRpbWlzZWQ/IGkuZS4gcGljayBhbiByZWV2YWx1YXRlU2VjdGlvbiBmdW5jdGlvbiBkdXJpbmcgaW5pdFxuXHRcdFx0Ly8gYW5kIGF2b2lkIGRvaW5nIHRoaXMgZWFjaCB0aW1lP1xuXHRcdFx0aWYgKCBzZWN0aW9uLnN1YnR5cGUgKSB7XG5cdFx0XHRcdHN3aXRjaCAoIHNlY3Rpb24uc3VidHlwZSApIHtcblx0XHRcdFx0XHRjYXNlIHR5cGVzLlNFQ1RJT05fSUY6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZhbHNlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRjYXNlIHR5cGVzLlNFQ1RJT05fVU5MRVNTOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCB0cnVlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRjYXNlIHR5cGVzLlNFQ1RJT05fV0lUSDpcblx0XHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oIHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdGNhc2UgdHlwZXMuU0VDVElPTl9JRl9XSVRIOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbENvbnRleHRTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX0VBQ0g6XG5cdFx0XHRcdFx0XHRpZiAoIGlzT2JqZWN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIHdvcmsgb3V0IHdoYXQgc29ydCBvZiBzZWN0aW9uIHdlJ3JlIGRlYWxpbmcgd2l0aFxuXHRcdFx0c2VjdGlvbi5vcmRlcmVkID0gISFpc0FycmF5TGlrZSggdmFsdWUgKTtcblx0XHRcdC8vIE9yZGVyZWQgbGlzdCBzZWN0aW9uXG5cdFx0XHRpZiAoIHNlY3Rpb24ub3JkZXJlZCApIHtcblx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVMaXN0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVW5vcmRlcmVkIGxpc3QsIG9yIGNvbnRleHRcblx0XHRcdGlmICggaXNPYmplY3QoIHZhbHVlICkgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHQvLyBJbmRleCByZWZlcmVuY2UgaW5kaWNhdGVzIHNlY3Rpb24gc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBsaXN0XG5cdFx0XHRcdGlmICggc2VjdGlvbi50ZW1wbGF0ZS5pICkge1xuXHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIG9iamVjdCBwcm92aWRlcyBjb250ZXh0IGZvciBjb250ZW50c1xuXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKCBzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdC8vIENvbmRpdGlvbmFsIHNlY3Rpb25cblx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZmFsc2UsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZXZhbHVhdGVMaXN0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApIHtcblx0XHRcdHZhciBpLCBsZW5ndGgsIGZyYWdtZW50O1xuXHRcdFx0bGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0aWYgKCBsZW5ndGggPT09IHNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHQvLyBOb3RoaW5nIHRvIGRvXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIGlmIHRoZSBhcnJheSBpcyBzaG9ydGVyIHRoYW4gaXQgd2FzIHByZXZpb3VzbHksIHJlbW92ZSBpdGVtc1xuXHRcdFx0aWYgKCBsZW5ndGggPCBzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKCBsZW5ndGgsIHNlY3Rpb24ubGVuZ3RoIC0gbGVuZ3RoICk7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggbGVuZ3RoID4gc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdFx0Ly8gYWRkIGFueSBuZXcgb25lc1xuXHRcdFx0XHRcdGZvciAoIGkgPSBzZWN0aW9uLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdFx0Ly8gYXBwZW5kIGxpc3QgaXRlbSB0byBjb250ZXh0IHN0YWNrXG5cdFx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aCArICcuJyArIGk7XG5cdFx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0aWYgKCBzZWN0aW9uLnRlbXBsYXRlLmkgKSB7XG5cdFx0XHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleFJlZiA9IHNlY3Rpb24udGVtcGxhdGUuaTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaCggc2VjdGlvbi5mcmFnbWVudHNbIGkgXSA9IGZyYWdtZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzZWN0aW9uLmxlbmd0aCA9IGxlbmd0aDtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZXZhbHVhdGVMaXN0T2JqZWN0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApIHtcblx0XHRcdHZhciBpZCwgaSwgaGFzS2V5LCBmcmFnbWVudCwgY2hhbmdlZDtcblx0XHRcdGhhc0tleSA9IHNlY3Rpb24uaGFzS2V5IHx8ICggc2VjdGlvbi5oYXNLZXkgPSB7fSApO1xuXHRcdFx0Ly8gcmVtb3ZlIGFueSBmcmFnbWVudHMgdGhhdCBzaG91bGQgbm8gbG9uZ2VyIGV4aXN0XG5cdFx0XHRpID0gc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGZyYWdtZW50ID0gc2VjdGlvbi5mcmFnbWVudHNbIGkgXTtcblx0XHRcdFx0aWYgKCAhKCBmcmFnbWVudC5pbmRleCBpbiB2YWx1ZSApICkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5wdXNoKCBmcmFnbWVudCApO1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdGhhc0tleVsgZnJhZ21lbnQuaW5kZXggXSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBhZGQgYW55IHRoYXQgaGF2ZW4ndCBiZWVuIGNyZWF0ZWQgeWV0XG5cdFx0XHRmb3IgKCBpZCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhaGFzS2V5WyBpZCBdICkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gc2VjdGlvbi5rZXlwYXRoICsgJy4nICsgaWQ7XG5cdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaWQ7XG5cdFx0XHRcdFx0aWYgKCBzZWN0aW9uLnRlbXBsYXRlLmkgKSB7XG5cdFx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXhSZWYgPSBzZWN0aW9uLnRlbXBsYXRlLmk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIGZyYWdtZW50ICk7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHMucHVzaCggZnJhZ21lbnQgKTtcblx0XHRcdFx0XHRoYXNLZXlbIGlkIF0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzZWN0aW9uLmxlbmd0aCA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZXZhbHVhdGVDb25kaXRpb25hbENvbnRleHRTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zICkge1xuXHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbiggc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlU2VjdGlvbkZyYWdtZW50cyggc2VjdGlvbiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbiggc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zICkge1xuXHRcdFx0dmFyIGZyYWdtZW50O1xuXHRcdFx0Ly8gLi4udGhlbiBpZiBpdCBpc24ndCByZW5kZXJlZCwgcmVuZGVyIGl0LCBhZGRpbmcgc2VjdGlvbi5rZXlwYXRoIHRvIHRoZSBjb250ZXh0IHN0YWNrXG5cdFx0XHQvLyAoaWYgaXQgaXMgYWxyZWFkeSByZW5kZXJlZCwgdGhlbiBhbnkgY2hpbGRyZW4gZGVwZW5kZW50IG9uIHRoZSBjb250ZXh0IHN0YWNrXG5cdFx0XHQvLyB3aWxsIHVwZGF0ZSB0aGVtc2VsdmVzIHdpdGhvdXQgYW55IHByb21wdGluZylcblx0XHRcdGlmICggIXNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHQvLyBhcHBlbmQgdGhpcyBzZWN0aW9uIHRvIHRoZSBjb250ZXh0IHN0YWNrXG5cdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gc2VjdGlvbi5rZXlwYXRoO1xuXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSAwO1xuXHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaCggc2VjdGlvbi5mcmFnbWVudHNbIDAgXSA9IGZyYWdtZW50ICk7XG5cdFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gMTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGludmVydGVkLCBmcmFnbWVudE9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgZG9SZW5kZXIsIGVtcHR5QXJyYXksIGVtcHR5T2JqZWN0LCBmcmFnbWVudCwgbmFtZTtcblx0XHRcdGVtcHR5QXJyYXkgPSBpc0FycmF5TGlrZSggdmFsdWUgKSAmJiB2YWx1ZS5sZW5ndGggPT09IDA7XG5cdFx0XHRlbXB0eU9iamVjdCA9IGZhbHNlO1xuXHRcdFx0aWYgKCAhaXNBcnJheUxpa2UoIHZhbHVlICkgJiYgaXNPYmplY3QoIHZhbHVlICkgKSB7XG5cdFx0XHRcdGVtcHR5T2JqZWN0ID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggbmFtZSBpbiB2YWx1ZSApIHtcblx0XHRcdFx0XHRlbXB0eU9iamVjdCA9IGZhbHNlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGludmVydGVkICkge1xuXHRcdFx0XHRkb1JlbmRlciA9IGVtcHR5QXJyYXkgfHwgZW1wdHlPYmplY3QgfHwgIXZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG9SZW5kZXIgPSB2YWx1ZSAmJiAhZW1wdHlBcnJheSAmJiAhZW1wdHlPYmplY3Q7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGRvUmVuZGVyICkge1xuXHRcdFx0XHRpZiAoICFzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0XHQvLyBubyBjaGFuZ2UgdG8gY29udGV4dCBzdGFja1xuXHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IDA7XG5cdFx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaCggc2VjdGlvbi5mcmFnbWVudHNbIDAgXSA9IGZyYWdtZW50ICk7XG5cdFx0XHRcdFx0c2VjdGlvbi5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggc2VjdGlvbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSggMSApO1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHJlbW92ZVNlY3Rpb25GcmFnbWVudHMoIHNlY3Rpb24gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW1vdmVTZWN0aW9uRnJhZ21lbnRzKCBzZWN0aW9uICkge1xuXHRcdFx0aWYgKCBzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKCAwLCBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGggKS5maWx0ZXIoIGlzUmVuZGVyZWQgKTtcblx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0XHRzZWN0aW9uLmxlbmd0aCA9IHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIubGVuZ3RoID0gMDtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCBmcmFnbWVudCApIHtcblx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzUmVuZGVyZWQoIGZyYWdtZW50ICkge1xuXHRcdFx0cmV0dXJuIGZyYWdtZW50LnJlbmRlcmVkO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHR5cGVzLCBpc0FycmF5TGlrZSwgaXNPYmplY3QsIHJ1bmxvb3AsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHRvU3RyaW5nID0gZnVuY3Rpb24gU2VjdGlvbiR0b1N0cmluZyggZXNjYXBlICkge1xuXHRcdHZhciBzdHIsIGksIGxlbjtcblx0XHRzdHIgPSAnJztcblx0XHRpID0gMDtcblx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0c3RyICs9IHRoaXMuZnJhZ21lbnRzWyBpIF0udG9TdHJpbmcoIGVzY2FwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RyO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvdW5iaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdW5iaW5kID0gZnVuY3Rpb24oIHVuYmluZCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFNlY3Rpb24kdW5iaW5kKCkge1xuXHRcdFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaCggdW5iaW5kRnJhZ21lbnQgKTtcblx0XHRcdHVuYmluZC5jYWxsKCB0aGlzICk7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDA7XG5cdFx0XHR0aGlzLnVuYm91bmQgPSB0cnVlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bmJpbmRGcmFnbWVudCggZnJhZ21lbnQgKSB7XG5cdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB1bmJpbmQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdW5yZW5kZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFNlY3Rpb24kdW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKCBzaG91bGREZXN0cm95ID8gdW5yZW5kZXJBbmREZXN0cm95IDogdW5yZW5kZXIgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5yZW5kZXJBbmREZXN0cm95KCBmcmFnbWVudCApIHtcblx0XHRcdGZyYWdtZW50LnVucmVuZGVyKCB0cnVlICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5yZW5kZXIoIGZyYWdtZW50ICkge1xuXHRcdFx0ZnJhZ21lbnQudW5yZW5kZXIoIGZhbHNlICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvdXBkYXRlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdXBkYXRlID0gZnVuY3Rpb24gU2VjdGlvbiR1cGRhdGUoKSB7XG5cdFx0dmFyIGZyYWdtZW50LCByZW5kZXJJbmRleCwgcmVuZGVyZWRGcmFnbWVudHMsIGFuY2hvciwgdGFyZ2V0LCBpLCBsZW47XG5cdFx0Ly8gYHRoaXMucmVuZGVyZWRGcmFnbWVudHNgIGlzIGluIHRoZSBvcmRlciBvZiB0aGUgcHJldmlvdXMgcmVuZGVyLlxuXHRcdC8vIElmIGZyYWdtZW50cyBoYXZlIHNodWZmbGVkIGFib3V0LCB0aGlzIGFsbG93cyB1cyB0byBxdWlja2x5XG5cdFx0Ly8gcmVpbnNlcnQgdGhlbSBpbiB0aGUgY29ycmVjdCBwbGFjZVxuXHRcdHJlbmRlcmVkRnJhZ21lbnRzID0gdGhpcy5yZW5kZXJlZEZyYWdtZW50cztcblx0XHQvLyBSZW1vdmUgZnJhZ21lbnRzIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZCBmb3IgZGVzdHJ1Y3Rpb25cblx0XHR3aGlsZSAoIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNUb1VucmVuZGVyLnBvcCgpICkge1xuXHRcdFx0ZnJhZ21lbnQudW5yZW5kZXIoIHRydWUgKTtcblx0XHRcdHJlbmRlcmVkRnJhZ21lbnRzLnNwbGljZSggcmVuZGVyZWRGcmFnbWVudHMuaW5kZXhPZiggZnJhZ21lbnQgKSwgMSApO1xuXHRcdH1cblx0XHQvLyBSZW5kZXIgbmV3IGZyYWdtZW50cyAoYnV0IGRvbid0IGluc2VydCB0aGVtIHlldClcblx0XHR3aGlsZSAoIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNUb1JlbmRlci5zaGlmdCgpICkge1xuXHRcdFx0ZnJhZ21lbnQucmVuZGVyKCk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdHRhcmdldCA9IHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpO1xuXHRcdH1cblx0XHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNbIGkgXTtcblx0XHRcdHJlbmRlckluZGV4ID0gcmVuZGVyZWRGcmFnbWVudHMuaW5kZXhPZiggZnJhZ21lbnQsIGkgKTtcblx0XHRcdC8vIHNlYXJjaCBmcm9tIGN1cnJlbnQgaW5kZXggLSBpdCdzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHNhbWUgb3IgaGlnaGVyXG5cdFx0XHRpZiAoIHJlbmRlckluZGV4ID09PSBpICkge1xuXHRcdFx0XHQvLyBhbHJlYWR5IGluIHRoZSByaWdodCBwbGFjZS4gaW5zZXJ0IGFjY3VtdWxhdGVkIG5vZGVzIChpZiBhbnkpIGFuZCBjYXJyeSBvblxuXHRcdFx0XHRpZiAoIHRoaXMuZG9jRnJhZy5jaGlsZE5vZGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRhbmNob3IgPSBmcmFnbWVudC5maXJzdE5vZGUoKTtcblx0XHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCB0aGlzLmRvY0ZyYWcsIGFuY2hvciApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKCBmcmFnbWVudC5kZXRhY2goKSApO1xuXHRcdFx0Ly8gdXBkYXRlIHJlbmRlcmVkRnJhZ21lbnRzXG5cdFx0XHRpZiAoIHJlbmRlckluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0cmVuZGVyZWRGcmFnbWVudHMuc3BsaWNlKCByZW5kZXJJbmRleCwgMSApO1xuXHRcdFx0fVxuXHRcdFx0cmVuZGVyZWRGcmFnbWVudHMuc3BsaWNlKCBpLCAwLCBmcmFnbWVudCApO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMucmVuZGVyZWQgJiYgdGhpcy5kb2NGcmFnLmNoaWxkTm9kZXMubGVuZ3RoICkge1xuXHRcdFx0YW5jaG9yID0gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZG9jRnJhZywgYW5jaG9yICk7XG5cdFx0fVxuXHRcdC8vIFNhdmUgdGhlIHJlbmRlcmluZyBvcmRlciBmb3IgbmV4dCB0aW1lXG5cdFx0dGhpcy5yZW5kZXJlZEZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzLnNsaWNlKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL19TZWN0aW9uLmpzICovXG5cdHZhciBTZWN0aW9uID0gZnVuY3Rpb24oIHR5cGVzLCBNdXN0YWNoZSwgYnViYmxlLCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpbmRBbGxDb21wb25lbnRzLCBmaW5kQ29tcG9uZW50LCBmaW5kTmV4dE5vZGUsIGZpcnN0Tm9kZSwgc2h1ZmZsZSwgcmVuZGVyLCBzZXRWYWx1ZSwgdG9TdHJpbmcsIHVuYmluZCwgdW5yZW5kZXIsIHVwZGF0ZSApIHtcblxuXHRcdHZhciBTZWN0aW9uID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5TRUNUSU9OO1xuXHRcdFx0dGhpcy5zdWJ0eXBlID0gb3B0aW9ucy50ZW1wbGF0ZS5uO1xuXHRcdFx0dGhpcy5pbnZlcnRlZCA9IHRoaXMuc3VidHlwZSA9PT0gdHlwZXMuU0VDVElPTl9VTkxFU1M7XG5cdFx0XHR0aGlzLnBFbGVtZW50ID0gb3B0aW9ucy5wRWxlbWVudDtcblx0XHRcdHRoaXMuZnJhZ21lbnRzID0gW107XG5cdFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlID0gW107XG5cdFx0XHR0aGlzLmZyYWdtZW50c1RvUmVuZGVyID0gW107XG5cdFx0XHR0aGlzLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBbXTtcblx0XHRcdHRoaXMucmVuZGVyZWRGcmFnbWVudHMgPSBbXTtcblx0XHRcdHRoaXMubGVuZ3RoID0gMDtcblx0XHRcdC8vIG51bWJlciBvZiB0aW1lcyB0aGlzIHNlY3Rpb24gaXMgcmVuZGVyZWRcblx0XHRcdE11c3RhY2hlLmluaXQoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdFNlY3Rpb24ucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBidWJibGUsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG5cdFx0XHRzaHVmZmxlOiBzaHVmZmxlLFxuXHRcdFx0cmViaW5kOiBNdXN0YWNoZS5yZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG5cdFx0XHRzZXRWYWx1ZTogc2V0VmFsdWUsXG5cdFx0XHR0b1N0cmluZzogdG9TdHJpbmcsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlcixcblx0XHRcdHVwZGF0ZTogdXBkYXRlXG5cdFx0fTtcblx0XHRyZXR1cm4gU2VjdGlvbjtcblx0fSggdHlwZXMsIE11c3RhY2hlLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kYnViYmxlLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZGV0YWNoLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRBbGwsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kQWxsQ29tcG9uZW50cywgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRDb21wb25lbnQsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kTmV4dE5vZGUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaXJzdE5vZGUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRzaHVmZmxlLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kc2V0VmFsdWUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR0b1N0cmluZywgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVuYmluZCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVucmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdXBkYXRlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL2RldGFjaC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZGV0YWNoID0gZnVuY3Rpb24gVHJpcGxlJGRldGFjaCgpIHtcblx0XHR2YXIgbGVuLCBpO1xuXHRcdGlmICggdGhpcy5kb2NGcmFnICkge1xuXHRcdFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQoIHRoaXMubm9kZXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpbmQgPSBmdW5jdGlvbiggbWF0Y2hlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgaSwgbGVuLCBub2RlLCBxdWVyeVJlc3VsdDtcblx0XHRcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0bm9kZSA9IHRoaXMubm9kZXNbIGkgXTtcblx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWF0Y2hlcyggbm9kZSwgc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHF1ZXJ5UmVzdWx0ID0gbm9kZS5xdWVyeVNlbGVjdG9yKCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fSggbWF0Y2hlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaW5kQWxsID0gZnVuY3Rpb24oIG1hdGNoZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJGZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeVJlc3VsdCApIHtcblx0XHRcdHZhciBpLCBsZW4sIG5vZGUsIHF1ZXJ5QWxsUmVzdWx0LCBudW1Ob2Rlcywgajtcblx0XHRcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0bm9kZSA9IHRoaXMubm9kZXNbIGkgXTtcblx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWF0Y2hlcyggbm9kZSwgc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRxdWVyeVJlc3VsdC5wdXNoKCBub2RlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBxdWVyeUFsbFJlc3VsdCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCggc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRudW1Ob2RlcyA9IHF1ZXJ5QWxsUmVzdWx0Lmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IG51bU5vZGVzOyBqICs9IDEgKSB7XG5cdFx0XHRcdFx0XHRxdWVyeVJlc3VsdC5wdXNoKCBxdWVyeUFsbFJlc3VsdFsgaiBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggbWF0Y2hlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9maXJzdE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpcnN0Tm9kZSA9IGZ1bmN0aW9uIFRyaXBsZSRmaXJzdE5vZGUoKSB7XG5cdFx0aWYgKCB0aGlzLnJlbmRlcmVkICYmIHRoaXMubm9kZXNbIDAgXSApIHtcblx0XHRcdHJldHVybiB0aGlzLm5vZGVzWyAwIF07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL2hlbHBlcnMvaW5zZXJ0SHRtbC5qcyAqL1xuXHR2YXIgaW5zZXJ0SHRtbCA9IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBjcmVhdGVFbGVtZW50ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBlbGVtZW50Q2FjaGUgPSB7fSxcblx0XHRcdGllQnVnLCBpZUJsYWNrbGlzdDtcblx0XHR0cnkge1xuXHRcdFx0Y3JlYXRlRWxlbWVudCggJ3RhYmxlJyApLmlubmVySFRNTCA9ICdmb28nO1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRpZUJ1ZyA9IHRydWU7XG5cdFx0XHRpZUJsYWNrbGlzdCA9IHtcblx0XHRcdFx0VEFCTEU6IFtcblx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwieFwiPicsXG5cdFx0XHRcdFx0JzwvdGFibGU+J1xuXHRcdFx0XHRdLFxuXHRcdFx0XHRUSEVBRDogW1xuXHRcdFx0XHRcdCc8dGFibGU+PHRoZWFkIGNsYXNzPVwieFwiPicsXG5cdFx0XHRcdFx0JzwvdGhlYWQ+PC90YWJsZT4nXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFRCT0RZOiBbXG5cdFx0XHRcdFx0Jzx0YWJsZT48dGJvZHkgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC90Ym9keT48L3RhYmxlPidcblx0XHRcdFx0XSxcblx0XHRcdFx0VFI6IFtcblx0XHRcdFx0XHQnPHRhYmxlPjx0ciBjbGFzcz1cInhcIj4nLFxuXHRcdFx0XHRcdCc8L3RyPjwvdGFibGU+J1xuXHRcdFx0XHRdLFxuXHRcdFx0XHRTRUxFQ1Q6IFtcblx0XHRcdFx0XHQnPHNlbGVjdCBjbGFzcz1cInhcIj4nLFxuXHRcdFx0XHRcdCc8L3NlbGVjdD4nXG5cdFx0XHRcdF1cblx0XHRcdH07XG5cdFx0fVxuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oIGh0bWwsIG5vZGUsIGRvY0ZyYWcgKSB7XG5cdFx0XHR2YXIgY29udGFpbmVyLCBub2RlcyA9IFtdLFxuXHRcdFx0XHR3cmFwcGVyLCBzZWxlY3RlZE9wdGlvbiwgY2hpbGQsIGk7XG5cdFx0XHQvLyByZW5kZXIgMCBhbmQgZmFsc2Vcblx0XHRcdGlmICggaHRtbCAhPSBudWxsICYmIGh0bWwgIT09ICcnICkge1xuXHRcdFx0XHRpZiAoIGllQnVnICYmICggd3JhcHBlciA9IGllQmxhY2tsaXN0WyBub2RlLnRhZ05hbWUgXSApICkge1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoICdESVYnICk7XG5cdFx0XHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IHdyYXBwZXJbIDAgXSArIGh0bWwgKyB3cmFwcGVyWyAxIF07XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoICcueCcgKTtcblx0XHRcdFx0XHRpZiAoIGNvbnRhaW5lci50YWdOYW1lID09PSAnU0VMRUNUJyApIHtcblx0XHRcdFx0XHRcdHNlbGVjdGVkT3B0aW9uID0gY29udGFpbmVyLm9wdGlvbnNbIGNvbnRhaW5lci5zZWxlY3RlZEluZGV4IF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5zdmcgKSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gZWxlbWVudCggJ0RJVicgKTtcblx0XHRcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmcgY2xhc3M9XCJ4XCI+JyArIGh0bWwgKyAnPC9zdmc+Jztcblx0XHRcdFx0XHRjb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvciggJy54JyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoIG5vZGUudGFnTmFtZSApO1xuXHRcdFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuXHRcdFx0XHRcdGlmICggY29udGFpbmVyLnRhZ05hbWUgPT09ICdTRUxFQ1QnICkge1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWRPcHRpb24gPSBjb250YWluZXIub3B0aW9uc1sgY29udGFpbmVyLnNlbGVjdGVkSW5kZXggXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0d2hpbGUgKCBjaGlsZCA9IGNvbnRhaW5lci5maXJzdENoaWxkICkge1xuXHRcdFx0XHRcdG5vZGVzLnB1c2goIGNoaWxkICk7XG5cdFx0XHRcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZCggY2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBUaGlzIGlzIHJlYWxseSBhbm5veWluZy4gRXh0cmFjdGluZyA8b3B0aW9uPiBub2RlcyBmcm9tIHRoZVxuXHRcdFx0XHQvLyB0ZW1wb3JhcnkgY29udGFpbmVyIDxzZWxlY3Q+IGNhdXNlcyB0aGUgcmVtYWluaW5nIG9uZXMgdG9cblx0XHRcdFx0Ly8gYmVjb21lIHNlbGVjdGVkLiBTbyBub3cgd2UgaGF2ZSB0byBkZXNlbGVjdCB0aGVtLiBJRTgsIHlvdVxuXHRcdFx0XHQvLyBhbWF6ZSBtZS4gWW91IHJlYWxseSBkb1xuXHRcdFx0XHQvLyAuLi5hbmQgbm93IENocm9tZSB0b29cblx0XHRcdFx0aWYgKCBub2RlLnRhZ05hbWUgPT09ICdTRUxFQ1QnICkge1xuXHRcdFx0XHRcdGkgPSBub2Rlcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGVzWyBpIF0gIT09IHNlbGVjdGVkT3B0aW9uICkge1xuXHRcdFx0XHRcdFx0XHRub2Rlc1sgaSBdLnNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbm9kZXM7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGVsZW1lbnQoIHRhZ05hbWUgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudENhY2hlWyB0YWdOYW1lIF0gfHwgKCBlbGVtZW50Q2FjaGVbIHRhZ05hbWUgXSA9IGNyZWF0ZUVsZW1lbnQoIHRhZ05hbWUgKSApO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIG5hbWVzcGFjZXMsIGNyZWF0ZUVsZW1lbnQgKTtcblxuXHQvKiB1dGlscy90b0FycmF5LmpzICovXG5cdHZhciB0b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSggYXJyYXlMaWtlICkge1xuXHRcdHZhciBhcnJheSA9IFtdLFxuXHRcdFx0aSA9IGFycmF5TGlrZS5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhcnJheVsgaSBdID0gYXJyYXlMaWtlWyBpIF07XG5cdFx0fVxuXHRcdHJldHVybiBhcnJheTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9oZWxwZXJzL3VwZGF0ZVNlbGVjdC5qcyAqL1xuXHR2YXIgdXBkYXRlU2VsZWN0ID0gZnVuY3Rpb24oIHRvQXJyYXkgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiB1cGRhdGVTZWxlY3QoIHBhcmVudEVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgc2VsZWN0ZWRPcHRpb25zLCBvcHRpb24sIHZhbHVlO1xuXHRcdFx0aWYgKCAhcGFyZW50RWxlbWVudCB8fCBwYXJlbnRFbGVtZW50Lm5hbWUgIT09ICdzZWxlY3QnIHx8ICFwYXJlbnRFbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNlbGVjdGVkT3B0aW9ucyA9IHRvQXJyYXkoIHBhcmVudEVsZW1lbnQubm9kZS5vcHRpb25zICkuZmlsdGVyKCBpc1NlbGVjdGVkICk7XG5cdFx0XHQvLyBJZiBvbmUgb2YgdGhlbSBoYWQgYSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSwgd2UgbmVlZCB0byBzeW5jXG5cdFx0XHQvLyB0aGUgbW9kZWwgdG8gdGhlIHZpZXdcblx0XHRcdGlmICggcGFyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoICdtdWx0aXBsZScgKSApIHtcblx0XHRcdFx0dmFsdWUgPSBzZWxlY3RlZE9wdGlvbnMubWFwKCBmdW5jdGlvbiggbyApIHtcblx0XHRcdFx0XHRyZXR1cm4gby52YWx1ZTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSBlbHNlIGlmICggb3B0aW9uID0gc2VsZWN0ZWRPcHRpb25zWyAwIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gb3B0aW9uLnZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRwYXJlbnRFbGVtZW50LmJpbmRpbmcuc2V0VmFsdWUoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0XHRwYXJlbnRFbGVtZW50LmJ1YmJsZSgpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpc1NlbGVjdGVkKCBvcHRpb24gKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9uLnNlbGVjdGVkO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHRvQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRyZW5kZXIgPSBmdW5jdGlvbiggaW5zZXJ0SHRtbCwgdXBkYXRlU2VsZWN0ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyaXBsZSRyZW5kZXIoKSB7XG5cdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0F0dGVtcHRlZCB0byByZW5kZXIgYW4gaXRlbSB0aGF0IHdhcyBhbHJlYWR5IHJlbmRlcmVkJyApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0dGhpcy5ub2RlcyA9IGluc2VydEh0bWwoIHRoaXMudmFsdWUsIHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpLCB0aGlzLmRvY0ZyYWcgKTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHdlJ3JlIGluc2VydGluZyB0aGUgY29udGVudHMgb2YgYSA8c2VsZWN0PlxuXHRcdFx0dXBkYXRlU2VsZWN0KCB0aGlzLnBFbGVtZW50ICk7XG5cdFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0aGlzLmRvY0ZyYWc7XG5cdFx0fTtcblx0fSggaW5zZXJ0SHRtbCwgdXBkYXRlU2VsZWN0ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL3NldFZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRzZXRWYWx1ZSA9IGZ1bmN0aW9uKCBydW5sb29wICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyaXBsZSRzZXRWYWx1ZSggdmFsdWUgKSB7XG5cdFx0XHR2YXIgd3JhcHBlcjtcblx0XHRcdC8vIFRPRE8gaXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGFwcHJvYWNoIHRoaXM/XG5cdFx0XHRpZiAoIHdyYXBwZXIgPSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRbIHRoaXMua2V5cGF0aCBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlICE9PSB0aGlzLnZhbHVlICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cdFx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXcoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHJ1bmxvb3AgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHRvU3RyaW5nID0gZnVuY3Rpb24oIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJHRvU3RyaW5nKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWUgIT0gdW5kZWZpbmVkID8gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyggJycgKyB0aGlzLnZhbHVlICkgOiAnJztcblx0XHR9O1xuXHR9KCBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR1bnJlbmRlciA9IGZ1bmN0aW9uKCBkZXRhY2hOb2RlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyaXBsZSR1bnJlbmRlciggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCAmJiBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHR0aGlzLm5vZGVzLmZvckVhY2goIGRldGFjaE5vZGUgKTtcblx0XHRcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGRldGFjaE5vZGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvdXBkYXRlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR1cGRhdGUgPSBmdW5jdGlvbiggaW5zZXJ0SHRtbCwgdXBkYXRlU2VsZWN0ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyaXBsZSR1cGRhdGUoKSB7XG5cdFx0XHR2YXIgbm9kZSwgcGFyZW50Tm9kZTtcblx0XHRcdGlmICggIXRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIFJlbW92ZSBleGlzdGluZyBub2Rlc1xuXHRcdFx0d2hpbGUgKCB0aGlzLm5vZGVzICYmIHRoaXMubm9kZXMubGVuZ3RoICkge1xuXHRcdFx0XHRub2RlID0gdGhpcy5ub2Rlcy5wb3AoKTtcblx0XHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBJbnNlcnQgbmV3IG5vZGVzXG5cdFx0XHRwYXJlbnROb2RlID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG5cdFx0XHR0aGlzLm5vZGVzID0gaW5zZXJ0SHRtbCggdGhpcy52YWx1ZSwgcGFyZW50Tm9kZSwgdGhpcy5kb2NGcmFnICk7XG5cdFx0XHRwYXJlbnROb2RlLmluc2VydEJlZm9yZSggdGhpcy5kb2NGcmFnLCB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApICk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSB3ZSdyZSBpbnNlcnRpbmcgdGhlIGNvbnRlbnRzIG9mIGEgPHNlbGVjdD5cblx0XHRcdHVwZGF0ZVNlbGVjdCggdGhpcy5wRWxlbWVudCApO1xuXHRcdH07XG5cdH0oIGluc2VydEh0bWwsIHVwZGF0ZVNlbGVjdCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL19UcmlwbGUuanMgKi9cblx0dmFyIFRyaXBsZSA9IGZ1bmN0aW9uKCB0eXBlcywgTXVzdGFjaGUsIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmlyc3ROb2RlLCByZW5kZXIsIHNldFZhbHVlLCB0b1N0cmluZywgdW5yZW5kZXIsIHVwZGF0ZSwgdW5iaW5kICkge1xuXG5cdFx0dmFyIFRyaXBsZSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuVFJJUExFO1xuXHRcdFx0TXVzdGFjaGUuaW5pdCggdGhpcywgb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0VHJpcGxlLnByb3RvdHlwZSA9IHtcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcblx0XHRcdGdldFZhbHVlOiBNdXN0YWNoZS5nZXRWYWx1ZSxcblx0XHRcdHJlYmluZDogTXVzdGFjaGUucmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuXHRcdFx0c2V0VmFsdWU6IHNldFZhbHVlLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXIsXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZVxuXHRcdH07XG5cdFx0cmV0dXJuIFRyaXBsZTtcblx0fSggdHlwZXMsIE11c3RhY2hlLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRkZXRhY2gsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpbmQsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpbmRBbGwsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpcnN0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRzZXRWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdG9TdHJpbmcsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHVucmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR1cGRhdGUsIHVuYmluZCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvYnViYmxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkYnViYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2RldGFjaC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGRldGFjaCA9IGZ1bmN0aW9uIEVsZW1lbnQkZGV0YWNoKCkge1xuXHRcdHZhciBub2RlID0gdGhpcy5ub2RlLFxuXHRcdFx0cGFyZW50Tm9kZTtcblx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHQvLyBuZWVkIHRvIGNoZWNrIGZvciBwYXJlbnQgbm9kZSAtIERPTSBtYXkgaGF2ZSBiZWVuIGFsdGVyZWRcblx0XHRcdC8vIGJ5IHNvbWV0aGluZyBvdGhlciB0aGFuIFJhY3RpdmUhIGUuZy4galF1ZXJ5IFVJLi4uXG5cdFx0XHRpZiAoIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBub2RlO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kID0gZnVuY3Rpb24oIG1hdGNoZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0aWYgKCBtYXRjaGVzKCB0aGlzLm5vZGUsIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5mcmFnbWVudC5maW5kICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIG1hdGNoZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kQWxsID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHQvLyBBZGQgdGhpcyBub2RlIHRvIHRoZSBxdWVyeSwgaWYgYXBwbGljYWJsZSwgYW5kIHJlZ2lzdGVyIHRoZVxuXHRcdC8vIHF1ZXJ5IG9uIHRoaXMgZWxlbWVudFxuXHRcdGlmICggcXVlcnkuX3Rlc3QoIHRoaXMsIHRydWUgKSAmJiBxdWVyeS5saXZlICkge1xuXHRcdFx0KCB0aGlzLmxpdmVRdWVyaWVzIHx8ICggdGhpcy5saXZlUXVlcmllcyA9IFtdICkgKS5wdXNoKCBxdWVyeSApO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kQ29tcG9uZW50ID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZmluZE5leHROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZE5leHROb2RlID0gZnVuY3Rpb24gRWxlbWVudCRmaW5kTmV4dE5vZGUoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maXJzdE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaXJzdE5vZGUgPSBmdW5jdGlvbiBFbGVtZW50JGZpcnN0Tm9kZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZ2V0QXR0cmlidXRlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gRWxlbWVudCRnZXRBdHRyaWJ1dGUoIG5hbWUgKSB7XG5cdFx0aWYgKCAhdGhpcy5hdHRyaWJ1dGVzIHx8ICF0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdLnZhbHVlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zaGFyZWQvZW5mb3JjZUNhc2UuanMgKi9cblx0dmFyIGVuZm9yY2VDYXNlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgc3ZnQ2FtZWxDYXNlRWxlbWVudHMsIHN2Z0NhbWVsQ2FzZUF0dHJpYnV0ZXMsIGNyZWF0ZU1hcCwgbWFwO1xuXHRcdHN2Z0NhbWVsQ2FzZUVsZW1lbnRzID0gJ2FsdEdseXBoIGFsdEdseXBoRGVmIGFsdEdseXBoSXRlbSBhbmltYXRlQ29sb3IgYW5pbWF0ZU1vdGlvbiBhbmltYXRlVHJhbnNmb3JtIGNsaXBQYXRoIGZlQmxlbmQgZmVDb2xvck1hdHJpeCBmZUNvbXBvbmVudFRyYW5zZmVyIGZlQ29tcG9zaXRlIGZlQ29udm9sdmVNYXRyaXggZmVEaWZmdXNlTGlnaHRpbmcgZmVEaXNwbGFjZW1lbnRNYXAgZmVEaXN0YW50TGlnaHQgZmVGbG9vZCBmZUZ1bmNBIGZlRnVuY0IgZmVGdW5jRyBmZUZ1bmNSIGZlR2F1c3NpYW5CbHVyIGZlSW1hZ2UgZmVNZXJnZSBmZU1lcmdlTm9kZSBmZU1vcnBob2xvZ3kgZmVPZmZzZXQgZmVQb2ludExpZ2h0IGZlU3BlY3VsYXJMaWdodGluZyBmZVNwb3RMaWdodCBmZVRpbGUgZmVUdXJidWxlbmNlIGZvcmVpZ25PYmplY3QgZ2x5cGhSZWYgbGluZWFyR3JhZGllbnQgcmFkaWFsR3JhZGllbnQgdGV4dFBhdGggdmtlcm4nLnNwbGl0KCAnICcgKTtcblx0XHRzdmdDYW1lbENhc2VBdHRyaWJ1dGVzID0gJ2F0dHJpYnV0ZU5hbWUgYXR0cmlidXRlVHlwZSBiYXNlRnJlcXVlbmN5IGJhc2VQcm9maWxlIGNhbGNNb2RlIGNsaXBQYXRoVW5pdHMgY29udGVudFNjcmlwdFR5cGUgY29udGVudFN0eWxlVHlwZSBkaWZmdXNlQ29uc3RhbnQgZWRnZU1vZGUgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCBmaWx0ZXJSZXMgZmlsdGVyVW5pdHMgZ2x5cGhSZWYgZ3JhZGllbnRUcmFuc2Zvcm0gZ3JhZGllbnRVbml0cyBrZXJuZWxNYXRyaXgga2VybmVsVW5pdExlbmd0aCBrZXlQb2ludHMga2V5U3BsaW5lcyBrZXlUaW1lcyBsZW5ndGhBZGp1c3QgbGltaXRpbmdDb25lQW5nbGUgbWFya2VySGVpZ2h0IG1hcmtlclVuaXRzIG1hcmtlcldpZHRoIG1hc2tDb250ZW50VW5pdHMgbWFza1VuaXRzIG51bU9jdGF2ZXMgcGF0aExlbmd0aCBwYXR0ZXJuQ29udGVudFVuaXRzIHBhdHRlcm5UcmFuc2Zvcm0gcGF0dGVyblVuaXRzIHBvaW50c0F0WCBwb2ludHNBdFkgcG9pbnRzQXRaIHByZXNlcnZlQWxwaGEgcHJlc2VydmVBc3BlY3RSYXRpbyBwcmltaXRpdmVVbml0cyByZWZYIHJlZlkgcmVwZWF0Q291bnQgcmVwZWF0RHVyIHJlcXVpcmVkRXh0ZW5zaW9ucyByZXF1aXJlZEZlYXR1cmVzIHNwZWN1bGFyQ29uc3RhbnQgc3BlY3VsYXJFeHBvbmVudCBzcHJlYWRNZXRob2Qgc3RhcnRPZmZzZXQgc3RkRGV2aWF0aW9uIHN0aXRjaFRpbGVzIHN1cmZhY2VTY2FsZSBzeXN0ZW1MYW5ndWFnZSB0YWJsZVZhbHVlcyB0YXJnZXRYIHRhcmdldFkgdGV4dExlbmd0aCB2aWV3Qm94IHZpZXdUYXJnZXQgeENoYW5uZWxTZWxlY3RvciB5Q2hhbm5lbFNlbGVjdG9yIHpvb21BbmRQYW4nLnNwbGl0KCAnICcgKTtcblx0XHRjcmVhdGVNYXAgPSBmdW5jdGlvbiggaXRlbXMgKSB7XG5cdFx0XHR2YXIgbWFwID0ge30sXG5cdFx0XHRcdGkgPSBpdGVtcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0bWFwWyBpdGVtc1sgaSBdLnRvTG93ZXJDYXNlKCkgXSA9IGl0ZW1zWyBpIF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWFwO1xuXHRcdH07XG5cdFx0bWFwID0gY3JlYXRlTWFwKCBzdmdDYW1lbENhc2VFbGVtZW50cy5jb25jYXQoIHN2Z0NhbWVsQ2FzZUF0dHJpYnV0ZXMgKSApO1xuXHRcdHJldHVybiBmdW5jdGlvbiggZWxlbWVudE5hbWUgKSB7XG5cdFx0XHR2YXIgbG93ZXJDYXNlRWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG1hcFsgbG93ZXJDYXNlRWxlbWVudE5hbWUgXSB8fCBsb3dlckNhc2VFbGVtZW50TmFtZTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvYnViYmxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJGJ1YmJsZSA9IGZ1bmN0aW9uKCBydW5sb29wLCBpc0VxdWFsICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSRidWJibGUoKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cdFx0XHQvLyBUT0RPIHRoaXMgY2FuIHJlZ2lzdGVyIHRoZSBhdHRyaWJ1dGUgbXVsdGlwbGUgdGltZXMgKHNlZSByZW5kZXIgdGVzdFxuXHRcdFx0Ly8gJ0F0dHJpYnV0ZSB3aXRoIG5lc3RlZCBtdXN0YWNoZXMnKVxuXHRcdFx0aWYgKCAhaXNFcXVhbCggdmFsdWUsIHRoaXMudmFsdWUgKSApIHtcblx0XHRcdFx0Ly8gTmVlZCB0byBjbGVhciBvbGQgaWQgZnJvbSByYWN0aXZlLm5vZGVzXG5cdFx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnaWQnICYmIHRoaXMudmFsdWUgKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMucm9vdC5ub2Rlc1sgdGhpcy52YWx1ZSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICd2YWx1ZScgJiYgdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gc3RvcmUgdGhlIHZhbHVlIG9uIHRoZSBET00gbGlrZSB0aGlzIHNvIHdlXG5cdFx0XHRcdFx0Ly8gY2FuIHJldHJpZXZlIGl0IGxhdGVyIHdpdGhvdXQgaXQgYmVpbmcgY29lcmNlZCB0byBhIHN0cmluZ1xuXHRcdFx0XHRcdHRoaXMubm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXcoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIGlzRXF1YWwgKTtcblxuXHQvKiBjb25maWcvYm9vbGVhbkF0dHJpYnV0ZXMuanMgKi9cblx0dmFyIGJvb2xlYW5BdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7XG5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2h0bWwtbWluaWZpZXIvaXNzdWVzLzYzI2lzc3VlY29tbWVudC0zNzc2MzMxNlxuXHRcdHZhciBib29sZWFuQXR0cmlidXRlcyA9IC9eKGFsbG93RnVsbHNjcmVlbnxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y2hlY2tlZHxjb21wYWN0fGNvbnRyb2xzfGRlY2xhcmV8ZGVmYXVsdHxkZWZhdWx0Q2hlY2tlZHxkZWZhdWx0TXV0ZWR8ZGVmYXVsdFNlbGVjdGVkfGRlZmVyfGRpc2FibGVkfGRyYWdnYWJsZXxlbmFibGVkfGZvcm1Ob1ZhbGlkYXRlfGhpZGRlbnxpbmRldGVybWluYXRlfGluZXJ0fGlzTWFwfGl0ZW1TY29wZXxsb29wfG11bHRpcGxlfG11dGVkfG5vSHJlZnxub1Jlc2l6ZXxub1NoYWRlfG5vVmFsaWRhdGV8bm9XcmFwfG9wZW58cGF1c2VPbkV4aXR8cmVhZE9ubHl8cmVxdWlyZWR8cmV2ZXJzZWR8c2NvcGVkfHNlYW1sZXNzfHNlbGVjdGVkfHNvcnRhYmxlfHRyYW5zbGF0ZXx0cnVlU3BlZWR8dHlwZU11c3RNYXRjaHx2aXNpYmxlKSQvaTtcblx0XHRyZXR1cm4gYm9vbGVhbkF0dHJpYnV0ZXM7XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL2hlbHBlcnMvZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZS5qcyAqL1xuXHR2YXIgZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSA9IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBlbmZvcmNlQ2FzZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggYXR0cmlidXRlLCBuYW1lICkge1xuXHRcdFx0dmFyIGNvbG9uSW5kZXgsIG5hbWVzcGFjZVByZWZpeDtcblx0XHRcdC8vIGFyZSB3ZSBkZWFsaW5nIHdpdGggYSBuYW1lc3BhY2VkIGF0dHJpYnV0ZSwgZS5nLiB4bGluazpocmVmP1xuXHRcdFx0Y29sb25JbmRleCA9IG5hbWUuaW5kZXhPZiggJzonICk7XG5cdFx0XHRpZiAoIGNvbG9uSW5kZXggIT09IC0xICkge1xuXHRcdFx0XHQvLyBsb29rcyBsaWtlIHdlIGFyZSwgeWVzLi4uXG5cdFx0XHRcdG5hbWVzcGFjZVByZWZpeCA9IG5hbWUuc3Vic3RyKCAwLCBjb2xvbkluZGV4ICk7XG5cdFx0XHRcdC8vIC4uLnVubGVzcyBpdCdzIGEgbmFtZXNwYWNlICpkZWNsYXJhdGlvbiosIHdoaWNoIHdlIGlnbm9yZSAob24gdGhlIGFzc3VtcHRpb25cblx0XHRcdFx0Ly8gdGhhdCBvbmx5IHZhbGlkIG5hbWVzcGFjZXMgd2lsbCBiZSB1c2VkKVxuXHRcdFx0XHRpZiAoIG5hbWVzcGFjZVByZWZpeCAhPT0gJ3htbG5zJyApIHtcblx0XHRcdFx0XHRuYW1lID0gbmFtZS5zdWJzdHJpbmcoIGNvbG9uSW5kZXggKyAxICk7XG5cdFx0XHRcdFx0YXR0cmlidXRlLm5hbWUgPSBlbmZvcmNlQ2FzZSggbmFtZSApO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzWyBuYW1lc3BhY2VQcmVmaXgudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5uYW1lc3BhY2VQcmVmaXggPSBuYW1lc3BhY2VQcmVmaXg7XG5cdFx0XHRcdFx0aWYgKCAhYXR0cmlidXRlLm5hbWVzcGFjZSApIHtcblx0XHRcdFx0XHRcdHRocm93ICdVbmtub3duIG5hbWVzcGFjZSAoXCInICsgbmFtZXNwYWNlUHJlZml4ICsgJ1wiKSc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gU1ZHIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZSBzZW5zaXRpdmVcblx0XHRcdGF0dHJpYnV0ZS5uYW1lID0gYXR0cmlidXRlLmVsZW1lbnQubmFtZXNwYWNlICE9PSBuYW1lc3BhY2VzLmh0bWwgPyBlbmZvcmNlQ2FzZSggbmFtZSApIDogbmFtZTtcblx0XHR9O1xuXHR9KCBuYW1lc3BhY2VzLCBlbmZvcmNlQ2FzZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvaGVscGVycy9nZXRJbnRlcnBvbGF0b3IuanMgKi9cblx0dmFyIGdldEludGVycG9sYXRvciA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRJbnRlcnBvbGF0b3IoIGF0dHJpYnV0ZSApIHtcblx0XHRcdHZhciBpdGVtcyA9IGF0dHJpYnV0ZS5mcmFnbWVudC5pdGVtcztcblx0XHRcdGlmICggaXRlbXMubGVuZ3RoICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGl0ZW1zWyAwIF0udHlwZSA9PT0gdHlwZXMuSU5URVJQT0xBVE9SICkge1xuXHRcdFx0XHRyZXR1cm4gaXRlbXNbIDAgXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvaGVscGVycy9kZXRlcm1pbmVQcm9wZXJ0eU5hbWUuanMgKi9cblx0dmFyIGRldGVybWluZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBib29sZWFuQXR0cmlidXRlcyApIHtcblxuXHRcdHZhciBwcm9wZXJ0eU5hbWVzID0ge1xuXHRcdFx0J2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuXHRcdFx0YWNjZXNza2V5OiAnYWNjZXNzS2V5Jyxcblx0XHRcdGJnY29sb3I6ICdiZ0NvbG9yJyxcblx0XHRcdCdjbGFzcyc6ICdjbGFzc05hbWUnLFxuXHRcdFx0Y29kZWJhc2U6ICdjb2RlQmFzZScsXG5cdFx0XHRjb2xzcGFuOiAnY29sU3BhbicsXG5cdFx0XHRjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuXHRcdFx0ZGF0ZXRpbWU6ICdkYXRlVGltZScsXG5cdFx0XHRkaXJuYW1lOiAnZGlyTmFtZScsXG5cdFx0XHQnZm9yJzogJ2h0bWxGb3InLFxuXHRcdFx0J2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2Jyxcblx0XHRcdGlzbWFwOiAnaXNNYXAnLFxuXHRcdFx0bWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcblx0XHRcdG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcblx0XHRcdHB1YmRhdGU6ICdwdWJEYXRlJyxcblx0XHRcdHJlYWRvbmx5OiAncmVhZE9ubHknLFxuXHRcdFx0cm93c3BhbjogJ3Jvd1NwYW4nLFxuXHRcdFx0dGFiaW5kZXg6ICd0YWJJbmRleCcsXG5cdFx0XHR1c2VtYXA6ICd1c2VNYXAnXG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGF0dHJpYnV0ZSwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBwcm9wZXJ0eU5hbWU7XG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5wTm9kZSAmJiAhYXR0cmlidXRlLm5hbWVzcGFjZSAmJiAoICFvcHRpb25zLnBOb2RlLm5hbWVzcGFjZVVSSSB8fCBvcHRpb25zLnBOb2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5odG1sICkgKSB7XG5cdFx0XHRcdHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZXNbIGF0dHJpYnV0ZS5uYW1lIF0gfHwgYXR0cmlidXRlLm5hbWU7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5wTm9kZVsgcHJvcGVydHlOYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRhdHRyaWJ1dGUucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlzIGF0dHJpYnV0ZSBhIGJvb2xlYW4gYXR0cmlidXRlIG9yICd2YWx1ZSc/IElmIHNvIHdlJ3JlIGJldHRlciBvZmYgZG9pbmcgZS5nLlxuXHRcdFx0XHQvLyBub2RlLnNlbGVjdGVkID0gdHJ1ZSByYXRoZXIgdGhhbiBub2RlLnNldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJywgJycgKVxuXHRcdFx0XHRpZiAoIGJvb2xlYW5BdHRyaWJ1dGVzLnRlc3QoIHByb3BlcnR5TmFtZSApIHx8IHByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJyApIHtcblx0XHRcdFx0XHRhdHRyaWJ1dGUudXNlUHJvcGVydHkgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggbmFtZXNwYWNlcywgYm9vbGVhbkF0dHJpYnV0ZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJGluaXQgPSBmdW5jdGlvbiggdHlwZXMsIGJvb2xlYW5BdHRyaWJ1dGVzLCBkZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlLCBnZXRJbnRlcnBvbGF0b3IsIGRldGVybWluZVByb3BlcnR5TmFtZSwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJGluaXQoIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5BVFRSSUJVVEU7XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG5cdFx0XHR0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3Q7XG5cdFx0XHRkZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlKCB0aGlzLCBvcHRpb25zLm5hbWUgKTtcblx0XHRcdC8vIGlmIGl0J3MgYW4gZW1wdHkgYXR0cmlidXRlLCBvciBqdXN0IGEgc3RyYWlnaHQga2V5LXZhbHVlIHBhaXIsIHdpdGggbm9cblx0XHRcdC8vIG11c3RhY2hlIHNoZW5hbmlnYW5zLCBzZXQgdGhlIGF0dHJpYnV0ZSBhY2NvcmRpbmdseSBhbmQgZ28gaG9tZVxuXHRcdFx0aWYgKCAhb3B0aW9ucy52YWx1ZSB8fCB0eXBlb2Ygb3B0aW9ucy52YWx1ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSBib29sZWFuQXR0cmlidXRlcy50ZXN0KCB0aGlzLm5hbWUgKSA/IHRydWUgOiBvcHRpb25zLnZhbHVlIHx8ICcnO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byBkbyBzb21lIHdvcmtcblx0XHRcdC8vIHNoYXJlIHBhcmVudEZyYWdtZW50IHdpdGggcGFyZW50IGVsZW1lbnRcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdHRlbXBsYXRlOiBvcHRpb25zLnZhbHVlLFxuXHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdFx0Ly8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhpcyBhdHRyaWJ1dGUncyBpbnRlcnBvbGF0b3IsIGlmIGl0cyBmcmFnbWVudFxuXHRcdFx0Ly8gdGFrZXMgdGhlIGZvcm0gYHt7Zm9vfX1gLiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgdHdvLXdheSBiaW5kaW5nIGFuZFxuXHRcdFx0Ly8gZm9yIGNvcnJlY3RseSByZW5kZXJpbmcgSFRNTCBsYXRlclxuXHRcdFx0dGhpcy5pbnRlcnBvbGF0b3IgPSBnZXRJbnRlcnBvbGF0b3IoIHRoaXMgKTtcblx0XHRcdHRoaXMuaXNCaW5kYWJsZSA9ICEhdGhpcy5pbnRlcnBvbGF0b3IgJiYgIXRoaXMuaW50ZXJwb2xhdG9yLmlzU3RhdGljO1xuXHRcdFx0Ly8gY2FuIHdlIGVzdGFibGlzaCB0aGlzIGF0dHJpYnV0ZSdzIHByb3BlcnR5IG5hbWUgZXF1aXZhbGVudD9cblx0XHRcdGRldGVybWluZVByb3BlcnR5TmFtZSggdGhpcywgb3B0aW9ucyApO1xuXHRcdFx0Ly8gbWFyayBhcyByZWFkeVxuXHRcdFx0dGhpcy5yZWFkeSA9IHRydWU7XG5cdFx0fTtcblx0fSggdHlwZXMsIGJvb2xlYW5BdHRyaWJ1dGVzLCBkZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlLCBnZXRJbnRlcnBvbGF0b3IsIGRldGVybWluZVByb3BlcnR5TmFtZSwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS9yZWJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkcmViaW5kID0gZnVuY3Rpb24gQXR0cmlidXRlJHJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHJlbmRlciA9IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBib29sZWFuQXR0cmlidXRlcyApIHtcblxuXHRcdHZhciBwcm9wZXJ0eU5hbWVzID0ge1xuXHRcdFx0J2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuXHRcdFx0J2FjY2Vzc2tleSc6ICdhY2Nlc3NLZXknLFxuXHRcdFx0J2JnY29sb3InOiAnYmdDb2xvcicsXG5cdFx0XHQnY2xhc3MnOiAnY2xhc3NOYW1lJyxcblx0XHRcdCdjb2RlYmFzZSc6ICdjb2RlQmFzZScsXG5cdFx0XHQnY29sc3Bhbic6ICdjb2xTcGFuJyxcblx0XHRcdCdjb250ZW50ZWRpdGFibGUnOiAnY29udGVudEVkaXRhYmxlJyxcblx0XHRcdCdkYXRldGltZSc6ICdkYXRlVGltZScsXG5cdFx0XHQnZGlybmFtZSc6ICdkaXJOYW1lJyxcblx0XHRcdCdmb3InOiAnaHRtbEZvcicsXG5cdFx0XHQnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuXHRcdFx0J2lzbWFwJzogJ2lzTWFwJyxcblx0XHRcdCdtYXhsZW5ndGgnOiAnbWF4TGVuZ3RoJyxcblx0XHRcdCdub3ZhbGlkYXRlJzogJ25vVmFsaWRhdGUnLFxuXHRcdFx0J3B1YmRhdGUnOiAncHViRGF0ZScsXG5cdFx0XHQncmVhZG9ubHknOiAncmVhZE9ubHknLFxuXHRcdFx0J3Jvd3NwYW4nOiAncm93U3BhbicsXG5cdFx0XHQndGFiaW5kZXgnOiAndGFiSW5kZXgnLFxuXHRcdFx0J3VzZW1hcCc6ICd1c2VNYXAnXG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJHJlbmRlciggbm9kZSApIHtcblx0XHRcdHZhciBwcm9wZXJ0eU5hbWU7XG5cdFx0XHR0aGlzLm5vZGUgPSBub2RlO1xuXHRcdFx0Ly8gc2hvdWxkIHdlIHVzZSBkaXJlY3QgcHJvcGVydHkgYWNjZXNzLCBvciBzZXRBdHRyaWJ1dGU/XG5cdFx0XHRpZiAoICFub2RlLm5hbWVzcGFjZVVSSSB8fCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5odG1sICkge1xuXHRcdFx0XHRwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVzWyB0aGlzLm5hbWUgXSB8fCB0aGlzLm5hbWU7XG5cdFx0XHRcdGlmICggbm9kZVsgcHJvcGVydHlOYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpcyBhdHRyaWJ1dGUgYSBib29sZWFuIGF0dHJpYnV0ZSBvciAndmFsdWUnPyBJZiBzbyB3ZSdyZSBiZXR0ZXIgb2ZmIGRvaW5nIGUuZy5cblx0XHRcdFx0Ly8gbm9kZS5zZWxlY3RlZCA9IHRydWUgcmF0aGVyIHRoYW4gbm9kZS5zZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcsICcnIClcblx0XHRcdFx0aWYgKCBib29sZWFuQXR0cmlidXRlcy50ZXN0KCBwcm9wZXJ0eU5hbWUgKSB8fCBwcm9wZXJ0eU5hbWUgPT09ICd2YWx1ZScgKSB7XG5cdFx0XHRcdFx0dGhpcy51c2VQcm9wZXJ0eSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBwcm9wZXJ0eU5hbWUgPT09ICd2YWx1ZScgKSB7XG5cdFx0XHRcdFx0dGhpcy51c2VQcm9wZXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0bm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9O1xuXHR9KCBuYW1lc3BhY2VzLCBib29sZWFuQXR0cmlidXRlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHRvU3RyaW5nID0gZnVuY3Rpb24oIGJvb2xlYW5BdHRyaWJ1dGVzICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gQXR0cmlidXRlJHRvU3RyaW5nKCkge1xuXHRcdFx0dmFyIG5hbWUgPSAoIGZyYWdtZW50ID0gdGhpcyApLm5hbWUsXG5cdFx0XHRcdG5hbWVzcGFjZVByZWZpeCA9IGZyYWdtZW50Lm5hbWVzcGFjZVByZWZpeCxcblx0XHRcdFx0dmFsdWUgPSBmcmFnbWVudC52YWx1ZSxcblx0XHRcdFx0aW50ZXJwb2xhdG9yID0gZnJhZ21lbnQuaW50ZXJwb2xhdG9yLFxuXHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LmZyYWdtZW50O1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gc2VsZWN0IGFuZCB0ZXh0YXJlYSB2YWx1ZXMgKHNob3VsZCBub3QgYmUgc3RyaW5naWZpZWQpXG5cdFx0XHRpZiAoIG5hbWUgPT09ICd2YWx1ZScgJiYgKCB0aGlzLmVsZW1lbnQubmFtZSA9PT0gJ3NlbGVjdCcgfHwgdGhpcy5lbGVtZW50Lm5hbWUgPT09ICd0ZXh0YXJlYScgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gY29udGVudCBlZGl0YWJsZVxuXHRcdFx0aWYgKCBuYW1lID09PSAndmFsdWUnICYmIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdjb250ZW50ZWRpdGFibGUnICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gcmFkaW8gbmFtZXNcblx0XHRcdGlmICggbmFtZSA9PT0gJ25hbWUnICYmIHRoaXMuZWxlbWVudC5uYW1lID09PSAnaW5wdXQnICYmIGludGVycG9sYXRvciApIHtcblx0XHRcdFx0cmV0dXJuICduYW1lPXt7JyArICggaW50ZXJwb2xhdG9yLmtleXBhdGggfHwgaW50ZXJwb2xhdG9yLnJlZiApICsgJ319Jztcblx0XHRcdH1cblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlc1xuXHRcdFx0aWYgKCBib29sZWFuQXR0cmlidXRlcy50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA/IG5hbWUgOiAnJztcblx0XHRcdH1cblx0XHRcdGlmICggZnJhZ21lbnQgKSB7XG5cdFx0XHRcdHZhbHVlID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcblx0XHRcdH1cblx0XHRcdGlmICggbmFtZXNwYWNlUHJlZml4ICkge1xuXHRcdFx0XHRuYW1lID0gbmFtZXNwYWNlUHJlZml4ICsgJzonICsgbmFtZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZSA/IG5hbWUgKyAnPVwiJyArIGVzY2FwZSggdmFsdWUgKSArICdcIicgOiBuYW1lO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBlc2NhcGUoIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlLnJlcGxhY2UoIC8mL2csICcmYW1wOycgKS5yZXBsYWNlKCAvXCIvZywgJyZxdW90OycgKS5yZXBsYWNlKCAvJy9nLCAnJiMzOTsnICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggYm9vbGVhbkF0dHJpYnV0ZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdW5iaW5kID0gZnVuY3Rpb24gQXR0cmlidXRlJHVuYmluZCgpIHtcblx0XHQvLyBpZ25vcmUgbm9uLWR5bmFtaWMgYXR0cmlidXRlc1xuXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5uYW1lID09PSAnaWQnICkge1xuXHRcdFx0ZGVsZXRlIHRoaXMucm9vdC5ub2Rlc1sgdGhpcy52YWx1ZSBdO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlU2VsZWN0VmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVNlbGVjdFZhbHVlID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVNlbGVjdCgpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLFxuXHRcdFx0b3B0aW9ucywgb3B0aW9uLCBvcHRpb25WYWx1ZSwgaTtcblx0XHRpZiAoICF0aGlzLmxvY2tlZCApIHtcblx0XHRcdHRoaXMubm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0b3B0aW9ucyA9IHRoaXMubm9kZS5vcHRpb25zO1xuXHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG5cdFx0XHRcdC8vIG9wdGlvbnMgaW5zZXJ0ZWQgdmlhIGEgdHJpcGxlIGRvbid0IGhhdmUgX3JhY3RpdmVcblx0XHRcdFx0aWYgKCBvcHRpb25WYWx1ZSA9PSB2YWx1ZSApIHtcblx0XHRcdFx0XHQvLyBkb3VibGUgZXF1YWxzIGFzIHdlIG1heSBiZSBjb21wYXJpbmcgbnVtYmVycyB3aXRoIHN0cmluZ3Ncblx0XHRcdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHV0aWxzL2FycmF5Q29udGFpbnMuanMgKi9cblx0dmFyIGFycmF5Q29udGFpbnMgPSBmdW5jdGlvbiBhcnJheUNvbnRhaW5zKCBhcnJheSwgdmFsdWUgKSB7XG5cdFx0Zm9yICggdmFyIGkgPSAwLCBjID0gYXJyYXkubGVuZ3RoOyBpIDwgYzsgaSsrICkge1xuXHRcdFx0aWYgKCBhcnJheVsgaSBdID09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlID0gZnVuY3Rpb24oIGFycmF5Q29udGFpbnMsIGlzQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZU11bHRpcGxlU2VsZWN0KCkge1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZSxcblx0XHRcdFx0b3B0aW9ucywgaSwgb3B0aW9uLCBvcHRpb25WYWx1ZTtcblx0XHRcdGlmICggIWlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHZhbHVlID0gWyB2YWx1ZSBdO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9ucyA9IHRoaXMubm9kZS5vcHRpb25zO1xuXHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG5cdFx0XHRcdC8vIG9wdGlvbnMgaW5zZXJ0ZWQgdmlhIGEgdHJpcGxlIGRvbid0IGhhdmUgX3JhY3RpdmVcblx0XHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gYXJyYXlDb250YWlucyggdmFsdWUsIG9wdGlvblZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggYXJyYXlDb250YWlucywgaXNBcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVSYWRpb05hbWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVJhZGlvTmFtZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVSYWRpb05hbWUoKSB7XG5cdFx0dmFyIG5vZGUgPSAoIHZhbHVlID0gdGhpcyApLm5vZGUsXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuXHRcdG5vZGUuY2hlY2tlZCA9IHZhbHVlID09IG5vZGUuX3JhY3RpdmUudmFsdWU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZVJhZGlvVmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVJhZGlvVmFsdWUgPSBmdW5jdGlvbiggcnVubG9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9WYWx1ZSgpIHtcblx0XHRcdHZhciB3YXNDaGVja2VkLCBub2RlID0gdGhpcy5ub2RlLFxuXHRcdFx0XHRiaW5kaW5nLCBiaW5kaW5ncywgaTtcblx0XHRcdHdhc0NoZWNrZWQgPSBub2RlLmNoZWNrZWQ7XG5cdFx0XHRub2RlLnZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0bm9kZS5jaGVja2VkID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApID09PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKTtcblx0XHRcdC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgLSBpZiB0aGUgaW5wdXQgd2FzIGNoZWNrZWQsIGFuZCB0aGUgdmFsdWVcblx0XHRcdC8vIGNoYW5nZWQgc28gdGhhdCBpdCdzIG5vIGxvbmdlciBjaGVja2VkLCB0aGUgdHdvd2F5IGJpbmRpbmcgaXNcblx0XHRcdC8vIG1vc3QgbGlrZWx5IG91dCBvZiBkYXRlLiBUbyBmaXggaXQgd2UgaGF2ZSB0byBqdW1wIHRocm91Z2ggc29tZVxuXHRcdFx0Ly8gaG9vcHMuLi4gdGhpcyBpcyBhIGxpdHRsZSBrbHVkZ3kgYnV0IGl0IHdvcmtzXG5cdFx0XHRpZiAoIHdhc0NoZWNrZWQgJiYgIW5vZGUuY2hlY2tlZCAmJiB0aGlzLmVsZW1lbnQuYmluZGluZyApIHtcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLmVsZW1lbnQuYmluZGluZy5zaWJsaW5ncztcblx0XHRcdFx0aWYgKCBpID0gYmluZGluZ3MubGVuZ3RoICkge1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoICFiaW5kaW5nLmVsZW1lbnQubm9kZSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBpcyB0aGUgaW5pdGlhbCByZW5kZXIsIHNpYmxpbmdzIGFyZSBzdGlsbCByZW5kZXJpbmchXG5cdFx0XHRcdFx0XHRcdC8vIHdlJ2xsIGNvbWUgYmFjayBsYXRlci4uLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGJpbmRpbmcuZWxlbWVudC5ub2RlLmNoZWNrZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCBiaW5kaW5nLnJvb3Qudmlld21vZGVsICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBiaW5kaW5nLmhhbmRsZUNoYW5nZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggYmluZGluZy5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCBiaW5kaW5nLmtleXBhdGgsIHVuZGVmaW5lZCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVDaGVja2JveE5hbWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNoZWNrYm94TmFtZSA9IGZ1bmN0aW9uKCBpc0FycmF5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDaGVja2JveE5hbWUoKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9ICggdmFsdWUgPSB0aGlzICkuZWxlbWVudCxcblx0XHRcdFx0bm9kZSA9IHZhbHVlLm5vZGUsXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUudmFsdWUsXG5cdFx0XHRcdHZhbHVlQXR0cmlidXRlLCBpO1xuXHRcdFx0dmFsdWVBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0aWYgKCAhaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0bm9kZS5jaGVja2VkID0gdmFsdWUgPT0gdmFsdWVBdHRyaWJ1dGU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIHZhbHVlQXR0cmlidXRlID09IHZhbHVlWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRub2RlLmNoZWNrZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLmNoZWNrZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBpc0FycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUNsYXNzTmFtZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQ2xhc3NOYW1lID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNsYXNzTmFtZSgpIHtcblx0XHR2YXIgbm9kZSwgdmFsdWU7XG5cdFx0bm9kZSA9IHRoaXMubm9kZTtcblx0XHR2YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsdWUgPSAnJztcblx0XHR9XG5cdFx0bm9kZS5jbGFzc05hbWUgPSB2YWx1ZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlSWRBdHRyaWJ1dGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUlkQXR0cmlidXRlID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUlkQXR0cmlidXRlKCkge1xuXHRcdHZhciBub2RlID0gKCB2YWx1ZSA9IHRoaXMgKS5ub2RlLFxuXHRcdFx0dmFsdWUgPSB2YWx1ZS52YWx1ZTtcblx0XHR0aGlzLnJvb3Qubm9kZXNbIHZhbHVlIF0gPSBub2RlO1xuXHRcdG5vZGUuaWQgPSB2YWx1ZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVJRVN0eWxlQXR0cmlidXRlKCkge1xuXHRcdHZhciBub2RlLCB2YWx1ZTtcblx0XHRub2RlID0gdGhpcy5ub2RlO1xuXHRcdHZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdH1cblx0XHRub2RlLnN0eWxlLnNldEF0dHJpYnV0ZSggJ2Nzc1RleHQnLCB2YWx1ZSApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUoKSB7XG5cdFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLmxvY2tlZCApIHtcblx0XHRcdHRoaXMubm9kZS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZVZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVWYWx1ZSgpIHtcblx0XHR2YXIgbm9kZSA9ICggdmFsdWUgPSB0aGlzICkubm9kZSxcblx0XHRcdHZhbHVlID0gdmFsdWUudmFsdWU7XG5cdFx0Ly8gc3RvcmUgYWN0dWFsIHZhbHVlLCBzbyBpdCBkb2Vzbid0IGdldCBjb2VyY2VkIHRvIGEgc3RyaW5nXG5cdFx0bm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuXHRcdC8vIHdpdGggdHdvLXdheSBiaW5kaW5nLCBvbmx5IHVwZGF0ZSBpZiB0aGUgY2hhbmdlIHdhc24ndCBpbml0aWF0ZWQgYnkgdGhlIHVzZXJcblx0XHQvLyBvdGhlcndpc2UgdGhlIGN1cnNvciB3aWxsIG9mdGVuIGJlIHNlbnQgdG8gdGhlIHdyb25nIHBsYWNlXG5cdFx0aWYgKCAhdGhpcy5sb2NrZWQgKSB7XG5cdFx0XHRub2RlLnZhbHVlID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUJvb2xlYW4uanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUJvb2xlYW4gPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQm9vbGVhbkF0dHJpYnV0ZSgpIHtcblx0XHQvLyB3aXRoIHR3by13YXkgYmluZGluZywgb25seSB1cGRhdGUgaWYgdGhlIGNoYW5nZSB3YXNuJ3QgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyXG5cdFx0Ly8gb3RoZXJ3aXNlIHRoZSBjdXJzb3Igd2lsbCBvZnRlbiBiZSBzZW50IHRvIHRoZSB3cm9uZyBwbGFjZVxuXHRcdGlmICggIXRoaXMubG9ja2VkICkge1xuXHRcdFx0dGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdID0gdGhpcy52YWx1ZTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUV2ZXJ5dGhpbmdFbHNlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVFdmVyeXRoaW5nRWxzZSA9IGZ1bmN0aW9uKCBib29sZWFuQXR0cmlidXRlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlRXZlcnl0aGluZ0Vsc2UoKSB7XG5cdFx0XHR2YXIgbm9kZSA9ICggZnJhZ21lbnQgPSB0aGlzICkubm9kZSxcblx0XHRcdFx0bmFtZXNwYWNlID0gZnJhZ21lbnQubmFtZXNwYWNlLFxuXHRcdFx0XHRuYW1lID0gZnJhZ21lbnQubmFtZSxcblx0XHRcdFx0dmFsdWUgPSBmcmFnbWVudC52YWx1ZSxcblx0XHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5mcmFnbWVudDtcblx0XHRcdGlmICggbmFtZXNwYWNlICkge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZU5TKCBuYW1lc3BhY2UsIG5hbWUsICggZnJhZ21lbnQgfHwgdmFsdWUgKS50b1N0cmluZygpICk7XG5cdFx0XHR9IGVsc2UgaWYgKCAhYm9vbGVhbkF0dHJpYnV0ZXMudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSggbmFtZSwgKCBmcmFnbWVudCB8fCB2YWx1ZSApLnRvU3RyaW5nKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoIG5hbWUsICcnICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGJvb2xlYW5BdHRyaWJ1dGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZSA9IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBub29wLCB1cGRhdGVTZWxlY3RWYWx1ZSwgdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSwgdXBkYXRlUmFkaW9OYW1lLCB1cGRhdGVSYWRpb1ZhbHVlLCB1cGRhdGVDaGVja2JveE5hbWUsIHVwZGF0ZUNsYXNzTmFtZSwgdXBkYXRlSWRBdHRyaWJ1dGUsIHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUsIHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlLCB1cGRhdGVWYWx1ZSwgdXBkYXRlQm9vbGVhbiwgdXBkYXRlRXZlcnl0aGluZ0Vsc2UgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZSgpIHtcblx0XHRcdHZhciBuYW1lID0gKCBub2RlID0gdGhpcyApLm5hbWUsXG5cdFx0XHRcdGVsZW1lbnQgPSBub2RlLmVsZW1lbnQsXG5cdFx0XHRcdG5vZGUgPSBub2RlLm5vZGUsXG5cdFx0XHRcdHR5cGUsIHVwZGF0ZU1ldGhvZDtcblx0XHRcdGlmICggbmFtZSA9PT0gJ2lkJyApIHtcblx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlSWRBdHRyaWJ1dGU7XG5cdFx0XHR9IGVsc2UgaWYgKCBuYW1lID09PSAndmFsdWUnICkge1xuXHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBzZWxlY3RzXG5cdFx0XHRcdGlmICggZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyAmJiBuYW1lID09PSAndmFsdWUnICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICkgPyB1cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlIDogdXBkYXRlU2VsZWN0VmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3RleHRhcmVhJyApIHtcblx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVWYWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdjb250ZW50ZWRpdGFibGUnICkgIT0gbnVsbCApIHtcblx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAnaW5wdXQnICkge1xuXHRcdFx0XHRcdHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3R5cGUnICk7XG5cdFx0XHRcdFx0Ly8gdHlwZT0nZmlsZScgdmFsdWU9J3t7ZmlsZUxpc3R9fSc+XG5cdFx0XHRcdFx0aWYgKCB0eXBlID09PSAnZmlsZScgKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSBub29wO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICdyYWRpbycgJiYgZWxlbWVudC5iaW5kaW5nICYmIGVsZW1lbnQuYmluZGluZy5uYW1lID09PSAnbmFtZScgKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVSYWRpb1ZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMudHdvd2F5ICYmIG5hbWUgPT09ICduYW1lJyApIHtcblx0XHRcdFx0aWYgKCBub2RlLnR5cGUgPT09ICdyYWRpbycgKSB7XG5cdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlUmFkaW9OYW1lO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBub2RlLnR5cGUgPT09ICdjaGVja2JveCcgKSB7XG5cdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQ2hlY2tib3hOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBuYW1lID09PSAnc3R5bGUnICYmIG5vZGUuc3R5bGUuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVJRVN0eWxlQXR0cmlidXRlO1xuXHRcdFx0fSBlbHNlIGlmICggbmFtZSA9PT0gJ2NsYXNzJyAmJiAoICFub2RlLm5hbWVzcGFjZVVSSSB8fCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5odG1sICkgKSB7XG5cdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNsYXNzTmFtZTtcblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMudXNlUHJvcGVydHkgKSB7XG5cdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUJvb2xlYW47XG5cdFx0XHR9XG5cdFx0XHRpZiAoICF1cGRhdGVNZXRob2QgKSB7XG5cdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy51cGRhdGUgPSB1cGRhdGVNZXRob2Q7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH07XG5cdH0oIG5hbWVzcGFjZXMsIG5vb3AsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVNlbGVjdFZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVSYWRpb05hbWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVJhZGlvVmFsdWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNoZWNrYm94TmFtZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQ2xhc3NOYW1lLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVJZEF0dHJpYnV0ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVCb29sZWFuLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVFdmVyeXRoaW5nRWxzZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvX0F0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgQXR0cmlidXRlID0gZnVuY3Rpb24oIGJ1YmJsZSwgaW5pdCwgcmViaW5kLCByZW5kZXIsIHRvU3RyaW5nLCB1bmJpbmQsIHVwZGF0ZSApIHtcblxuXHRcdHZhciBBdHRyaWJ1dGUgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMuaW5pdCggb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0QXR0cmlidXRlLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogYnViYmxlLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlYmluZDogcmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHR0b1N0cmluZzogdG9TdHJpbmcsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHVwZGF0ZTogdXBkYXRlXG5cdFx0fTtcblx0XHRyZXR1cm4gQXR0cmlidXRlO1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJGJ1YmJsZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRpbml0LCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHJlYmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdG9TdHJpbmcsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdW5iaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvaW5pdC9jcmVhdGVBdHRyaWJ1dGVzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24oIEF0dHJpYnV0ZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggZWxlbWVudCwgYXR0cmlidXRlcyApIHtcblx0XHRcdHZhciBuYW1lLCBhdHRyaWJ1dGUsIHJlc3VsdCA9IFtdO1xuXHRcdFx0Zm9yICggbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoIG5hbWUgKSApIHtcblx0XHRcdFx0XHRhdHRyaWJ1dGUgPSBuZXcgQXR0cmlidXRlKCB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuXHRcdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHRcdHZhbHVlOiBhdHRyaWJ1dGVzWyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRyb290OiBlbGVtZW50LnJvb3Rcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goIHJlc3VsdFsgbmFtZSBdID0gYXR0cmlidXRlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0fSggQXR0cmlidXRlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0NvbmRpdGlvbmFsQXR0cmlidXRlL19Db25kaXRpb25hbEF0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgQ29uZGl0aW9uYWxBdHRyaWJ1dGUgPSBmdW5jdGlvbiggY2lyY3VsYXIsIG5hbWVzcGFjZXMsIGNyZWF0ZUVsZW1lbnQsIHRvQXJyYXkgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIEZyYWdtZW50LCBkaXY7XG5cdFx0aWYgKCB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0ZGl2ID0gY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0XHR9XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHR2YXIgQ29uZGl0aW9uYWxBdHRyaWJ1dGUgPSBmdW5jdGlvbiggZWxlbWVudCwgdGVtcGxhdGUgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcblx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0cm9vdDogZWxlbWVudC5yb290LFxuXHRcdFx0XHRvd25lcjogdGhpcyxcblx0XHRcdFx0dGVtcGxhdGU6IFsgdGVtcGxhdGUgXVxuXHRcdFx0fSApO1xuXHRcdH07XG5cdFx0Q29uZGl0aW9uYWxBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLm5vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmVsZW1lbnQuYnViYmxlKCk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbiggbm9kZSApIHtcblx0XHRcdFx0dGhpcy5ub2RlID0gbm9kZTtcblx0XHRcdFx0dGhpcy5pc1N2ZyA9IG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLnN2Zztcblx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgc3RyLCBhdHRycztcblx0XHRcdFx0c3RyID0gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuXHRcdFx0XHRhdHRycyA9IHBhcnNlQXR0cmlidXRlcyggc3RyLCB0aGlzLmlzU3ZnICk7XG5cdFx0XHRcdC8vIGFueSBhdHRyaWJ1dGVzIHRoYXQgcHJldmlvdXNseSBleGlzdGVkIGJ1dCBubyBsb25nZXIgZG9cblx0XHRcdFx0Ly8gbXVzdCBiZSByZW1vdmVkXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlcy5maWx0ZXIoIGZ1bmN0aW9uKCBhICkge1xuXHRcdFx0XHRcdHJldHVybiBub3RJbiggYXR0cnMsIGEgKTtcblx0XHRcdFx0fSApLmZvckVhY2goIGZ1bmN0aW9uKCBhICkge1xuXHRcdFx0XHRcdHRoaXMkMC5ub2RlLnJlbW92ZUF0dHJpYnV0ZSggYS5uYW1lICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0YXR0cnMuZm9yRWFjaCggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdFx0dGhpcyQwLm5vZGUuc2V0QXR0cmlidXRlKCBhLm5hbWUsIGEudmFsdWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBhdHRycztcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRfX2V4cG9ydCA9IENvbmRpdGlvbmFsQXR0cmlidXRlO1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKCBzdHIsIGlzU3ZnICkge1xuXHRcdFx0dmFyIHRhZyA9IGlzU3ZnID8gJ3N2ZycgOiAnZGl2Jztcblx0XHRcdGRpdi5pbm5lckhUTUwgPSAnPCcgKyB0YWcgKyAnICcgKyBzdHIgKyAnPjwvJyArIHRhZyArICc+Jztcblx0XHRcdHJldHVybiB0b0FycmF5KCBkaXYuY2hpbGROb2Rlc1sgMCBdLmF0dHJpYnV0ZXMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBub3RJbiggaGF5c3RhY2ssIG5lZWRsZSApIHtcblx0XHRcdHZhciBpID0gaGF5c3RhY2subGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggaGF5c3RhY2tbIGkgXS5uYW1lID09PSBuZWVkbGUubmFtZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGNpcmN1bGFyLCBuYW1lc3BhY2VzLCBjcmVhdGVFbGVtZW50LCB0b0FycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9pbml0L2NyZWF0ZUNvbmRpdGlvbmFsQXR0cmlidXRlcy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlQ29uZGl0aW9uYWxBdHRyaWJ1dGVzID0gZnVuY3Rpb24oIENvbmRpdGlvbmFsQXR0cmlidXRlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtZW50LCBhdHRyaWJ1dGVzICkge1xuXHRcdFx0aWYgKCAhYXR0cmlidXRlcyApIHtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGF0dHJpYnV0ZXMubWFwKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBDb25kaXRpb25hbEF0dHJpYnV0ZSggZWxlbWVudCwgYSApO1xuXHRcdFx0fSApO1xuXHRcdH07XG5cdH0oIENvbmRpdGlvbmFsQXR0cmlidXRlICk7XG5cblx0LyogdXRpbHMvZXh0ZW5kLmpzICovXG5cdHZhciBleHRlbmQgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciBTTElDRSQwID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRcdHZhciBzb3VyY2VzID0gU0xJQ0UkMC5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblx0XHR2YXIgcHJvcCwgc291cmNlO1xuXHRcdHdoaWxlICggc291cmNlID0gc291cmNlcy5zaGlmdCgpICkge1xuXHRcdFx0Zm9yICggcHJvcCBpbiBzb3VyY2UgKSB7XG5cdFx0XHRcdGlmICggc291cmNlLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBwcm9wIF0gPSBzb3VyY2VbIHByb3AgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0JpbmRpbmcuanMgKi9cblx0dmFyIEJpbmRpbmcgPSBmdW5jdGlvbiggcnVubG9vcCwgd2FybiwgY3JlYXRlLCBleHRlbmQsIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHZhciBCaW5kaW5nID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgaW50ZXJwb2xhdG9yLCBrZXlwYXRoLCB2YWx1ZTtcblx0XHRcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHR0aGlzLnJvb3QgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHR0aGlzLmF0dHJpYnV0ZSA9IGVsZW1lbnQuYXR0cmlidXRlc1sgdGhpcy5uYW1lIHx8ICd2YWx1ZScgXTtcblx0XHRcdGludGVycG9sYXRvciA9IHRoaXMuYXR0cmlidXRlLmludGVycG9sYXRvcjtcblx0XHRcdGludGVycG9sYXRvci50d293YXlCaW5kaW5nID0gdGhpcztcblx0XHRcdGlmICggaW50ZXJwb2xhdG9yLmtleXBhdGggJiYgaW50ZXJwb2xhdG9yLmtleXBhdGguc3Vic3RyKCAwLCAyICkgPT09ICckeycgKSB7XG5cdFx0XHRcdHdhcm4oICdUd28td2F5IGJpbmRpbmcgZG9lcyBub3Qgd29yayB3aXRoIGV4cHJlc3Npb25zIChgJyArIGludGVycG9sYXRvci5rZXlwYXRoLnNsaWNlKCAyLCAtMSApICsgJ2ApJyApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBBIG11c3RhY2hlIG1heSBiZSAqYW1iaWd1b3VzKi4gTGV0J3Mgc2F5IHdlIHdlcmUgZ2l2ZW5cblx0XHRcdC8vIGB2YWx1ZT1cInt7YmFyfX1cImAuIElmIHRoZSBjb250ZXh0IHdhcyBgZm9vYCwgYW5kIGBmb28uYmFyYFxuXHRcdFx0Ly8gKndhc24ndCogYHVuZGVmaW5lZGAsIHRoZSBrZXlwYXRoIHdvdWxkIGJlIGBmb28uYmFyYC5cblx0XHRcdC8vIFRoZW4sIGFueSB1c2VyIGlucHV0IHdvdWxkIHJlc3VsdCBpbiBgZm9vLmJhcmAgYmVpbmcgdXBkYXRlZC5cblx0XHRcdC8vXG5cdFx0XHQvLyBJZiwgaG93ZXZlciwgYGZvby5iYXJgICp3YXMqIHVuZGVmaW5lZCwgYW5kIHNvIHdhcyBgYmFyYCwgd2Ugd291bGQgYmVcblx0XHRcdC8vIGxlZnQgd2l0aCBhbiB1bnJlc29sdmVkIHBhcnRpYWwga2V5cGF0aCAtIHNvIHdlIGFyZSBmb3JjZWQgdG8gbWFrZSBhblxuXHRcdFx0Ly8gYXNzdW1wdGlvbi4gVGhhdCBhc3N1bXB0aW9uIGlzIHRoYXQgdGhlIGlucHV0IGluIHF1ZXN0aW9uIHNob3VsZFxuXHRcdFx0Ly8gYmUgZm9yY2VkIHRvIHJlc29sdmUgdG8gYGJhcmAsIGFuZCBhbnkgdXNlciBpbnB1dCB3b3VsZCBhZmZlY3QgYGJhcmBcblx0XHRcdC8vIGFuZCBub3QgYGZvby5iYXJgLlxuXHRcdFx0Ly9cblx0XHRcdC8vIERpZCB0aGF0IG1ha2UgYW55IHNlbnNlPyBObz8gT2guIFNvcnJ5LiBXZWxsIHRoZSBtb3JhbCBvZiB0aGUgc3RvcnkgaXNcblx0XHRcdC8vIGJlIGV4cGxpY2l0IHdoZW4gdXNpbmcgdHdvLXdheSBkYXRhLWJpbmRpbmcgYWJvdXQgd2hhdCBrZXlwYXRoIHlvdSdyZVxuXHRcdFx0Ly8gdXBkYXRpbmcuIFVzaW5nIGl0IGluIGxpc3RzIGlzIHByb2JhYmx5IGEgcmVjaXBlIGZvciBjb25mdXNpb24uLi5cblx0XHRcdGlmICggIWludGVycG9sYXRvci5rZXlwYXRoICkge1xuXHRcdFx0XHRpbnRlcnBvbGF0b3IucmVzb2x2ZXIuZm9yY2VSZXNvbHV0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoID0gaW50ZXJwb2xhdG9yLmtleXBhdGg7XG5cdFx0XHQvLyBpbml0aWFsaXNlIHZhbHVlLCBpZiBpdCdzIHVuZGVmaW5lZFxuXHRcdFx0aWYgKCB0aGlzLnJvb3Qudmlld21vZGVsLmdldCgga2V5cGF0aCApID09PSB1bmRlZmluZWQgJiYgdGhpcy5nZXRJbml0aWFsVmFsdWUgKSB7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5nZXRJbml0aWFsVmFsdWUoKTtcblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRCaW5kaW5nLnByb3RvdHlwZSA9IHtcblx0XHRcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHRydW5sb29wLnN0YXJ0KCB0aGlzLnJvb3QgKTtcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5cGF0aCwgdGhpcy5nZXRWYWx1ZSgpICk7XG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0fSxcblx0XHRcdHJlYm91bmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgYmluZGluZ3MsIG9sZEtleXBhdGgsIG5ld0tleXBhdGg7XG5cdFx0XHRcdG9sZEtleXBhdGggPSB0aGlzLmtleXBhdGg7XG5cdFx0XHRcdG5ld0tleXBhdGggPSB0aGlzLmF0dHJpYnV0ZS5pbnRlcnBvbGF0b3Iua2V5cGF0aDtcblx0XHRcdFx0Ly8gVGhlIGF0dHJpYnV0ZSB0aGlzIGJpbmRpbmcgaXMgbGlua2VkIHRvIGhhcyBhbHJlYWR5IGRvbmUgdGhlIHdvcmtcblx0XHRcdFx0aWYgKCBvbGRLZXlwYXRoID09PSBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbIG9sZEtleXBhdGggXSwgdGhpcyApO1xuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBuZXdLZXlwYXRoO1xuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbIG5ld0tleXBhdGggXSB8fCAoIHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbIG5ld0tleXBhdGggXSA9IFtdICk7XG5cdFx0XHRcdGJpbmRpbmdzLnB1c2goIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge31cblx0XHR9O1xuXHRcdEJpbmRpbmcuZXh0ZW5kID0gZnVuY3Rpb24oIHByb3BlcnRpZXMgKSB7XG5cdFx0XHR2YXIgUGFyZW50ID0gdGhpcyxcblx0XHRcdFx0U3BlY2lhbGlzZWRCaW5kaW5nO1xuXHRcdFx0U3BlY2lhbGlzZWRCaW5kaW5nID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHRcdEJpbmRpbmcuY2FsbCggdGhpcywgZWxlbWVudCApO1xuXHRcdFx0XHRpZiAoIHRoaXMuaW5pdCApIHtcblx0XHRcdFx0XHR0aGlzLmluaXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFNwZWNpYWxpc2VkQmluZGluZy5wcm90b3R5cGUgPSBjcmVhdGUoIFBhcmVudC5wcm90b3R5cGUgKTtcblx0XHRcdGV4dGVuZCggU3BlY2lhbGlzZWRCaW5kaW5nLnByb3RvdHlwZSwgcHJvcGVydGllcyApO1xuXHRcdFx0U3BlY2lhbGlzZWRCaW5kaW5nLmV4dGVuZCA9IEJpbmRpbmcuZXh0ZW5kO1xuXHRcdFx0cmV0dXJuIFNwZWNpYWxpc2VkQmluZGluZztcblx0XHR9O1xuXHRcdHJldHVybiBCaW5kaW5nO1xuXHR9KCBydW5sb29wLCB3YXJuLCBjcmVhdGUsIGV4dGVuZCwgcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvc2hhcmVkL2hhbmRsZURvbUV2ZW50LmpzICovXG5cdHZhciBoYW5kbGVEb21FdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSgpIHtcblx0XHR0aGlzLl9yYWN0aXZlLmJpbmRpbmcuaGFuZGxlQ2hhbmdlKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvQ29udGVudEVkaXRhYmxlQmluZGluZy5qcyAqL1xuXHR2YXIgQ29udGVudEVkaXRhYmxlQmluZGluZyA9IGZ1bmN0aW9uKCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBDb250ZW50RWRpdGFibGVCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQuZnJhZ21lbnQgPyB0aGlzLmVsZW1lbnQuZnJhZ21lbnQudG9TdHJpbmcoKSA6ICcnO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRpZiAoICF0aGlzLnJvb3QubGF6eSApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdpbnB1dCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnaW5wdXQnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5dXAnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBDb250ZW50RWRpdGFibGVCaW5kaW5nO1xuXHR9KCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL3NoYXJlZC9nZXRTaWJsaW5ncy5qcyAqL1xuXHR2YXIgZ2V0U2libGluZ3MgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBzZXRzID0ge307XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldFNpYmxpbmdzKCBpZCwgZ3JvdXAsIGtleXBhdGggKSB7XG5cdFx0XHR2YXIgaGFzaCA9IGlkICsgZ3JvdXAgKyBrZXlwYXRoO1xuXHRcdFx0cmV0dXJuIHNldHNbIGhhc2ggXSB8fCAoIHNldHNbIGhhc2ggXSA9IFtdICk7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL1JhZGlvQmluZGluZy5qcyAqL1xuXHR2YXIgUmFkaW9CaW5kaW5nID0gZnVuY3Rpb24oIHJ1bmxvb3AsIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgZ2V0U2libGluZ3MsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIFJhZGlvQmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRuYW1lOiAnY2hlY2tlZCcsXG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5zaWJsaW5ncyA9IGdldFNpYmxpbmdzKCB0aGlzLnJvb3QuX2d1aWQsICdyYWRpbycsIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApICk7XG5cdFx0XHRcdHRoaXMuc2libGluZ3MucHVzaCggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cnVubG9vcC5zdGFydCggdGhpcy5yb290ICk7XG5cdFx0XHRcdHRoaXMuc2libGluZ3MuZm9yRWFjaCggZnVuY3Rpb24oIGJpbmRpbmcgKSB7XG5cdFx0XHRcdFx0YmluZGluZy5yb290LnZpZXdtb2RlbC5zZXQoIGJpbmRpbmcua2V5cGF0aCwgYmluZGluZy5nZXRWYWx1ZSgpICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5zaWJsaW5ncywgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gUmFkaW9CaW5kaW5nO1xuXHR9KCBydW5sb29wLCByZW1vdmVGcm9tQXJyYXksIEJpbmRpbmcsIGdldFNpYmxpbmdzLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL1JhZGlvTmFtZUJpbmRpbmcuanMgKi9cblx0dmFyIFJhZGlvTmFtZUJpbmRpbmcgPSBmdW5jdGlvbiggcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCwgZ2V0U2libGluZ3MgKSB7XG5cblx0XHR2YXIgUmFkaW9OYW1lQmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRuYW1lOiAnbmFtZScsXG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5zaWJsaW5ncyA9IGdldFNpYmxpbmdzKCB0aGlzLnJvb3QuX2d1aWQsICdyYWRpb25hbWUnLCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKCB0aGlzICk7XG5cdFx0XHRcdHRoaXMucmFkaW9OYW1lID0gdHJ1ZTtcblx0XHRcdFx0Ly8gc28gdGhhdCByYWN0aXZlLnVwZGF0ZU1vZGVsKCkga25vd3Mgd2hhdCB0byBkbyB3aXRoIHRoaXNcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUudHdvd2F5ID0gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdjaGVja2VkJyApICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLm5hbWUgPSAne3snICsgdGhpcy5rZXlwYXRoICsgJ319Jztcblx0XHRcdFx0bm9kZS5jaGVja2VkID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5cGF0aCApID09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdHJldHVybiBub2RlLl9yYWN0aXZlID8gbm9kZS5fcmFjdGl2ZS52YWx1ZSA6IG5vZGUudmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gSWYgdGhpcyA8aW5wdXQ+IGlzIHRoZSBvbmUgdGhhdCdzIGNoZWNrZWQsIHRoZW4gdGhlIHZhbHVlIG9mIGl0c1xuXHRcdFx0XHQvLyBgbmFtZWAga2V5cGF0aCBnZXRzIHNldCB0byBpdHMgdmFsdWVcblx0XHRcdFx0aWYgKCB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkICkge1xuXHRcdFx0XHRcdEJpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZWJvdW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgbm9kZTtcblx0XHRcdFx0QmluZGluZy5wcm90b3R5cGUucmVib3VuZC5jYWxsKCB0aGlzLCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0aWYgKCBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGUgKSB7XG5cdFx0XHRcdFx0bm9kZS5uYW1lID0gJ3t7JyArIHRoaXMua2V5cGF0aCArICd9fSc7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuc2libGluZ3MsIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIFJhZGlvTmFtZUJpbmRpbmc7XG5cdH0oIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgaGFuZGxlRG9tRXZlbnQsIGdldFNpYmxpbmdzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvQ2hlY2tib3hOYW1lQmluZGluZy5qcyAqL1xuXHR2YXIgQ2hlY2tib3hOYW1lQmluZGluZyA9IGZ1bmN0aW9uKCBpc0FycmF5LCBhcnJheUNvbnRhaW5zLCByZW1vdmVGcm9tQXJyYXksIEJpbmRpbmcsIGdldFNpYmxpbmdzLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBDaGVja2JveE5hbWVCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdG5hbWU6ICduYW1lJyxcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIFRoaXMgb25seSBnZXRzIGNhbGxlZCBvbmNlIHBlciBncm91cCAob2YgaW5wdXRzIHRoYXRcblx0XHRcdFx0Ly8gc2hhcmUgYSBuYW1lKSwgYmVjYXVzZSBpdCBvbmx5IGdldHMgY2FsbGVkIGlmIHRoZXJlXG5cdFx0XHRcdC8vIGlzbid0IGFuIGluaXRpYWwgdmFsdWUuIEJ5IHRoZSBzYW1lIHRva2VuLCB3ZSBjYW4gbWFrZVxuXHRcdFx0XHQvLyBhIG5vdGUgb2YgdGhhdCBmYWN0IHRoYXQgdGhlcmUgd2FzIG5vIGluaXRpYWwgdmFsdWUsXG5cdFx0XHRcdC8vIGFuZCBwb3B1bGF0ZSBpdCB1c2luZyBhbnkgYGNoZWNrZWRgIGF0dHJpYnV0ZXMgdGhhdFxuXHRcdFx0XHQvLyBleGlzdCAod2hpY2ggdXNlcnMgc2hvdWxkIGF2b2lkLCBidXQgd2hpY2ggd2Ugc2hvdWxkXG5cdFx0XHRcdC8vIHN1cHBvcnQgYW55d2F5IHRvIGF2b2lkIGJyZWFraW5nIGV4cGVjdGF0aW9ucylcblx0XHRcdFx0dGhpcy5ub0luaXRpYWxWYWx1ZSA9IHRydWU7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH0sXG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGV4aXN0aW5nVmFsdWUsIGJpbmRpbmdWYWx1ZTtcblx0XHRcdFx0dGhpcy5jaGVja2JveE5hbWUgPSB0cnVlO1xuXHRcdFx0XHQvLyBzbyB0aGF0IHJhY3RpdmUudXBkYXRlTW9kZWwoKSBrbm93cyB3aGF0IHRvIGRvIHdpdGggdGhpc1xuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS50d293YXkgPSB0cnVlO1xuXHRcdFx0XHQvLyB3ZSBzZXQgdGhpcyBwcm9wZXJ0eSBzbyB0aGF0IHRoZSBhdHRyaWJ1dGUgZ2V0cyB0aGUgY29ycmVjdCB1cGRhdGUgbWV0aG9kXG5cdFx0XHRcdC8vIEVhY2ggaW5wdXQgaGFzIGEgcmVmZXJlbmNlIHRvIGFuIGFycmF5IGNvbnRhaW5pbmcgaXQgYW5kIGl0c1xuXHRcdFx0XHQvLyBzaWJsaW5ncywgYXMgdHdvLXdheSBiaW5kaW5nIGRlcGVuZHMgb24gYmVpbmcgYWJsZSB0byBhc2NlcnRhaW5cblx0XHRcdFx0Ly8gdGhlIHN0YXR1cyBvZiBhbGwgaW5wdXRzIHdpdGhpbiB0aGUgZ3JvdXBcblx0XHRcdFx0dGhpcy5zaWJsaW5ncyA9IGdldFNpYmxpbmdzKCB0aGlzLnJvb3QuX2d1aWQsICdjaGVja2JveGVzJywgdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdHRoaXMuc2libGluZ3MucHVzaCggdGhpcyApO1xuXHRcdFx0XHRpZiAoIHRoaXMubm9Jbml0aWFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zaWJsaW5ncy5ub0luaXRpYWxWYWx1ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSWYgbm8gaW5pdGlhbCB2YWx1ZSB3YXMgc2V0LCBhbmQgdGhpcyBpbnB1dCBpcyBjaGVja2VkLCB3ZVxuXHRcdFx0XHQvLyB1cGRhdGUgdGhlIG1vZGVsXG5cdFx0XHRcdGlmICggdGhpcy5zaWJsaW5ncy5ub0luaXRpYWxWYWx1ZSAmJiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY2hlY2tlZCcgKSApIHtcblx0XHRcdFx0XHRleGlzdGluZ1ZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRcdGJpbmRpbmdWYWx1ZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdFx0XHRleGlzdGluZ1ZhbHVlLnB1c2goIGJpbmRpbmdWYWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnNpYmxpbmdzLCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZSxcblx0XHRcdFx0XHRleGlzdGluZ1ZhbHVlLCBiaW5kaW5nVmFsdWU7XG5cdFx0XHRcdGV4aXN0aW5nVmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCggdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdGJpbmRpbmdWYWx1ZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdFx0aWYgKCBpc0FycmF5KCBleGlzdGluZ1ZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5pc0NoZWNrZWQgPSBhcnJheUNvbnRhaW5zKCBleGlzdGluZ1ZhbHVlLCBiaW5kaW5nVmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IGV4aXN0aW5nVmFsdWUgPT0gYmluZGluZ1ZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUubmFtZSA9ICd7eycgKyB0aGlzLmtleXBhdGggKyAnfX0nO1xuXHRcdFx0XHRub2RlLmNoZWNrZWQgPSB0aGlzLmlzQ2hlY2tlZDtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdC8vIGluIGNhc2Ugb2YgSUUgZW1lcmdlbmN5LCBiaW5kIHRvIGNsaWNrIGV2ZW50IGFzIHdlbGxcblx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgd2FzQ2hlY2tlZCA9ICEhdGhpcy5pc0NoZWNrZWQ7XG5cdFx0XHRcdHRoaXMuaXNDaGVja2VkID0gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcblx0XHRcdFx0cmV0dXJuIHRoaXMuaXNDaGVja2VkID09PSB3YXNDaGVja2VkO1xuXHRcdFx0fSxcblx0XHRcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuaXNDaGVja2VkID0gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcblx0XHRcdFx0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwoIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnNpYmxpbmdzLmZpbHRlciggaXNDaGVja2VkICkubWFwKCBnZXRWYWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdGZ1bmN0aW9uIGlzQ2hlY2tlZCggYmluZGluZyApIHtcblx0XHRcdHJldHVybiBiaW5kaW5nLmlzQ2hlY2tlZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZSggYmluZGluZyApIHtcblx0XHRcdHJldHVybiBiaW5kaW5nLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0fVxuXHRcdHJldHVybiBDaGVja2JveE5hbWVCaW5kaW5nO1xuXHR9KCBpc0FycmF5LCBhcnJheUNvbnRhaW5zLCByZW1vdmVGcm9tQXJyYXksIEJpbmRpbmcsIGdldFNpYmxpbmdzLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0NoZWNrYm94QmluZGluZy5qcyAqL1xuXHR2YXIgQ2hlY2tib3hCaW5kaW5nID0gZnVuY3Rpb24oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIENoZWNrYm94QmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRuYW1lOiAnY2hlY2tlZCcsXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBDaGVja2JveEJpbmRpbmc7XG5cdH0oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvU2VsZWN0QmluZGluZy5qcyAqL1xuXHR2YXIgU2VsZWN0QmluZGluZyA9IGZ1bmN0aW9uKCBydW5sb29wLCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBTZWxlY3RCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5lbGVtZW50Lm9wdGlvbnMsXG5cdFx0XHRcdFx0bGVuLCBpLCB2YWx1ZSwgb3B0aW9uV2FzU2VsZWN0ZWQ7XG5cdFx0XHRcdGlmICggdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSBsZW4gPSBvcHRpb25zLmxlbmd0aDtcblx0XHRcdFx0aWYgKCAhbGVuICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyB0YWtlIHRoZSBmaW5hbCBzZWxlY3RlZCBvcHRpb24uLi5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zWyBpIF0uZ2V0QXR0cmlidXRlKCAnc2VsZWN0ZWQnICkgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IG9wdGlvbnNbIGkgXS5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdFx0XHRcdG9wdGlvbldhc1NlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBvciB0aGUgZmlyc3Qgbm9uLWRpc2FibGVkIG9wdGlvbiwgaWYgbm9uZSBhcmUgc2VsZWN0ZWRcblx0XHRcdFx0aWYgKCAhb3B0aW9uV2FzU2VsZWN0ZWQgKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCArK2kgPCBsZW4gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zWyBpIF0uZ2V0QXR0cmlidXRlKCAnZGlzYWJsZWQnICkgKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gb3B0aW9uc1sgaSBdLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVGhpcyBpcyBhbiBvcHRpbWlzYXRpb24gKGFrYSBoYWNrKSB0aGF0IGFsbG93cyB1cyB0byBmb3JnbyBzb21lXG5cdFx0XHRcdC8vIG90aGVyIG1vcmUgZXhwZW5zaXZlIHdvcmtcblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMuZWxlbWVudC5hdHRyaWJ1dGVzLnZhbHVlLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBUT0RPIHRoaXMgbWV0aG9kIGlzIGFuIGFub21hbHkuLi4gaXMgaXQgbmVjZXNzYXJ5P1xuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBvcHRpb25zLCBpLCBsZW4sIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQubm9kZS5vcHRpb25zO1xuXHRcdFx0XHRsZW4gPSBvcHRpb25zLmxlbmd0aDtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zWyBpIF0uc2VsZWN0ZWQgKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcblx0XHRcdFx0XHRcdHJldHVybiBvcHRpb25WYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmb3JjZVVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCB0aGlzLnJvb3Qudmlld21vZGVsICk7XG5cdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCB0aGlzLmtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIFNlbGVjdEJpbmRpbmc7XG5cdH0oIHJ1bmxvb3AsIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdXRpbHMvYXJyYXlDb250ZW50c01hdGNoLmpzICovXG5cdHZhciBhcnJheUNvbnRlbnRzTWF0Y2ggPSBmdW5jdGlvbiggaXNBcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBpO1xuXHRcdFx0aWYgKCAhaXNBcnJheSggYSApIHx8ICFpc0FycmF5KCBiICkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICggYS5sZW5ndGggIT09IGIubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBhWyBpIF0gIT09IGJbIGkgXSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdH0oIGlzQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9NdWx0aXBsZVNlbGVjdEJpbmRpbmcuanMgKi9cblx0dmFyIE11bHRpcGxlU2VsZWN0QmluZGluZyA9IGZ1bmN0aW9uKCBydW5sb29wLCBhcnJheUNvbnRlbnRzTWF0Y2gsIFNlbGVjdEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIE11bHRpcGxlU2VsZWN0QmluZGluZyA9IFNlbGVjdEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm9wdGlvbnMuZmlsdGVyKCBmdW5jdGlvbiggb3B0aW9uICkge1xuXHRcdFx0XHRcdHJldHVybiBvcHRpb24uZ2V0QXR0cmlidXRlKCAnc2VsZWN0ZWQnICk7XG5cdFx0XHRcdH0gKS5tYXAoIGZ1bmN0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wdGlvbi5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZUZyb21Nb2RlbDtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR2YWx1ZUZyb21Nb2RlbCA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0aWYgKCB2YWx1ZUZyb21Nb2RlbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdC8vIGdldCB2YWx1ZSBmcm9tIERPTSwgaWYgcG9zc2libGVcblx0XHRcdFx0XHR0aGlzLmhhbmRsZUNoYW5nZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUT0RPIG5vdCBpbXBsZW1lbnRlZCB5ZXQnICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc2VsZWN0ZWRWYWx1ZXMsIG9wdGlvbnMsIGksIGxlbiwgb3B0aW9uLCBvcHRpb25WYWx1ZTtcblx0XHRcdFx0c2VsZWN0ZWRWYWx1ZXMgPSBbXTtcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMuZWxlbWVudC5ub2RlLm9wdGlvbnM7XG5cdFx0XHRcdGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCApIHtcblx0XHRcdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWRWYWx1ZXMucHVzaCggb3B0aW9uVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNlbGVjdGVkVmFsdWVzO1xuXHRcdFx0fSxcblx0XHRcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBhdHRyaWJ1dGUsIHByZXZpb3VzVmFsdWUsIHZhbHVlO1xuXHRcdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZTtcblx0XHRcdFx0cHJldmlvdXNWYWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0XHRcdGlmICggcHJldmlvdXNWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFhcnJheUNvbnRlbnRzTWF0Y2goIHZhbHVlLCBwcmV2aW91c1ZhbHVlICkgKSB7XG5cdFx0XHRcdFx0U2VsZWN0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRmb3JjZVVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCB0aGlzLnJvb3Qudmlld21vZGVsICk7XG5cdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCB0aGlzLmtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1cGRhdGVNb2RlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5hdHRyaWJ1dGUudmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhdGhpcy5hdHRyaWJ1dGUudmFsdWUubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCB0aGlzLmtleXBhdGgsIHRoaXMuaW5pdGlhbFZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIE11bHRpcGxlU2VsZWN0QmluZGluZztcblx0fSggcnVubG9vcCwgYXJyYXlDb250ZW50c01hdGNoLCBTZWxlY3RCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0ZpbGVMaXN0QmluZGluZy5qcyAqL1xuXHR2YXIgRmlsZUxpc3RCaW5kaW5nID0gZnVuY3Rpb24oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIEZpbGVMaXN0QmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuZmlsZXM7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBGaWxlTGlzdEJpbmRpbmc7XG5cdH0oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvR2VuZXJpY0JpbmRpbmcuanMgKi9cblx0dmFyIEdlbmVyaWNCaW5kaW5nID0gZnVuY3Rpb24oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBHZW5lcmljQmluZGluZywgZ2V0T3B0aW9ucztcblx0XHRnZXRPcHRpb25zID0ge1xuXHRcdFx0ZXZhbHVhdGVXcmFwcGVkOiB0cnVlXG5cdFx0fTtcblx0XHRHZW5lcmljQmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUudmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdGlmICggIXRoaXMucm9vdC5sYXp5ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAna2V5dXAnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnYmx1cicsIGhhbmRsZUJsdXIsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnaW5wdXQnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5dXAnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnYmx1cicsIGhhbmRsZUJsdXIsIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdF9fZXhwb3J0ID0gR2VuZXJpY0JpbmRpbmc7XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuXHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0aGFuZGxlRG9tRXZlbnQuY2FsbCggdGhpcyApO1xuXHRcdFx0dmFsdWUgPSB0aGlzLl9yYWN0aXZlLnJvb3Qudmlld21vZGVsLmdldCggdGhpcy5fcmFjdGl2ZS5iaW5kaW5nLmtleXBhdGgsIGdldE9wdGlvbnMgKTtcblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZSA9PSB1bmRlZmluZWQgPyAnJyA6IHZhbHVlO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvTnVtZXJpY0JpbmRpbmcuanMgKi9cblx0dmFyIE51bWVyaWNCaW5kaW5nID0gZnVuY3Rpb24oIEdlbmVyaWNCaW5kaW5nICkge1xuXG5cdFx0cmV0dXJuIEdlbmVyaWNCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQoIHRoaXMuZWxlbWVudC5ub2RlLnZhbHVlICk7XG5cdFx0XHRcdHJldHVybiBpc05hTiggdmFsdWUgKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSggR2VuZXJpY0JpbmRpbmcgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2luaXQvY3JlYXRlVHdvd2F5QmluZGluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlVHdvd2F5QmluZGluZyA9IGZ1bmN0aW9uKCBsb2csIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcsIFJhZGlvQmluZGluZywgUmFkaW9OYW1lQmluZGluZywgQ2hlY2tib3hOYW1lQmluZGluZywgQ2hlY2tib3hCaW5kaW5nLCBTZWxlY3RCaW5kaW5nLCBNdWx0aXBsZVNlbGVjdEJpbmRpbmcsIEZpbGVMaXN0QmluZGluZywgTnVtZXJpY0JpbmRpbmcsIEdlbmVyaWNCaW5kaW5nICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gY3JlYXRlVHdvd2F5QmluZGluZyggZWxlbWVudCApIHtcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzLFxuXHRcdFx0XHR0eXBlLCBCaW5kaW5nLCBiaW5kTmFtZSwgYmluZENoZWNrZWQ7XG5cdFx0XHQvLyBpZiB0aGlzIGlzIGEgbGF0ZSBiaW5kaW5nLCBhbmQgdGhlcmUncyBhbHJlYWR5IG9uZSwgaXRcblx0XHRcdC8vIG5lZWRzIHRvIGJlIHRvcm4gZG93blxuXHRcdFx0aWYgKCBlbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdGVsZW1lbnQuYmluZGluZy50ZWFyZG93bigpO1xuXHRcdFx0XHRlbGVtZW50LmJpbmRpbmcgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY29udGVudGVkaXRhYmxlXG5cdFx0XHRpZiAoIC8vIGlmIHRoZSBjb250ZW50ZWRpdGFibGUgYXR0cmlidXRlIGlzIHRydWUgb3IgaXMgYmluZGFibGUgYW5kIG1heSB0aHVzIGJlY29tZSB0cnVlXG5cdFx0XHRcdCggZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdjb250ZW50ZWRpdGFibGUnICkgfHwgISFhdHRyaWJ1dGVzLmNvbnRlbnRlZGl0YWJsZSAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLmNvbnRlbnRlZGl0YWJsZSApICkgJiYgaXNCaW5kYWJsZSggYXR0cmlidXRlcy52YWx1ZSApICkge1xuXHRcdFx0XHRCaW5kaW5nID0gQ29udGVudEVkaXRhYmxlQmluZGluZztcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ2lucHV0JyApIHtcblx0XHRcdFx0dHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndHlwZScgKTtcblx0XHRcdFx0aWYgKCB0eXBlID09PSAncmFkaW8nIHx8IHR5cGUgPT09ICdjaGVja2JveCcgKSB7XG5cdFx0XHRcdFx0YmluZE5hbWUgPSBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLm5hbWUgKTtcblx0XHRcdFx0XHRiaW5kQ2hlY2tlZCA9IGlzQmluZGFibGUoIGF0dHJpYnV0ZXMuY2hlY2tlZCApO1xuXHRcdFx0XHRcdC8vIHdlIGNhbiBlaXRoZXIgYmluZCB0aGUgbmFtZSBhdHRyaWJ1dGUsIG9yIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSAtIG5vdCBib3RoXG5cdFx0XHRcdFx0aWYgKCBiaW5kTmFtZSAmJiBiaW5kQ2hlY2tlZCApIHtcblx0XHRcdFx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiAnYmFkUmFkaW9JbnB1dEJpbmRpbmcnXG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggYmluZE5hbWUgKSB7XG5cdFx0XHRcdFx0XHRCaW5kaW5nID0gdHlwZSA9PT0gJ3JhZGlvJyA/IFJhZGlvTmFtZUJpbmRpbmcgOiBDaGVja2JveE5hbWVCaW5kaW5nO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGJpbmRDaGVja2VkICkge1xuXHRcdFx0XHRcdFx0QmluZGluZyA9IHR5cGUgPT09ICdyYWRpbycgPyBSYWRpb0JpbmRpbmcgOiBDaGVja2JveEJpbmRpbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAnZmlsZScgJiYgaXNCaW5kYWJsZSggYXR0cmlidXRlcy52YWx1ZSApICkge1xuXHRcdFx0XHRcdEJpbmRpbmcgPSBGaWxlTGlzdEJpbmRpbmc7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcblx0XHRcdFx0XHRCaW5kaW5nID0gdHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZSA9PT0gJ3JhbmdlJyA/IE51bWVyaWNCaW5kaW5nIDogR2VuZXJpY0JpbmRpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3NlbGVjdCcgJiYgaXNCaW5kYWJsZSggYXR0cmlidXRlcy52YWx1ZSApICkge1xuXHRcdFx0XHRCaW5kaW5nID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdtdWx0aXBsZScgKSA/IE11bHRpcGxlU2VsZWN0QmluZGluZyA6IFNlbGVjdEJpbmRpbmc7XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50Lm5hbWUgPT09ICd0ZXh0YXJlYScgJiYgaXNCaW5kYWJsZSggYXR0cmlidXRlcy52YWx1ZSApICkge1xuXHRcdFx0XHRCaW5kaW5nID0gR2VuZXJpY0JpbmRpbmc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIEJpbmRpbmcgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQmluZGluZyggZWxlbWVudCApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGUgKSB7XG5cdFx0XHRyZXR1cm4gYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5pc0JpbmRhYmxlO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGxvZywgQ29udGVudEVkaXRhYmxlQmluZGluZywgUmFkaW9CaW5kaW5nLCBSYWRpb05hbWVCaW5kaW5nLCBDaGVja2JveE5hbWVCaW5kaW5nLCBDaGVja2JveEJpbmRpbmcsIFNlbGVjdEJpbmRpbmcsIE11bHRpcGxlU2VsZWN0QmluZGluZywgRmlsZUxpc3RCaW5kaW5nLCBOdW1lcmljQmluZGluZywgR2VuZXJpY0JpbmRpbmcgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9idWJibGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkYnViYmxlID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGJ1YmJsZSgpIHtcblx0XHR2YXIgaGFzQWN0aW9uID0gdGhpcy5nZXRBY3Rpb24oKTtcblx0XHRpZiAoIGhhc0FjdGlvbiAmJiAhdGhpcy5oYXNMaXN0ZW5lciApIHtcblx0XHRcdHRoaXMubGlzdGVuKCk7XG5cdFx0fSBlbHNlIGlmICggIWhhc0FjdGlvbiAmJiB0aGlzLmhhc0xpc3RlbmVyICkge1xuXHRcdFx0dGhpcy51bnJlbmRlcigpO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9maXJlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGZpcmUgPSBmdW5jdGlvbiggZmlyZUV2ZW50ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRmaXJlKCBldmVudCApIHtcblx0XHRcdGZpcmVFdmVudCggdGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7XG5cdFx0XHRcdGV2ZW50OiBldmVudFxuXHRcdFx0fSApO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2ZpcmVFdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL2dldEFjdGlvbi5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRnZXRBY3Rpb24gPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkZ2V0QWN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmFjdGlvbi50b1N0cmluZygpLnRyaW0oKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGluaXQgPSBmdW5jdGlvbiggZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nLCBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlciwgY2lyY3VsYXIsIGZpcmVFdmVudCwgbG9nICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBGcmFnbWVudCwgZ2V0VmFsdWVPcHRpb25zID0ge1xuXHRcdFx0XHRhcmdzOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0ZXZlbnRQYXR0ZXJuID0gL15ldmVudCg/OlxcLiguKykpPy87XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRpbml0KCBlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciBoYW5kbGVyID0gdGhpcyxcblx0XHRcdFx0YWN0aW9uLCByZWZzLCByYWN0aXZlO1xuXHRcdFx0aGFuZGxlci5lbGVtZW50ID0gZWxlbWVudDtcblx0XHRcdGhhbmRsZXIucm9vdCA9IGVsZW1lbnQucm9vdDtcblx0XHRcdGhhbmRsZXIubmFtZSA9IG5hbWU7XG5cdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggJyonICkgIT09IC0xICkge1xuXHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRkZWJ1ZzogdGhpcy5yb290LmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdub0VsZW1lbnRQcm94eUV2ZW50V2lsZGNhcmRzJyxcblx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiBlbGVtZW50LnRhZ05hbWUsXG5cdFx0XHRcdFx0XHRldmVudDogbmFtZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGlzLmludmFsaWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5tICkge1xuXHRcdFx0XHRyZWZzID0gdGVtcGxhdGUuYS5yO1xuXHRcdFx0XHQvLyBUaGlzIGlzIGEgbWV0aG9kIGNhbGxcblx0XHRcdFx0aGFuZGxlci5tZXRob2QgPSB0ZW1wbGF0ZS5tO1xuXHRcdFx0XHRoYW5kbGVyLmtleXBhdGhzID0gW107XG5cdFx0XHRcdGhhbmRsZXIuZm4gPSBnZXRGdW5jdGlvbkZyb21TdHJpbmcoIHRlbXBsYXRlLmEucywgcmVmcy5sZW5ndGggKTtcblx0XHRcdFx0aGFuZGxlci5wYXJlbnRGcmFnbWVudCA9IGVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRcdHJhY3RpdmUgPSBoYW5kbGVyLnJvb3Q7XG5cdFx0XHRcdC8vIENyZWF0ZSByZXNvbHZlcnMgZm9yIGVhY2ggcmVmZXJlbmNlXG5cdFx0XHRcdGhhbmRsZXIucmVmUmVzb2x2ZXJzID0gcmVmcy5tYXAoIGZ1bmN0aW9uKCByZWYsIGkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIHRoZSBgZXZlbnRgIG9iamVjdFxuXHRcdFx0XHRcdGlmICggbWF0Y2ggPSBldmVudFBhdHRlcm4uZXhlYyggcmVmICkgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyLmtleXBhdGhzWyBpIF0gPSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50T2JqZWN0OiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRyZWZpbmVtZW50czogbWF0Y2hbIDEgXSA/IG1hdGNoWyAxIF0uc3BsaXQoICcuJyApIDogW11cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKCBoYW5kbGVyLCByZWYsIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlci5yZXNvbHZlKCBpLCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuZmlyZSA9IGZpcmVNZXRob2RDYWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gR2V0IGFjdGlvbiAoJ2ZvbycgaW4gJ29uLWNsaWNrPSdmb28nKVxuXHRcdFx0XHRhY3Rpb24gPSB0ZW1wbGF0ZS5uIHx8IHRlbXBsYXRlO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBhY3Rpb24gIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdGFjdGlvbiA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdFx0dGVtcGxhdGU6IGFjdGlvbixcblx0XHRcdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcblx0XHRcdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYWN0aW9uID0gYWN0aW9uO1xuXHRcdFx0XHQvLyBHZXQgcGFyYW1ldGVyc1xuXHRcdFx0XHRpZiAoIHRlbXBsYXRlLmQgKSB7XG5cdFx0XHRcdFx0dGhpcy5keW5hbWljUGFyYW1zID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZCxcblx0XHRcdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcblx0XHRcdFx0XHRcdG93bmVyOiB0aGlzLmVsZW1lbnRcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0dGhpcy5maXJlID0gZmlyZUV2ZW50V2l0aER5bmFtaWNQYXJhbXM7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRlbXBsYXRlLmEgKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuXHRcdFx0XHRcdHRoaXMuZmlyZSA9IGZpcmVFdmVudFdpdGhQYXJhbXM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZmlyZU1ldGhvZENhbGwoIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJhY3RpdmUsIHZhbHVlcywgYXJncztcblx0XHRcdHJhY3RpdmUgPSB0aGlzLnJvb3Q7XG5cdFx0XHRpZiAoIHR5cGVvZiByYWN0aXZlWyB0aGlzLm1ldGhvZCBdICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdBdHRlbXB0ZWQgdG8gY2FsbCBhIG5vbi1leGlzdGVudCBtZXRob2QgKFwiJyArIHRoaXMubWV0aG9kICsgJ1wiKScgKTtcblx0XHRcdH1cblx0XHRcdHZhbHVlcyA9IHRoaXMua2V5cGF0aHMubWFwKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBsZW4sIGk7XG5cdFx0XHRcdGlmICgga2V5cGF0aCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdC8vIG5vdCB5ZXQgcmVzb2x2ZWRcblx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFRPRE8gdGhlIHJlZmluZW1lbnRzIHN0dWZmIHdvdWxkIGJlIGJldHRlciBoYW5kbGVkIGF0IHBhcnNlIHRpbWVcblx0XHRcdFx0aWYgKCBrZXlwYXRoLmV2ZW50T2JqZWN0ICkge1xuXHRcdFx0XHRcdHZhbHVlID0gZXZlbnQ7XG5cdFx0XHRcdFx0aWYgKCBsZW4gPSBrZXlwYXRoLnJlZmluZW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbIGtleXBhdGgucmVmaW5lbWVudHNbIGkgXSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH0gKTtcblx0XHRcdHJhY3RpdmUuZXZlbnQgPSBldmVudDtcblx0XHRcdGFyZ3MgPSB0aGlzLmZuLmFwcGx5KCBudWxsLCB2YWx1ZXMgKTtcblx0XHRcdHJhY3RpdmVbIHRoaXMubWV0aG9kIF0uYXBwbHkoIHJhY3RpdmUsIGFyZ3MgKTtcblx0XHRcdGRlbGV0ZSByYWN0aXZlLmV2ZW50O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpcmVFdmVudFdpdGhQYXJhbXMoIGV2ZW50ICkge1xuXHRcdFx0ZmlyZUV2ZW50KCB0aGlzLnJvb3QsIHRoaXMuZ2V0QWN0aW9uKCksIHtcblx0XHRcdFx0ZXZlbnQ6IGV2ZW50LFxuXHRcdFx0XHRhcmdzOiB0aGlzLnBhcmFtc1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpcmVFdmVudFdpdGhEeW5hbWljUGFyYW1zKCBldmVudCApIHtcblx0XHRcdHZhciBhcmdzID0gdGhpcy5keW5hbWljUGFyYW1zLmdldFZhbHVlKCBnZXRWYWx1ZU9wdGlvbnMgKTtcblx0XHRcdC8vIG5lZWQgdG8gc3RyaXAgW10gZnJvbSBlbmRzIGlmIGEgc3RyaW5nIVxuXHRcdFx0aWYgKCB0eXBlb2YgYXJncyA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGFyZ3MgPSBhcmdzLnN1YnN0ciggMSwgYXJncy5sZW5ndGggLSAyICk7XG5cdFx0XHR9XG5cdFx0XHRmaXJlRXZlbnQoIHRoaXMucm9vdCwgdGhpcy5nZXRBY3Rpb24oKSwge1xuXHRcdFx0XHRldmVudDogZXZlbnQsXG5cdFx0XHRcdGFyZ3M6IGFyZ3Ncblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBnZXRGdW5jdGlvbkZyb21TdHJpbmcsIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyLCBjaXJjdWxhciwgUmFjdGl2ZSRzaGFyZWRfZmlyZUV2ZW50LCBsb2cgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3NoYXJlZC9nZW5lcmljSGFuZGxlci5qcyAqL1xuXHR2YXIgZ2VuZXJpY0hhbmRsZXIgPSBmdW5jdGlvbiBnZW5lcmljSGFuZGxlciggZXZlbnQgKSB7XG5cdFx0dmFyIHN0b3JhZ2UsIGhhbmRsZXI7XG5cdFx0c3RvcmFnZSA9IHRoaXMuX3JhY3RpdmU7XG5cdFx0aGFuZGxlciA9IHN0b3JhZ2UuZXZlbnRzWyBldmVudC50eXBlIF07XG5cdFx0aGFuZGxlci5maXJlKCB7XG5cdFx0XHRub2RlOiB0aGlzLFxuXHRcdFx0b3JpZ2luYWw6IGV2ZW50LFxuXHRcdFx0aW5kZXg6IHN0b3JhZ2UuaW5kZXgsXG5cdFx0XHRrZXlwYXRoOiBzdG9yYWdlLmtleXBhdGgsXG5cdFx0XHRjb250ZXh0OiBzdG9yYWdlLnJvb3QuZ2V0KCBzdG9yYWdlLmtleXBhdGggKVxuXHRcdH0gKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9saXN0ZW4uanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkbGlzdGVuID0gZnVuY3Rpb24oIGNvbmZpZywgZ2VuZXJpY0hhbmRsZXIsIGxvZyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgY3VzdG9tSGFuZGxlcnMgPSB7fSxcblx0XHRcdHRvdWNoRXZlbnRzID0ge1xuXHRcdFx0XHR0b3VjaHN0YXJ0OiB0cnVlLFxuXHRcdFx0XHR0b3VjaG1vdmU6IHRydWUsXG5cdFx0XHRcdHRvdWNoZW5kOiB0cnVlLFxuXHRcdFx0XHR0b3VjaGNhbmNlbDogdHJ1ZSxcblx0XHRcdFx0Ly9ub3QgdzNjLCBidXQgc3VwcG9ydGVkIGluIHNvbWUgYnJvd3NlcnNcblx0XHRcdFx0dG91Y2hsZWF2ZTogdHJ1ZVxuXHRcdFx0fTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRsaXN0ZW4oKSB7XG5cdFx0XHR2YXIgZGVmaW5pdGlvbiwgbmFtZSA9IHRoaXMubmFtZTtcblx0XHRcdGlmICggdGhpcy5pbnZhbGlkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGRlZmluaXRpb24gPSBjb25maWcucmVnaXN0cmllcy5ldmVudHMuZmluZCggdGhpcy5yb290LCBuYW1lICkgKSB7XG5cdFx0XHRcdHRoaXMuY3VzdG9tID0gZGVmaW5pdGlvbiggdGhpcy5ub2RlLCBnZXRDdXN0b21IYW5kbGVyKCBuYW1lICkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIExvb2tzIGxpa2Ugd2UncmUgZGVhbGluZyB3aXRoIGEgc3RhbmRhcmQgRE9NIGV2ZW50Li4uIGJ1dCBsZXQncyBjaGVja1xuXHRcdFx0XHRpZiAoICEoICdvbicgKyBuYW1lIGluIHRoaXMubm9kZSApICYmICEoIHdpbmRvdyAmJiAnb24nICsgbmFtZSBpbiB3aW5kb3cgKSApIHtcblx0XHRcdFx0XHQvLyBva2F5IHRvIHVzZSB0b3VjaCBldmVudHMgaWYgdGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGVtXG5cdFx0XHRcdFx0aWYgKCAhdG91Y2hFdmVudHNbIG5hbWUgXSApIHtcblx0XHRcdFx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRcdFx0XHRkZWJ1ZzogdGhpcy5yb290LmRlYnVnLFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiAnbWlzc2luZ1BsdWdpbicsXG5cdFx0XHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRwbHVnaW46ICdldmVudCcsXG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggbmFtZSwgZ2VuZXJpY0hhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmhhc0xpc3RlbmVyID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Q3VzdG9tSGFuZGxlciggbmFtZSApIHtcblx0XHRcdGlmICggIWN1c3RvbUhhbmRsZXJzWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGN1c3RvbUhhbmRsZXJzWyBuYW1lIF0gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0dmFyIHN0b3JhZ2UgPSBldmVudC5ub2RlLl9yYWN0aXZlO1xuXHRcdFx0XHRcdGV2ZW50LmluZGV4ID0gc3RvcmFnZS5pbmRleDtcblx0XHRcdFx0XHRldmVudC5rZXlwYXRoID0gc3RvcmFnZS5rZXlwYXRoO1xuXHRcdFx0XHRcdGV2ZW50LmNvbnRleHQgPSBzdG9yYWdlLnJvb3QuZ2V0KCBzdG9yYWdlLmtleXBhdGggKTtcblx0XHRcdFx0XHRzdG9yYWdlLmV2ZW50c1sgbmFtZSBdLmZpcmUoIGV2ZW50ICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY3VzdG9tSGFuZGxlcnNbIG5hbWUgXTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBjb25maWcsIGdlbmVyaWNIYW5kbGVyLCBsb2cgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9yZWJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmViaW5kID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdHZhciBmcmFnbWVudDtcblx0XHRpZiAoIHRoaXMubWV0aG9kICkge1xuXHRcdFx0ZnJhZ21lbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLnJlZlJlc29sdmVycy5mb3JFYWNoKCByZWJpbmQgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5hY3Rpb24gIT09ICdzdHJpbmcnICkge1xuXHRcdFx0cmViaW5kKCB0aGlzLmFjdGlvbiApO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuZHluYW1pY1BhcmFtcyApIHtcblx0XHRcdHJlYmluZCggdGhpcy5keW5hbWljUGFyYW1zICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmViaW5kKCB0aGluZyApIHtcblx0XHRcdHRoaW5nICYmIHRoaW5nLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRyZW5kZXIgPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkcmVuZGVyKCkge1xuXHRcdHRoaXMubm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdC8vIHN0b3JlIHRoaXMgb24gdGhlIG5vZGUgaXRzZWxmLCBzbyBpdCBjYW4gYmUgcmV0cmlldmVkIGJ5IGFcblx0XHQvLyB1bml2ZXJzYWwgaGFuZGxlclxuXHRcdHRoaXMubm9kZS5fcmFjdGl2ZS5ldmVudHNbIHRoaXMubmFtZSBdID0gdGhpcztcblx0XHRpZiAoIHRoaXMubWV0aG9kIHx8IHRoaXMuZ2V0QWN0aW9uKCkgKSB7XG5cdFx0XHR0aGlzLmxpc3RlbigpO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9yZXNvbHZlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHJlc29sdmUgPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkcmVzb2x2ZSggaW5kZXgsIGtleXBhdGggKSB7XG5cdFx0dGhpcy5rZXlwYXRoc1sgaW5kZXggXSA9IGtleXBhdGg7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvdW5iaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHVuYmluZCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHVuYmluZCgpIHtcblx0XHRcdGlmICggdGhpcy5tZXRob2QgKSB7XG5cdFx0XHRcdHRoaXMucmVmUmVzb2x2ZXJzLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBUZWFyIGRvd24gZHluYW1pYyBuYW1lXG5cdFx0XHRpZiAoIHR5cGVvZiB0aGlzLmFjdGlvbiAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHRoaXMuYWN0aW9uLnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGVhciBkb3duIGR5bmFtaWMgcGFyYW1ldGVyc1xuXHRcdFx0aWYgKCB0aGlzLmR5bmFtaWNQYXJhbXMgKSB7XG5cdFx0XHRcdHRoaXMuZHluYW1pY1BhcmFtcy51bmJpbmQoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCB4ICkge1xuXHRcdFx0eC51bmJpbmQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkdW5yZW5kZXIgPSBmdW5jdGlvbiggZ2VuZXJpY0hhbmRsZXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHVucmVuZGVyKCkge1xuXHRcdFx0aWYgKCB0aGlzLmN1c3RvbSApIHtcblx0XHRcdFx0dGhpcy5jdXN0b20udGVhcmRvd24oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCB0aGlzLm5hbWUsIGdlbmVyaWNIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5oYXNMaXN0ZW5lciA9IGZhbHNlO1xuXHRcdH07XG5cdH0oIGdlbmVyaWNIYW5kbGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9fRXZlbnRIYW5kbGVyLmpzICovXG5cdHZhciBFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiggYnViYmxlLCBmaXJlLCBnZXRBY3Rpb24sIGluaXQsIGxpc3RlbiwgcmViaW5kLCByZW5kZXIsIHJlc29sdmUsIHVuYmluZCwgdW5yZW5kZXIgKSB7XG5cblx0XHR2YXIgRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24oIGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlICkge1xuXHRcdFx0dGhpcy5pbml0KCBlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSApO1xuXHRcdH07XG5cdFx0RXZlbnRIYW5kbGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogYnViYmxlLFxuXHRcdFx0ZmlyZTogZmlyZSxcblx0XHRcdGdldEFjdGlvbjogZ2V0QWN0aW9uLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdGxpc3RlbjogbGlzdGVuLFxuXHRcdFx0cmViaW5kOiByZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHJlc29sdmU6IHJlc29sdmUsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlclxuXHRcdH07XG5cdFx0cmV0dXJuIEV2ZW50SGFuZGxlcjtcblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRidWJibGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkZmlyZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRnZXRBY3Rpb24sIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkaW5pdCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRsaXN0ZW4sIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmViaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRyZXNvbHZlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHVuYmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciR1bnJlbmRlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvaW5pdC9jcmVhdGVFdmVudEhhbmRsZXJzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24oIEV2ZW50SGFuZGxlciApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggZWxlbWVudCwgdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgaSwgbmFtZSwgbmFtZXMsIGhhbmRsZXIsIHJlc3VsdCA9IFtdO1xuXHRcdFx0Zm9yICggbmFtZSBpbiB0ZW1wbGF0ZSApIHtcblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZS5oYXNPd25Qcm9wZXJ0eSggbmFtZSApICkge1xuXHRcdFx0XHRcdG5hbWVzID0gbmFtZS5zcGxpdCggJy0nICk7XG5cdFx0XHRcdFx0aSA9IG5hbWVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyKCBlbGVtZW50LCBuYW1lc1sgaSBdLCB0ZW1wbGF0ZVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCggaGFuZGxlciApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHR9KCBFdmVudEhhbmRsZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRGVjb3JhdG9yL19EZWNvcmF0b3IuanMgKi9cblx0dmFyIERlY29yYXRvciA9IGZ1bmN0aW9uKCBsb2csIGNpcmN1bGFyLCBjb25maWcgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQsIGdldFZhbHVlT3B0aW9ucywgRGVjb3JhdG9yO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0Z2V0VmFsdWVPcHRpb25zID0ge1xuXHRcdFx0YXJnczogdHJ1ZVxuXHRcdH07XG5cdFx0RGVjb3JhdG9yID0gZnVuY3Rpb24oIGVsZW1lbnQsIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIGRlY29yYXRvciA9IHRoaXMsXG5cdFx0XHRcdHJhY3RpdmUsIG5hbWUsIGZyYWdtZW50O1xuXHRcdFx0ZGVjb3JhdG9yLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0ZGVjb3JhdG9yLnJvb3QgPSByYWN0aXZlID0gZWxlbWVudC5yb290O1xuXHRcdFx0bmFtZSA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG5cdFx0XHRpZiAoIHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogbmFtZSxcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiBlbGVtZW50XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0bmFtZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5hICkge1xuXHRcdFx0XHRkZWNvcmF0b3IucGFyYW1zID0gdGVtcGxhdGUuYTtcblx0XHRcdH0gZWxzZSBpZiAoIHRlbXBsYXRlLmQgKSB7XG5cdFx0XHRcdGRlY29yYXRvci5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IGVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRkZWNvcmF0b3IucGFyYW1zID0gZGVjb3JhdG9yLmZyYWdtZW50LmdldFZhbHVlKCBnZXRWYWx1ZU9wdGlvbnMgKTtcblx0XHRcdFx0ZGVjb3JhdG9yLmZyYWdtZW50LmJ1YmJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMuZGlydHlBcmdzID0gdGhpcy5kaXJ0eVZhbHVlID0gdHJ1ZTtcblx0XHRcdFx0XHRkZWNvcmF0b3IucGFyYW1zID0gdGhpcy5nZXRWYWx1ZSggZ2V0VmFsdWVPcHRpb25zICk7XG5cdFx0XHRcdFx0aWYgKCBkZWNvcmF0b3IucmVhZHkgKSB7XG5cdFx0XHRcdFx0XHRkZWNvcmF0b3IudXBkYXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0ZGVjb3JhdG9yLmZuID0gY29uZmlnLnJlZ2lzdHJpZXMuZGVjb3JhdG9ycy5maW5kKCByYWN0aXZlLCBuYW1lICk7XG5cdFx0XHRpZiAoICFkZWNvcmF0b3IuZm4gKSB7XG5cdFx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdtaXNzaW5nUGx1Z2luJyxcblx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRwbHVnaW46ICdkZWNvcmF0b3InLFxuXHRcdFx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0RGVjb3JhdG9yLnByb3RvdHlwZSA9IHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZGVjb3JhdG9yID0gdGhpcyxcblx0XHRcdFx0XHRub2RlLCByZXN1bHQsIGFyZ3M7XG5cdFx0XHRcdG5vZGUgPSBkZWNvcmF0b3IuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRpZiAoIGRlY29yYXRvci5wYXJhbXMgKSB7XG5cdFx0XHRcdFx0YXJncyA9IFsgbm9kZSBdLmNvbmNhdCggZGVjb3JhdG9yLnBhcmFtcyApO1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRlY29yYXRvci5mbi5hcHBseSggZGVjb3JhdG9yLnJvb3QsIGFyZ3MgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBkZWNvcmF0b3IuZm4uY2FsbCggZGVjb3JhdG9yLnJvb3QsIG5vZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFyZXN1bHQgfHwgIXJlc3VsdC50ZWFyZG93biApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdEZWNvcmF0b3IgZGVmaW5pdGlvbiBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2l0aCBhIHRlYXJkb3duIG1ldGhvZCcgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBUT0RPIGRvZXMgdGhpcyBtYWtlIHNlbnNlP1xuXHRcdFx0XHRkZWNvcmF0b3IuYWN0dWFsID0gcmVzdWx0O1xuXHRcdFx0XHRkZWNvcmF0b3IucmVhZHkgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5hY3R1YWwudXBkYXRlICkge1xuXHRcdFx0XHRcdHRoaXMuYWN0dWFsLnVwZGF0ZS5hcHBseSggdGhpcy5yb290LCB0aGlzLnBhcmFtcyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuYWN0dWFsLnRlYXJkb3duKCB0cnVlICk7XG5cdFx0XHRcdFx0dGhpcy5pbml0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oIHVwZGF0aW5nICkge1xuXHRcdFx0XHR0aGlzLmFjdHVhbC50ZWFyZG93bigpO1xuXHRcdFx0XHRpZiAoICF1cGRhdGluZyAmJiB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBEZWNvcmF0b3I7XG5cdH0oIGxvZywgY2lyY3VsYXIsIGNvbmZpZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zcGVjaWFsL3NlbGVjdC9zeW5jLmpzICovXG5cdHZhciBzeW5jID0gZnVuY3Rpb24oIHRvQXJyYXkgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBzeW5jU2VsZWN0KCBzZWxlY3RFbGVtZW50ICkge1xuXHRcdFx0dmFyIHNlbGVjdE5vZGUsIHNlbGVjdFZhbHVlLCBpc011bHRpcGxlLCBvcHRpb25zLCBvcHRpb25XYXNTZWxlY3RlZDtcblx0XHRcdHNlbGVjdE5vZGUgPSBzZWxlY3RFbGVtZW50Lm5vZGU7XG5cdFx0XHRpZiAoICFzZWxlY3ROb2RlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zID0gdG9BcnJheSggc2VsZWN0Tm9kZS5vcHRpb25zICk7XG5cdFx0XHRzZWxlY3RWYWx1ZSA9IHNlbGVjdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpc011bHRpcGxlID0gc2VsZWN0RWxlbWVudC5nZXRBdHRyaWJ1dGUoICdtdWx0aXBsZScgKTtcblx0XHRcdC8vIElmIHRoZSA8c2VsZWN0PiBoYXMgYSBzcGVjaWZpZWQgdmFsdWUsIHRoYXQgc2hvdWxkIG92ZXJyaWRlXG5cdFx0XHQvLyB0aGVzZSBvcHRpb25zXG5cdFx0XHRpZiAoIHNlbGVjdFZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdG9wdGlvbnMuZm9yRWFjaCggZnVuY3Rpb24oIG8gKSB7XG5cdFx0XHRcdFx0dmFyIG9wdGlvblZhbHVlLCBzaG91bGRTZWxlY3Q7XG5cdFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvLl9yYWN0aXZlID8gby5fcmFjdGl2ZS52YWx1ZSA6IG8udmFsdWU7XG5cdFx0XHRcdFx0c2hvdWxkU2VsZWN0ID0gaXNNdWx0aXBsZSA/IHZhbHVlQ29udGFpbnMoIHNlbGVjdFZhbHVlLCBvcHRpb25WYWx1ZSApIDogc2VsZWN0VmFsdWUgPT0gb3B0aW9uVmFsdWU7XG5cdFx0XHRcdFx0aWYgKCBzaG91bGRTZWxlY3QgKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25XYXNTZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG8uc2VsZWN0ZWQgPSBzaG91bGRTZWxlY3Q7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0aWYgKCAhb3B0aW9uV2FzU2VsZWN0ZWQgKSB7XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zWyAwIF0gKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zWyAwIF0uc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNlbGVjdEVsZW1lbnQuYmluZGluZyApIHtcblx0XHRcdFx0XHRcdHNlbGVjdEVsZW1lbnQuYmluZGluZy5mb3JjZVVwZGF0ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggc2VsZWN0RWxlbWVudC5iaW5kaW5nICkge1xuXHRcdFx0XHRzZWxlY3RFbGVtZW50LmJpbmRpbmcuZm9yY2VVcGRhdGUoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdmFsdWVDb250YWlucyggc2VsZWN0VmFsdWUsIG9wdGlvblZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSBzZWxlY3RWYWx1ZS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWxlY3RWYWx1ZVsgaSBdID09IG9wdGlvblZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdG9BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zcGVjaWFsL3NlbGVjdC9idWJibGUuanMgKi9cblx0dmFyIGJ1YmJsZSA9IGZ1bmN0aW9uKCBydW5sb29wLCBzeW5jU2VsZWN0ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGJ1YmJsZVNlbGVjdCgpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0aWYgKCAhdGhpcy5kaXJ0eSApIHtcblx0XHRcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzeW5jU2VsZWN0KCB0aGlzJDAgKTtcblx0XHRcdFx0XHR0aGlzJDAuZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHR9O1xuXHR9KCBydW5sb29wLCBzeW5jICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvb3B0aW9uL2ZpbmRQYXJlbnRTZWxlY3QuanMgKi9cblx0dmFyIGZpbmRQYXJlbnRTZWxlY3QgPSBmdW5jdGlvbiBmaW5kUGFyZW50U2VsZWN0KCBlbGVtZW50ICkge1xuXHRcdGRvIHtcblx0XHRcdGlmICggZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudCApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zcGVjaWFsL29wdGlvbi9pbml0LmpzICovXG5cdHZhciBpbml0ID0gZnVuY3Rpb24oIGZpbmRQYXJlbnRTZWxlY3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gaW5pdE9wdGlvbiggb3B0aW9uLCB0ZW1wbGF0ZSApIHtcblx0XHRcdG9wdGlvbi5zZWxlY3QgPSBmaW5kUGFyZW50U2VsZWN0KCBvcHRpb24ucGFyZW50ICk7XG5cdFx0XHQvLyB3ZSBtaWdodCBiZSBpbnNpZGUgYSA8ZGF0YWxpc3Q+IGVsZW1lbnRcblx0XHRcdGlmICggIW9wdGlvbi5zZWxlY3QgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdG9wdGlvbi5zZWxlY3Qub3B0aW9ucy5wdXNoKCBvcHRpb24gKTtcblx0XHRcdC8vIElmIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgaXMgbWlzc2luZywgdXNlIHRoZSBlbGVtZW50J3MgY29udGVudFxuXHRcdFx0aWYgKCAhdGVtcGxhdGUuYSApIHtcblx0XHRcdFx0dGVtcGxhdGUuYSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gLi4uYXMgbG9uZyBhcyBpdCBpc24ndCBkaXNhYmxlZFxuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5hLnZhbHVlID09PSB1bmRlZmluZWQgJiYgIXRlbXBsYXRlLmEuaGFzT3duUHJvcGVydHkoICdkaXNhYmxlZCcgKSApIHtcblx0XHRcdFx0dGVtcGxhdGUuYS52YWx1ZSA9IHRlbXBsYXRlLmY7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGVyZSBpcyBhIGBzZWxlY3RlZGAgYXR0cmlidXRlLCBidXQgdGhlIDxzZWxlY3Q+XG5cdFx0XHQvLyBhbHJlYWR5IGhhcyBhIHZhbHVlLCBkZWxldGUgaXRcblx0XHRcdGlmICggJ3NlbGVjdGVkJyBpbiB0ZW1wbGF0ZS5hICYmIG9wdGlvbi5zZWxlY3QuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZGVsZXRlIHRlbXBsYXRlLmEuc2VsZWN0ZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggZmluZFBhcmVudFNlbGVjdCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXQgPSBmdW5jdGlvbiggdHlwZXMsIGVuZm9yY2VDYXNlLCBjcmVhdGVBdHRyaWJ1dGVzLCBjcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXMsIGNyZWF0ZVR3b3dheUJpbmRpbmcsIGNyZWF0ZUV2ZW50SGFuZGxlcnMsIERlY29yYXRvciwgYnViYmxlU2VsZWN0LCBpbml0T3B0aW9uLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBFbGVtZW50JGluaXQoIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlLCByYWN0aXZlLCBiaW5kaW5nLCBiaW5kaW5ncztcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLkVMRU1FTlQ7XG5cdFx0XHQvLyBzdHVmZiB3ZSdsbCBuZWVkIGxhdGVyXG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblx0XHRcdHRoaXMucGFyZW50ID0gb3B0aW9ucy5wRWxlbWVudCB8fCBwYXJlbnRGcmFnbWVudC5wRWxlbWVudDtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmUgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuXHRcdFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG5cdFx0XHR0aGlzLm5hbWUgPSBlbmZvcmNlQ2FzZSggdGVtcGxhdGUuZSApO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPG9wdGlvbj4gZWxlbWVudHNcblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnb3B0aW9uJyApIHtcblx0XHRcdFx0aW5pdE9wdGlvbiggdGhpcywgdGVtcGxhdGUgKTtcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxzZWxlY3Q+IGVsZW1lbnRzXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ3NlbGVjdCcgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucyA9IFtdO1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSA9IGJ1YmJsZVNlbGVjdDtcblx0XHRcdH1cblx0XHRcdC8vIGNyZWF0ZSBhdHRyaWJ1dGVzXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVzKCB0aGlzLCB0ZW1wbGF0ZS5hICk7XG5cdFx0XHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcyA9IGNyZWF0ZUNvbmRpdGlvbmFsQXR0cmlidXRlcyggdGhpcywgdGVtcGxhdGUubSApO1xuXHRcdFx0Ly8gYXBwZW5kIGNoaWxkcmVuLCBpZiB0aGVyZSBhcmUgYW55XG5cdFx0XHRpZiAoIHRlbXBsYXRlLmYgKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZixcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHRcdHBFbGVtZW50OiB0aGlzXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIGNyZWF0ZSB0d293YXkgYmluZGluZ1xuXHRcdFx0aWYgKCByYWN0aXZlLnR3b3dheSAmJiAoIGJpbmRpbmcgPSBjcmVhdGVUd293YXlCaW5kaW5nKCB0aGlzLCB0ZW1wbGF0ZS5hICkgKSApIHtcblx0XHRcdFx0dGhpcy5iaW5kaW5nID0gYmluZGluZztcblx0XHRcdFx0Ly8gcmVnaXN0ZXIgdGhpcyB3aXRoIHRoZSByb290LCBzbyB0aGF0IHdlIGNhbiBkbyByYWN0aXZlLnVwZGF0ZU1vZGVsKClcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBiaW5kaW5nLmtleXBhdGggXSB8fCAoIHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbIGJpbmRpbmcua2V5cGF0aCBdID0gW10gKTtcblx0XHRcdFx0YmluZGluZ3MucHVzaCggYmluZGluZyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIGV2ZW50IHByb3hpZXNcblx0XHRcdGlmICggdGVtcGxhdGUudiApIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXJzID0gY3JlYXRlRXZlbnRIYW5kbGVycyggdGhpcywgdGVtcGxhdGUudiApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIGRlY29yYXRvclxuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5vICkge1xuXHRcdFx0XHR0aGlzLmRlY29yYXRvciA9IG5ldyBEZWNvcmF0b3IoIHRoaXMsIHRlbXBsYXRlLm8gKTtcblx0XHRcdH1cblx0XHRcdC8vIGNyZWF0ZSB0cmFuc2l0aW9uc1xuXHRcdFx0dGhpcy5pbnRybyA9IHRlbXBsYXRlLnQwIHx8IHRlbXBsYXRlLnQxO1xuXHRcdFx0dGhpcy5vdXRybyA9IHRlbXBsYXRlLnQwIHx8IHRlbXBsYXRlLnQyO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBlbmZvcmNlQ2FzZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlQXR0cmlidXRlcywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlQ29uZGl0aW9uYWxBdHRyaWJ1dGVzLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVUd293YXlCaW5kaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVFdmVudEhhbmRsZXJzLCBEZWNvcmF0b3IsIGJ1YmJsZSwgaW5pdCwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC91dGlscy9zdGFydHNXaXRoLmpzICovXG5cdHZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24oIHN0YXJ0c1dpdGhLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoIHRhcmdldCwga2V5cGF0aCApIHtcblx0XHRcdHJldHVybiB0YXJnZXQgPT09IGtleXBhdGggfHwgc3RhcnRzV2l0aEtleXBhdGgoIHRhcmdldCwga2V5cGF0aCApO1xuXHRcdH07XG5cdH0oIHN0YXJ0c1dpdGhLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvdXRpbHMvYXNzaWduTmV3S2V5cGF0aC5qcyAqL1xuXHR2YXIgYXNzaWduTmV3S2V5cGF0aCA9IGZ1bmN0aW9uKCBzdGFydHNXaXRoLCBnZXROZXdLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFzc2lnbk5ld0tleXBhdGgoIHRhcmdldCwgcHJvcGVydHksIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHR2YXIgZXhpc3RpbmdLZXlwYXRoID0gdGFyZ2V0WyBwcm9wZXJ0eSBdO1xuXHRcdFx0aWYgKCAhZXhpc3RpbmdLZXlwYXRoIHx8IHN0YXJ0c1dpdGgoIGV4aXN0aW5nS2V5cGF0aCwgbmV3S2V5cGF0aCApIHx8ICFzdGFydHNXaXRoKCBleGlzdGluZ0tleXBhdGgsIG9sZEtleXBhdGggKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0WyBwcm9wZXJ0eSBdID0gZ2V0TmV3S2V5cGF0aCggZXhpc3RpbmdLZXlwYXRoLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0fTtcblx0fSggc3RhcnRzV2l0aCwgZ2V0TmV3S2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvcmViaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkcmViaW5kID0gZnVuY3Rpb24oIGFzc2lnbk5ld0tleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gRWxlbWVudCRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdHZhciBpLCBzdG9yYWdlLCBsaXZlUXVlcmllcywgcmFjdGl2ZTtcblx0XHRcdGlmICggdGhpcy5hdHRyaWJ1dGVzICkge1xuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaCggcmViaW5kICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzICkge1xuXHRcdFx0XHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5mb3JFYWNoKCByZWJpbmQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5ldmVudEhhbmRsZXJzICkge1xuXHRcdFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCggcmViaW5kICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZGVjb3JhdG9yICkge1xuXHRcdFx0XHRyZWJpbmQoIHRoaXMuZGVjb3JhdG9yICk7XG5cdFx0XHR9XG5cdFx0XHQvLyByZWJpbmQgY2hpbGRyZW5cblx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0cmViaW5kKCB0aGlzLmZyYWdtZW50ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBVcGRhdGUgbGl2ZSBxdWVyaWVzLCBpZiBuZWNlc3Nhcnlcblx0XHRcdGlmICggbGl2ZVF1ZXJpZXMgPSB0aGlzLmxpdmVRdWVyaWVzICkge1xuXHRcdFx0XHRyYWN0aXZlID0gdGhpcy5yb290O1xuXHRcdFx0XHRpID0gbGl2ZVF1ZXJpZXMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRsaXZlUXVlcmllc1sgaSBdLl9tYWtlRGlydHkoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLm5vZGUgJiYgKCBzdG9yYWdlID0gdGhpcy5ub2RlLl9yYWN0aXZlICkgKSB7XG5cdFx0XHRcdC8vIGFkanVzdCBrZXlwYXRoIGlmIG5lZWRlZFxuXHRcdFx0XHRhc3NpZ25OZXdLZXlwYXRoKCBzdG9yYWdlLCAna2V5cGF0aCcsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0aWYgKCBpbmRleFJlZiAhPSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0c3RvcmFnZS5pbmRleFsgaW5kZXhSZWYgXSA9IG5ld0luZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHJlYmluZCggdGhpbmcgKSB7XG5cdFx0XHRcdHRoaW5nLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggYXNzaWduTmV3S2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zcGVjaWFsL2ltZy9yZW5kZXIuanMgKi9cblx0dmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlckltYWdlKCBpbWcgKSB7XG5cdFx0dmFyIGxvYWRIYW5kbGVyO1xuXHRcdC8vIGlmIHRoaXMgaXMgYW4gPGltZz4sIGFuZCB3ZSdyZSBpbiBhIGNyYXAgYnJvd3Nlciwgd2UgbWF5IG5lZWQgdG8gcHJldmVudCBpdFxuXHRcdC8vIGZyb20gb3ZlcnJpZGluZyB3aWR0aCBhbmQgaGVpZ2h0IHdoZW4gaXQgbG9hZHMgdGhlIHNyY1xuXHRcdGlmICggaW1nLmF0dHJpYnV0ZXMud2lkdGggfHwgaW1nLmF0dHJpYnV0ZXMuaGVpZ2h0ICkge1xuXHRcdFx0aW1nLm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBsb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgd2lkdGggPSBpbWcuZ2V0QXR0cmlidXRlKCAnd2lkdGgnICksXG5cdFx0XHRcdFx0aGVpZ2h0ID0gaW1nLmdldEF0dHJpYnV0ZSggJ2hlaWdodCcgKTtcblx0XHRcdFx0aWYgKCB3aWR0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGltZy5ub2RlLnNldEF0dHJpYnV0ZSggJ3dpZHRoJywgd2lkdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGhlaWdodCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGltZy5ub2RlLnNldEF0dHJpYnV0ZSggJ2hlaWdodCcsIGhlaWdodCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGltZy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdsb2FkJywgbG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHR9LCBmYWxzZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kaW5pdCA9IGZ1bmN0aW9uKCBsb2csIGNvbmZpZywgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQsIGdldFZhbHVlT3B0aW9ucyA9IHt9O1xuXHRcdC8vIFRPRE8gd2hhdCBhcmUgdGhlIG9wdGlvbnM/XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJhbnNpdGlvbiRpbml0KCBlbGVtZW50LCB0ZW1wbGF0ZSwgaXNJbnRybyApIHtcblx0XHRcdHZhciB0ID0gdGhpcyxcblx0XHRcdFx0cmFjdGl2ZSwgbmFtZSwgZnJhZ21lbnQ7XG5cdFx0XHR0LmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0dC5yb290ID0gcmFjdGl2ZSA9IGVsZW1lbnQucm9vdDtcblx0XHRcdHQuaXNJbnRybyA9IGlzSW50cm87XG5cdFx0XHRuYW1lID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcblx0XHRcdGlmICggdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiBuYW1lLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IGVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRuYW1lID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcblx0XHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHR0Lm5hbWUgPSBuYW1lO1xuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5hICkge1xuXHRcdFx0XHR0LnBhcmFtcyA9IHRlbXBsYXRlLmE7XG5cdFx0XHR9IGVsc2UgaWYgKCB0ZW1wbGF0ZS5kICkge1xuXHRcdFx0XHQvLyBUT0RPIGlzIHRoZXJlIGEgd2F5IHRvIGludGVycHJldCBkeW5hbWljIGFyZ3VtZW50cyB3aXRob3V0IGFsbCB0aGVcblx0XHRcdFx0Ly8gJ2RlcGVuZGVuY3kgdGhyYXNoaW5nJz9cblx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZCxcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiBlbGVtZW50XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dC5wYXJhbXMgPSBmcmFnbWVudC5nZXRWYWx1ZSggZ2V0VmFsdWVPcHRpb25zICk7XG5cdFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdFx0dC5fZm4gPSBjb25maWcucmVnaXN0cmllcy50cmFuc2l0aW9ucy5maW5kKCByYWN0aXZlLCBuYW1lICk7XG5cdFx0XHRpZiAoICF0Ll9mbiApIHtcblx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ21pc3NpbmdQbHVnaW4nLFxuXHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdHBsdWdpbjogJ3RyYW5zaXRpb24nLFxuXHRcdFx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggbG9nLCBjb25maWcsIGNpcmN1bGFyICk7XG5cblx0LyogdXRpbHMvY2FtZWxDYXNlLmpzICovXG5cdHZhciBjYW1lbENhc2UgPSBmdW5jdGlvbiggaHlwaGVuYXRlZFN0ciApIHtcblx0XHRyZXR1cm4gaHlwaGVuYXRlZFN0ci5yZXBsYWNlKCAvLShbYS16QS1aXSkvZywgZnVuY3Rpb24oIG1hdGNoLCAkMSApIHtcblx0XHRcdHJldHVybiAkMS50b1VwcGVyQ2FzZSgpO1xuXHRcdH0gKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9oZWxwZXJzL3ByZWZpeC5qcyAqL1xuXHR2YXIgcHJlZml4ID0gZnVuY3Rpb24oIGlzQ2xpZW50LCB2ZW5kb3JzLCBjcmVhdGVFbGVtZW50LCBjYW1lbENhc2UgKSB7XG5cblx0XHR2YXIgcHJlZml4LCBwcmVmaXhDYWNoZSwgdGVzdFN0eWxlO1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0cHJlZml4ID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJlZml4Q2FjaGUgPSB7fTtcblx0XHRcdHRlc3RTdHlsZSA9IGNyZWF0ZUVsZW1lbnQoICdkaXYnICkuc3R5bGU7XG5cdFx0XHRwcmVmaXggPSBmdW5jdGlvbiggcHJvcCApIHtcblx0XHRcdFx0dmFyIGksIHZlbmRvciwgY2FwcGVkO1xuXHRcdFx0XHRwcm9wID0gY2FtZWxDYXNlKCBwcm9wICk7XG5cdFx0XHRcdGlmICggIXByZWZpeENhY2hlWyBwcm9wIF0gKSB7XG5cdFx0XHRcdFx0aWYgKCB0ZXN0U3R5bGVbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0cHJlZml4Q2FjaGVbIHByb3AgXSA9IHByb3A7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHRlc3QgdmVuZG9ycy4uLlxuXHRcdFx0XHRcdFx0Y2FwcGVkID0gcHJvcC5jaGFyQXQoIDAgKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zdWJzdHJpbmcoIDEgKTtcblx0XHRcdFx0XHRcdGkgPSB2ZW5kb3JzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHR2ZW5kb3IgPSB2ZW5kb3JzWyBpIF07XG5cdFx0XHRcdFx0XHRcdGlmICggdGVzdFN0eWxlWyB2ZW5kb3IgKyBjYXBwZWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRcdHByZWZpeENhY2hlWyBwcm9wIF0gPSB2ZW5kb3IgKyBjYXBwZWQ7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHByZWZpeENhY2hlWyBwcm9wIF07XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gcHJlZml4O1xuXHR9KCBpc0NsaWVudCwgdmVuZG9ycywgY3JlYXRlRWxlbWVudCwgY2FtZWxDYXNlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL2dldFN0eWxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRnZXRTdHlsZSA9IGZ1bmN0aW9uKCBsZWdhY3ksIGlzQ2xpZW50LCBpc0FycmF5LCBwcmVmaXggKSB7XG5cblx0XHR2YXIgZ2V0U3R5bGUsIGdldENvbXB1dGVkU3R5bGU7XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRnZXRTdHlsZSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdldENvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSB8fCBsZWdhY3kuZ2V0Q29tcHV0ZWRTdHlsZTtcblx0XHRcdGdldFN0eWxlID0gZnVuY3Rpb24oIHByb3BzICkge1xuXHRcdFx0XHR2YXIgY29tcHV0ZWRTdHlsZSwgc3R5bGVzLCBpLCBwcm9wLCB2YWx1ZTtcblx0XHRcdFx0Y29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoIHRoaXMubm9kZSApO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBwcm9wcyA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjb21wdXRlZFN0eWxlWyBwcmVmaXgoIHByb3BzICkgXTtcblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSAnMHB4JyApIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIWlzQXJyYXkoIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVHJhbnNpdGlvbiRnZXRTdHlsZSBtdXN0IGJlIHBhc3NlZCBhIHN0cmluZywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgQ1NTIHByb3BlcnRpZXMnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGVzID0ge307XG5cdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdHByb3AgPSBwcm9wc1sgaSBdO1xuXHRcdFx0XHRcdHZhbHVlID0gY29tcHV0ZWRTdHlsZVsgcHJlZml4KCBwcm9wICkgXTtcblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSAnMHB4JyApIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3R5bGVzWyBwcm9wIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc3R5bGVzO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGdldFN0eWxlO1xuXHR9KCBsZWdhY3ksIGlzQ2xpZW50LCBpc0FycmF5LCBwcmVmaXggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvc2V0U3R5bGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJHNldFN0eWxlID0gZnVuY3Rpb24oIHByZWZpeCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggc3R5bGUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHByb3A7XG5cdFx0XHRpZiAoIHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHRoaXMubm9kZS5zdHlsZVsgcHJlZml4KCBzdHlsZSApIF0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gc3R5bGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBzdHlsZS5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xuXHRcdFx0XHRcdFx0dGhpcy5ub2RlLnN0eWxlWyBwcmVmaXgoIHByb3AgKSBdID0gc3R5bGVbIHByb3AgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0oIHByZWZpeCApO1xuXG5cdC8qIHNoYXJlZC9UaWNrZXIuanMgKi9cblx0dmFyIFRpY2tlciA9IGZ1bmN0aW9uKCB3YXJuLCBnZXRUaW1lLCBhbmltYXRpb25zICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBUaWNrZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHZhciBlYXNpbmc7XG5cdFx0XHR0aGlzLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcblx0XHRcdHRoaXMuc3RlcCA9IG9wdGlvbnMuc3RlcDtcblx0XHRcdHRoaXMuY29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuXHRcdFx0Ly8gZWFzaW5nXG5cdFx0XHRpZiAoIHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGVhc2luZyA9IG9wdGlvbnMucm9vdC5lYXNpbmdbIG9wdGlvbnMuZWFzaW5nIF07XG5cdFx0XHRcdGlmICggIWVhc2luZyApIHtcblx0XHRcdFx0XHR3YXJuKCAnTWlzc2luZyBlYXNpbmcgZnVuY3Rpb24gKFwiJyArIG9wdGlvbnMuZWFzaW5nICsgJ1wiKS4gWW91IG1heSBuZWVkIHRvIGRvd25sb2FkIGEgcGx1Z2luIGZyb20gW1RPRE9dJyApO1xuXHRcdFx0XHRcdGVhc2luZyA9IGxpbmVhcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVhc2luZyA9IGxpbmVhcjtcblx0XHRcdH1cblx0XHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nO1xuXHRcdFx0dGhpcy5zdGFydCA9IGdldFRpbWUoKTtcblx0XHRcdHRoaXMuZW5kID0gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG5cdFx0XHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXHRcdFx0YW5pbWF0aW9ucy5hZGQoIHRoaXMgKTtcblx0XHR9O1xuXHRcdFRpY2tlci5wcm90b3R5cGUgPSB7XG5cdFx0XHR0aWNrOiBmdW5jdGlvbiggbm93ICkge1xuXHRcdFx0XHR2YXIgZWxhcHNlZCwgZWFzZWQ7XG5cdFx0XHRcdGlmICggIXRoaXMucnVubmluZyApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBub3cgPiB0aGlzLmVuZCApIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMuc3RlcCApIHtcblx0XHRcdFx0XHRcdHRoaXMuc3RlcCggMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHRoaXMuY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmNvbXBsZXRlKCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbGFwc2VkID0gbm93IC0gdGhpcy5zdGFydDtcblx0XHRcdFx0ZWFzZWQgPSB0aGlzLmVhc2luZyggZWxhcHNlZCAvIHRoaXMuZHVyYXRpb24gKTtcblx0XHRcdFx0aWYgKCB0aGlzLnN0ZXAgKSB7XG5cdFx0XHRcdFx0dGhpcy5zdGVwKCBlYXNlZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMuYWJvcnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5hYm9ydCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0X19leHBvcnQgPSBUaWNrZXI7XG5cblx0XHRmdW5jdGlvbiBsaW5lYXIoIHQgKSB7XG5cdFx0XHRyZXR1cm4gdDtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB3YXJuLCBnZXRUaW1lLCBhbmltYXRpb25zICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vaGVscGVycy91bnByZWZpeC5qcyAqL1xuXHR2YXIgdW5wcmVmaXggPSBmdW5jdGlvbiggdmVuZG9ycyApIHtcblxuXHRcdHZhciB1bnByZWZpeFBhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXi0oPzonICsgdmVuZG9ycy5qb2luKCAnfCcgKSArICcpLScgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHByb3AgKSB7XG5cdFx0XHRyZXR1cm4gcHJvcC5yZXBsYWNlKCB1bnByZWZpeFBhdHRlcm4sICcnICk7XG5cdFx0fTtcblx0fSggdmVuZG9ycyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL2hlbHBlcnMvaHlwaGVuYXRlLmpzICovXG5cdHZhciBoeXBoZW5hdGUgPSBmdW5jdGlvbiggdmVuZG9ycyApIHtcblxuXHRcdHZhciB2ZW5kb3JQYXR0ZXJuID0gbmV3IFJlZ0V4cCggJ14oPzonICsgdmVuZG9ycy5qb2luKCAnfCcgKSArICcpKFtBLVpdKScgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdHZhciBoeXBoZW5hdGVkO1xuXHRcdFx0aWYgKCAhc3RyICkge1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZlbmRvclBhdHRlcm4udGVzdCggc3RyICkgKSB7XG5cdFx0XHRcdHN0ciA9ICctJyArIHN0cjtcblx0XHRcdH1cblx0XHRcdGh5cGhlbmF0ZWQgPSBzdHIucmVwbGFjZSggL1tBLVpdL2csIGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdFx0cmV0dXJuICctJyArIG1hdGNoLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gaHlwaGVuYXRlZDtcblx0XHR9O1xuXHR9KCB2ZW5kb3JzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL2FuaW1hdGVTdHlsZS9jcmVhdGVUcmFuc2l0aW9ucy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24oIGlzQ2xpZW50LCB3YXJuLCBjcmVhdGVFbGVtZW50LCBjYW1lbENhc2UsIGludGVycG9sYXRlLCBUaWNrZXIsIHByZWZpeCwgdW5wcmVmaXgsIGh5cGhlbmF0ZSApIHtcblxuXHRcdHZhciBjcmVhdGVUcmFuc2l0aW9ucywgdGVzdFN0eWxlLCBUUkFOU0lUSU9OLCBUUkFOU0lUSU9ORU5ELCBDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCwgVFJBTlNJVElPTl9EVVJBVElPTiwgVFJBTlNJVElPTl9QUk9QRVJUWSwgVFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04sIGNhblVzZUNzc1RyYW5zaXRpb25zID0ge30sXG5cdFx0XHRjYW5ub3RVc2VDc3NUcmFuc2l0aW9ucyA9IHt9O1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0Y3JlYXRlVHJhbnNpdGlvbnMgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ZXN0U3R5bGUgPSBjcmVhdGVFbGVtZW50KCAnZGl2JyApLnN0eWxlO1xuXHRcdFx0Ly8gZGV0ZXJtaW5lIHNvbWUgZmFjdHMgYWJvdXQgb3VyIGVudmlyb25tZW50XG5cdFx0XHQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRlc3RTdHlsZS50cmFuc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0VFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcblx0XHRcdFx0XHRUUkFOU0lUSU9ORU5EID0gJ3RyYW5zaXRpb25lbmQnO1xuXHRcdFx0XHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggdGVzdFN0eWxlLndlYmtpdFRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRUUkFOU0lUSU9OID0gJ3dlYmtpdFRyYW5zaXRpb24nO1xuXHRcdFx0XHRcdFRSQU5TSVRJT05FTkQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG5cdFx0XHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0oKSApO1xuXHRcdFx0aWYgKCBUUkFOU0lUSU9OICkge1xuXHRcdFx0XHRUUkFOU0lUSU9OX0RVUkFUSU9OID0gVFJBTlNJVElPTiArICdEdXJhdGlvbic7XG5cdFx0XHRcdFRSQU5TSVRJT05fUFJPUEVSVFkgPSBUUkFOU0lUSU9OICsgJ1Byb3BlcnR5Jztcblx0XHRcdFx0VFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04gPSBUUkFOU0lUSU9OICsgJ1RpbWluZ0Z1bmN0aW9uJztcblx0XHRcdH1cblx0XHRcdGNyZWF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24oIHQsIHRvLCBvcHRpb25zLCBjaGFuZ2VkUHJvcGVydGllcywgcmVzb2x2ZSApIHtcblx0XHRcdFx0Ly8gV2FpdCBhIGJlYXQgKG90aGVyd2lzZSB0aGUgdGFyZ2V0IHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgaW1tZWRpYXRlbHkpXG5cdFx0XHRcdC8vIFRPRE8gdXNlIGEgZmFzdGRvbS1zdHlsZSBtZWNoYW5pc20/XG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBoYXNoUHJlZml4LCBqc1RyYW5zaXRpb25zQ29tcGxldGUsIGNzc1RyYW5zaXRpb25zQ29tcGxldGUsIGNoZWNrQ29tcGxldGUsIHRyYW5zaXRpb25FbmRIYW5kbGVyO1xuXHRcdFx0XHRcdGNoZWNrQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICgganNUcmFuc2l0aW9uc0NvbXBsZXRlICYmIGNzc1RyYW5zaXRpb25zQ29tcGxldGUgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHdpbGwgY2hhbmdlcyB0byBldmVudHMgYW5kIGZpcmUgaGF2ZSBhbiB1bmV4cGVjdGVkIGNvbnNlcXVlbmNlIGhlcmU/XG5cdFx0XHRcdFx0XHRcdHQucm9vdC5maXJlKCB0Lm5hbWUgKyAnOmVuZCcsIHQubm9kZSwgdC5pc0ludHJvICk7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdC8vIHRoaXMgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIGVsZW1lbnRzIGNhbiB1c2UgQ1NTIHRvIGFuaW1hdGVcblx0XHRcdFx0XHQvLyB3aGljaCBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0aGFzaFByZWZpeCA9ICggdC5ub2RlLm5hbWVzcGFjZVVSSSB8fCAnJyApICsgdC5ub2RlLnRhZ05hbWU7XG5cdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBUUkFOU0lUSU9OX1BST1BFUlRZIF0gPSBjaGFuZ2VkUHJvcGVydGllcy5tYXAoIHByZWZpeCApLm1hcCggaHlwaGVuYXRlICkuam9pbiggJywnICk7XG5cdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiBdID0gaHlwaGVuYXRlKCBvcHRpb25zLmVhc2luZyB8fCAnbGluZWFyJyApO1xuXHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgVFJBTlNJVElPTl9EVVJBVElPTiBdID0gb3B0aW9ucy5kdXJhdGlvbiAvIDEwMDAgKyAncyc7XG5cdFx0XHRcdFx0dHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0XHRpbmRleCA9IGNoYW5nZWRQcm9wZXJ0aWVzLmluZGV4T2YoIGNhbWVsQ2FzZSggdW5wcmVmaXgoIGV2ZW50LnByb3BlcnR5TmFtZSApICkgKTtcblx0XHRcdFx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gc3RpbGwgdHJhbnNpdGlvbmluZy4uLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHRcdFx0XHRjc3NUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHQubm9kZS5hZGRFdmVudExpc3RlbmVyKCBUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBpID0gY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRoYXNoLCBvcmlnaW5hbFZhbHVlLCBpbmRleCwgcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMgPSBbXSxcblx0XHRcdFx0XHRcdFx0cHJvcCwgc3VmZml4O1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdHByb3AgPSBjaGFuZ2VkUHJvcGVydGllc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRoYXNoID0gaGFzaFByZWZpeCArIHByb3A7XG5cdFx0XHRcdFx0XHRcdGlmICggQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgJiYgIWNhbm5vdFVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBwcmVmaXgoIHByb3AgKSBdID0gdG9bIHByb3AgXTtcblx0XHRcdFx0XHRcdFx0XHQvLyBJZiB3ZSdyZSBub3Qgc3VyZSBpZiBDU1MgdHJhbnNpdGlvbnMgYXJlIHN1cHBvcnRlZCBmb3Jcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGlzIHRhZy9wcm9wZXJ0eSBjb21ibywgZmluZCBvdXQgbm93XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhY2FuVXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG9yaWdpbmFsVmFsdWUgPSB0LmdldFN0eWxlKCBwcm9wICk7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBpZiB0aGlzIHByb3BlcnR5IGlzIHRyYW5zaXRpb25hYmxlIGluIHRoaXMgYnJvd3Nlcixcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHRoZSBjdXJyZW50IHN0eWxlIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gdGhlIHRhcmdldCBzdHlsZVxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FuVXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSA9IHQuZ2V0U3R5bGUoIHByb3AgKSAhPSB0b1sgcHJvcCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSA9ICFjYW5Vc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmVzZXQsIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSB0aW1lcnMgYWZ0ZXIgYWxsXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgcHJlZml4KCBwcm9wICkgXSA9IG9yaWdpbmFsVmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICggIUNTU19UUkFOU0lUSU9OU19FTkFCTEVEIHx8IGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGltZXItYmFzZWQgc3R1ZmZcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG9yaWdpbmFsVmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG9yaWdpbmFsVmFsdWUgPSB0LmdldFN0eWxlKCBwcm9wICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIG5lZWQgdG8gcmVtb3ZlIHRoaXMgZnJvbSBjaGFuZ2VkUHJvcGVydGllcywgb3RoZXJ3aXNlIHRyYW5zaXRpb25FbmRIYW5kbGVyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2lsbCBnZXQgY29uZnVzZWRcblx0XHRcdFx0XHRcdFx0XHRpbmRleCA9IGNoYW5nZWRQcm9wZXJ0aWVzLmluZGV4T2YoIHByb3AgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHdhcm4oICdTb21ldGhpbmcgdmVyeSBzdHJhbmdlIGhhcHBlbmVkIHdpdGggdHJhbnNpdGlvbnMuIElmIHlvdSBzZWUgdGhpcyBtZXNzYWdlLCBwbGVhc2UgbGV0IEBSYWN0aXZlSlMga25vdy4gVGhhbmtzIScgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBUT0RPIERldGVybWluZSB3aGV0aGVyIHRoaXMgcHJvcGVydHkgaXMgYW5pbWF0YWJsZSBhdCBhbGxcblx0XHRcdFx0XHRcdFx0XHRzdWZmaXggPSAvW15cXGRdKiQvLmV4ZWMoIHRvWyBwcm9wIF0gKVsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLnRoZW4ga2ljayBvZmYgYSB0aW1lci1iYXNlZCB0cmFuc2l0aW9uXG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMucHVzaCgge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZTogcHJlZml4KCBwcm9wICksXG5cdFx0XHRcdFx0XHRcdFx0XHRpbnRlcnBvbGF0b3I6IGludGVycG9sYXRlKCBwYXJzZUZsb2F0KCBvcmlnaW5hbFZhbHVlICksIHBhcnNlRmxvYXQoIHRvWyBwcm9wIF0gKSApLFxuXHRcdFx0XHRcdFx0XHRcdFx0c3VmZml4OiBzdWZmaXhcblx0XHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGphdmFzY3JpcHQgdHJhbnNpdGlvbnNcblx0XHRcdFx0XHRcdGlmICggcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRuZXcgVGlja2VyKCB7XG5cdFx0XHRcdFx0XHRcdFx0cm9vdDogdC5yb290LFxuXHRcdFx0XHRcdFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdGVhc2luZzogY2FtZWxDYXNlKCBvcHRpb25zLmVhc2luZyB8fCAnJyApLFxuXHRcdFx0XHRcdFx0XHRcdHN0ZXA6IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcHJvcCwgaTtcblx0XHRcdFx0XHRcdFx0XHRcdGkgPSBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcCA9IHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzWyBpIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wLmludGVycG9sYXRvciggcG9zICkgKyBwcm9wLnN1ZmZpeDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGpzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRqc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCAhY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGFuZCBkZWFsIHdpdGhcblx0XHRcdFx0XHRcdFx0Ly8gdGhlIGZhY3QgdGhhdCBpdCB3aWxsIG5ldmVyIGZpcmVcblx0XHRcdFx0XHRcdFx0dC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoIFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0XHRcdFx0XHRjc3NUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIDAgKTtcblx0XHRcdFx0fSwgb3B0aW9ucy5kZWxheSB8fCAwICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlVHJhbnNpdGlvbnM7XG5cdH0oIGlzQ2xpZW50LCB3YXJuLCBjcmVhdGVFbGVtZW50LCBjYW1lbENhc2UsIGludGVycG9sYXRlLCBUaWNrZXIsIHByZWZpeCwgdW5wcmVmaXgsIGh5cGhlbmF0ZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9hbmltYXRlU3R5bGUvdmlzaWJpbGl0eS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHkgPSBmdW5jdGlvbiggdmVuZG9ycyApIHtcblxuXHRcdHZhciBoaWRkZW4sIHZlbmRvciwgcHJlZml4LCBpLCB2aXNpYmlsaXR5O1xuXHRcdGlmICggdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdGhpZGRlbiA9ICdoaWRkZW4nO1xuXHRcdFx0dmlzaWJpbGl0eSA9IHt9O1xuXHRcdFx0aWYgKCBoaWRkZW4gaW4gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdHByZWZpeCA9ICcnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IHZlbmRvcnMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHR2ZW5kb3IgPSB2ZW5kb3JzWyBpIF07XG5cdFx0XHRcdFx0aGlkZGVuID0gdmVuZG9yICsgJ0hpZGRlbic7XG5cdFx0XHRcdFx0aWYgKCBoaWRkZW4gaW4gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRwcmVmaXggPSB2ZW5kb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHByZWZpeCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBwcmVmaXggKyAndmlzaWJpbGl0eWNoYW5nZScsIG9uQ2hhbmdlICk7XG5cdFx0XHRcdC8vIGluaXRpYWxpc2Vcblx0XHRcdFx0b25DaGFuZ2UoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGdhaCwgd2UncmUgaW4gYW4gb2xkIGJyb3dzZXJcblx0XHRcdFx0aWYgKCAnb25mb2N1c291dCcgaW4gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2ZvY3Vzb3V0Jywgb25IaWRlICk7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2ZvY3VzaW4nLCBvblNob3cgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3BhZ2VoaWRlJywgb25IaWRlICk7XG5cdFx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdibHVyJywgb25IaWRlICk7XG5cdFx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdwYWdlc2hvdycsIG9uU2hvdyApO1xuXHRcdFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXMnLCBvblNob3cgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuXHRcdFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBkb2N1bWVudFsgaGlkZGVuIF07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25IaWRlKCkge1xuXHRcdFx0dmlzaWJpbGl0eS5oaWRkZW4gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uU2hvdygpIHtcblx0XHRcdHZpc2liaWxpdHkuaGlkZGVuID0gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB2aXNpYmlsaXR5O1xuXHR9KCB2ZW5kb3JzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL2FuaW1hdGVTdHlsZS9fYW5pbWF0ZVN0eWxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfX2FuaW1hdGVTdHlsZSA9IGZ1bmN0aW9uKCBsZWdhY3ksIGlzQ2xpZW50LCB3YXJuLCBQcm9taXNlLCBwcmVmaXgsIGNyZWF0ZVRyYW5zaXRpb25zLCB2aXNpYmlsaXR5ICkge1xuXG5cdFx0dmFyIGFuaW1hdGVTdHlsZSwgZ2V0Q29tcHV0ZWRTdHlsZSwgcmVzb2x2ZWQ7XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRhbmltYXRlU3R5bGUgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnZXRDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgfHwgbGVnYWN5LmdldENvbXB1dGVkU3R5bGU7XG5cdFx0XHRhbmltYXRlU3R5bGUgPSBmdW5jdGlvbiggc3R5bGUsIHZhbHVlLCBvcHRpb25zLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIHQgPSB0aGlzLFxuXHRcdFx0XHRcdHRvO1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBwYWdlIGlzbid0IHZpc2libGUuIERvbid0IGFuaW1hdGUgYW55dGhpbmcsIGJlY2F1c2Vcblx0XHRcdFx0Ly8gdGhhdCB3YXkgeW91J2xsIG5ldmVyIGdldCBDU1MgdHJhbnNpdGlvbmVuZCBldmVudHNcblx0XHRcdFx0aWYgKCB2aXNpYmlsaXR5LmhpZGRlbiApIHtcblx0XHRcdFx0XHR0aGlzLnNldFN0eWxlKCBzdHlsZSwgdmFsdWUgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzb2x2ZWQgfHwgKCByZXNvbHZlZCA9IFByb21pc2UucmVzb2x2ZSgpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHRvID0ge307XG5cdFx0XHRcdFx0dG9bIHN0eWxlIF0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0byA9IHN0eWxlO1xuXHRcdFx0XHRcdC8vIHNodWZmbGUgYXJndW1lbnRzXG5cdFx0XHRcdFx0Y29tcGxldGUgPSBvcHRpb25zO1xuXHRcdFx0XHRcdG9wdGlvbnMgPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBBcyBvZiAwLjMuOSwgdHJhbnNpdGlvbiBhdXRob3JzIHNob3VsZCBzdXBwbHkgYW4gYG9wdGlvbmAgb2JqZWN0IHdpdGhcblx0XHRcdFx0Ly8gYGR1cmF0aW9uYCBhbmQgYGVhc2luZ2AgcHJvcGVydGllcyAoYW5kIG9wdGlvbmFsIGBkZWxheWApLCBwbHVzIGFcblx0XHRcdFx0Ly8gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlc1xuXHRcdFx0XHQvLyBUT0RPIHJlbW92ZSB0aGlzIGNoZWNrIGluIGEgZnV0dXJlIHZlcnNpb25cblx0XHRcdFx0aWYgKCAhb3B0aW9ucyApIHtcblx0XHRcdFx0XHR3YXJuKCAnVGhlIFwiJyArIHQubmFtZSArICdcIiB0cmFuc2l0aW9uIGRvZXMgbm90IHN1cHBseSBhbiBvcHRpb25zIG9iamVjdCB0byBgdC5hbmltYXRlU3R5bGUoKWAuIFRoaXMgd2lsbCBicmVhayBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJhY3RpdmUuIEZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMvMzQwJyApO1xuXHRcdFx0XHRcdG9wdGlvbnMgPSB0O1xuXHRcdFx0XHRcdGNvbXBsZXRlID0gdC5jb21wbGV0ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKCBmdW5jdGlvbiggcmVzb2x2ZSApIHtcblx0XHRcdFx0XHR2YXIgcHJvcGVydHlOYW1lcywgY2hhbmdlZFByb3BlcnRpZXMsIGNvbXB1dGVkU3R5bGUsIGN1cnJlbnQsIGZyb20sIGksIHByb3A7XG5cdFx0XHRcdFx0Ly8gRWRnZSBjYXNlIC0gaWYgZHVyYXRpb24gaXMgemVybywgc2V0IHN0eWxlIHN5bmNocm9ub3VzbHkgYW5kIGNvbXBsZXRlXG5cdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdFx0XHRcdHQuc2V0U3R5bGUoIHRvICk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEdldCBhIGxpc3Qgb2YgdGhlIHByb3BlcnRpZXMgd2UncmUgYW5pbWF0aW5nXG5cdFx0XHRcdFx0cHJvcGVydHlOYW1lcyA9IE9iamVjdC5rZXlzKCB0byApO1xuXHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzID0gW107XG5cdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIGN1cnJlbnQgc3R5bGVzXG5cdFx0XHRcdFx0Y29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoIHQubm9kZSApO1xuXHRcdFx0XHRcdGZyb20gPSB7fTtcblx0XHRcdFx0XHRpID0gcHJvcGVydHlOYW1lcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRwcm9wID0gcHJvcGVydHlOYW1lc1sgaSBdO1xuXHRcdFx0XHRcdFx0Y3VycmVudCA9IGNvbXB1dGVkU3R5bGVbIHByZWZpeCggcHJvcCApIF07XG5cdFx0XHRcdFx0XHRpZiAoIGN1cnJlbnQgPT09ICcwcHgnICkge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIHdlIG5lZWQgdG8ga25vdyBpZiB3ZSdyZSBhY3R1YWxseSBjaGFuZ2luZyBhbnl0aGluZ1xuXHRcdFx0XHRcdFx0aWYgKCBjdXJyZW50ICE9IHRvWyBwcm9wIF0gKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHVzZSAhPSBpbnN0ZWFkIG9mICE9PSwgc28gd2UgY2FuIGNvbXBhcmUgc3RyaW5ncyB3aXRoIG51bWJlcnNcblx0XHRcdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMucHVzaCggcHJvcCApO1xuXHRcdFx0XHRcdFx0XHQvLyBtYWtlIHRoZSBjb21wdXRlZCBzdHlsZSBleHBsaWNpdCwgc28gd2UgY2FuIGFuaW1hdGUgd2hlcmVcblx0XHRcdFx0XHRcdFx0Ly8gZS5nLiBoZWlnaHQ9J2F1dG8nXG5cdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgcHJlZml4KCBwcm9wICkgXSA9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBhY3R1YWxseSBjaGFuZ2luZyBhbnl0aGluZywgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnRcblx0XHRcdFx0XHQvLyB3aWxsIG5ldmVyIGZpcmUhIFNvIHdlIGNvbXBsZXRlIGVhcmx5XG5cdFx0XHRcdFx0aWYgKCAhY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjcmVhdGVUcmFuc2l0aW9ucyggdCwgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0Ly8gSWYgYSBjYWxsYmFjayB3YXMgc3VwcGxpZWQsIGRvIHRoZSBob25vdXJzXG5cdFx0XHRcdC8vIFRPRE8gcmVtb3ZlIHRoaXMgY2hlY2sgaW4gZnV0dXJlXG5cdFx0XHRcdGlmICggY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0d2FybiggJ3QuYW5pbWF0ZVN0eWxlIHJldHVybnMgYSBQcm9taXNlIGFzIG9mIDAuNC4wLiBUcmFuc2l0aW9uIGF1dGhvcnMgc2hvdWxkIGRvIHQuYW5pbWF0ZVN0eWxlKC4uLikudGhlbihjYWxsYmFjayknICk7XG5cdFx0XHRcdFx0cHJvbWlzZS50aGVuKCBjb21wbGV0ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGFuaW1hdGVTdHlsZTtcblx0fSggbGVnYWN5LCBpc0NsaWVudCwgd2FybiwgUHJvbWlzZSwgcHJlZml4LCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnMsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5ICk7XG5cblx0LyogdXRpbHMvZmlsbEdhcHMuanMgKi9cblx0dmFyIGZpbGxHYXBzID0gZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgU0xJQ0UkMCA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0XHR2YXIgc291cmNlcyA9IFNMSUNFJDAuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cdFx0c291cmNlcy5mb3JFYWNoKCBmdW5jdGlvbiggcyApIHtcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gcyApIHtcblx0XHRcdFx0aWYgKCBzLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiAhKCBrZXkgaW4gdGFyZ2V0ICkgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9IHNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL3Byb2Nlc3NQYXJhbXMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJHByb2Nlc3NQYXJhbXMgPSBmdW5jdGlvbiggZmlsbEdhcHMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcmFtcywgZGVmYXVsdHMgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBwYXJhbXMgPT09ICdudW1iZXInICkge1xuXHRcdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdFx0ZHVyYXRpb246IHBhcmFtc1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGlmICggcGFyYW1zID09PSAnc2xvdycgKSB7XG5cdFx0XHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IDYwMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhcmFtcyA9PT0gJ2Zhc3QnICkge1xuXHRcdFx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiAyMDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiA0MDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCAhcGFyYW1zICkge1xuXHRcdFx0XHRwYXJhbXMgPSB7fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmaWxsR2Fwcygge30sIHBhcmFtcywgZGVmYXVsdHMgKTtcblx0XHR9O1xuXHR9KCBmaWxsR2FwcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9zdGFydC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kc3RhcnQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFRyYW5zaXRpb24kc3RhcnQoKSB7XG5cdFx0XHR2YXIgdCA9IHRoaXMsXG5cdFx0XHRcdG5vZGUsIG9yaWdpbmFsU3R5bGUsIGNvbXBsZXRlZDtcblx0XHRcdG5vZGUgPSB0Lm5vZGUgPSB0LmVsZW1lbnQubm9kZTtcblx0XHRcdG9yaWdpbmFsU3R5bGUgPSBub2RlLmdldEF0dHJpYnV0ZSggJ3N0eWxlJyApO1xuXHRcdFx0Ly8gY3JlYXRlIHQuY29tcGxldGUoKSAtIHdlIGRvbid0IHdhbnQgdGhpcyBvbiB0aGUgcHJvdG90eXBlLFxuXHRcdFx0Ly8gYmVjYXVzZSB3ZSBkb24ndCB3YW50IGB0aGlzYCBzaWxsaW5lc3Mgd2hlbiBwYXNzaW5nIGl0IGFzXG5cdFx0XHQvLyBhbiBhcmd1bWVudFxuXHRcdFx0dC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCBub1Jlc2V0ICkge1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhbm9SZXNldCAmJiB0LmlzSW50cm8gKSB7XG5cdFx0XHRcdFx0cmVzZXRTdHlsZSggbm9kZSwgb3JpZ2luYWxTdHlsZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuX3JhY3RpdmUudHJhbnNpdGlvbiA9IG51bGw7XG5cdFx0XHRcdHQuX21hbmFnZXIucmVtb3ZlKCB0ICk7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gSWYgdGhlIHRyYW5zaXRpb24gZnVuY3Rpb24gZG9lc24ndCBleGlzdCwgYWJvcnRcblx0XHRcdGlmICggIXQuX2ZuICkge1xuXHRcdFx0XHR0LmNvbXBsZXRlKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHQuX2ZuLmFwcGx5KCB0LnJvb3QsIFsgdCBdLmNvbmNhdCggdC5wYXJhbXMgKSApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXNldFN0eWxlKCBub2RlLCBzdHlsZSApIHtcblx0XHRcdGlmICggc3R5bGUgKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCAnc3R5bGUnLCBzdHlsZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gTmV4dCBsaW5lIGlzIG5lY2Vzc2FyeSwgdG8gcmVtb3ZlIGVtcHR5IHN0eWxlIGF0dHJpYnV0ZSFcblx0XHRcdFx0Ly8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNjc1NTNcblx0XHRcdFx0bm9kZS5nZXRBdHRyaWJ1dGUoICdzdHlsZScgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUoICdzdHlsZScgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vX1RyYW5zaXRpb24uanMgKi9cblx0dmFyIFRyYW5zaXRpb24gPSBmdW5jdGlvbiggaW5pdCwgZ2V0U3R5bGUsIHNldFN0eWxlLCBhbmltYXRlU3R5bGUsIHByb2Nlc3NQYXJhbXMsIHN0YXJ0LCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudCwgVHJhbnNpdGlvbjtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdFRyYW5zaXRpb24gPSBmdW5jdGlvbiggb3duZXIsIHRlbXBsYXRlLCBpc0ludHJvICkge1xuXHRcdFx0dGhpcy5pbml0KCBvd25lciwgdGVtcGxhdGUsIGlzSW50cm8gKTtcblx0XHR9O1xuXHRcdFRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGdldFN0eWxlOiBnZXRTdHlsZSxcblx0XHRcdHNldFN0eWxlOiBzZXRTdHlsZSxcblx0XHRcdGFuaW1hdGVTdHlsZTogYW5pbWF0ZVN0eWxlLFxuXHRcdFx0cHJvY2Vzc1BhcmFtczogcHJvY2Vzc1BhcmFtc1xuXHRcdH07XG5cdFx0cmV0dXJuIFRyYW5zaXRpb247XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGluaXQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGdldFN0eWxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRzZXRTdHlsZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX19hbmltYXRlU3R5bGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJHByb2Nlc3NQYXJhbXMsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJHN0YXJ0LCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkcmVuZGVyID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGlzQXJyYXksIHdhcm4sIGNyZWF0ZSwgY3JlYXRlRWxlbWVudCwgZGVmaW5lUHJvcGVydHksIG5vb3AsIHJ1bmxvb3AsIGdldElubmVyQ29udGV4dCwgcmVuZGVySW1hZ2UsIFRyYW5zaXRpb24gKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIHVwZGF0ZUNzcywgdXBkYXRlU2NyaXB0O1xuXHRcdHVwZGF0ZUNzcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5vZGUgPSB0aGlzLm5vZGUsXG5cdFx0XHRcdGNvbnRlbnQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCBmYWxzZSApO1xuXHRcdFx0Ly8gSUU4IGhhcyBubyBzdHlsZVNoZWV0IHVubGVzcyB0aGVyZSdzIGEgdHlwZSB0ZXh0L2Nzc1xuXHRcdFx0aWYgKCB3aW5kb3cgJiYgd2luZG93LmFwcGVhcnNUb0JlSUVMZXNzRXF1YWw4ICkge1xuXHRcdFx0XHRub2RlLnR5cGUgPSAndGV4dC9jc3MnO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBub2RlLnN0eWxlU2hlZXQgKSB7XG5cdFx0XHRcdG5vZGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY29udGVudDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggbm9kZS5oYXNDaGlsZE5vZGVzKCkgKSB7XG5cdFx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZCggbm9kZS5maXJzdENoaWxkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIGNvbnRlbnQgKSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0dXBkYXRlU2NyaXB0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICF0aGlzLm5vZGUudHlwZSB8fCB0aGlzLm5vZGUudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCcgKSB7XG5cdFx0XHRcdHdhcm4oICdTY3JpcHQgdGFnIHdhcyB1cGRhdGVkLiBUaGlzIGRvZXMgbm90IGNhdXNlIHRoZSBjb2RlIHRvIGJlIHJlLWV2YWx1YXRlZCEnICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm5vZGUudGV4dCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIGZhbHNlICk7XG5cdFx0fTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIEVsZW1lbnQkcmVuZGVyKCkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcm9vdCA9IHRoaXMucm9vdCxcblx0XHRcdFx0bmFtZXNwYWNlLCBub2RlO1xuXHRcdFx0bmFtZXNwYWNlID0gZ2V0TmFtZXNwYWNlKCB0aGlzICk7XG5cdFx0XHRub2RlID0gdGhpcy5ub2RlID0gY3JlYXRlRWxlbWVudCggdGhpcy5uYW1lLCBuYW1lc3BhY2UgKTtcblx0XHRcdC8vIElzIHRoaXMgYSB0b3AtbGV2ZWwgbm9kZSBvZiBhIGNvbXBvbmVudD8gSWYgc28sIHdlIG1heSBuZWVkIHRvIGFkZFxuXHRcdFx0Ly8gYSBkYXRhLXJ2Y2d1aWQgYXR0cmlidXRlLCBmb3IgQ1NTIGVuY2Fwc3VsYXRpb25cblx0XHRcdC8vIE5PVEU6IGNzcyBubyBsb25nZXIgY29waWVkIHRvIGluc3RhbmNlLCBzbyB3ZSBjaGVjayBjb25zdHJ1Y3Rvci5jc3MgLVxuXHRcdFx0Ly8gd2UgY2FuIGVuaGFuY2UgdG8gaGFuZGxlIGluc3RhbmNlLCBidXQgdGhpcyBpcyBtb3JlIFwiY29ycmVjdFwiIHdpdGggY3VycmVudFxuXHRcdFx0Ly8gZnVuY3Rpb25hbGl0eVxuXHRcdFx0aWYgKCByb290LmNvbnN0cnVjdG9yLmNzcyAmJiB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSA9PT0gcm9vdC5lbCApIHtcblx0XHRcdFx0dGhpcy5ub2RlLnNldEF0dHJpYnV0ZSggJ2RhdGEtcnZjZ3VpZCcsIHJvb3QuY29uc3RydWN0b3IuX2d1aWQgKTtcblx0XHRcdH1cblx0XHRcdC8vIEFkZCBfcmFjdGl2ZSBwcm9wZXJ0eSB0byB0aGUgbm9kZSAtIHdlIHVzZSB0aGlzIG9iamVjdCB0byBzdG9yZSBzdHVmZlxuXHRcdFx0Ly8gcmVsYXRlZCB0byBwcm94eSBldmVudHMsIHR3by13YXkgYmluZGluZ3MgZXRjXG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSggdGhpcy5ub2RlLCAnX3JhY3RpdmUnLCB7XG5cdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0cHJveHk6IHRoaXMsXG5cdFx0XHRcdFx0a2V5cGF0aDogZ2V0SW5uZXJDb250ZXh0KCB0aGlzLnBhcmVudEZyYWdtZW50ICksXG5cdFx0XHRcdFx0aW5kZXg6IHRoaXMucGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzLFxuXHRcdFx0XHRcdGV2ZW50czogY3JlYXRlKCBudWxsICksXG5cdFx0XHRcdFx0cm9vdDogcm9vdFxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHQvLyBSZW5kZXIgYXR0cmlidXRlc1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goIGZ1bmN0aW9uKCBhICkge1xuXHRcdFx0XHRyZXR1cm4gYS5yZW5kZXIoIG5vZGUgKTtcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLmZvckVhY2goIGZ1bmN0aW9uKCBhICkge1xuXHRcdFx0XHRyZXR1cm4gYS5yZW5kZXIoIG5vZGUgKTtcblx0XHRcdH0gKTtcblx0XHRcdC8vIFJlbmRlciBjaGlsZHJlblxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8c2NyaXB0PiBlbGVtZW50XG5cdFx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnc2NyaXB0JyApIHtcblx0XHRcdFx0XHR0aGlzLmJ1YmJsZSA9IHVwZGF0ZVNjcmlwdDtcblx0XHRcdFx0XHR0aGlzLm5vZGUudGV4dCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIGZhbHNlICk7XG5cdFx0XHRcdFx0Ly8gYnlwYXNzIHdhcm5pbmcgaW5pdGlhbGx5XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMubmFtZSA9PT0gJ3N0eWxlJyApIHtcblx0XHRcdFx0XHR0aGlzLmJ1YmJsZSA9IHVwZGF0ZUNzcztcblx0XHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLmJpbmRpbmcgJiYgdGhpcy5nZXRBdHRyaWJ1dGUoICdjb250ZW50ZWRpdGFibGUnICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5ub2RlLmFwcGVuZENoaWxkKCB0aGlzLmZyYWdtZW50LnJlbmRlcigpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIEFkZCBwcm94eSBldmVudCBoYW5kbGVyc1xuXHRcdFx0aWYgKCB0aGlzLmV2ZW50SGFuZGxlcnMgKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKCBmdW5jdGlvbiggaCApIHtcblx0XHRcdFx0XHRyZXR1cm4gaC5yZW5kZXIoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZGVhbCB3aXRoIHR3by13YXkgYmluZGluZ3Ncblx0XHRcdGlmICggdGhpcy5iaW5kaW5nICkge1xuXHRcdFx0XHR0aGlzLmJpbmRpbmcucmVuZGVyKCk7XG5cdFx0XHRcdHRoaXMubm9kZS5fcmFjdGl2ZS5iaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlOiBpZiB0aGlzIGlzIGFuIDxpbWc+LCBhbmQgd2UncmUgaW4gYSBjcmFwIGJyb3dzZXIsIHdlIG1heVxuXHRcdFx0Ly8gbmVlZCB0byBwcmV2ZW50IGl0IGZyb20gb3ZlcnJpZGluZyB3aWR0aCBhbmQgaGVpZ2h0IHdoZW4gaXQgbG9hZHMgdGhlIHNyY1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdpbWcnICkge1xuXHRcdFx0XHRyZW5kZXJJbWFnZSggdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYXBwbHkgZGVjb3JhdG9yKHMpXG5cdFx0XHRpZiAoIHRoaXMuZGVjb3JhdG9yICYmIHRoaXMuZGVjb3JhdG9yLmZuICkge1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5kZWNvcmF0b3IuaW5pdCgpO1xuXHRcdFx0XHR9LCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyB0cmlnZ2VyIGludHJvIHRyYW5zaXRpb25cblx0XHRcdGlmICggcm9vdC50cmFuc2l0aW9uc0VuYWJsZWQgJiYgdGhpcy5pbnRybyApIHtcblx0XHRcdFx0dmFyIHRyYW5zaXRpb24gPSBuZXcgVHJhbnNpdGlvbiggdGhpcywgdGhpcy5pbnRybywgdHJ1ZSApO1xuXHRcdFx0XHRydW5sb29wLnJlZ2lzdGVyVHJhbnNpdGlvbiggdHJhbnNpdGlvbiApO1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRyYW5zaXRpb24uc3RhcnQoKTtcblx0XHRcdFx0fSwgdHJ1ZSApO1xuXHRcdFx0XHR0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdvcHRpb24nICkge1xuXHRcdFx0XHRwcm9jZXNzT3B0aW9uKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMubm9kZS5hdXRvZm9jdXMgKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZS4gU29tZSBicm93c2VycyAoKmNvdWdoKiBGaXJlZml4ICpjb3VnaCopIGhhdmUgYSBwcm9ibGVtXG5cdFx0XHRcdC8vIHdpdGggZHluYW1pY2FsbHktZ2VuZXJhdGVkIGVsZW1lbnRzIGhhdmluZyBhdXRvZm9jdXMsIGFuZCB0aGV5IHdvbid0XG5cdFx0XHRcdC8vIGFsbG93IHlvdSB0byBwcm9ncmFtbWF0aWNhbGx5IGZvY3VzIHRoZSBlbGVtZW50IHVudGlsIGl0J3MgaW4gdGhlIERPTVxuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5ub2RlLmZvY3VzKCk7XG5cdFx0XHRcdH0sIHRydWUgKTtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZUxpdmVRdWVyaWVzKCB0aGlzICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXROYW1lc3BhY2UoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgbmFtZXNwYWNlLCB4bWxucywgcGFyZW50O1xuXHRcdFx0Ly8gVXNlIHNwZWNpZmllZCBuYW1lc3BhY2UuLi5cblx0XHRcdGlmICggeG1sbnMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3htbG5zJyApICkge1xuXHRcdFx0XHRuYW1lc3BhY2UgPSB4bWxucztcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3N2ZycgKSB7XG5cdFx0XHRcdG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuc3ZnO1xuXHRcdFx0fSBlbHNlIGlmICggcGFyZW50ID0gZWxlbWVudC5wYXJlbnQgKSB7XG5cdFx0XHRcdC8vIC4uLm9yIEhUTUwsIGlmIHRoZSBwYXJlbnQgaXMgYSA8Zm9yZWlnbk9iamVjdD5cblx0XHRcdFx0aWYgKCBwYXJlbnQubmFtZSA9PT0gJ2ZvcmVpZ25PYmplY3QnICkge1xuXHRcdFx0XHRcdG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuaHRtbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuYW1lc3BhY2UgPSBwYXJlbnQubm9kZS5uYW1lc3BhY2VVUkk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5hbWVzcGFjZSA9IGVsZW1lbnQucm9vdC5lbC5uYW1lc3BhY2VVUkk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmFtZXNwYWNlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NPcHRpb24oIG9wdGlvbiApIHtcblx0XHRcdHZhciBvcHRpb25WYWx1ZSwgc2VsZWN0VmFsdWUsIGk7XG5cdFx0XHRpZiAoICFvcHRpb24uc2VsZWN0ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzZWxlY3RWYWx1ZSA9IG9wdGlvbi5zZWxlY3QuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoIHNlbGVjdFZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0Lm5vZGUubXVsdGlwbGUgJiYgaXNBcnJheSggc2VsZWN0VmFsdWUgKSApIHtcblx0XHRcdFx0aSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25WYWx1ZSA9PSBzZWxlY3RWYWx1ZVsgaSBdICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uLm5vZGUuc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb24ubm9kZS5zZWxlY3RlZCA9IG9wdGlvblZhbHVlID09IHNlbGVjdFZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZUxpdmVRdWVyaWVzKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGluc3RhbmNlLCBsaXZlUXVlcmllcywgaSwgc2VsZWN0b3IsIHF1ZXJ5O1xuXHRcdFx0Ly8gRG9lcyB0aGlzIG5lZWQgdG8gYmUgYWRkZWQgdG8gYW55IGxpdmUgcXVlcmllcz9cblx0XHRcdGluc3RhbmNlID0gZWxlbWVudC5yb290O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRsaXZlUXVlcmllcyA9IGluc3RhbmNlLl9saXZlUXVlcmllcztcblx0XHRcdFx0aSA9IGxpdmVRdWVyaWVzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBsaXZlUXVlcmllc1sgaSBdO1xuXHRcdFx0XHRcdHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbICdfJyArIHNlbGVjdG9yIF07XG5cdFx0XHRcdFx0aWYgKCBxdWVyeS5fdGVzdCggZWxlbWVudCApICkge1xuXHRcdFx0XHRcdFx0Ly8ga2VlcCByZWdpc3RlciBvZiBhcHBsaWNhYmxlIHNlbGVjdG9ycywgZm9yIHdoZW4gd2UgdGVhcmRvd25cblx0XHRcdFx0XHRcdCggZWxlbWVudC5saXZlUXVlcmllcyB8fCAoIGVsZW1lbnQubGl2ZVF1ZXJpZXMgPSBbXSApICkucHVzaCggcXVlcnkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUgKCBpbnN0YW5jZSA9IGluc3RhbmNlLl9wYXJlbnQgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBuYW1lc3BhY2VzLCBpc0FycmF5LCB3YXJuLCBjcmVhdGUsIGNyZWF0ZUVsZW1lbnQsIGRlZmluZVByb3BlcnR5LCBub29wLCBydW5sb29wLCBnZXRJbm5lckNvbnRleHQsIHJlbmRlciwgVHJhbnNpdGlvbiApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR0b1N0cmluZyA9IGZ1bmN0aW9uKCB2b2lkRWxlbWVudE5hbWVzLCBpc0FycmF5LCBlc2NhcGVIdG1sICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc3RyLCBlc2NhcGU7XG5cdFx0XHRzdHIgPSAnPCcgKyAoIHRoaXMudGVtcGxhdGUueSA/ICchRE9DVFlQRScgOiB0aGlzLnRlbXBsYXRlLmUgKTtcblx0XHRcdHN0ciArPSB0aGlzLmF0dHJpYnV0ZXMubWFwKCBzdHJpbmdpZnlBdHRyaWJ1dGUgKS5qb2luKCAnJyApICsgdGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMubWFwKCBzdHJpbmdpZnlBdHRyaWJ1dGUgKS5qb2luKCAnJyApO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdvcHRpb24nICYmIG9wdGlvbklzU2VsZWN0ZWQoIHRoaXMgKSApIHtcblx0XHRcdFx0c3RyICs9ICcgc2VsZWN0ZWQnO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gdHdvLXdheSByYWRpbyBuYW1lIGJpbmRpbmdzXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ2lucHV0JyAmJiBpbnB1dElzQ2hlY2tlZFJhZGlvKCB0aGlzICkgKSB7XG5cdFx0XHRcdHN0ciArPSAnIGNoZWNrZWQnO1xuXHRcdFx0fVxuXHRcdFx0c3RyICs9ICc+Jztcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHRleHRhcmVhXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ3RleHRhcmVhJyAmJiB0aGlzLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHN0ciArPSBlc2NhcGVIdG1sKCB0aGlzLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLmdldEF0dHJpYnV0ZSggJ2NvbnRlbnRlZGl0YWJsZScgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRzdHIgKz0gdGhpcy5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0ZXNjYXBlID0gdGhpcy5uYW1lICE9PSAnc2NyaXB0JyAmJiB0aGlzLm5hbWUgIT09ICdzdHlsZSc7XG5cdFx0XHRcdHN0ciArPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCBlc2NhcGUgKTtcblx0XHRcdH1cblx0XHRcdC8vIGFkZCBhIGNsb3NpbmcgdGFnIGlmIHRoaXMgaXNuJ3QgYSB2b2lkIGVsZW1lbnRcblx0XHRcdGlmICggIXZvaWRFbGVtZW50TmFtZXMudGVzdCggdGhpcy50ZW1wbGF0ZS5lICkgKSB7XG5cdFx0XHRcdHN0ciArPSAnPC8nICsgdGhpcy50ZW1wbGF0ZS5lICsgJz4nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gb3B0aW9uSXNTZWxlY3RlZCggZWxlbWVudCApIHtcblx0XHRcdHZhciBvcHRpb25WYWx1ZSwgc2VsZWN0VmFsdWUsIGk7XG5cdFx0XHRvcHRpb25WYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoIG9wdGlvblZhbHVlID09PSB1bmRlZmluZWQgfHwgIWVsZW1lbnQuc2VsZWN0ICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRzZWxlY3RWYWx1ZSA9IGVsZW1lbnQuc2VsZWN0LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0aWYgKCBzZWxlY3RWYWx1ZSA9PSBvcHRpb25WYWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW1lbnQuc2VsZWN0LmdldEF0dHJpYnV0ZSggJ211bHRpcGxlJyApICYmIGlzQXJyYXkoIHNlbGVjdFZhbHVlICkgKSB7XG5cdFx0XHRcdGkgPSBzZWxlY3RWYWx1ZS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggc2VsZWN0VmFsdWVbIGkgXSA9PSBvcHRpb25WYWx1ZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlucHV0SXNDaGVja2VkUmFkaW8oIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgYXR0cmlidXRlcywgdHlwZUF0dHJpYnV0ZSwgdmFsdWVBdHRyaWJ1dGUsIG5hbWVBdHRyaWJ1dGU7XG5cdFx0XHRhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzO1xuXHRcdFx0dHlwZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMudHlwZTtcblx0XHRcdHZhbHVlQXR0cmlidXRlID0gYXR0cmlidXRlcy52YWx1ZTtcblx0XHRcdG5hbWVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLm5hbWU7XG5cdFx0XHRpZiAoICF0eXBlQXR0cmlidXRlIHx8IHR5cGVBdHRyaWJ1dGUudmFsdWUgIT09ICdyYWRpbycgfHwgIXZhbHVlQXR0cmlidXRlIHx8ICFuYW1lQXR0cmlidXRlLmludGVycG9sYXRvciApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZUF0dHJpYnV0ZS52YWx1ZSA9PT0gbmFtZUF0dHJpYnV0ZS5pbnRlcnBvbGF0b3IudmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN0cmluZ2lmeUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXHRcdFx0dmFyIHN0ciA9IGF0dHJpYnV0ZS50b1N0cmluZygpO1xuXHRcdFx0cmV0dXJuIHN0ciA/ICcgJyArIHN0ciA6ICcnO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHZvaWRFbGVtZW50TmFtZXMsIGlzQXJyYXksIGVzY2FwZUh0bWwgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc3BlY2lhbC9vcHRpb24vdW5iaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfc3BlY2lhbF9vcHRpb25fdW5iaW5kID0gZnVuY3Rpb24oIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB1bmJpbmRPcHRpb24oIG9wdGlvbiApIHtcblx0XHRcdGlmICggb3B0aW9uLnNlbGVjdCApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCBvcHRpb24uc2VsZWN0Lm9wdGlvbnMsIG9wdGlvbiApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHJlbW92ZUZyb21BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvdW5iaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkdW5iaW5kID0gZnVuY3Rpb24oIHVuYmluZE9wdGlvbiApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIEVsZW1lbnQkdW5iaW5kKCkge1xuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmJpbmRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuYmluZGluZy51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5ldmVudEhhbmRsZXJzICkge1xuXHRcdFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8b3B0aW9uPlxuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdvcHRpb24nICkge1xuXHRcdFx0XHR1bmJpbmRPcHRpb24oIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLmZvckVhY2goIHVuYmluZCApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bmJpbmQoIHggKSB7XG5cdFx0XHR4LnVuYmluZCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9zcGVjaWFsX29wdGlvbl91bmJpbmQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkdW5yZW5kZXIgPSBmdW5jdGlvbiggcnVubG9vcCwgVHJhbnNpdGlvbiApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIEVsZW1lbnQkdW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHR2YXIgYmluZGluZywgYmluZGluZ3M7XG5cdFx0XHRpZiAoIHRoaXMudHJhbnNpdGlvbiApIHtcblx0XHRcdFx0dGhpcy50cmFuc2l0aW9uLmNvbXBsZXRlKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBEZXRhY2ggYXMgc29vbiBhcyB3ZSBjYW5cblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnb3B0aW9uJyApIHtcblx0XHRcdFx0Ly8gPG9wdGlvbj4gZWxlbWVudHMgZGV0YWNoIGltbWVkaWF0ZWx5LCBzbyB0aGF0XG5cdFx0XHRcdC8vIHRoZWlyIHBhcmVudCA8c2VsZWN0PiBlbGVtZW50IHN5bmNzIGNvcnJlY3RseSwgYW5kXG5cdFx0XHRcdC8vIHNpbmNlIG9wdGlvbiBlbGVtZW50cyBjYW4ndCBoYXZlIHRyYW5zaXRpb25zIGFueXdheVxuXHRcdFx0XHR0aGlzLmRldGFjaCgpO1xuXHRcdFx0fSBlbHNlIGlmICggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0cnVubG9vcC5kZXRhY2hXaGVuUmVhZHkoIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdC8vIENoaWxkcmVuIGZpcnN0LiB0aGF0IHdheSwgYW55IHRyYW5zaXRpb25zIG9uIGNoaWxkIGVsZW1lbnRzIHdpbGwgYmVcblx0XHRcdC8vIGhhbmRsZWQgYnkgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbk1hbmFnZXJcblx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciggZmFsc2UgKTtcblx0XHRcdH1cblx0XHRcdGlmICggYmluZGluZyA9IHRoaXMuYmluZGluZyApIHtcblx0XHRcdFx0dGhpcy5iaW5kaW5nLnVucmVuZGVyKCk7XG5cdFx0XHRcdHRoaXMubm9kZS5fcmFjdGl2ZS5iaW5kaW5nID0gbnVsbDtcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBiaW5kaW5nLmtleXBhdGggXTtcblx0XHRcdFx0YmluZGluZ3Muc3BsaWNlKCBiaW5kaW5ncy5pbmRleE9mKCBiaW5kaW5nICksIDEgKTtcblx0XHRcdH1cblx0XHRcdC8vIFJlbW92ZSBldmVudCBoYW5kbGVyc1xuXHRcdFx0aWYgKCB0aGlzLmV2ZW50SGFuZGxlcnMgKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKCBmdW5jdGlvbiggaCApIHtcblx0XHRcdFx0XHRyZXR1cm4gaC51bnJlbmRlcigpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZGVjb3JhdG9yICkge1xuXHRcdFx0XHR0aGlzLmRlY29yYXRvci50ZWFyZG93bigpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdHJpZ2dlciBvdXRybyB0cmFuc2l0aW9uIGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKCB0aGlzLnJvb3QudHJhbnNpdGlvbnNFbmFibGVkICYmIHRoaXMub3V0cm8gKSB7XG5cdFx0XHRcdHZhciB0cmFuc2l0aW9uID0gbmV3IFRyYW5zaXRpb24oIHRoaXMsIHRoaXMub3V0cm8sIGZhbHNlICk7XG5cdFx0XHRcdHJ1bmxvb3AucmVnaXN0ZXJUcmFuc2l0aW9uKCB0cmFuc2l0aW9uICk7XG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJhbnNpdGlvbi5zdGFydCgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBSZW1vdmUgdGhpcyBub2RlIGZyb20gYW55IGxpdmUgcXVlcmllc1xuXHRcdFx0aWYgKCB0aGlzLmxpdmVRdWVyaWVzICkge1xuXHRcdFx0XHRyZW1vdmVGcm9tTGl2ZVF1ZXJpZXMoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlRnJvbUxpdmVRdWVyaWVzKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIHF1ZXJ5LCBzZWxlY3RvciwgaTtcblx0XHRcdGkgPSBlbGVtZW50LmxpdmVRdWVyaWVzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRxdWVyeSA9IGVsZW1lbnQubGl2ZVF1ZXJpZXNbIGkgXTtcblx0XHRcdFx0c2VsZWN0b3IgPSBxdWVyeS5zZWxlY3Rvcjtcblx0XHRcdFx0cXVlcnkuX3JlbW92ZSggZWxlbWVudC5ub2RlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggcnVubG9vcCwgVHJhbnNpdGlvbiApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9fRWxlbWVudC5qcyAqL1xuXHR2YXIgRWxlbWVudCA9IGZ1bmN0aW9uKCBidWJibGUsIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmluZEFsbENvbXBvbmVudHMsIGZpbmRDb21wb25lbnQsIGZpbmROZXh0Tm9kZSwgZmlyc3ROb2RlLCBnZXRBdHRyaWJ1dGUsIGluaXQsIHJlYmluZCwgcmVuZGVyLCB0b1N0cmluZywgdW5iaW5kLCB1bnJlbmRlciApIHtcblxuXHRcdHZhciBFbGVtZW50ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLmluaXQoIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdEVsZW1lbnQucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBidWJibGUsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRnZXRBdHRyaWJ1dGU6IGdldEF0dHJpYnV0ZSxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXJcblx0XHR9O1xuXHRcdHJldHVybiBFbGVtZW50O1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkYnViYmxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZGV0YWNoLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRBbGwsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kQWxsQ29tcG9uZW50cywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRDb21wb25lbnQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kTmV4dE5vZGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaXJzdE5vZGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRnZXRBdHRyaWJ1dGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0LCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkcmViaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkdG9TdHJpbmcsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR1bmJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR1bnJlbmRlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvUGFydGlhbC9kZUluZGVudC5qcyAqL1xuXHR2YXIgZGVJbmRlbnQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgZW1wdHkgPSAvXlxccyokLyxcblx0XHRcdGxlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMqLztcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0XHR2YXIgbGluZXMsIGZpcnN0TGluZSwgbGFzdExpbmUsIG1pbkluZGVudDtcblx0XHRcdGxpbmVzID0gc3RyLnNwbGl0KCAnXFxuJyApO1xuXHRcdFx0Ly8gcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IGxpbmUsIGlmIHRoZXkgb25seSBjb250YWluIHdoaXRlc3BhY2Vcblx0XHRcdGZpcnN0TGluZSA9IGxpbmVzWyAwIF07XG5cdFx0XHRpZiAoIGZpcnN0TGluZSAhPT0gdW5kZWZpbmVkICYmIGVtcHR5LnRlc3QoIGZpcnN0TGluZSApICkge1xuXHRcdFx0XHRsaW5lcy5zaGlmdCgpO1xuXHRcdFx0fVxuXHRcdFx0bGFzdExpbmUgPSBsaW5lc1sgbGluZXMubGVuZ3RoIC0gMSBdO1xuXHRcdFx0aWYgKCBsYXN0TGluZSAhPT0gdW5kZWZpbmVkICYmIGVtcHR5LnRlc3QoIGxhc3RMaW5lICkgKSB7XG5cdFx0XHRcdGxpbmVzLnBvcCgpO1xuXHRcdFx0fVxuXHRcdFx0bWluSW5kZW50ID0gbGluZXMucmVkdWNlKCByZWR1Y2VyLCBudWxsICk7XG5cdFx0XHRpZiAoIG1pbkluZGVudCApIHtcblx0XHRcdFx0c3RyID0gbGluZXMubWFwKCBmdW5jdGlvbiggbGluZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbGluZS5yZXBsYWNlKCBtaW5JbmRlbnQsICcnICk7XG5cdFx0XHRcdH0gKS5qb2luKCAnXFxuJyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVkdWNlciggcHJldmlvdXMsIGxpbmUgKSB7XG5cdFx0XHR2YXIgbGluZUluZGVudCA9IGxlYWRpbmdXaGl0ZXNwYWNlLmV4ZWMoIGxpbmUgKVsgMCBdO1xuXHRcdFx0aWYgKCBwcmV2aW91cyA9PT0gbnVsbCB8fCBsaW5lSW5kZW50Lmxlbmd0aCA8IHByZXZpb3VzLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIGxpbmVJbmRlbnQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJldmlvdXM7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvUGFydGlhbC9nZXRQYXJ0aWFsVGVtcGxhdGUuanMgKi9cblx0dmFyIGdldFBhcnRpYWxUZW1wbGF0ZSA9IGZ1bmN0aW9uKCBsb2csIGNvbmZpZywgcGFyc2VyLCBkZUluZGVudCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIGdldFBhcnRpYWxUZW1wbGF0ZSggcmFjdGl2ZSwgbmFtZSApIHtcblx0XHRcdHZhciBwYXJ0aWFsO1xuXHRcdFx0Ly8gSWYgdGhlIHBhcnRpYWwgaW4gaW5zdGFuY2Ugb3IgdmlldyBoZWlyYXJjaHkgaW5zdGFuY2VzLCBncmVhdFxuXHRcdFx0aWYgKCBwYXJ0aWFsID0gZ2V0UGFydGlhbEZyb21SZWdpc3RyeSggcmFjdGl2ZSwgbmFtZSApICkge1xuXHRcdFx0XHRyZXR1cm4gcGFydGlhbDtcblx0XHRcdH1cblx0XHRcdC8vIERvZXMgaXQgZXhpc3Qgb24gdGhlIHBhZ2UgYXMgYSBzY3JpcHQgdGFnP1xuXHRcdFx0cGFydGlhbCA9IHBhcnNlci5mcm9tSWQoIG5hbWUsIHtcblx0XHRcdFx0bm9UaHJvdzogdHJ1ZVxuXHRcdFx0fSApO1xuXHRcdFx0aWYgKCBwYXJ0aWFsICkge1xuXHRcdFx0XHQvLyBpcyB0aGlzIG5lY2Vzc2FyeT9cblx0XHRcdFx0cGFydGlhbCA9IGRlSW5kZW50KCBwYXJ0aWFsICk7XG5cdFx0XHRcdC8vIHBhcnNlIGFuZCByZWdpc3RlciB0byB0aGlzIHJhY3RpdmUgaW5zdGFuY2Vcblx0XHRcdFx0dmFyIHBhcnNlZCA9IHBhcnNlci5wYXJzZSggcGFydGlhbCwgcGFyc2VyLmdldFBhcnNlT3B0aW9ucyggcmFjdGl2ZSApICk7XG5cdFx0XHRcdC8vIHJlZ2lzdGVyIChhbmQgcmV0dXJuIG1haW4gcGFydGlhbCBpZiB0aGVyZSBhcmUgb3RoZXJzIGluIHRoZSB0ZW1wbGF0ZSlcblx0XHRcdFx0cmV0dXJuIHJhY3RpdmUucGFydGlhbHNbIG5hbWUgXSA9IHBhcnNlZC50O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRQYXJ0aWFsRnJvbVJlZ2lzdHJ5KCByYWN0aXZlLCBuYW1lICkge1xuXHRcdFx0dmFyIHBhcnRpYWxzID0gY29uZmlnLnJlZ2lzdHJpZXMucGFydGlhbHM7XG5cdFx0XHQvLyBmaW5kIGZpcnN0IGluc3RhbmNlIGluIHRoZSByYWN0aXZlIG9yIHZpZXcgaGllcmFyY2h5IHRoYXQgaGFzIHRoaXMgcGFydGlhbFxuXHRcdFx0dmFyIGluc3RhbmNlID0gcGFydGlhbHMuZmluZEluc3RhbmNlKCByYWN0aXZlLCBuYW1lICk7XG5cdFx0XHRpZiAoICFpbnN0YW5jZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHBhcnRpYWwgPSBpbnN0YW5jZS5wYXJ0aWFsc1sgbmFtZSBdLFxuXHRcdFx0XHRmbjtcblx0XHRcdC8vIHBhcnRpYWwgaXMgYSBmdW5jdGlvbj9cblx0XHRcdGlmICggdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGZuID0gcGFydGlhbC5iaW5kKCBpbnN0YW5jZSApO1xuXHRcdFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UucGFydGlhbHMuaGFzT3duUHJvcGVydHkoIG5hbWUgKTtcblx0XHRcdFx0cGFydGlhbCA9IGZuKCBpbnN0YW5jZS5kYXRhLCBwYXJzZXIgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIXBhcnRpYWwgKSB7XG5cdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ25vUmVnaXN0cnlGdW5jdGlvblJldHVybicsXG5cdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0cmVnaXN0cnk6ICdwYXJ0aWFsJyxcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYWRkZWQgbWFudWFsbHkgdG8gdGhlIHJlZ2lzdHJ5LFxuXHRcdFx0Ly8gYnV0IGhhc24ndCBiZWVuIHBhcnNlZCwgcGFyc2UgaXQgbm93XG5cdFx0XHRpZiAoICFwYXJzZXIuaXNQYXJzZWQoIHBhcnRpYWwgKSApIHtcblx0XHRcdFx0Ly8gdXNlIHRoZSBwYXJzZU9wdGlvbnMgb2YgdGhlIHJhY3RpdmUgaW5zdGFuY2Ugb24gd2hpY2ggaXQgd2FzIGZvdW5kXG5cdFx0XHRcdHZhciBwYXJzZWQgPSBwYXJzZXIucGFyc2UoIHBhcnRpYWwsIHBhcnNlci5nZXRQYXJzZU9wdGlvbnMoIGluc3RhbmNlICkgKTtcblx0XHRcdFx0Ly8gUGFydGlhbHMgY2Fubm90IGNvbnRhaW4gbmVzdGVkIHBhcnRpYWxzIVxuXHRcdFx0XHQvLyBUT0RPIGFkZCBhIHRlc3QgZm9yIHRoaXNcblx0XHRcdFx0aWYgKCBwYXJzZWQucCApIHtcblx0XHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiAnbm9OZXN0ZWRQYXJ0aWFscycsXG5cdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdHJuYW1lOiBuYW1lXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIGZuLCB1c2UgaW5zdGFuY2UgdG8gc3RvcmUgcmVzdWx0LCBvdGhlcndpc2UgbmVlZHMgdG8gZ29cblx0XHRcdFx0Ly8gaW4gdGhlIGNvcnJlY3QgcG9pbnQgaW4gcHJvdG90eXBlIGNoYWluIG9uIGluc3RhbmNlIG9yIGNvbnN0cnVjdG9yXG5cdFx0XHRcdHZhciB0YXJnZXQgPSBmbiA/IGluc3RhbmNlIDogcGFydGlhbHMuZmluZE93bmVyKCBpbnN0YW5jZSwgbmFtZSApO1xuXHRcdFx0XHQvLyBtYXkgYmUgYSB0ZW1wbGF0ZSB3aXRoIHBhcnRpYWxzLCB3aGljaCBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgYW5kIG1haW4gdGVtcGxhdGUgZXh0cmFjdGVkXG5cdFx0XHRcdHRhcmdldC5wYXJ0aWFsc1sgbmFtZSBdID0gcGFydGlhbCA9IHBhcnNlZC50O1xuXHRcdFx0fVxuXHRcdFx0Ly8gc3RvcmUgZm9yIHJlc2V0XG5cdFx0XHRpZiAoIGZuICkge1xuXHRcdFx0XHRwYXJ0aWFsLl9mbiA9IGZuO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcnRpYWwudiA/IHBhcnRpYWwudCA6IHBhcnRpYWw7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggbG9nLCBjb25maWcsIHBhcnNlciwgZGVJbmRlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1BhcnRpYWwvYXBwbHlJbmRlbnQuanMgKi9cblx0dmFyIGFwcGx5SW5kZW50ID0gZnVuY3Rpb24oIHN0cmluZywgaW5kZW50ICkge1xuXHRcdHZhciBpbmRlbnRlZDtcblx0XHRpZiAoICFpbmRlbnQgKSB7XG5cdFx0XHRyZXR1cm4gc3RyaW5nO1xuXHRcdH1cblx0XHRpbmRlbnRlZCA9IHN0cmluZy5zcGxpdCggJ1xcbicgKS5tYXAoIGZ1bmN0aW9uKCBsaW5lLCBub3RGaXJzdExpbmUgKSB7XG5cdFx0XHRyZXR1cm4gbm90Rmlyc3RMaW5lID8gaW5kZW50ICsgbGluZSA6IGxpbmU7XG5cdFx0fSApLmpvaW4oICdcXG4nICk7XG5cdFx0cmV0dXJuIGluZGVudGVkO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvUGFydGlhbC9fUGFydGlhbC5qcyAqL1xuXHR2YXIgUGFydGlhbCA9IGZ1bmN0aW9uKCBsb2csIHR5cGVzLCBnZXRQYXJ0aWFsVGVtcGxhdGUsIGFwcGx5SW5kZW50LCBjaXJjdWxhciwgcnVubG9vcCwgTXVzdGFjaGUsIHJlYmluZCwgdW5iaW5kICkge1xuXG5cdFx0dmFyIFBhcnRpYWwsIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0UGFydGlhbCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZTtcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLnJvb3QgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuUEFSVElBTDtcblx0XHRcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHRcdFx0dGhpcy5uYW1lID0gb3B0aW9ucy50ZW1wbGF0ZS5yO1xuXHRcdFx0dGhpcy5mcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRUb1JlbmRlciA9IHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gbnVsbDtcblx0XHRcdE11c3RhY2hlLmluaXQoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHRcdC8vIElmIHRoaXMgZGlkbid0IHJlc29sdmUsIGl0IG1vc3QgbGlrZWx5IG1lYW5zIHdlIGhhdmUgYSBuYW1lZCBwYXJ0aWFsXG5cdFx0XHQvLyAoaS5lLiBge3s+Zm9vfX1gIG1lYW5zICd1c2UgdGhlIGZvbyBwYXJ0aWFsJywgbm90ICd1c2UgdGhlIHBhcnRpYWxcblx0XHRcdC8vIHdob3NlIG5hbWUgaXMgdGhlIHZhbHVlIG9mIGBmb29gJylcblx0XHRcdGlmICggIXRoaXMua2V5cGF0aCAmJiAoIHRlbXBsYXRlID0gZ2V0UGFydGlhbFRlbXBsYXRlKCB0aGlzLnJvb3QsIHRoaXMubmFtZSApICkgKSB7XG5cdFx0XHRcdHVuYmluZC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdC8vIHByZXZlbnQgYW55IGZ1cnRoZXIgY2hhbmdlc1xuXHRcdFx0XHR0aGlzLmlzTmFtZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnNldFRlbXBsYXRlKCB0ZW1wbGF0ZSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0UGFydGlhbC5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHRcdFx0fSxcblx0XHRcdGRldGFjaDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmRldGFjaCgpO1xuXHRcdFx0fSxcblx0XHRcdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kQWxsOiBmdW5jdGlvbiggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZ1bmN0aW9uKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdH0sXG5cdFx0XHRmaXJzdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maXJzdE5vZGUoKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kTmV4dE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHRyZWJpbmQuY2FsbCggdGhpcywgaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuXHRcdFx0fSxcblx0XHRcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgdGVtcGxhdGU7XG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA9PT0gdGhpcy52YWx1ZSApIHtcblx0XHRcdFx0XHQvLyBub3RoaW5nIGhhcyBjaGFuZ2VkLCBzbyBubyB3b3JrIHRvIGJlIGRvbmVcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGVtcGxhdGUgPSBnZXRQYXJ0aWFsVGVtcGxhdGUoIHRoaXMucm9vdCwgJycgKyB2YWx1ZSApO1xuXHRcdFx0XHQvLyB3ZSBtYXkgYmUgaGVyZSBpZiB3ZSBoYXZlIGEgcGFydGlhbCBsaWtlIGB7ez5mb299fWAgYW5kIGBmb29gIGlzIHRoZVxuXHRcdFx0XHQvLyBuYW1lIG9mIGJvdGggYSBkYXRhIHByb3BlcnR5ICh3aG9zZSB2YWx1ZSBJU04nVCB0aGUgbmFtZSBvZiBhIHBhcnRpYWwpXG5cdFx0XHRcdC8vIGFuZCBhIHBhcnRpYWwuIEluIHRob3NlIGNhc2VzLCB0aGlzIGJlY29tZXMgYSBuYW1lZCBwYXJ0aWFsXG5cdFx0XHRcdGlmICggIXRlbXBsYXRlICYmIHRoaXMubmFtZSAmJiAoIHRlbXBsYXRlID0gZ2V0UGFydGlhbFRlbXBsYXRlKCB0aGlzLnJvb3QsIHRoaXMubmFtZSApICkgKSB7XG5cdFx0XHRcdFx0dW5iaW5kLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0XHR0aGlzLmlzTmFtZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXRlbXBsYXRlICkge1xuXHRcdFx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRcdFx0ZGVidWc6IHRoaXMucm9vdC5kZWJ1Zyxcblx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdub1RlbXBsYXRlRm9yUGFydGlhbCcsXG5cdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHRoaXMubmFtZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnNldFRlbXBsYXRlKCB0ZW1wbGF0ZSB8fCBbXSApO1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuYnViYmxlKCk7XG5cdFx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXcoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNldFRlbXBsYXRlOiBmdW5jdGlvbiggdGVtcGxhdGUgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gdGhpcy5mcmFnbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuXHRcdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcblx0XHRcdFx0XHRvd25lcjogdGhpcyxcblx0XHRcdFx0XHRwRWxlbWVudDogdGhpcy5wYXJlbnRGcmFnbWVudC5wRWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnRUb1JlbmRlciA9IHRoaXMuZnJhZ21lbnQ7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCB0b1N0cmluZyApIHtcblx0XHRcdFx0dmFyIHN0cmluZywgcHJldmlvdXNJdGVtLCBsYXN0TGluZSwgbWF0Y2g7XG5cdFx0XHRcdHN0cmluZyA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIHRvU3RyaW5nICk7XG5cdFx0XHRcdHByZXZpb3VzSXRlbSA9IHRoaXMucGFyZW50RnJhZ21lbnQuaXRlbXNbIHRoaXMuaW5kZXggLSAxIF07XG5cdFx0XHRcdGlmICggIXByZXZpb3VzSXRlbSB8fCBwcmV2aW91c0l0ZW0udHlwZSAhPT0gdHlwZXMuVEVYVCApIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3RMaW5lID0gcHJldmlvdXNJdGVtLnRleHQuc3BsaXQoICdcXG4nICkucG9wKCk7XG5cdFx0XHRcdGlmICggbWF0Y2ggPSAvXlxccyskLy5leGVjKCBsYXN0TGluZSApICkge1xuXHRcdFx0XHRcdHJldHVybiBhcHBseUluZGVudCggc3RyaW5nLCBtYXRjaFsgMCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLmlzTmFtZWQgKSB7XG5cdFx0XHRcdFx0Ly8gZHluYW1pYyBwYXJ0aWFsIC0gbmVlZCB0byB1bmJpbmQgc2VsZlxuXHRcdFx0XHRcdHVuYmluZC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKCBzaG91bGREZXN0cm95ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQsIGFuY2hvcjtcblx0XHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50VG9VbnJlbmRlciApIHtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50VG9VbnJlbmRlci51bnJlbmRlciggdHJ1ZSApO1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnRUb1JlbmRlciApIHtcblx0XHRcdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQoIHRoaXMuZnJhZ21lbnRUb1JlbmRlci5yZW5kZXIoKSApO1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnRUb1JlbmRlciA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdHRhcmdldCA9IHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpO1xuXHRcdFx0XHRcdGFuY2hvciA9IHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdFx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggdGhpcy5kb2NGcmFnLCBhbmNob3IgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFBhcnRpYWw7XG5cdH0oIGxvZywgdHlwZXMsIGdldFBhcnRpYWxUZW1wbGF0ZSwgYXBwbHlJbmRlbnQsIGNpcmN1bGFyLCBydW5sb29wLCBNdXN0YWNoZSwgcmViaW5kLCB1bmJpbmQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9nZXRDb21wb25lbnQuanMgKi9cblx0dmFyIGdldENvbXBvbmVudCA9IGZ1bmN0aW9uKCBjb25maWcsIGxvZywgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgUmFjdGl2ZTtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFJhY3RpdmUgPSBjaXJjdWxhci5SYWN0aXZlO1xuXHRcdH0gKTtcblx0XHQvLyBmaW5kcyB0aGUgY29tcG9uZW50IGNvbnN0cnVjdG9yIGluIHRoZSByZWdpc3RyeSBvciB2aWV3IGhpZXJhcmNoeSByZWdpc3RyaWVzXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldENvbXBvbmVudCggcmFjdGl2ZSwgbmFtZSApIHtcblx0XHRcdHZhciBjb21wb25lbnQsIGluc3RhbmNlID0gY29uZmlnLnJlZ2lzdHJpZXMuY29tcG9uZW50cy5maW5kSW5zdGFuY2UoIHJhY3RpdmUsIG5hbWUgKTtcblx0XHRcdGlmICggaW5zdGFuY2UgKSB7XG5cdFx0XHRcdGNvbXBvbmVudCA9IGluc3RhbmNlLmNvbXBvbmVudHNbIG5hbWUgXTtcblx0XHRcdFx0Ly8gYmVzdCB0ZXN0IHdlIGhhdmUgZm9yIG5vdCBSYWN0aXZlLmV4dGVuZFxuXHRcdFx0XHRpZiAoICFjb21wb25lbnQuX3BhcmVudCApIHtcblx0XHRcdFx0XHQvLyBmdW5jdGlvbiBvcHRpb24sIGV4ZWN1dGUgYW5kIHN0b3JlIGZvciByZXNldFxuXHRcdFx0XHRcdHZhciBmbiA9IGNvbXBvbmVudC5iaW5kKCBpbnN0YW5jZSApO1xuXHRcdFx0XHRcdGZuLmlzT3duZXIgPSBpbnN0YW5jZS5jb21wb25lbnRzLmhhc093blByb3BlcnR5KCBuYW1lICk7XG5cdFx0XHRcdFx0Y29tcG9uZW50ID0gZm4oIGluc3RhbmNlLmRhdGEgKTtcblx0XHRcdFx0XHRpZiAoICFjb21wb25lbnQgKSB7XG5cdFx0XHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRcdFx0bWVzc2FnZTogJ25vUmVnaXN0cnlGdW5jdGlvblJldHVybicsXG5cdFx0XHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRyZWdpc3RyeTogJ2NvbXBvbmVudCcsXG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggdHlwZW9mIGNvbXBvbmVudCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHQvL2FsbG93IHN0cmluZyBsb29rdXBcblx0XHRcdFx0XHRcdGNvbXBvbmVudCA9IGdldENvbXBvbmVudCggcmFjdGl2ZSwgY29tcG9uZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbXBvbmVudC5fZm4gPSBmbjtcblx0XHRcdFx0XHRpbnN0YW5jZS5jb21wb25lbnRzWyBuYW1lIF0gPSBjb21wb25lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjb21wb25lbnQ7XG5cdFx0fTtcblx0fSggY29uZmlnLCBsb2csIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2RldGFjaC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZGV0YWNoID0gZnVuY3Rpb24oIEhvb2sgKSB7XG5cblx0XHR2YXIgZGV0YWNoSG9vayA9IG5ldyBIb29rKCAnZGV0YWNoJyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBDb21wb25lbnQkZGV0YWNoKCkge1xuXHRcdFx0dmFyIGRldGFjaGVkID0gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5kZXRhY2goKTtcblx0XHRcdGRldGFjaEhvb2suZmlyZSggdGhpcy5pbnN0YW5jZSApO1xuXHRcdFx0cmV0dXJuIGRldGFjaGVkO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2hvb2tzX0hvb2sgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZCA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kKCBzZWxlY3RvciApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQWxsID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmluZEFsbENvbXBvbmVudHMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0cXVlcnkuX3Rlc3QoIHRoaXMsIHRydWUgKTtcblx0XHRpZiAoIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiBDb21wb25lbnQkZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSB7XG5cdFx0aWYgKCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IHRoaXMubmFtZSApIHtcblx0XHRcdHJldHVybiB0aGlzLmluc3RhbmNlO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmluZE5leHROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kTmV4dE5vZGUgPSBmdW5jdGlvbiBDb21wb25lbnQkZmluZE5leHROb2RlKCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9maXJzdE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpcnN0Tm9kZSA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaXJzdE5vZGUoKSB7XG5cdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvY3JlYXRlTW9kZWwvQ29tcG9uZW50UGFyYW1ldGVyLmpzICovXG5cdHZhciBDb21wb25lbnRQYXJhbWV0ZXIgPSBmdW5jdGlvbiggcnVubG9vcCwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQsIENvbXBvbmVudFBhcmFtZXRlcjtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdENvbXBvbmVudFBhcmFtZXRlciA9IGZ1bmN0aW9uKCBjb21wb25lbnQsIGtleSwgdmFsdWUgKSB7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG5cdFx0XHR0aGlzLmtleSA9IGtleTtcblx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0dGVtcGxhdGU6IHZhbHVlLFxuXHRcdFx0XHRyb290OiBjb21wb25lbnQucm9vdCxcblx0XHRcdFx0b3duZXI6IHRoaXNcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cdFx0fTtcblx0XHRDb21wb25lbnRQYXJhbWV0ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5kaXJ0eSApIHtcblx0XHRcdFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXcoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcblx0XHRcdFx0dGhpcy5jb21wb25lbnQuaW5zdGFuY2Uudmlld21vZGVsLnNldCggdGhpcy5rZXksIHZhbHVlICk7XG5cdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCB0aGlzLmNvbXBvbmVudC5pbnN0YW5jZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLmRpcnR5ID0gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBDb21wb25lbnRQYXJhbWV0ZXI7XG5cdH0oIHJ1bmxvb3AsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS9jcmVhdGVNb2RlbC9SZWZlcmVuY2VFeHByZXNzaW9uUGFyYW1ldGVyLmpzICovXG5cdHZhciBSZWZlcmVuY2VFeHByZXNzaW9uUGFyYW1ldGVyID0gZnVuY3Rpb24oIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciwgY3JlYXRlQ29tcG9uZW50QmluZGluZyApIHtcblxuXHRcdHZhciBSZWZlcmVuY2VFeHByZXNzaW9uUGFyYW1ldGVyID0gZnVuY3Rpb24oIGNvbXBvbmVudCwgY2hpbGRLZXlwYXRoLCB0ZW1wbGF0ZSwgdG9CaW5kICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR0aGlzLnJvb3QgPSBjb21wb25lbnQucm9vdDtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLnJlYWR5ID0gZmFsc2U7XG5cdFx0XHR0aGlzLmhhc2ggPSBudWxsO1xuXHRcdFx0dGhpcy5yZXNvbHZlciA9IG5ldyBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIoIHRoaXMsIHRlbXBsYXRlLCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0Ly8gQXJlIHdlIHVwZGF0aW5nIGFuIGV4aXN0aW5nIGJpbmRpbmc/XG5cdFx0XHRcdGlmICggdGhpcyQwLmJpbmRpbmcgfHwgKCB0aGlzJDAuYmluZGluZyA9IGNvbXBvbmVudC5iaW5kaW5nc1sgdGhpcyQwLmhhc2ggXSApICkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5iaW5kaW5nc1sgdGhpcyQwLmhhc2ggXSA9IG51bGw7XG5cdFx0XHRcdFx0dGhpcyQwLmJpbmRpbmcucmViaW5kKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0dGhpcyQwLmhhc2ggPSBrZXlwYXRoICsgJz0nICsgY2hpbGRLZXlwYXRoO1xuXHRcdFx0XHRcdGNvbXBvbmVudC5iaW5kaW5nc1sgdGhpcyQwLmhhc2ggXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoICF0aGlzJDAucmVhZHkgKSB7XG5cdFx0XHRcdFx0XHQvLyBUaGUgY2hpbGQgaW5zdGFuY2UgaXNuJ3QgY3JlYXRlZCB5ZXQsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBiaW5kaW5nIGxhdGVyXG5cdFx0XHRcdFx0XHR0b0JpbmQucHVzaCgge1xuXHRcdFx0XHRcdFx0XHRjaGlsZEtleXBhdGg6IGNoaWxkS2V5cGF0aCxcblx0XHRcdFx0XHRcdFx0cGFyZW50S2V5cGF0aDoga2V5cGF0aFxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjcmVhdGVDb21wb25lbnRCaW5kaW5nKCBjb21wb25lbnQsIGNvbXBvbmVudC5yb290LCBrZXlwYXRoLCBjaGlsZEtleXBhdGggKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcyQwLnZhbHVlID0gY29tcG9uZW50LnJvb3Qudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0fSApO1xuXHRcdH07XG5cdFx0UmVmZXJlbmNlRXhwcmVzc2lvblBhcmFtZXRlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZXIucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnJlc29sdmVyLnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFJlZmVyZW5jZUV4cHJlc3Npb25QYXJhbWV0ZXI7XG5cdH0oIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciwgY3JlYXRlQ29tcG9uZW50QmluZGluZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvY3JlYXRlTW9kZWwvX2NyZWF0ZU1vZGVsLmpzICovXG5cdHZhciBjcmVhdGVNb2RlbCA9IGZ1bmN0aW9uKCB0eXBlcywgcGFyc2VKU09OLCByZXNvbHZlUmVmLCBDb21wb25lbnRQYXJhbWV0ZXIsIFJlZmVyZW5jZUV4cHJlc3Npb25QYXJhbWV0ZXIgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiggY29tcG9uZW50LCBkZWZhdWx0RGF0YSwgYXR0cmlidXRlcywgdG9CaW5kICkge1xuXHRcdFx0dmFyIGRhdGEgPSB7fSxcblx0XHRcdFx0a2V5LCB2YWx1ZTtcblx0XHRcdC8vIHNvbWUgcGFyYW1ldGVycywgZS5nLiBmb289XCJUaGUgdmFsdWUgaXMge3tiYXJ9fVwiLCBhcmUgJ2NvbXBsZXgnIC0gaW5cblx0XHRcdC8vIG90aGVyIHdvcmRzLCB3ZSBuZWVkIHRvIGNvbnN0cnVjdCBhIHN0cmluZyBmcmFnbWVudCB0byB3YXRjaFxuXHRcdFx0Ly8gd2hlbiB0aGV5IGNoYW5nZS4gV2Ugc3RvcmUgdGhlc2Ugc28gdGhleSBjYW4gYmUgdG9ybiBkb3duIGxhdGVyXG5cdFx0XHRjb21wb25lbnQuY29tcGxleFBhcmFtZXRlcnMgPSBbXTtcblx0XHRcdGZvciAoIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdHZhbHVlID0gZ2V0VmFsdWUoIGNvbXBvbmVudCwga2V5LCBhdHRyaWJ1dGVzWyBrZXkgXSwgdG9CaW5kICk7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGRlZmF1bHREYXRhWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0ZGF0YVsga2V5IF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZSggY29tcG9uZW50LCBrZXksIHRlbXBsYXRlLCB0b0JpbmQgKSB7XG5cdFx0XHR2YXIgcGFyYW1ldGVyLCBwYXJzZWQsIHBhcmVudEluc3RhbmNlLCBwYXJlbnRGcmFnbWVudCwga2V5cGF0aCwgaW5kZXhSZWY7XG5cdFx0XHRwYXJlbnRJbnN0YW5jZSA9IGNvbXBvbmVudC5yb290O1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgc3RhdGljIHZhbHVlLCBncmVhdFxuXHRcdFx0aWYgKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oIHRlbXBsYXRlICk7XG5cdFx0XHRcdGlmICggIXBhcnNlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGVtcGxhdGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHBhcnNlZC52YWx1ZTtcblx0XHRcdH1cblx0XHRcdC8vIElmIG51bGwsIHdlIHRyZWF0IGl0IGFzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgKGkuZS4gdHJ1ZSlcblx0XHRcdGlmICggdGVtcGxhdGUgPT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU2luZ2xlIGludGVycG9sYXRvcj9cblx0XHRcdGlmICggdGVtcGxhdGUubGVuZ3RoID09PSAxICYmIHRlbXBsYXRlWyAwIF0udCA9PT0gdHlwZXMuSU5URVJQT0xBVE9SICkge1xuXHRcdFx0XHQvLyBJZiBpdCdzIGEgcmVndWxhciBpbnRlcnBvbGF0b3IsIHdlIGJpbmQgdG8gaXRcblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZVsgMCBdLnIgKSB7XG5cdFx0XHRcdFx0Ly8gSXMgaXQgYW4gaW5kZXggcmVmZXJlbmNlP1xuXHRcdFx0XHRcdGlmICggcGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzICYmIHBhcmVudEZyYWdtZW50LmluZGV4UmVmc1sgaW5kZXhSZWYgPSB0ZW1wbGF0ZVsgMCBdLnIgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50LmluZGV4UmVmQmluZGluZ3NbIGluZGV4UmVmIF0gPSBrZXk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzWyBpbmRleFJlZiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBUT0RPIHdoYXQgYWJvdXQgcmVmZXJlbmNlcyB0aGF0IHJlc29sdmUgbGF0ZT8gU2hvdWxkIHRoZXNlIGJlIGNvbnNpZGVyZWQ/XG5cdFx0XHRcdFx0a2V5cGF0aCA9IHJlc29sdmVSZWYoIHBhcmVudEluc3RhbmNlLCB0ZW1wbGF0ZVsgMCBdLnIsIHBhcmVudEZyYWdtZW50ICkgfHwgdGVtcGxhdGVbIDAgXS5yO1xuXHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gc2V0IHVwIGJpbmRpbmdzIGJldHdlZW4gcGFyZW50IGFuZCBjaGlsZCwgYnV0XG5cdFx0XHRcdFx0Ly8gd2UgY2FuJ3QgZG8gaXQgeWV0IGJlY2F1c2UgdGhlIGNoaWxkIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3Rcblx0XHRcdFx0XHQvLyB5ZXQgLSBzbyB3ZSBtYWtlIGEgbm90ZSBpbnN0ZWFkXG5cdFx0XHRcdFx0dG9CaW5kLnB1c2goIHtcblx0XHRcdFx0XHRcdGNoaWxkS2V5cGF0aDoga2V5LFxuXHRcdFx0XHRcdFx0cGFyZW50S2V5cGF0aDoga2V5cGF0aFxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRyZXR1cm4gcGFyZW50SW5zdGFuY2Uudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIGl0J3MgYSByZWZlcmVuY2UgZXhwcmVzc2lvbiAoZS5nLiBge3tmb29bYmFyXX19YCksIHdlIG5lZWRcblx0XHRcdFx0Ly8gdG8gd2F0Y2ggdGhlIGtleXBhdGggYW5kIGNyZWF0ZS9kZXN0cm95IGJpbmRpbmdzXG5cdFx0XHRcdGlmICggdGVtcGxhdGVbIDAgXS5yeCApIHtcblx0XHRcdFx0XHRwYXJhbWV0ZXIgPSBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblBhcmFtZXRlciggY29tcG9uZW50LCBrZXksIHRlbXBsYXRlWyAwIF0ucngsIHRvQmluZCApO1xuXHRcdFx0XHRcdGNvbXBvbmVudC5jb21wbGV4UGFyYW1ldGVycy5wdXNoKCBwYXJhbWV0ZXIgKTtcblx0XHRcdFx0XHRwYXJhbWV0ZXIucmVhZHkgPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybiBwYXJhbWV0ZXIudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFdlIGhhdmUgYSAnY29tcGxleCBwYXJhbWV0ZXInIC0gd2UgbmVlZCB0byBjcmVhdGUgYSBmdWxsLWJsb3duIHN0cmluZ1xuXHRcdFx0Ly8gZnJhZ21lbnQgaW4gb3JkZXIgdG8gZXZhbHVhdGUgYW5kIG9ic2VydmUgaXRzIHZhbHVlXG5cdFx0XHRwYXJhbWV0ZXIgPSBuZXcgQ29tcG9uZW50UGFyYW1ldGVyKCBjb21wb25lbnQsIGtleSwgdGVtcGxhdGUgKTtcblx0XHRcdGNvbXBvbmVudC5jb21wbGV4UGFyYW1ldGVycy5wdXNoKCBwYXJhbWV0ZXIgKTtcblx0XHRcdHJldHVybiBwYXJhbWV0ZXIudmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggdHlwZXMsIHBhcnNlSlNPTiwgcmVzb2x2ZVJlZiwgQ29tcG9uZW50UGFyYW1ldGVyLCBSZWZlcmVuY2VFeHByZXNzaW9uUGFyYW1ldGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS9jcmVhdGVJbnN0YW5jZS5qcyAqL1xuXHR2YXIgY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiggbG9nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBjb21wb25lbnQsIENvbXBvbmVudCwgZGF0YSwgY29udGVudERlc2NyaXB0b3IgKSB7XG5cdFx0XHR2YXIgaW5zdGFuY2UsIHBhcmVudEZyYWdtZW50LCBwYXJ0aWFscywgcmFjdGl2ZTtcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0cmFjdGl2ZSA9IGNvbXBvbmVudC5yb290O1xuXHRcdFx0Ly8gTWFrZSBjb250ZW50cyBhdmFpbGFibGUgYXMgYSB7ez5jb250ZW50fX0gcGFydGlhbFxuXHRcdFx0cGFydGlhbHMgPSB7XG5cdFx0XHRcdGNvbnRlbnQ6IGNvbnRlbnREZXNjcmlwdG9yIHx8IFtdXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCBDb21wb25lbnQuZGVmYXVsdHMuZWwgKSB7XG5cdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ2RlZmF1bHRFbFNwZWNpZmllZCcsXG5cdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0bmFtZTogY29tcG9uZW50Lm5hbWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGluc3RhbmNlID0gbmV3IENvbXBvbmVudCgge1xuXHRcdFx0XHRlbDogbnVsbCxcblx0XHRcdFx0YXBwZW5kOiB0cnVlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRwYXJ0aWFsczogcGFydGlhbHMsXG5cdFx0XHRcdG1hZ2ljOiByYWN0aXZlLm1hZ2ljIHx8IENvbXBvbmVudC5kZWZhdWx0cy5tYWdpYyxcblx0XHRcdFx0bW9kaWZ5QXJyYXlzOiByYWN0aXZlLm1vZGlmeUFycmF5cyxcblx0XHRcdFx0X3BhcmVudDogcmFjdGl2ZSxcblx0XHRcdFx0X2NvbXBvbmVudDogY29tcG9uZW50LFxuXHRcdFx0XHQvLyBuZWVkIHRvIGluaGVyaXQgcnVudGltZSBwYXJlbnQgYWRhcHRvcnNcblx0XHRcdFx0YWRhcHQ6IHJhY3RpdmUuYWRhcHQsXG5cdFx0XHRcdHlpZWxkOiB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IGNvbnRlbnREZXNjcmlwdG9yLFxuXHRcdFx0XHRcdGluc3RhbmNlOiByYWN0aXZlXG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBpbnN0YW5jZTtcblx0XHR9O1xuXHR9KCBsb2cgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL2NyZWF0ZUJpbmRpbmdzLmpzICovXG5cdHZhciBjcmVhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uKCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxDb21wb25lbnRCaW5kaW5ncyggY29tcG9uZW50LCB0b0JpbmQgKSB7XG5cdFx0XHR0b0JpbmQuZm9yRWFjaCggZnVuY3Rpb24gY3JlYXRlSW5pdGlhbENvbXBvbmVudEJpbmRpbmcoIHBhaXIgKSB7XG5cdFx0XHRcdHZhciBjaGlsZFZhbHVlLCBwYXJlbnRWYWx1ZTtcblx0XHRcdFx0Y3JlYXRlQ29tcG9uZW50QmluZGluZyggY29tcG9uZW50LCBjb21wb25lbnQucm9vdCwgcGFpci5wYXJlbnRLZXlwYXRoLCBwYWlyLmNoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHRjaGlsZFZhbHVlID0gY29tcG9uZW50Lmluc3RhbmNlLnZpZXdtb2RlbC5nZXQoIHBhaXIuY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdHBhcmVudFZhbHVlID0gY29tcG9uZW50LnJvb3Qudmlld21vZGVsLmdldCggcGFpci5wYXJlbnRLZXlwYXRoICk7XG5cdFx0XHRcdGlmICggY2hpbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHBhcmVudFZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LnJvb3Qudmlld21vZGVsLnNldCggcGFpci5wYXJlbnRLZXlwYXRoLCBjaGlsZFZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9O1xuXHR9KCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS9wcm9wYWdhdGVFdmVudHMuanMgKi9cblx0dmFyIHByb3BhZ2F0ZUV2ZW50cyA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgZmlyZUV2ZW50LCBsb2cgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBwcm9wYWdhdGVFdmVudHMoIGNvbXBvbmVudCwgZXZlbnRzRGVzY3JpcHRvciApIHtcblx0XHRcdHZhciBldmVudE5hbWU7XG5cdFx0XHRmb3IgKCBldmVudE5hbWUgaW4gZXZlbnRzRGVzY3JpcHRvciApIHtcblx0XHRcdFx0aWYgKCBldmVudHNEZXNjcmlwdG9yLmhhc093blByb3BlcnR5KCBldmVudE5hbWUgKSApIHtcblx0XHRcdFx0XHRwcm9wYWdhdGVFdmVudCggY29tcG9uZW50Lmluc3RhbmNlLCBjb21wb25lbnQucm9vdCwgZXZlbnROYW1lLCBldmVudHNEZXNjcmlwdG9yWyBldmVudE5hbWUgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHByb3BhZ2F0ZUV2ZW50KCBjaGlsZEluc3RhbmNlLCBwYXJlbnRJbnN0YW5jZSwgZXZlbnROYW1lLCBwcm94eUV2ZW50TmFtZSApIHtcblx0XHRcdGlmICggdHlwZW9mIHByb3h5RXZlbnROYW1lICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHBhcmVudEluc3RhbmNlLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdub0NvbXBvbmVudEV2ZW50QXJndW1lbnRzJ1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRjaGlsZEluc3RhbmNlLm9uKCBldmVudE5hbWUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZXZlbnQsIGFyZ3M7XG5cdFx0XHRcdC8vIHNlbWktd2VhayB0ZXN0LCBidXQgd2hhdCBlbHNlPyB0YWcgdGhlIGV2ZW50IG9iaiAuX2lzRXZlbnQgP1xuXHRcdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWyAwIF0gJiYgYXJndW1lbnRzWyAwIF0ubm9kZSApIHtcblx0XHRcdFx0XHRldmVudCA9IEFycmF5LnByb3RvdHlwZS5zaGlmdC5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRmaXJlRXZlbnQoIHBhcmVudEluc3RhbmNlLCBwcm94eUV2ZW50TmFtZSwge1xuXHRcdFx0XHRcdGV2ZW50OiBldmVudCxcblx0XHRcdFx0XHRhcmdzOiBhcmdzXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0Ly8gY2FuY2VsIGJ1YmJsaW5nXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBjaXJjdWxhciwgUmFjdGl2ZSRzaGFyZWRfZmlyZUV2ZW50LCBsb2cgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL3VwZGF0ZUxpdmVRdWVyaWVzLmpzICovXG5cdHZhciB1cGRhdGVMaXZlUXVlcmllcyA9IGZ1bmN0aW9uKCBjb21wb25lbnQgKSB7XG5cdFx0dmFyIGFuY2VzdG9yLCBxdWVyeTtcblx0XHQvLyBJZiB0aGVyZSdzIGEgbGl2ZSBxdWVyeSBmb3IgdGhpcyBjb21wb25lbnQgdHlwZSwgYWRkIGl0XG5cdFx0YW5jZXN0b3IgPSBjb21wb25lbnQucm9vdDtcblx0XHR3aGlsZSAoIGFuY2VzdG9yICkge1xuXHRcdFx0aWYgKCBxdWVyeSA9IGFuY2VzdG9yLl9saXZlQ29tcG9uZW50UXVlcmllc1sgJ18nICsgY29tcG9uZW50Lm5hbWUgXSApIHtcblx0XHRcdFx0cXVlcnkucHVzaCggY29tcG9uZW50Lmluc3RhbmNlICk7XG5cdFx0XHR9XG5cdFx0XHRhbmNlc3RvciA9IGFuY2VzdG9yLl9wYXJlbnQ7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRpbml0ID0gZnVuY3Rpb24oIHR5cGVzLCB3YXJuLCBjcmVhdGVNb2RlbCwgY3JlYXRlSW5zdGFuY2UsIGNyZWF0ZUJpbmRpbmdzLCBwcm9wYWdhdGVFdmVudHMsIHVwZGF0ZUxpdmVRdWVyaWVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIENvbXBvbmVudCRpbml0KCBvcHRpb25zLCBDb21wb25lbnQgKSB7XG5cdFx0XHR2YXIgcGFyZW50RnJhZ21lbnQsIHJvb3QsIGRhdGEsIHRvQmluZDtcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRyb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdHRoaXMucm9vdCA9IHJvb3Q7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5DT01QT05FTlQ7XG5cdFx0XHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLmU7XG5cdFx0XHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcblx0XHRcdHRoaXMuaW5kZXhSZWZCaW5kaW5ncyA9IHt9O1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IFtdO1xuXHRcdFx0Ly8gZXZlbiB0aG91Z2ggb25seSBvbmUgeWllbGRlciBpcyBhbGxvd2VkLCB3ZSBuZWVkIHRvIGhhdmUgYW4gYXJyYXkgb2YgdGhlbVxuXHRcdFx0Ly8gYXMgaXQncyBwb3NzaWJsZSB0byBjYXVzZSBhIHlpZWxkZXIgdG8gYmUgY3JlYXRlZCBiZWZvcmUgdGhlIGxhc3Qgb25lXG5cdFx0XHQvLyB3YXMgZGVzdHJveWVkIGluIHRoZSBzYW1lIHR1cm4gb2YgdGhlIHJ1bmxvb3Bcblx0XHRcdHRoaXMueWllbGRlcnMgPSBbXTtcblx0XHRcdGlmICggIUNvbXBvbmVudCApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ29tcG9uZW50IFwiJyArIHRoaXMubmFtZSArICdcIiBub3QgZm91bmQnICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBGaXJzdCwgd2UgbmVlZCB0byBjcmVhdGUgYSBtb2RlbCBmb3IgdGhlIGNvbXBvbmVudCAtIGUuZy4gaWYgd2Vcblx0XHRcdC8vIGVuY291bnRlciA8d2lkZ2V0IGZvbz0nYmFyJy8+IHRoZW4gd2UgbmVlZCB0byBjcmVhdGUgYSB3aWRnZXRcblx0XHRcdC8vIHdpdGggYGRhdGE6IHsgZm9vOiAnYmFyJyB9YC5cblx0XHRcdC8vXG5cdFx0XHQvLyBUaGlzIG1heSBpbnZvbHZlIHNldHRpbmcgdXAgc29tZSBiaW5kaW5ncywgYnV0IHdlIGNhbid0IGRvIGl0XG5cdFx0XHQvLyB5ZXQgc28gd2UgdGFrZSBzb21lIG5vdGVzIGluc3RlYWRcblx0XHRcdHRvQmluZCA9IFtdO1xuXHRcdFx0ZGF0YSA9IGNyZWF0ZU1vZGVsKCB0aGlzLCBDb21wb25lbnQuZGVmYXVsdHMuZGF0YSB8fCB7fSwgb3B0aW9ucy50ZW1wbGF0ZS5hLCB0b0JpbmQgKTtcblx0XHRcdGNyZWF0ZUluc3RhbmNlKCB0aGlzLCBDb21wb25lbnQsIGRhdGEsIG9wdGlvbnMudGVtcGxhdGUuZiApO1xuXHRcdFx0Y3JlYXRlQmluZGluZ3MoIHRoaXMsIHRvQmluZCApO1xuXHRcdFx0cHJvcGFnYXRlRXZlbnRzKCB0aGlzLCBvcHRpb25zLnRlbXBsYXRlLnYgKTtcblx0XHRcdC8vIGludHJvLCBvdXRybyBhbmQgZGVjb3JhdG9yIGRpcmVjdGl2ZXMgaGF2ZSBubyBlZmZlY3Rcblx0XHRcdGlmICggb3B0aW9ucy50ZW1wbGF0ZS50MSB8fCBvcHRpb25zLnRlbXBsYXRlLnQyIHx8IG9wdGlvbnMudGVtcGxhdGUubyApIHtcblx0XHRcdFx0d2FybiggJ1RoZSBcImludHJvXCIsIFwib3V0cm9cIiBhbmQgXCJkZWNvcmF0b3JcIiBkaXJlY3RpdmVzIGhhdmUgbm8gZWZmZWN0IG9uIGNvbXBvbmVudHMnICk7XG5cdFx0XHR9XG5cdFx0XHR1cGRhdGVMaXZlUXVlcmllcyggdGhpcyApO1xuXHRcdH07XG5cdH0oIHR5cGVzLCB3YXJuLCBjcmVhdGVNb2RlbCwgY3JlYXRlSW5zdGFuY2UsIGNyZWF0ZUJpbmRpbmdzLCBwcm9wYWdhdGVFdmVudHMsIHVwZGF0ZUxpdmVRdWVyaWVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL3JlYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkcmViaW5kID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGdldE5ld0tleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQ29tcG9uZW50JHJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0dmFyIGNoaWxkSW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlLFxuXHRcdFx0XHRwYXJlbnRJbnN0YW5jZSA9IGNoaWxkSW5zdGFuY2UuX3BhcmVudCxcblx0XHRcdFx0aW5kZXhSZWZBbGlhcywgcXVlcnk7XG5cdFx0XHR0aGlzLmJpbmRpbmdzLmZvckVhY2goIGZ1bmN0aW9uKCBiaW5kaW5nICkge1xuXHRcdFx0XHR2YXIgdXBkYXRlZDtcblx0XHRcdFx0aWYgKCBiaW5kaW5nLnJvb3QgIT09IHBhcmVudEluc3RhbmNlICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHVwZGF0ZWQgPSBnZXROZXdLZXlwYXRoKCBiaW5kaW5nLmtleXBhdGgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSApIHtcblx0XHRcdFx0XHRiaW5kaW5nLnJlYmluZCggdXBkYXRlZCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLmNvbXBsZXhQYXJhbWV0ZXJzLmZvckVhY2goIHJlYmluZCApO1xuXHRcdFx0aWYgKCB0aGlzLnlpZWxkZXJzWyAwIF0gKSB7XG5cdFx0XHRcdHJlYmluZCggdGhpcy55aWVsZGVyc1sgMCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGluZGV4UmVmQWxpYXMgPSB0aGlzLmluZGV4UmVmQmluZGluZ3NbIGluZGV4UmVmIF0gKSB7XG5cdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCBjaGlsZEluc3RhbmNlLnZpZXdtb2RlbCApO1xuXHRcdFx0XHRjaGlsZEluc3RhbmNlLnZpZXdtb2RlbC5zZXQoIGluZGV4UmVmQWxpYXMsIG5ld0luZGV4ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHF1ZXJ5ID0gdGhpcy5yb290Ll9saXZlQ29tcG9uZW50UXVlcmllc1sgJ18nICsgdGhpcy5uYW1lIF0gKSB7XG5cdFx0XHRcdHF1ZXJ5Ll9tYWtlRGlydHkoKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcmViaW5kKCB4ICkge1xuXHRcdFx0XHR4LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCwgZ2V0TmV3S2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHJlbmRlciA9IGZ1bmN0aW9uIENvbXBvbmVudCRyZW5kZXIoKSB7XG5cdFx0dmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZTtcblx0XHRpbnN0YW5jZS5yZW5kZXIoIHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpICk7XG5cdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0cmV0dXJuIGluc3RhbmNlLmZyYWdtZW50LmRldGFjaCgpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkdG9TdHJpbmcgPSBmdW5jdGlvbiBDb21wb25lbnQkdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQudG9TdHJpbmcoKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvdW5iaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCR1bmJpbmQgPSBmdW5jdGlvbiggSG9vaywgcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciB0ZWFyZG93bkhvb2sgPSBuZXcgSG9vayggJ3RlYXJkb3duJyApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gQ29tcG9uZW50JHVuYmluZCgpIHtcblx0XHRcdHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2U7XG5cdFx0XHR0aGlzLmNvbXBsZXhQYXJhbWV0ZXJzLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncy5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdHJlbW92ZUZyb21MaXZlQ29tcG9uZW50UXVlcmllcyggdGhpcyApO1xuXHRcdFx0Ly8gdGVhcmRvd24gdGhlIGluc3RhbmNlXG5cdFx0XHRpbnN0YW5jZS5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdGluc3RhbmNlLnZpZXdtb2RlbC50ZWFyZG93bigpO1xuXHRcdFx0aWYgKCBpbnN0YW5jZS5mcmFnbWVudC5yZW5kZXJlZCAmJiBpbnN0YW5jZS5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggaW5zdGFuY2UuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCBpbnN0YW5jZSApO1xuXHRcdFx0fVxuXHRcdFx0dGVhcmRvd25Ib29rLmZpcmUoIGluc3RhbmNlICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVuYmluZCggdGhpbmcgKSB7XG5cdFx0XHR0aGluZy51bmJpbmQoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW1vdmVGcm9tTGl2ZUNvbXBvbmVudFF1ZXJpZXMoIGNvbXBvbmVudCApIHtcblx0XHRcdHZhciBpbnN0YW5jZSwgcXVlcnk7XG5cdFx0XHRpbnN0YW5jZSA9IGNvbXBvbmVudC5yb290O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRpZiAoIHF1ZXJ5ID0gaW5zdGFuY2UuX2xpdmVDb21wb25lbnRRdWVyaWVzWyAnXycgKyBjb21wb25lbnQubmFtZSBdICkge1xuXHRcdFx0XHRcdHF1ZXJ5Ll9yZW1vdmUoIGNvbXBvbmVudCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlICggaW5zdGFuY2UgPSBpbnN0YW5jZS5fcGFyZW50ICk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vaywgcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCR1bnJlbmRlciA9IGZ1bmN0aW9uIENvbXBvbmVudCR1bnJlbmRlciggc2hvdWxkRGVzdHJveSApIHtcblx0XHR0aGlzLnNob3VsZERlc3Ryb3kgPSBzaG91bGREZXN0cm95O1xuXHRcdHRoaXMuaW5zdGFuY2UudW5yZW5kZXIoKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9fQ29tcG9uZW50LmpzICovXG5cdHZhciBDb21wb25lbnQgPSBmdW5jdGlvbiggZGV0YWNoLCBmaW5kLCBmaW5kQWxsLCBmaW5kQWxsQ29tcG9uZW50cywgZmluZENvbXBvbmVudCwgZmluZE5leHROb2RlLCBmaXJzdE5vZGUsIGluaXQsIHJlYmluZCwgcmVuZGVyLCB0b1N0cmluZywgdW5iaW5kLCB1bnJlbmRlciApIHtcblxuXHRcdHZhciBDb21wb25lbnQgPSBmdW5jdGlvbiggb3B0aW9ucywgQ29uc3RydWN0b3IgKSB7XG5cdFx0XHR0aGlzLmluaXQoIG9wdGlvbnMsIENvbnN0cnVjdG9yICk7XG5cdFx0fTtcblx0XHRDb21wb25lbnQucHJvdG90eXBlID0ge1xuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaW5kOiBmaW5kLFxuXHRcdFx0ZmluZEFsbDogZmluZEFsbCxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmaW5kQWxsQ29tcG9uZW50cyxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZpbmRDb21wb25lbnQsXG5cdFx0XHRmaW5kTmV4dE5vZGU6IGZpbmROZXh0Tm9kZSxcblx0XHRcdGZpcnN0Tm9kZTogZmlyc3ROb2RlLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlYmluZDogcmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHR0b1N0cmluZzogdG9TdHJpbmcsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlclxuXHRcdH07XG5cdFx0cmV0dXJuIENvbXBvbmVudDtcblx0fSggdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZGV0YWNoLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQWxsLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cywgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZENvbXBvbmVudCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZE5leHROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaXJzdE5vZGUsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGluaXQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHJlYmluZCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCR0b1N0cmluZywgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkdW5iaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCR1bnJlbmRlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tbWVudC5qcyAqL1xuXHR2YXIgQ29tbWVudCA9IGZ1bmN0aW9uKCB0eXBlcywgZGV0YWNoICkge1xuXG5cdFx0dmFyIENvbW1lbnQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLkNPTU1FTlQ7XG5cdFx0XHR0aGlzLnZhbHVlID0gb3B0aW9ucy50ZW1wbGF0ZS5jO1xuXHRcdH07XG5cdFx0Q29tbWVudC5wcm90b3R5cGUgPSB7XG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpcnN0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoIHRoaXMudmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fSxcblx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICc8IS0tJyArIHRoaXMudmFsdWUgKyAnLS0+Jztcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdGlmICggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0XHR0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGhpcy5ub2RlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBDb21tZW50O1xuXHR9KCB0eXBlcywgZGV0YWNoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9ZaWVsZGVyLmpzICovXG5cdHZhciBZaWVsZGVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIHJlbW92ZUZyb21BcnJheSwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHR2YXIgWWllbGRlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGNvbXBvbmVudEluc3RhbmNlLCBjb21wb25lbnQ7XG5cdFx0XHRjb21wb25lbnRJbnN0YW5jZSA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50ID0gY29tcG9uZW50SW5zdGFuY2UuY29tcG9uZW50O1xuXHRcdFx0dGhpcy5zdXJyb2dhdGVQYXJlbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0b3duZXI6IHRoaXMsXG5cdFx0XHRcdHJvb3Q6IGNvbXBvbmVudEluc3RhbmNlLnlpZWxkLmluc3RhbmNlLFxuXHRcdFx0XHR0ZW1wbGF0ZTogY29tcG9uZW50SW5zdGFuY2UueWllbGQudGVtcGxhdGUsXG5cdFx0XHRcdHBFbGVtZW50OiB0aGlzLnN1cnJvZ2F0ZVBhcmVudC5wRWxlbWVudFxuXHRcdFx0fSApO1xuXHRcdFx0Y29tcG9uZW50LnlpZWxkZXJzLnB1c2goIHRoaXMgKTtcblx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjb21wb25lbnQueWllbGRlcnMubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdBIGNvbXBvbmVudCB0ZW1wbGF0ZSBjYW4gb25seSBoYXZlIG9uZSB7e3lpZWxkfX0gZGVjbGFyYXRpb24gYXQgYSB0aW1lJyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0XHRZaWVsZGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGRldGFjaDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmRldGFjaCgpO1xuXHRcdFx0fSxcblx0XHRcdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kQWxsOiBmdW5jdGlvbiggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZ1bmN0aW9uKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kTmV4dE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdXJyb2dhdGVQYXJlbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0Zmlyc3ROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSggb3B0aW9ucyApO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnJlbmRlcigpO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKCBzaG91bGREZXN0cm95ICk7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5jb21wb25lbnQueWllbGRlcnMsIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gWWllbGRlcjtcblx0fSggcnVubG9vcCwgcmVtb3ZlRnJvbUFycmF5LCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2luaXQvY3JlYXRlSXRlbS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRpbml0X2NyZWF0ZUl0ZW0gPSBmdW5jdGlvbiggdHlwZXMsIFRleHQsIEludGVycG9sYXRvciwgU2VjdGlvbiwgVHJpcGxlLCBFbGVtZW50LCBQYXJ0aWFsLCBnZXRDb21wb25lbnQsIENvbXBvbmVudCwgQ29tbWVudCwgWWllbGRlciApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVJdGVtKCBvcHRpb25zICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucy50ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgVGV4dCggb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0c3dpdGNoICggb3B0aW9ucy50ZW1wbGF0ZS50ICkge1xuXHRcdFx0XHRjYXNlIHR5cGVzLklOVEVSUE9MQVRPUjpcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMudGVtcGxhdGUuciA9PT0gJ3lpZWxkJyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgWWllbGRlciggb3B0aW9ucyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbmV3IEludGVycG9sYXRvciggb3B0aW9ucyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlNFQ1RJT046XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBTZWN0aW9uKCBvcHRpb25zICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuVFJJUExFOlxuXHRcdFx0XHRcdHJldHVybiBuZXcgVHJpcGxlKCBvcHRpb25zICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuRUxFTUVOVDpcblx0XHRcdFx0XHR2YXIgY29uc3RydWN0b3I7XG5cdFx0XHRcdFx0aWYgKCBjb25zdHJ1Y3RvciA9IGdldENvbXBvbmVudCggb3B0aW9ucy5wYXJlbnRGcmFnbWVudC5yb290LCBvcHRpb25zLnRlbXBsYXRlLmUgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgQ29tcG9uZW50KCBvcHRpb25zLCBjb25zdHJ1Y3RvciApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbmV3IEVsZW1lbnQoIG9wdGlvbnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5QQVJUSUFMOlxuXHRcdFx0XHRcdHJldHVybiBuZXcgUGFydGlhbCggb3B0aW9ucyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLkNPTU1FTlQ6XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBDb21tZW50KCBvcHRpb25zICk7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnU29tZXRoaW5nIHZlcnkgc3RyYW5nZSBoYXBwZW5lZC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy4gVGhhbmtzIScgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCB0eXBlcywgVGV4dCwgSW50ZXJwb2xhdG9yLCBTZWN0aW9uLCBUcmlwbGUsIEVsZW1lbnQsIFBhcnRpYWwsIGdldENvbXBvbmVudCwgQ29tcG9uZW50LCBDb21tZW50LCBZaWVsZGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRpbml0ID0gZnVuY3Rpb24oIHR5cGVzLCBjcmVhdGUsIGNyZWF0ZUl0ZW0gKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gRnJhZ21lbnQkaW5pdCggb3B0aW9ucyApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHBhcmVudEZyYWdtZW50LCBwYXJlbnRSZWZzLCByZWY7XG5cdFx0XHQvLyBUaGUgaXRlbSB0aGF0IG93bnMgdGhpcyBmcmFnbWVudCAtIGFuIGVsZW1lbnQsIHNlY3Rpb24sIHBhcnRpYWwsIG9yIGF0dHJpYnV0ZVxuXHRcdFx0dGhpcy5vd25lciA9IG9wdGlvbnMub3duZXI7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50ID0gdGhpcy5vd25lci5wYXJlbnRGcmFnbWVudDtcblx0XHRcdC8vIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG5cdFx0XHR0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3Q7XG5cdFx0XHR0aGlzLnBFbGVtZW50ID0gb3B0aW9ucy5wRWxlbWVudDtcblx0XHRcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcblx0XHRcdC8vIElmIHBhcmVudCBpdGVtIGlzIGEgc2VjdGlvbiwgdGhpcyBtYXkgbm90IGJlIHRoZSBvbmx5IGZyYWdtZW50XG5cdFx0XHQvLyB0aGF0IGJlbG9uZ3MgdG8gaXQgLSB3ZSBuZWVkIHRvIG1ha2UgYSBub3RlIG9mIHRoZSBpbmRleFxuXHRcdFx0aWYgKCB0aGlzLm93bmVyLnR5cGUgPT09IHR5cGVzLlNFQ1RJT04gKSB7XG5cdFx0XHRcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHRcdFx0fVxuXHRcdFx0Ly8gaW5kZXggcmVmZXJlbmNlcyAodGhlICdpJyBpbiB7eyNzZWN0aW9uOml9fS4uLnt7L3NlY3Rpb259fSkgbmVlZCB0byBjYXNjYWRlXG5cdFx0XHQvLyBkb3duIHRoZSB0cmVlXG5cdFx0XHRpZiAoIHBhcmVudEZyYWdtZW50ICkge1xuXHRcdFx0XHRwYXJlbnRSZWZzID0gcGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzO1xuXHRcdFx0XHRpZiAoIHBhcmVudFJlZnMgKSB7XG5cdFx0XHRcdFx0dGhpcy5pbmRleFJlZnMgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdFx0XHQvLyBhdm9pZHMgbmVlZCBmb3IgaGFzT3duUHJvcGVydHlcblx0XHRcdFx0XHRmb3IgKCByZWYgaW4gcGFyZW50UmVmcyApIHtcblx0XHRcdFx0XHRcdHRoaXMuaW5kZXhSZWZzWyByZWYgXSA9IHBhcmVudFJlZnNbIHJlZiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBvcHRpb25zLmluZGV4UmVmICkge1xuXHRcdFx0XHRpZiAoICF0aGlzLmluZGV4UmVmcyApIHtcblx0XHRcdFx0XHR0aGlzLmluZGV4UmVmcyA9IHt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuaW5kZXhSZWZzWyBvcHRpb25zLmluZGV4UmVmIF0gPSBvcHRpb25zLmluZGV4O1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGltZSB0byBjcmVhdGUgdGhpcyBmcmFnbWVudCdzIGNoaWxkIGl0ZW1zXG5cdFx0XHQvLyBURU1QIHNob3VsZCB0aGlzIGJlIGhhcHBlbmluZz9cblx0XHRcdGlmICggdHlwZW9mIG9wdGlvbnMudGVtcGxhdGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRvcHRpb25zLnRlbXBsYXRlID0gWyBvcHRpb25zLnRlbXBsYXRlIF07XG5cdFx0XHR9IGVsc2UgaWYgKCAhb3B0aW9ucy50ZW1wbGF0ZSApIHtcblx0XHRcdFx0b3B0aW9ucy50ZW1wbGF0ZSA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pdGVtcyA9IG9wdGlvbnMudGVtcGxhdGUubWFwKCBmdW5jdGlvbiggdGVtcGxhdGUsIGkgKSB7XG5cdFx0XHRcdHJldHVybiBjcmVhdGVJdGVtKCB7XG5cdFx0XHRcdFx0cGFyZW50RnJhZ21lbnQ6IHRoaXMkMCxcblx0XHRcdFx0XHRwRWxlbWVudDogb3B0aW9ucy5wRWxlbWVudCxcblx0XHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG5cdFx0XHRcdFx0aW5kZXg6IGlcblx0XHRcdFx0fSApO1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuYXJnc0xpc3QgPSBudWxsO1xuXHRcdFx0dGhpcy5kaXJ0eUFyZ3MgPSB0aGlzLmRpcnR5VmFsdWUgPSB0cnVlO1xuXHRcdFx0dGhpcy5ib3VuZCA9IHRydWU7XG5cdFx0fTtcblx0fSggdHlwZXMsIGNyZWF0ZSwgdmlydHVhbGRvbV9GcmFnbWVudCRpbml0X2NyZWF0ZUl0ZW0gKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9yZWJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkcmViaW5kID0gZnVuY3Rpb24oIGFzc2lnbk5ld0tleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gRnJhZ21lbnQkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHR0aGlzLmluZGV4ID0gbmV3SW5kZXg7XG5cdFx0XHQvLyBhc3NpZ24gbmV3IGNvbnRleHQga2V5cGF0aCBpZiBuZWVkZWRcblx0XHRcdGFzc2lnbk5ld0tleXBhdGgoIHRoaXMsICdjb250ZXh0Jywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0aWYgKCB0aGlzLmluZGV4UmVmcyAmJiB0aGlzLmluZGV4UmVmc1sgaW5kZXhSZWYgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLmluZGV4UmVmc1sgaW5kZXhSZWYgXSA9IG5ld0luZGV4O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0aWYgKCBpdGVtLnJlYmluZCApIHtcblx0XHRcdFx0XHRpdGVtLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9O1xuXHR9KCBhc3NpZ25OZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JHJlbmRlciA9IGZ1bmN0aW9uIEZyYWdtZW50JHJlbmRlcigpIHtcblx0XHR2YXIgcmVzdWx0O1xuXHRcdGlmICggdGhpcy5pdGVtcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRyZXN1bHQgPSB0aGlzLml0ZW1zWyAwIF0ucmVuZGVyKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRcdHJlc3VsdC5hcHBlbmRDaGlsZCggaXRlbS5yZW5kZXIoKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JHRvU3RyaW5nID0gZnVuY3Rpb24gRnJhZ21lbnQkdG9TdHJpbmcoIGVzY2FwZSApIHtcblx0XHRpZiAoICF0aGlzLml0ZW1zICkge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5pdGVtcy5tYXAoIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0cmV0dXJuIGl0ZW0udG9TdHJpbmcoIGVzY2FwZSApO1xuXHRcdH0gKS5qb2luKCAnJyApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCR1bmJpbmQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIEZyYWdtZW50JHVuYmluZCgpIHtcblx0XHRcdGlmICggIXRoaXMuYm91bmQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMuaXRlbXMuZm9yRWFjaCggdW5iaW5kSXRlbSApO1xuXHRcdFx0dGhpcy5ib3VuZCA9IGZhbHNlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bmJpbmRJdGVtKCBpdGVtICkge1xuXHRcdFx0aWYgKCBpdGVtLnVuYmluZCApIHtcblx0XHRcdFx0aXRlbS51bmJpbmQoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkdW5yZW5kZXIgPSBmdW5jdGlvbiBGcmFnbWVudCR1bnJlbmRlciggc2hvdWxkRGVzdHJveSApIHtcblx0XHRpZiAoICF0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQXR0ZW1wdGVkIHRvIHVucmVuZGVyIGEgZnJhZ21lbnQgdGhhdCB3YXMgbm90IHJlbmRlcmVkJyApO1xuXHRcdH1cblx0XHR0aGlzLml0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0cmV0dXJuIGkudW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKTtcblx0XHR9ICk7XG5cdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQuanMgKi9cblx0dmFyIEZyYWdtZW50ID0gZnVuY3Rpb24oIGJ1YmJsZSwgZGV0YWNoLCBmaW5kLCBmaW5kQWxsLCBmaW5kQWxsQ29tcG9uZW50cywgZmluZENvbXBvbmVudCwgZmluZE5leHROb2RlLCBmaXJzdE5vZGUsIGdldE5vZGUsIGdldFZhbHVlLCBpbml0LCByZWJpbmQsIHJlbmRlciwgdG9TdHJpbmcsIHVuYmluZCwgdW5yZW5kZXIsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLmluaXQoIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdEZyYWdtZW50LnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogYnViYmxlLFxuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaW5kOiBmaW5kLFxuXHRcdFx0ZmluZEFsbDogZmluZEFsbCxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmaW5kQWxsQ29tcG9uZW50cyxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZpbmRDb21wb25lbnQsXG5cdFx0XHRmaW5kTmV4dE5vZGU6IGZpbmROZXh0Tm9kZSxcblx0XHRcdGZpcnN0Tm9kZTogZmlyc3ROb2RlLFxuXHRcdFx0Z2V0Tm9kZTogZ2V0Tm9kZSxcblx0XHRcdGdldFZhbHVlOiBnZXRWYWx1ZSxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXJcblx0XHR9O1xuXHRcdGNpcmN1bGFyLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5cdFx0cmV0dXJuIEZyYWdtZW50O1xuXHR9KCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGJ1YmJsZSwgdmlydHVhbGRvbV9GcmFnbWVudCRkZXRhY2gsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZCwgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kQWxsLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmRBbGxDb21wb25lbnRzLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmRDb21wb25lbnQsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZE5leHROb2RlLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpcnN0Tm9kZSwgdmlydHVhbGRvbV9GcmFnbWVudCRnZXROb2RlLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGdldFZhbHVlLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGluaXQsIHZpcnR1YWxkb21fRnJhZ21lbnQkcmViaW5kLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHJlbmRlciwgdmlydHVhbGRvbV9GcmFnbWVudCR0b1N0cmluZywgdmlydHVhbGRvbV9GcmFnbWVudCR1bmJpbmQsIHZpcnR1YWxkb21fRnJhZ21lbnQkdW5yZW5kZXIsIGNpcmN1bGFyICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcmVzZXQuanMgKi9cblx0dmFyIFJhY3RpdmUkcmVzZXQgPSBmdW5jdGlvbiggSG9vaywgcnVubG9vcCwgRnJhZ21lbnQsIGNvbmZpZyApIHtcblxuXHRcdHZhciBzaG91bGRSZXJlbmRlciA9IFtcblx0XHRcdFx0J3RlbXBsYXRlJyxcblx0XHRcdFx0J3BhcnRpYWxzJyxcblx0XHRcdFx0J2NvbXBvbmVudHMnLFxuXHRcdFx0XHQnZGVjb3JhdG9ycycsXG5cdFx0XHRcdCdldmVudHMnXG5cdFx0XHRdLFxuXHRcdFx0cmVzZXRIb29rID0gbmV3IEhvb2soICdyZXNldCcgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRyZXNldCggZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgcHJvbWlzZSwgd3JhcHBlciwgY2hhbmdlcywgaSwgcmVyZW5kZXI7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjayApIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0ge307XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUaGUgcmVzZXQgbWV0aG9kIHRha2VzIGVpdGhlciBubyBhcmd1bWVudHMsIG9yIGFuIG9iamVjdCBjb250YWluaW5nIG5ldyBkYXRhJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgdGhlIHJvb3Qgb2JqZWN0IGlzIHdyYXBwZWQsIHRyeSBhbmQgdXNlIHRoZSB3cmFwcGVyJ3MgcmVzZXQgdmFsdWVcblx0XHRcdGlmICggKCB3cmFwcGVyID0gdGhpcy52aWV3bW9kZWwud3JhcHBlZFsgJycgXSApICYmIHdyYXBwZXIucmVzZXQgKSB7XG5cdFx0XHRcdGlmICggd3JhcHBlci5yZXNldCggZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHQvLyByZXNldCB3YXMgcmVqZWN0ZWQsIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgb2JqZWN0XG5cdFx0XHRcdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0XHRcdH1cblx0XHRcdC8vIHJlc2V0IGNvbmZpZyBpdGVtcyBhbmQgdHJhY2sgaWYgbmVlZCB0byByZXJlbmRlclxuXHRcdFx0Y2hhbmdlcyA9IGNvbmZpZy5yZXNldCggdGhpcyApO1xuXHRcdFx0aSA9IGNoYW5nZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2hvdWxkUmVyZW5kZXIuaW5kZXhPZiggY2hhbmdlc1sgaSBdICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXJlbmRlciA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggcmVyZW5kZXIgKSB7XG5cdFx0XHRcdHZhciBjb21wb25lbnQ7XG5cdFx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoICcnICk7XG5cdFx0XHRcdC8vIElzIHRoaXMgaXMgYSBjb21wb25lbnQsIHdlIG5lZWQgdG8gc2V0IHRoZSBgc2hvdWxkRGVzdHJveWBcblx0XHRcdFx0Ly8gZmxhZywgb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGJ5IGRlZmF1bHQgdGhhdCBhIHBhcmVudCBub2RlXG5cdFx0XHRcdC8vIHdpbGwgYmUgZGV0YWNoZWQsIGFuZCB0aGVyZWZvcmUgaXQgZG9lc24ndCBuZWVkIHRvIGJvdGhlclxuXHRcdFx0XHQvLyBkZXRhY2hpbmcgaXRzIG93biBub2Rlc1xuXHRcdFx0XHRpZiAoIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50ICkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVucmVuZGVyKCk7XG5cdFx0XHRcdGlmICggY29tcG9uZW50ICkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSWYgdGhlIHRlbXBsYXRlIGNoYW5nZWQsIHdlIG5lZWQgdG8gZGVzdHJveSB0aGUgcGFyYWxsZWwgRE9NXG5cdFx0XHRcdC8vIFRPRE8gaWYgd2UncmUgaGVyZSwgcHJlc3VtYWJseSBpdCBkaWQ/XG5cdFx0XHRcdGlmICggdGhpcy5mcmFnbWVudC50ZW1wbGF0ZSAhPT0gdGhpcy50ZW1wbGF0ZSApIHtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuXHRcdFx0XHRcdFx0cm9vdDogdGhpcyxcblx0XHRcdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByb21pc2UgPSB0aGlzLnJlbmRlciggdGhpcy5lbCwgdGhpcy5hbmNob3IgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG5cdFx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoICcnICk7XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXNldEhvb2suZmlyZSggdGhpcywgZGF0YSApO1xuXHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBjYWxsYmFjayApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vaywgcnVubG9vcCwgRnJhZ21lbnQsIGNvbmZpZyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3Jlc2V0VGVtcGxhdGUuanMgKi9cblx0dmFyIFJhY3RpdmUkcmVzZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uKCBjb25maWcsIEZyYWdtZW50ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkcmVzZXRUZW1wbGF0ZSggdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgdHJhbnNpdGlvbnNFbmFibGVkLCBjb21wb25lbnQ7XG5cdFx0XHRjb25maWcudGVtcGxhdGUuaW5pdCggbnVsbCwgdGhpcywge1xuXHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGVcblx0XHRcdH0gKTtcblx0XHRcdHRyYW5zaXRpb25zRW5hYmxlZCA9IHRoaXMudHJhbnNpdGlvbnNFbmFibGVkO1xuXHRcdFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSBmYWxzZTtcblx0XHRcdC8vIElzIHRoaXMgaXMgYSBjb21wb25lbnQsIHdlIG5lZWQgdG8gc2V0IHRoZSBgc2hvdWxkRGVzdHJveWBcblx0XHRcdC8vIGZsYWcsIG90aGVyd2lzZSBpdCB3aWxsIGFzc3VtZSBieSBkZWZhdWx0IHRoYXQgYSBwYXJlbnQgbm9kZVxuXHRcdFx0Ly8gd2lsbCBiZSBkZXRhY2hlZCwgYW5kIHRoZXJlZm9yZSBpdCBkb2Vzbid0IG5lZWQgdG8gYm90aGVyXG5cdFx0XHQvLyBkZXRhY2hpbmcgaXRzIG93biBub2Rlc1xuXHRcdFx0aWYgKCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudCApIHtcblx0XHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy51bnJlbmRlcigpO1xuXHRcdFx0aWYgKCBjb21wb25lbnQgKSB7XG5cdFx0XHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyByZW1vdmUgZXhpc3RpbmcgZnJhZ21lbnQgYW5kIGNyZWF0ZSBuZXcgb25lXG5cdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSxcblx0XHRcdFx0cm9vdDogdGhpcyxcblx0XHRcdFx0b3duZXI6IHRoaXNcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMucmVuZGVyKCB0aGlzLmVsLCB0aGlzLmFuY2hvciApO1xuXHRcdFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSB0cmFuc2l0aW9uc0VuYWJsZWQ7XG5cdFx0fTtcblx0fSggY29uZmlnLCBGcmFnbWVudCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3JldmVyc2UuanMgKi9cblx0dmFyIFJhY3RpdmUkcmV2ZXJzZSA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAncmV2ZXJzZScgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2V0LmpzICovXG5cdHZhciBSYWN0aXZlJHNldCA9IGZ1bmN0aW9uKCBydW5sb29wLCBpc09iamVjdCwgbm9ybWFsaXNlS2V5cGF0aCwgZ2V0TWF0Y2hpbmdLZXlwYXRocyApIHtcblxuXHRcdHZhciB3aWxkY2FyZCA9IC9cXCovO1xuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHNldCgga2V5cGF0aCwgdmFsdWUsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgbWFwLCBwcm9taXNlO1xuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdC8vIFNldCBtdWx0aXBsZSBrZXlwYXRocyBpbiBvbmUgZ29cblx0XHRcdGlmICggaXNPYmplY3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0bWFwID0ga2V5cGF0aDtcblx0XHRcdFx0Y2FsbGJhY2sgPSB2YWx1ZTtcblx0XHRcdFx0Zm9yICgga2V5cGF0aCBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0aWYgKCBtYXAuaGFzT3duUHJvcGVydHkoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gbWFwWyBrZXlwYXRoIF07XG5cdFx0XHRcdFx0XHRrZXlwYXRoID0gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdFx0aWYgKCB3aWxkY2FyZC50ZXN0KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0Z2V0TWF0Y2hpbmdLZXlwYXRocyggdGhpcywga2V5cGF0aCApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0dGhpcyQwLnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnNldCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggY2FsbGJhY2suYmluZCggdGhpcyApICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBydW5sb29wLCBpc09iamVjdCwgbm9ybWFsaXNlS2V5cGF0aCwgZ2V0TWF0Y2hpbmdLZXlwYXRocyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoaWZ0LmpzICovXG5cdHZhciBSYWN0aXZlJHNoaWZ0ID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICdzaGlmdCcgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc29ydC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzb3J0ID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICdzb3J0JyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zcGxpY2UuanMgKi9cblx0dmFyIFJhY3RpdmUkc3BsaWNlID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICdzcGxpY2UnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3N1YnRyYWN0LmpzICovXG5cdHZhciBSYWN0aXZlJHN1YnRyYWN0ID0gZnVuY3Rpb24oIGFkZCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHN1YnRyYWN0KCBrZXlwYXRoLCBkICkge1xuXHRcdFx0cmV0dXJuIGFkZCggdGhpcywga2V5cGF0aCwgZCA9PT0gdW5kZWZpbmVkID8gLTEgOiAtZCApO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2FkZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3RlYXJkb3duLmpzICovXG5cdHZhciBSYWN0aXZlJHRlYXJkb3duID0gZnVuY3Rpb24oIEhvb2ssIFByb21pc2UsIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHZhciB0ZWFyZG93bkhvb2sgPSBuZXcgSG9vayggJ3RlYXJkb3duJyApO1xuXHRcdC8vIFRlYXJkb3duLiBUaGlzIGdvZXMgdGhyb3VnaCB0aGUgcm9vdCBmcmFnbWVudCBhbmQgYWxsIGl0cyBjaGlsZHJlbiwgcmVtb3Zpbmcgb2JzZXJ2ZXJzXG5cdFx0Ly8gYW5kIGdlbmVyYWxseSBjbGVhbmluZyB1cCBhZnRlciBpdHNlbGZcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSR0ZWFyZG93biggY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgcHJvbWlzZTtcblx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR0aGlzLnZpZXdtb2RlbC50ZWFyZG93bigpO1xuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50LnJlbmRlcmVkICYmIHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fICkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNob3VsZERlc3Ryb3kgPSB0cnVlO1xuXHRcdFx0cHJvbWlzZSA9IHRoaXMuZnJhZ21lbnQucmVuZGVyZWQgPyB0aGlzLnVucmVuZGVyKCkgOiBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRcdHRlYXJkb3duSG9vay5maXJlKCB0aGlzICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHQvLyBUT0RPIGRlcHJlY2F0ZSB0aGlzP1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGNhbGxiYWNrLmJpbmQoIHRoaXMgKSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vaywgUHJvbWlzZSwgcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdG9nZ2xlLmpzICovXG5cdHZhciBSYWN0aXZlJHRvZ2dsZSA9IGZ1bmN0aW9uKCBsb2cgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSR0b2dnbGUoIGtleXBhdGgsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0aWYgKCB0eXBlb2Yga2V5cGF0aCAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGxvZy5lcnJvck9ubHkoIHtcblx0XHRcdFx0XHRkZWJ1ZzogdGhpcy5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzc2FnZTogJ2JhZEFyZ3VtZW50cycsXG5cdFx0XHRcdFx0YXJnOiB7XG5cdFx0XHRcdFx0XHRhcmd1bWVudHM6IGtleXBhdGhcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gdGhpcy5nZXQoIGtleXBhdGggKTtcblx0XHRcdHJldHVybiB0aGlzLnNldCgga2V5cGF0aCwgIXZhbHVlLCBjYWxsYmFjayApO1xuXHRcdH07XG5cdH0oIGxvZyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3RvSFRNTC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR0b0hUTUwgPSBmdW5jdGlvbiBSYWN0aXZlJHRvSFRNTCgpIHtcblx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZyggdHJ1ZSApO1xuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciBSYWN0aXZlJHVucmVuZGVyID0gZnVuY3Rpb24oIGNzcywgSG9vaywgbG9nLCBQcm9taXNlLCByZW1vdmVGcm9tQXJyYXksIHJ1bmxvb3AgKSB7XG5cblx0XHR2YXIgdW5yZW5kZXJIb29rID0gbmV3IEhvb2soICd1bnJlbmRlcicgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSR1bnJlbmRlcigpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHByb21pc2UsIHNob3VsZERlc3Ryb3k7XG5cdFx0XHRpZiAoICF0aGlzLmZyYWdtZW50LnJlbmRlcmVkICkge1xuXHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdGRlYnVnOiB0aGlzLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdyYWN0aXZlLnVucmVuZGVyKCkgd2FzIGNhbGxlZCBvbiBhIFJhY3RpdmUgaW5zdGFuY2UgdGhhdCB3YXMgbm90IHJlbmRlcmVkJ1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRcdH1cblx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgY29tcG9uZW50LCBhbmQgdGhlIGNvbXBvbmVudCBpc24ndCBtYXJrZWQgZm9yIGRlc3RydWN0aW9uLFxuXHRcdFx0Ly8gZG9uJ3QgZGV0YWNoIG5vZGVzIGZyb20gdGhlIERPTSB1bm5lY2Vzc2FyaWx5XG5cdFx0XHRzaG91bGREZXN0cm95ID0gIXRoaXMuY29tcG9uZW50IHx8IHRoaXMuY29tcG9uZW50LnNob3VsZERlc3Ryb3kgfHwgdGhpcy5zaG91bGREZXN0cm95O1xuXHRcdFx0aWYgKCB0aGlzLmNvbnN0cnVjdG9yLmNzcyApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRjc3MucmVtb3ZlKCB0aGlzJDAuY29uc3RydWN0b3IgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ2FuY2VsIGFueSBhbmltYXRpb25zIGluIHByb2dyZXNzXG5cdFx0XHR3aGlsZSAoIHRoaXMuX2FuaW1hdGlvbnNbIDAgXSApIHtcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uc1sgMCBdLnN0b3AoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKTtcblx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIHRoaXMgKTtcblx0XHRcdHVucmVuZGVySG9vay5maXJlKCB0aGlzICk7XG5cdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggZ2xvYmFsX2NzcywgUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vaywgbG9nLCBQcm9taXNlLCByZW1vdmVGcm9tQXJyYXksIHJ1bmxvb3AgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS91bnNoaWZ0LmpzICovXG5cdHZhciBSYWN0aXZlJHVuc2hpZnQgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3Vuc2hpZnQnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3VwZGF0ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR1cGRhdGUgPSBmdW5jdGlvbiggSG9vaywgcnVubG9vcCApIHtcblxuXHRcdHZhciB1cGRhdGVIb29rID0gbmV3IEhvb2soICd1cGRhdGUnICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkdXBkYXRlKCBrZXlwYXRoLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBwcm9taXNlO1xuXHRcdFx0aWYgKCB0eXBlb2Yga2V5cGF0aCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBrZXlwYXRoO1xuXHRcdFx0XHRrZXlwYXRoID0gJyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXlwYXRoID0ga2V5cGF0aCB8fCAnJztcblx0XHRcdH1cblx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG5cdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCBrZXlwYXRoICk7XG5cdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0dXBkYXRlSG9vay5maXJlKCB0aGlzLCBrZXlwYXRoICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGNhbGxiYWNrLmJpbmQoIHRoaXMgKSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vaywgcnVubG9vcCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3VwZGF0ZU1vZGVsLmpzICovXG5cdHZhciBSYWN0aXZlJHVwZGF0ZU1vZGVsID0gZnVuY3Rpb24oIGFycmF5Q29udGVudHNNYXRjaCwgaXNFcXVhbCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFJhY3RpdmUkdXBkYXRlTW9kZWwoIGtleXBhdGgsIGNhc2NhZGUgKSB7XG5cdFx0XHR2YXIgdmFsdWVzO1xuXHRcdFx0aWYgKCB0eXBlb2Yga2V5cGF0aCAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGtleXBhdGggPSAnJztcblx0XHRcdFx0Y2FzY2FkZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xpZGF0ZUNoYW5nZWRWYWx1ZXMoIHRoaXMsIGtleXBhdGgsIHZhbHVlcyA9IHt9LCBjYXNjYWRlICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXQoIHZhbHVlcyApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjb25zb2xpZGF0ZUNoYW5nZWRWYWx1ZXMoIHJhY3RpdmUsIGtleXBhdGgsIHZhbHVlcywgY2FzY2FkZSApIHtcblx0XHRcdHZhciBiaW5kaW5ncywgY2hpbGREZXBzLCBpLCBiaW5kaW5nLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGNoZWNrYm94R3JvdXBzID0gW107XG5cdFx0XHRiaW5kaW5ncyA9IHJhY3RpdmUuX3R3b3dheUJpbmRpbmdzWyBrZXlwYXRoIF07XG5cdFx0XHRpZiAoIGJpbmRpbmdzICYmICggaSA9IGJpbmRpbmdzLmxlbmd0aCApICkge1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcblx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSByYWRpbyBuYW1lIGJpbmRpbmdzXG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nLnJhZGlvTmFtZSAmJiAhYmluZGluZy5lbGVtZW50Lm5vZGUuY2hlY2tlZCApIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBjaGVja2JveCBuYW1lIGJpbmRpbmdzIGNvbWUgaW4gZ3JvdXBzLCBzb1xuXHRcdFx0XHRcdC8vIHdlIHdhbnQgdG8gZ2V0IHRoZSB2YWx1ZSBvbmNlIGF0IG1vc3Rcblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcuY2hlY2tib3hOYW1lICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhY2hlY2tib3hHcm91cHNbIGJpbmRpbmcua2V5cGF0aCBdICYmICFiaW5kaW5nLmNoYW5nZWQoKSApIHtcblx0XHRcdFx0XHRcdFx0Y2hlY2tib3hHcm91cHMucHVzaCggYmluZGluZy5rZXlwYXRoICk7XG5cdFx0XHRcdFx0XHRcdGNoZWNrYm94R3JvdXBzWyBiaW5kaW5nLmtleXBhdGggXSA9IGJpbmRpbmc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b2xkVmFsdWUgPSBiaW5kaW5nLmF0dHJpYnV0ZS52YWx1ZTtcblx0XHRcdFx0XHRuZXdWYWx1ZSA9IGJpbmRpbmcuZ2V0VmFsdWUoKTtcblx0XHRcdFx0XHRpZiAoIGFycmF5Q29udGVudHNNYXRjaCggb2xkVmFsdWUsIG5ld1ZhbHVlICkgKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhaXNFcXVhbCggb2xkVmFsdWUsIG5ld1ZhbHVlICkgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXNbIGtleXBhdGggXSA9IG5ld1ZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gSGFuZGxlIGdyb3VwcyBvZiBgPGlucHV0IHR5cGU9J2NoZWNrYm94JyBuYW1lPSd7e2Zvb319JyAuLi4+YFxuXHRcdFx0aWYgKCBjaGVja2JveEdyb3Vwcy5sZW5ndGggKSB7XG5cdFx0XHRcdGNoZWNrYm94R3JvdXBzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHZhciBiaW5kaW5nLCBvbGRWYWx1ZSwgbmV3VmFsdWU7XG5cdFx0XHRcdFx0YmluZGluZyA9IGNoZWNrYm94R3JvdXBzWyBrZXlwYXRoIF07XG5cdFx0XHRcdFx0Ly8gb25lIHRvIHJlcHJlc2VudCB0aGUgZW50aXJlIGdyb3VwXG5cdFx0XHRcdFx0b2xkVmFsdWUgPSBiaW5kaW5nLmF0dHJpYnV0ZS52YWx1ZTtcblx0XHRcdFx0XHRuZXdWYWx1ZSA9IGJpbmRpbmcuZ2V0VmFsdWUoKTtcblx0XHRcdFx0XHRpZiAoICFhcnJheUNvbnRlbnRzTWF0Y2goIG9sZFZhbHVlLCBuZXdWYWx1ZSApICkge1xuXHRcdFx0XHRcdFx0dmFsdWVzWyBrZXlwYXRoIF0gPSBuZXdWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggIWNhc2NhZGUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIGNhc2NhZGVcblx0XHRcdGNoaWxkRGVwcyA9IHJhY3RpdmUudmlld21vZGVsLmRlcHNNYXBbICdkZWZhdWx0JyBdWyBrZXlwYXRoIF07XG5cdFx0XHRpZiAoIGNoaWxkRGVwcyApIHtcblx0XHRcdFx0aSA9IGNoaWxkRGVwcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGNvbnNvbGlkYXRlQ2hhbmdlZFZhbHVlcyggcmFjdGl2ZSwgY2hpbGREZXBzWyBpIF0sIHZhbHVlcywgY2FzY2FkZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggYXJyYXlDb250ZW50c01hdGNoLCBpc0VxdWFsICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUuanMgKi9cblx0dmFyIHByb3RvdHlwZSA9IGZ1bmN0aW9uKCBhZGQsIGFuaW1hdGUsIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmluZEFsbENvbXBvbmVudHMsIGZpbmRDb21wb25lbnQsIGZpcmUsIGdldCwgaW5zZXJ0LCBtZXJnZSwgb2JzZXJ2ZSwgb2ZmLCBvbiwgcG9wLCBwdXNoLCByZW5kZXIsIHJlc2V0LCByZXNldFRlbXBsYXRlLCByZXZlcnNlLCBzZXQsIHNoaWZ0LCBzb3J0LCBzcGxpY2UsIHN1YnRyYWN0LCB0ZWFyZG93biwgdG9nZ2xlLCB0b0hUTUwsIHVucmVuZGVyLCB1bnNoaWZ0LCB1cGRhdGUsIHVwZGF0ZU1vZGVsICkge1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFkZDogYWRkLFxuXHRcdFx0YW5pbWF0ZTogYW5pbWF0ZSxcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuXHRcdFx0ZmlyZTogZmlyZSxcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0aW5zZXJ0OiBpbnNlcnQsXG5cdFx0XHRtZXJnZTogbWVyZ2UsXG5cdFx0XHRvYnNlcnZlOiBvYnNlcnZlLFxuXHRcdFx0b2ZmOiBvZmYsXG5cdFx0XHRvbjogb24sXG5cdFx0XHRwb3A6IHBvcCxcblx0XHRcdHB1c2g6IHB1c2gsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHJlc2V0OiByZXNldCxcblx0XHRcdHJlc2V0VGVtcGxhdGU6IHJlc2V0VGVtcGxhdGUsXG5cdFx0XHRyZXZlcnNlOiByZXZlcnNlLFxuXHRcdFx0c2V0OiBzZXQsXG5cdFx0XHRzaGlmdDogc2hpZnQsXG5cdFx0XHRzb3J0OiBzb3J0LFxuXHRcdFx0c3BsaWNlOiBzcGxpY2UsXG5cdFx0XHRzdWJ0cmFjdDogc3VidHJhY3QsXG5cdFx0XHR0ZWFyZG93bjogdGVhcmRvd24sXG5cdFx0XHR0b2dnbGU6IHRvZ2dsZSxcblx0XHRcdHRvSFRNTDogdG9IVE1MLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyLFxuXHRcdFx0dW5zaGlmdDogdW5zaGlmdCxcblx0XHRcdHVwZGF0ZTogdXBkYXRlLFxuXHRcdFx0dXBkYXRlTW9kZWw6IHVwZGF0ZU1vZGVsXG5cdFx0fTtcblx0fSggUmFjdGl2ZSRhZGQsIFJhY3RpdmUkYW5pbWF0ZSwgUmFjdGl2ZSRkZXRhY2gsIFJhY3RpdmUkZmluZCwgUmFjdGl2ZSRmaW5kQWxsLCBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzLCBSYWN0aXZlJGZpbmRDb21wb25lbnQsIFJhY3RpdmUkZmlyZSwgUmFjdGl2ZSRnZXQsIFJhY3RpdmUkaW5zZXJ0LCBSYWN0aXZlJG1lcmdlLCBSYWN0aXZlJG9ic2VydmUsIFJhY3RpdmUkb2ZmLCBSYWN0aXZlJG9uLCBSYWN0aXZlJHBvcCwgUmFjdGl2ZSRwdXNoLCBSYWN0aXZlJHJlbmRlciwgUmFjdGl2ZSRyZXNldCwgUmFjdGl2ZSRyZXNldFRlbXBsYXRlLCBSYWN0aXZlJHJldmVyc2UsIFJhY3RpdmUkc2V0LCBSYWN0aXZlJHNoaWZ0LCBSYWN0aXZlJHNvcnQsIFJhY3RpdmUkc3BsaWNlLCBSYWN0aXZlJHN1YnRyYWN0LCBSYWN0aXZlJHRlYXJkb3duLCBSYWN0aXZlJHRvZ2dsZSwgUmFjdGl2ZSR0b0hUTUwsIFJhY3RpdmUkdW5yZW5kZXIsIFJhY3RpdmUkdW5zaGlmdCwgUmFjdGl2ZSR1cGRhdGUsIFJhY3RpdmUkdXBkYXRlTW9kZWwgKTtcblxuXHQvKiB1dGlscy9nZXRHdWlkLmpzICovXG5cdHZhciBnZXRHdWlkID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoIC9beHldL2csIGZ1bmN0aW9uKCBjICkge1xuXHRcdFx0dmFyIHIsIHY7XG5cdFx0XHRyID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMDtcblx0XHRcdHYgPSBjID09ICd4JyA/IHIgOiByICYgMyB8IDg7XG5cdFx0XHRyZXR1cm4gdi50b1N0cmluZyggMTYgKTtcblx0XHR9ICk7XG5cdH07XG5cblx0LyogdXRpbHMvZ2V0TmV4dE51bWJlci5qcyAqL1xuXHR2YXIgZ2V0TmV4dE51bWJlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGkgPSAwO1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAnci0nICsgaSsrO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvaG9va3MvSG9va1F1ZXVlLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9ob29rc19Ib29rUXVldWUgPSBmdW5jdGlvbiggSG9vayApIHtcblxuXHRcdGZ1bmN0aW9uIEhvb2tRdWV1ZSggZXZlbnQgKSB7XG5cdFx0XHR0aGlzLmhvb2sgPSBuZXcgSG9vayggZXZlbnQgKTtcblx0XHRcdHRoaXMuaW5Qcm9jZXNzID0ge307XG5cdFx0XHR0aGlzLnF1ZXVlID0ge307XG5cdFx0fVxuXHRcdEhvb2tRdWV1ZS5wcm90b3R5cGUgPSB7XG5cdFx0XHRjb25zdHJ1Y3RvcjogSG9va1F1ZXVlLFxuXHRcdFx0YmVnaW46IGZ1bmN0aW9uKCByYWN0aXZlICkge1xuXHRcdFx0XHR0aGlzLmluUHJvY2Vzc1sgcmFjdGl2ZS5fZ3VpZCBdID0gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRlbmQ6IGZ1bmN0aW9uKCByYWN0aXZlICkge1xuXHRcdFx0XHR2YXIgcGFyZW50ID0gcmFjdGl2ZS5fcGFyZW50O1xuXHRcdFx0XHQvLyBJZiB0aGlzIGlzICppc24ndCogYSBjaGlsZCBvZiBhIGNvbXBvbmVudCB0aGF0J3MgaW4gcHJvY2Vzcyxcblx0XHRcdFx0Ly8gaXQgc2hvdWxkIGNhbGwgbWV0aG9kcyBvciBmaXJlIGF0IHRoaXMgcG9pbnRcblx0XHRcdFx0aWYgKCAhcGFyZW50IHx8ICF0aGlzLmluUHJvY2Vzc1sgcGFyZW50Ll9ndWlkIF0gKSB7XG5cdFx0XHRcdFx0ZmlyZSggdGhpcywgcmFjdGl2ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGdldENoaWxkUXVldWUoIHRoaXMucXVldWUsIHBhcmVudCApLnB1c2goIHJhY3RpdmUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgdGhpcy5pblByb2Nlc3NbIHJhY3RpdmUuX2d1aWQgXTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Q2hpbGRRdWV1ZSggcXVldWUsIHJhY3RpdmUgKSB7XG5cdFx0XHRyZXR1cm4gcXVldWVbIHJhY3RpdmUuX2d1aWQgXSB8fCAoIHF1ZXVlWyByYWN0aXZlLl9ndWlkIF0gPSBbXSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpcmUoIGhvb2tRdWV1ZSwgcmFjdGl2ZSApIHtcblx0XHRcdHZhciBjaGlsZFF1ZXVlID0gZ2V0Q2hpbGRRdWV1ZSggaG9va1F1ZXVlLnF1ZXVlLCByYWN0aXZlICk7XG5cdFx0XHRob29rUXVldWUuaG9vay5maXJlKCByYWN0aXZlICk7XG5cdFx0XHQvLyBxdWV1ZSBpcyBcImxpdmVcIiBiZWNhdXNlIGNvbXBvbmVudHMgY2FuIGVuZCB1cCBiZWluZ1xuXHRcdFx0Ly8gYWRkZWQgd2hpbGUgaG9va3MgZmlyZSBvbiBwYXJlbnRzIHRoYXQgbW9kaWZ5IGRhdGEgdmFsdWVzLlxuXHRcdFx0d2hpbGUgKCBjaGlsZFF1ZXVlLmxlbmd0aCApIHtcblx0XHRcdFx0ZmlyZSggaG9va1F1ZXVlLCBjaGlsZFF1ZXVlLnNoaWZ0KCkgKTtcblx0XHRcdH1cblx0XHRcdGRlbGV0ZSBob29rUXVldWUucXVldWVbIHJhY3RpdmUuX2d1aWQgXTtcblx0XHR9XG5cdFx0cmV0dXJuIEhvb2tRdWV1ZTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vayApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L2FycmF5QWRhcHRvci9wcm9jZXNzV3JhcHBlci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3JfcHJvY2Vzc1dyYXBwZXIgPSBmdW5jdGlvbiggd3JhcHBlciwgYXJyYXksIG1ldGhvZE5hbWUsIG5ld0luZGljZXMgKSB7XG5cdFx0dmFyIHJvb3QgPSB3cmFwcGVyLnJvb3QsXG5cdFx0XHRrZXlwYXRoID0gd3JhcHBlci5rZXlwYXRoO1xuXHRcdC8vIElmIHRoaXMgaXMgYSBzb3J0IG9yIHJldmVyc2UsIHdlIGp1c3QgZG8gcm9vdC5zZXQoKS4uLlxuXHRcdC8vIFRPRE8gdXNlIG1lcmdlIGxvZ2ljP1xuXHRcdGlmICggbWV0aG9kTmFtZSA9PT0gJ3NvcnQnIHx8IG1ldGhvZE5hbWUgPT09ICdyZXZlcnNlJyApIHtcblx0XHRcdHJvb3Qudmlld21vZGVsLnNldCgga2V5cGF0aCwgYXJyYXkgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cm9vdC52aWV3bW9kZWwuc21hcnRVcGRhdGUoIGtleXBhdGgsIGFycmF5LCBuZXdJbmRpY2VzICk7XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQvYXJyYXlBZGFwdG9yL3BhdGNoLmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvcl9wYXRjaCA9IGZ1bmN0aW9uKCBydW5sb29wLCBkZWZpbmVQcm9wZXJ0eSwgZ2V0TmV3SW5kaWNlcywgcHJvY2Vzc1dyYXBwZXIgKSB7XG5cblx0XHR2YXIgcGF0Y2hlZEFycmF5UHJvdG8gPSBbXSxcblx0XHRcdG11dGF0b3JNZXRob2RzID0gW1xuXHRcdFx0XHQncG9wJyxcblx0XHRcdFx0J3B1c2gnLFxuXHRcdFx0XHQncmV2ZXJzZScsXG5cdFx0XHRcdCdzaGlmdCcsXG5cdFx0XHRcdCdzb3J0Jyxcblx0XHRcdFx0J3NwbGljZScsXG5cdFx0XHRcdCd1bnNoaWZ0J1xuXHRcdFx0XSxcblx0XHRcdHRlc3RPYmosIHBhdGNoQXJyYXlNZXRob2RzLCB1bnBhdGNoQXJyYXlNZXRob2RzO1xuXHRcdG11dGF0b3JNZXRob2RzLmZvckVhY2goIGZ1bmN0aW9uKCBtZXRob2ROYW1lICkge1xuXHRcdFx0dmFyIG1ldGhvZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgU0xJQ0UkMCA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0XHRcdFx0dmFyIGFyZ3MgPSBTTElDRSQwLmNhbGwoIGFyZ3VtZW50cywgMCApO1xuXHRcdFx0XHR2YXIgbmV3SW5kaWNlcywgcmVzdWx0LCB3cmFwcGVyLCBpO1xuXHRcdFx0XHRuZXdJbmRpY2VzID0gZ2V0TmV3SW5kaWNlcyggdGhpcywgbWV0aG9kTmFtZSwgYXJncyApO1xuXHRcdFx0XHQvLyBhcHBseSB0aGUgdW5kZXJseWluZyBtZXRob2Rcblx0XHRcdFx0cmVzdWx0ID0gQXJyYXkucHJvdG90eXBlWyBtZXRob2ROYW1lIF0uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHQvLyB0cmlnZ2VyIGNoYW5nZXNcblx0XHRcdFx0cnVubG9vcC5zdGFydCgpO1xuXHRcdFx0XHR0aGlzLl9yYWN0aXZlLnNldHRpbmcgPSB0cnVlO1xuXHRcdFx0XHRpID0gdGhpcy5fcmFjdGl2ZS53cmFwcGVycy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdHdyYXBwZXIgPSB0aGlzLl9yYWN0aXZlLndyYXBwZXJzWyBpIF07XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHdyYXBwZXIucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHRwcm9jZXNzV3JhcHBlciggd3JhcHBlciwgdGhpcywgbWV0aG9kTmFtZSwgbmV3SW5kaWNlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdHRoaXMuX3JhY3RpdmUuc2V0dGluZyA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fTtcblx0XHRcdGRlZmluZVByb3BlcnR5KCBwYXRjaGVkQXJyYXlQcm90bywgbWV0aG9kTmFtZSwge1xuXHRcdFx0XHR2YWx1ZTogbWV0aG9kXG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHRcdC8vIGNhbiB3ZSB1c2UgcHJvdG90eXBlIGNoYWluIGluamVjdGlvbj9cblx0XHQvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9ob3ctZWNtYXNjcmlwdC01LXN0aWxsLWRvZXMtbm90LWFsbG93LXRvLXN1YmNsYXNzLWFuLWFycmF5LyN3cmFwcGVyc19wcm90b3R5cGVfY2hhaW5faW5qZWN0aW9uXG5cdFx0dGVzdE9iaiA9IHt9O1xuXHRcdGlmICggdGVzdE9iai5fX3Byb3RvX18gKSB7XG5cdFx0XHQvLyB5ZXMsIHdlIGNhblxuXHRcdFx0cGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdFx0XHRcdGFycmF5Ll9fcHJvdG9fXyA9IHBhdGNoZWRBcnJheVByb3RvO1xuXHRcdFx0fTtcblx0XHRcdHVucGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdFx0XHRcdGFycmF5Ll9fcHJvdG9fXyA9IEFycmF5LnByb3RvdHlwZTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIG5vLCB3ZSBjYW4ndFxuXHRcdFx0cGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdFx0XHRcdHZhciBpLCBtZXRob2ROYW1lO1xuXHRcdFx0XHRpID0gbXV0YXRvck1ldGhvZHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRtZXRob2ROYW1lID0gbXV0YXRvck1ldGhvZHNbIGkgXTtcblx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eSggYXJyYXksIG1ldGhvZE5hbWUsIHtcblx0XHRcdFx0XHRcdHZhbHVlOiBwYXRjaGVkQXJyYXlQcm90b1sgbWV0aG9kTmFtZSBdLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0dW5wYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0XHRcdFx0dmFyIGk7XG5cdFx0XHRcdGkgPSBtdXRhdG9yTWV0aG9kcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGRlbGV0ZSBhcnJheVsgbXV0YXRvck1ldGhvZHNbIGkgXSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRwYXRjaEFycmF5TWV0aG9kcy51bnBhdGNoID0gdW5wYXRjaEFycmF5TWV0aG9kcztcblx0XHRyZXR1cm4gcGF0Y2hBcnJheU1ldGhvZHM7XG5cdH0oIHJ1bmxvb3AsIGRlZmluZVByb3BlcnR5LCBnZXROZXdJbmRpY2VzLCB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvcl9wcm9jZXNzV3JhcHBlciApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L2FycmF5QWRhcHRvci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3IgPSBmdW5jdGlvbiggZGVmaW5lUHJvcGVydHksIGlzQXJyYXksIHBhdGNoICkge1xuXG5cdFx0dmFyIGFycmF5QWRhcHRvcixcblx0XHRcdC8vIGhlbHBlcnNcblx0XHRcdEFycmF5V3JhcHBlciwgZXJyb3JNZXNzYWdlO1xuXHRcdGFycmF5QWRhcHRvciA9IHtcblx0XHRcdGZpbHRlcjogZnVuY3Rpb24oIG9iamVjdCApIHtcblx0XHRcdFx0Ly8gd3JhcCB0aGUgYXJyYXkgaWYgYSkgYikgaXQncyBhbiBhcnJheSwgYW5kIGIpIGVpdGhlciBpdCBoYXNuJ3QgYmVlbiB3cmFwcGVkIGFscmVhZHksXG5cdFx0XHRcdC8vIG9yIHRoZSBhcnJheSBkaWRuJ3QgdHJpZ2dlciB0aGUgZ2V0KCkgaXRzZWxmXG5cdFx0XHRcdHJldHVybiBpc0FycmF5KCBvYmplY3QgKSAmJiAoICFvYmplY3QuX3JhY3RpdmUgfHwgIW9iamVjdC5fcmFjdGl2ZS5zZXR0aW5nICk7XG5cdFx0XHR9LFxuXHRcdFx0d3JhcDogZnVuY3Rpb24oIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEFycmF5V3JhcHBlciggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdEFycmF5V3JhcHBlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApIHtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLnZhbHVlID0gYXJyYXk7XG5cdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0Ly8gaWYgdGhpcyBhcnJheSBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJhY3RpZmllZCwgcmFjdGlmeSBpdFxuXHRcdFx0aWYgKCAhYXJyYXkuX3JhY3RpdmUgKSB7XG5cdFx0XHRcdC8vIGRlZmluZSBhIG5vbi1lbnVtZXJhYmxlIF9yYWN0aXZlIHByb3BlcnR5IHRvIHN0b3JlIHRoZSB3cmFwcGVyc1xuXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eSggYXJyYXksICdfcmFjdGl2ZScsIHtcblx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0d3JhcHBlcnM6IFtdLFxuXHRcdFx0XHRcdFx0aW5zdGFuY2VzOiBbXSxcblx0XHRcdFx0XHRcdHNldHRpbmc6IGZhbHNlXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRwYXRjaCggYXJyYXkgKTtcblx0XHRcdH1cblx0XHRcdC8vIHN0b3JlIHRoZSByYWN0aXZlIGluc3RhbmNlLCBzbyB3ZSBjYW4gaGFuZGxlIHRyYW5zaXRpb25zIGxhdGVyXG5cdFx0XHRpZiAoICFhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbIHJhY3RpdmUuX2d1aWQgXSApIHtcblx0XHRcdFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzWyByYWN0aXZlLl9ndWlkIF0gPSAwO1xuXHRcdFx0XHRhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXMucHVzaCggcmFjdGl2ZSApO1xuXHRcdFx0fVxuXHRcdFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzWyByYWN0aXZlLl9ndWlkIF0gKz0gMTtcblx0XHRcdGFycmF5Ll9yYWN0aXZlLndyYXBwZXJzLnB1c2goIHRoaXMgKTtcblx0XHR9O1xuXHRcdEFycmF5V3JhcHBlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBhcnJheSwgc3RvcmFnZSwgd3JhcHBlcnMsIGluc3RhbmNlcywgaW5kZXg7XG5cdFx0XHRcdGFycmF5ID0gdGhpcy52YWx1ZTtcblx0XHRcdFx0c3RvcmFnZSA9IGFycmF5Ll9yYWN0aXZlO1xuXHRcdFx0XHR3cmFwcGVycyA9IHN0b3JhZ2Uud3JhcHBlcnM7XG5cdFx0XHRcdGluc3RhbmNlcyA9IHN0b3JhZ2UuaW5zdGFuY2VzO1xuXHRcdFx0XHQvLyBpZiB0ZWFyZG93bigpIHdhcyBpbnZva2VkIGJlY2F1c2Ugd2UncmUgY2xlYXJpbmcgdGhlIGNhY2hlIGFzIGEgcmVzdWx0IG9mXG5cdFx0XHRcdC8vIGEgY2hhbmdlIHRoYXQgdGhlIGFycmF5IGl0c2VsZiB0cmlnZ2VyZWQsIHdlIGNhbiBzYXZlIG91cnNlbHZlcyB0aGUgdGVhcmRvd25cblx0XHRcdFx0Ly8gYW5kIGltbWVkaWF0ZSBzZXR1cFxuXHRcdFx0XHRpZiAoIHN0b3JhZ2Uuc2V0dGluZyApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXggPSB3cmFwcGVycy5pbmRleE9mKCB0aGlzICk7XG5cdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggZXJyb3JNZXNzYWdlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0d3JhcHBlcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHQvLyBpZiBub3RoaW5nIGVsc2UgZGVwZW5kcyBvbiB0aGlzIGFycmF5LCB3ZSBjYW4gcmV2ZXJ0IGl0IHRvIGl0c1xuXHRcdFx0XHQvLyBuYXR1cmFsIHN0YXRlXG5cdFx0XHRcdGlmICggIXdyYXBwZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRkZWxldGUgYXJyYXkuX3JhY3RpdmU7XG5cdFx0XHRcdFx0cGF0Y2gudW5wYXRjaCggdGhpcy52YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHJlbW92ZSByYWN0aXZlIGluc3RhbmNlIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0aW5zdGFuY2VzWyB0aGlzLnJvb3QuX2d1aWQgXSAtPSAxO1xuXHRcdFx0XHRcdGlmICggIWluc3RhbmNlc1sgdGhpcy5yb290Ll9ndWlkIF0gKSB7XG5cdFx0XHRcdFx0XHRpbmRleCA9IGluc3RhbmNlcy5pbmRleE9mKCB0aGlzLnJvb3QgKTtcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGVycm9yTWVzc2FnZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aW5zdGFuY2VzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdGVycm9yTWVzc2FnZSA9ICdTb21ldGhpbmcgd2VudCB3cm9uZyBpbiBhIHJhdGhlciBpbnRlcmVzdGluZyB3YXknO1xuXHRcdHJldHVybiBhcnJheUFkYXB0b3I7XG5cdH0oIGRlZmluZVByb3BlcnR5LCBpc0FycmF5LCB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvcl9wYXRjaCApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L21hZ2ljQXJyYXlBZGFwdG9yLmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X21hZ2ljQXJyYXlBZGFwdG9yID0gZnVuY3Rpb24oIG1hZ2ljQWRhcHRvciwgYXJyYXlBZGFwdG9yICkge1xuXG5cdFx0dmFyIG1hZ2ljQXJyYXlBZGFwdG9yLCBNYWdpY0FycmF5V3JhcHBlcjtcblx0XHRpZiAoIG1hZ2ljQWRhcHRvciApIHtcblx0XHRcdG1hZ2ljQXJyYXlBZGFwdG9yID0ge1xuXHRcdFx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hZ2ljQWRhcHRvci5maWx0ZXIoIG9iamVjdCwga2V5cGF0aCwgcmFjdGl2ZSApICYmIGFycmF5QWRhcHRvci5maWx0ZXIoIG9iamVjdCApO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR3cmFwOiBmdW5jdGlvbiggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBNYWdpY0FycmF5V3JhcHBlciggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdE1hZ2ljQXJyYXlXcmFwcGVyID0gZnVuY3Rpb24oIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gYXJyYXk7XG5cdFx0XHRcdHRoaXMubWFnaWMgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLm1hZ2ljV3JhcHBlciA9IG1hZ2ljQWRhcHRvci53cmFwKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLmFycmF5V3JhcHBlciA9IGFycmF5QWRhcHRvci53cmFwKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApO1xuXHRcdFx0fTtcblx0XHRcdE1hZ2ljQXJyYXlXcmFwcGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMuYXJyYXlXcmFwcGVyLnRlYXJkb3duKCk7XG5cdFx0XHRcdFx0dGhpcy5tYWdpY1dyYXBwZXIudGVhcmRvd24oKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5tYWdpY1dyYXBwZXIucmVzZXQoIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBtYWdpY0FycmF5QWRhcHRvcjtcblx0fSggdmlld21vZGVsJGdldF9tYWdpY0FkYXB0b3IsIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9hZGFwdC5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGFkYXB0ID0gZnVuY3Rpb24oIGNvbmZpZywgYXJyYXlBZGFwdG9yLCBsb2csIG1hZ2ljQWRhcHRvciwgbWFnaWNBcnJheUFkYXB0b3IgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIHByZWZpeGVycyA9IHt9O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVmlld21vZGVsJGFkYXB0KCBrZXlwYXRoLCB2YWx1ZSApIHtcblx0XHRcdHZhciByYWN0aXZlID0gdGhpcy5yYWN0aXZlLFxuXHRcdFx0XHRsZW4sIGksIGFkYXB0b3IsIHdyYXBwZWQ7XG5cdFx0XHQvLyBEbyB3ZSBoYXZlIGFuIGFkYXB0b3IgZm9yIHRoaXMgdmFsdWU/XG5cdFx0XHRsZW4gPSByYWN0aXZlLmFkYXB0Lmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdGFkYXB0b3IgPSByYWN0aXZlLmFkYXB0WyBpIF07XG5cdFx0XHRcdC8vIEFkYXB0b3JzIGNhbiBiZSBzcGVjaWZpZWQgYXMgZS5nLiBbICdCYWNrYm9uZS5Nb2RlbCcsICdCYWNrYm9uZS5Db2xsZWN0aW9uJyBdIC1cblx0XHRcdFx0Ly8gd2UgbmVlZCB0byBnZXQgdGhlIGFjdHVhbCBhZGFwdG9yIGlmIHRoYXQncyB0aGUgY2FzZVxuXHRcdFx0XHRpZiAoIHR5cGVvZiBhZGFwdG9yID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHR2YXIgZm91bmQgPSBjb25maWcucmVnaXN0cmllcy5hZGFwdG9ycy5maW5kKCByYWN0aXZlLCBhZGFwdG9yICk7XG5cdFx0XHRcdFx0aWYgKCAhZm91bmQgKSB7XG5cdFx0XHRcdFx0XHQvLyB3aWxsIHRocm93LiBcInJldHVyblwiIGZvciBzYWZldHksIGlmIHdlIGRvd25ncmFkZSA6KVxuXHRcdFx0XHRcdFx0cmV0dXJuIGxvZy5jcml0aWNhbCgge1xuXHRcdFx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRcdFx0bWVzc2FnZTogJ21pc3NpbmdQbHVnaW4nLFxuXHRcdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0cGx1Z2luOiAnYWRhcHRvcicsXG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogYWRhcHRvclxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGFkYXB0b3IgPSByYWN0aXZlLmFkYXB0WyBpIF0gPSBmb3VuZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGFkYXB0b3IuZmlsdGVyKCB2YWx1ZSwga2V5cGF0aCwgcmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdHdyYXBwZWQgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXSA9IGFkYXB0b3Iud3JhcCggcmFjdGl2ZSwgdmFsdWUsIGtleXBhdGgsIGdldFByZWZpeGVyKCBrZXlwYXRoICkgKTtcblx0XHRcdFx0XHR3cmFwcGVkLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJhY3RpdmUubWFnaWMgKSB7XG5cdFx0XHRcdGlmICggbWFnaWNBcnJheUFkYXB0b3IuZmlsdGVyKCB2YWx1ZSwga2V5cGF0aCwgcmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gbWFnaWNBcnJheUFkYXB0b3Iud3JhcCggcmFjdGl2ZSwgdmFsdWUsIGtleXBhdGggKTtcblx0XHRcdFx0fSBlbHNlIGlmICggbWFnaWNBZGFwdG9yLmZpbHRlciggdmFsdWUsIGtleXBhdGgsIHJhY3RpdmUgKSApIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZWRbIGtleXBhdGggXSA9IG1hZ2ljQWRhcHRvci53cmFwKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCByYWN0aXZlLm1vZGlmeUFycmF5cyAmJiBhcnJheUFkYXB0b3IuZmlsdGVyKCB2YWx1ZSwga2V5cGF0aCwgcmFjdGl2ZSApICkge1xuXHRcdFx0XHR0aGlzLndyYXBwZWRbIGtleXBhdGggXSA9IGFycmF5QWRhcHRvci53cmFwKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwcmVmaXhLZXlwYXRoKCBvYmosIHByZWZpeCApIHtcblx0XHRcdHZhciBwcmVmaXhlZCA9IHt9LFxuXHRcdFx0XHRrZXk7XG5cdFx0XHRpZiAoICFwcmVmaXggKSB7XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9XG5cdFx0XHRwcmVmaXggKz0gJy4nO1xuXHRcdFx0Zm9yICgga2V5IGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBvYmouaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdHByZWZpeGVkWyBwcmVmaXggKyBrZXkgXSA9IG9ialsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBwcmVmaXhlZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRQcmVmaXhlciggcm9vdEtleXBhdGggKSB7XG5cdFx0XHR2YXIgcm9vdERvdDtcblx0XHRcdGlmICggIXByZWZpeGVyc1sgcm9vdEtleXBhdGggXSApIHtcblx0XHRcdFx0cm9vdERvdCA9IHJvb3RLZXlwYXRoID8gcm9vdEtleXBhdGggKyAnLicgOiAnJztcblx0XHRcdFx0cHJlZml4ZXJzWyByb290S2V5cGF0aCBdID0gZnVuY3Rpb24oIHJlbGF0aXZlS2V5cGF0aCwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0dmFyIG9iajtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiByZWxhdGl2ZUtleXBhdGggPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0b2JqID0ge307XG5cdFx0XHRcdFx0XHRvYmpbIHJvb3REb3QgKyByZWxhdGl2ZUtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgcmVsYXRpdmVLZXlwYXRoID09PSAnb2JqZWN0JyApIHtcblx0XHRcdFx0XHRcdC8vICdyZWxhdGl2ZUtleXBhdGgnIGlzIGluIGZhY3QgYSBoYXNoLCBub3QgYSBrZXlwYXRoXG5cdFx0XHRcdFx0XHRyZXR1cm4gcm9vdERvdCA/IHByZWZpeEtleXBhdGgoIHJlbGF0aXZlS2V5cGF0aCwgcm9vdEtleXBhdGggKSA6IHJlbGF0aXZlS2V5cGF0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJlZml4ZXJzWyByb290S2V5cGF0aCBdO1xuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGNvbmZpZywgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3IsIGxvZywgdmlld21vZGVsJGdldF9tYWdpY0FkYXB0b3IsIHZpZXdtb2RlbCRnZXRfbWFnaWNBcnJheUFkYXB0b3IgKTtcblxuXHQvKiB2aWV3bW9kZWwvaGVscGVycy9nZXRVcHN0cmVhbUNoYW5nZXMuanMgKi9cblx0dmFyIGdldFVwc3RyZWFtQ2hhbmdlcyA9IGZ1bmN0aW9uIGdldFVwc3RyZWFtQ2hhbmdlcyggY2hhbmdlcyApIHtcblx0XHR2YXIgdXBzdHJlYW1DaGFuZ2VzID0gWyAnJyBdLFxuXHRcdFx0aSwga2V5cGF0aCwga2V5cywgdXBzdHJlYW1LZXlwYXRoO1xuXHRcdGkgPSBjaGFuZ2VzLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGtleXBhdGggPSBjaGFuZ2VzWyBpIF07XG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHR3aGlsZSAoIGtleXMubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0a2V5cy5wb3AoKTtcblx0XHRcdFx0dXBzdHJlYW1LZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0aWYgKCB1cHN0cmVhbUNoYW5nZXMuaW5kZXhPZiggdXBzdHJlYW1LZXlwYXRoICkgPT09IC0xICkge1xuXHRcdFx0XHRcdHVwc3RyZWFtQ2hhbmdlcy5wdXNoKCB1cHN0cmVhbUtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdXBzdHJlYW1DaGFuZ2VzO1xuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvYXBwbHlDaGFuZ2VzL2dldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcy5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGFwcGx5Q2hhbmdlc19nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgc3Rhck1hcHMgPSB7fTtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGEga2V5cGF0aCBzdWNoIGFzICdmb28uYmFyLmJheicsIGFuZCByZXR1cm5zXG5cdFx0Ly8gYWxsIHRoZSB2YXJpYW50cyBvZiB0aGF0IGtleXBhdGggdGhhdCBpbmNsdWRlIGEgd2lsZGNhcmQgaW4gcGxhY2Vcblx0XHQvLyBvZiBhIGtleSwgc3VjaCBhcyAnZm9vLmJhci4qJywgJ2Zvby4qLmJheicsICdmb28uKi4qJyBhbmQgc28gb24uXG5cdFx0Ly8gVGhlc2UgYXJlIHRoZW4gY2hlY2tlZCBhZ2FpbnN0IHRoZSBkZXBlbmRhbnRzIG1hcCAocmFjdGl2ZS52aWV3bW9kZWwuZGVwc01hcClcblx0XHQvLyB0byBzZWUgaWYgYW55IHBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSBkb3duc3RyZWFtIG9mIG9uZSBvciBtb3JlIG9mXG5cdFx0Ly8gdGhlc2Ugd2lsZGNhcmQga2V5cGF0aHMgKGUuZy4gJ2Zvby5iYXIuKi5zdGF0dXMnKVxuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGtleXMsIHN0YXJNYXAsIG1hcHBlciwgcmVzdWx0O1xuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0c3Rhck1hcCA9IGdldFN0YXJNYXAoIGtleXMubGVuZ3RoICk7XG5cdFx0XHRtYXBwZXIgPSBmdW5jdGlvbiggc3RhciwgaSApIHtcblx0XHRcdFx0cmV0dXJuIHN0YXIgPyAnKicgOiBrZXlzWyBpIF07XG5cdFx0XHR9O1xuXHRcdFx0cmVzdWx0ID0gc3Rhck1hcC5tYXAoIGZ1bmN0aW9uKCBtYXNrICkge1xuXHRcdFx0XHRyZXR1cm4gbWFzay5tYXAoIG1hcHBlciApLmpvaW4oICcuJyApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbGwgdGhlIHBvc3NpYmxlIHRydWUvZmFsc2UgY29tYmluYXRpb25zIGZvclxuXHRcdC8vIGEgZ2l2ZW4gbnVtYmVyIC0gZS5nLiBmb3IgdHdvLCB0aGUgcG9zc2libGUgY29tYmluYXRpb25zIGFyZVxuXHRcdC8vIFsgdHJ1ZSwgdHJ1ZSBdLCBbIHRydWUsIGZhbHNlIF0sIFsgZmFsc2UsIHRydWUgXSwgWyBmYWxzZSwgZmFsc2UgXS5cblx0XHQvLyBJdCBkb2VzIHNvIGJ5IGdldHRpbmcgYWxsIHRoZSBiaW5hcnkgdmFsdWVzIGJldHdlZW4gMCBhbmQgZS5nLiAxMVxuXHRcdGZ1bmN0aW9uIGdldFN0YXJNYXAoIGxlbmd0aCApIHtcblx0XHRcdHZhciBvbmVzID0gJycsXG5cdFx0XHRcdG1heCwgYmluYXJ5LCBzdGFyTWFwLCBtYXBwZXIsIGk7XG5cdFx0XHRpZiAoICFzdGFyTWFwc1sgbGVuZ3RoIF0gKSB7XG5cdFx0XHRcdHN0YXJNYXAgPSBbXTtcblx0XHRcdFx0d2hpbGUgKCBvbmVzLmxlbmd0aCA8IGxlbmd0aCApIHtcblx0XHRcdFx0XHRvbmVzICs9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF4ID0gcGFyc2VJbnQoIG9uZXMsIDIgKTtcblx0XHRcdFx0bWFwcGVyID0gZnVuY3Rpb24oIGRpZ2l0ICkge1xuXHRcdFx0XHRcdHJldHVybiBkaWdpdCA9PT0gJzEnO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8PSBtYXg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRiaW5hcnkgPSBpLnRvU3RyaW5nKCAyICk7XG5cdFx0XHRcdFx0d2hpbGUgKCBiaW5hcnkubGVuZ3RoIDwgbGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0YmluYXJ5ID0gJzAnICsgYmluYXJ5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdGFyTWFwWyBpIF0gPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoIGJpbmFyeSwgbWFwcGVyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3Rhck1hcHNbIGxlbmd0aCBdID0gc3Rhck1hcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdGFyTWFwc1sgbGVuZ3RoIF07XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvYXBwbHlDaGFuZ2VzL25vdGlmeVBhdHRlcm5PYnNlcnZlcnMuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRhcHBseUNoYW5nZXNfbm90aWZ5UGF0dGVybk9ic2VydmVycyA9IGZ1bmN0aW9uKCBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGxhc3RLZXkgPSAvW15cXC5dKyQvO1xuXHRcdF9fZXhwb3J0ID0gbm90aWZ5UGF0dGVybk9ic2VydmVycztcblxuXHRcdGZ1bmN0aW9uIG5vdGlmeVBhdHRlcm5PYnNlcnZlcnMoIHZpZXdtb2RlbCwga2V5cGF0aCwgb25seURpcmVjdCApIHtcblx0XHRcdHZhciBwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXM7XG5cdFx0XHR1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnMoIHZpZXdtb2RlbCwga2V5cGF0aCApO1xuXHRcdFx0aWYgKCBvbmx5RGlyZWN0ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgPSBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoIGtleXBhdGggKTtcblx0XHRcdHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcy5mb3JFYWNoKCBmdW5jdGlvbiggdXBzdHJlYW1QYXR0ZXJuICkge1xuXHRcdFx0XHRjYXNjYWRlKCB2aWV3bW9kZWwsIHVwc3RyZWFtUGF0dGVybiwga2V5cGF0aCApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNhc2NhZGUoIHZpZXdtb2RlbCwgdXBzdHJlYW1QYXR0ZXJuLCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGdyb3VwLCBtYXAsIGFjdHVhbENoaWxkS2V5cGF0aDtcblx0XHRcdGdyb3VwID0gdmlld21vZGVsLmRlcHNNYXAucGF0dGVybk9ic2VydmVycztcblx0XHRcdG1hcCA9IGdyb3VwWyB1cHN0cmVhbVBhdHRlcm4gXTtcblx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRtYXAuZm9yRWFjaCggZnVuY3Rpb24oIGNoaWxkS2V5cGF0aCApIHtcblx0XHRcdFx0XHR2YXIga2V5ID0gbGFzdEtleS5leGVjKCBjaGlsZEtleXBhdGggKVsgMCBdO1xuXHRcdFx0XHRcdC8vICdiYXonXG5cdFx0XHRcdFx0YWN0dWFsQ2hpbGRLZXlwYXRoID0ga2V5cGF0aCA/IGtleXBhdGggKyAnLicgKyBrZXkgOiBrZXk7XG5cdFx0XHRcdFx0Ly8gJ2Zvby5iYXIuYmF6J1xuXHRcdFx0XHRcdHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyggdmlld21vZGVsLCBhY3R1YWxDaGlsZEtleXBhdGggKTtcblx0XHRcdFx0XHRjYXNjYWRlKCB2aWV3bW9kZWwsIGNoaWxkS2V5cGF0aCwgYWN0dWFsQ2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnMoIHZpZXdtb2RlbCwga2V5cGF0aCApIHtcblx0XHRcdHZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBvYnNlcnZlciApIHtcblx0XHRcdFx0aWYgKCBvYnNlcnZlci5yZWdleC50ZXN0KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0b2JzZXJ2ZXIudXBkYXRlKCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzX2dldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvYXBwbHlDaGFuZ2VzLmpzICovXG5cdHZhciB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzID0gZnVuY3Rpb24oIGdldFVwc3RyZWFtQ2hhbmdlcywgbm90aWZ5UGF0dGVybk9ic2VydmVycyApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRhcHBseUNoYW5nZXMoKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdFx0Y2hhbmdlcywgdXBzdHJlYW1DaGFuZ2VzLCBoYXNoID0ge307XG5cdFx0XHRjaGFuZ2VzID0gdGhpcy5jaGFuZ2VzO1xuXHRcdFx0aWYgKCAhY2hhbmdlcy5sZW5ndGggKSB7XG5cdFx0XHRcdC8vIFRPRE8gd2UgZW5kIHVwIGhlcmUgb24gaW5pdGlhbCByZW5kZXIuIFBlcmhhcHMgd2Ugc2hvdWxkbid0P1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNhc2NhZGUoIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBtYXAsIGRlcGVuZGFudHMsIGtleXM7XG5cdFx0XHRcdGlmICggc2VsZi5ub0Nhc2NhZGUuaGFzT3duUHJvcGVydHkoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBkZXBlbmRhbnRzID0gc2VsZi5kZXBzLmNvbXB1dGVkWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0ZGVwZW5kYW50cy5mb3JFYWNoKCBpbnZhbGlkYXRlICk7XG5cdFx0XHRcdFx0a2V5cyA9IGRlcGVuZGFudHMubWFwKCBnZXRLZXkgKTtcblx0XHRcdFx0XHRrZXlzLmZvckVhY2goIG1hcmsgKTtcblx0XHRcdFx0XHRrZXlzLmZvckVhY2goIGNhc2NhZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1hcCA9IHNlbGYuZGVwc01hcC5jb21wdXRlZFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdG1hcC5mb3JFYWNoKCBjYXNjYWRlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gbWFyaygga2V5cGF0aCApIHtcblx0XHRcdFx0c2VsZi5tYXJrKCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0XHRjaGFuZ2VzLmZvckVhY2goIGNhc2NhZGUgKTtcblx0XHRcdHVwc3RyZWFtQ2hhbmdlcyA9IGdldFVwc3RyZWFtQ2hhbmdlcyggY2hhbmdlcyApO1xuXHRcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgZGVwZW5kYW50cywga2V5cztcblx0XHRcdFx0aWYgKCBkZXBlbmRhbnRzID0gc2VsZi5kZXBzLmNvbXB1dGVkWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0ZGVwZW5kYW50cy5mb3JFYWNoKCBpbnZhbGlkYXRlICk7XG5cdFx0XHRcdFx0a2V5cyA9IGRlcGVuZGFudHMubWFwKCBnZXRLZXkgKTtcblx0XHRcdFx0XHRrZXlzLmZvckVhY2goIG1hcmsgKTtcblx0XHRcdFx0XHRrZXlzLmZvckVhY2goIGNhc2NhZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5jaGFuZ2VzID0gW107XG5cdFx0XHQvLyBQYXR0ZXJuIG9ic2VydmVycyBhcmUgYSB3ZWlyZCBzcGVjaWFsIGNhc2Vcblx0XHRcdGlmICggdGhpcy5wYXR0ZXJuT2JzZXJ2ZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKCB0aGlzJDAsIGtleXBhdGgsIHRydWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRjaGFuZ2VzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKCB0aGlzJDAsIGtleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmRlcHMub2JzZXJ2ZXJzICkge1xuXHRcdFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vdGlmeVVwc3RyZWFtRGVwZW5kYW50cyggdGhpcyQwLCBudWxsLCBrZXlwYXRoLCAnb2JzZXJ2ZXJzJyApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdG5vdGlmeUFsbERlcGVuZGFudHMoIHRoaXMsIGNoYW5nZXMsICdvYnNlcnZlcnMnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZGVwc1sgJ2RlZmF1bHQnIF0gKSB7XG5cdFx0XHRcdHZhciBiaW5kaW5ncyA9IFtdO1xuXHRcdFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vdGlmeVVwc3RyZWFtRGVwZW5kYW50cyggdGhpcyQwLCBiaW5kaW5ncywga2V5cGF0aCwgJ2RlZmF1bHQnICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0aWYgKCBiaW5kaW5ncy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0bm90aWZ5QmluZGluZ3MoIHRoaXMsIGJpbmRpbmdzLCBjaGFuZ2VzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bm90aWZ5QWxsRGVwZW5kYW50cyggdGhpcywgY2hhbmdlcywgJ2RlZmF1bHQnICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBSZXR1cm4gYSBoYXNoIG9mIGtleXBhdGhzIHRvIHVwZGF0ZWQgdmFsdWVzXG5cdFx0XHRjaGFuZ2VzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRoYXNoWyBrZXlwYXRoIF0gPSB0aGlzJDAuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLmltcGxpY2l0Q2hhbmdlcyA9IHt9O1xuXHRcdFx0dGhpcy5ub0Nhc2NhZGUgPSB7fTtcblx0XHRcdHJldHVybiBoYXNoO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpbnZhbGlkYXRlKCBjb21wdXRhdGlvbiApIHtcblx0XHRcdGNvbXB1dGF0aW9uLmludmFsaWRhdGUoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRLZXkoIGNvbXB1dGF0aW9uICkge1xuXHRcdFx0cmV0dXJuIGNvbXB1dGF0aW9uLmtleTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBub3RpZnlVcHN0cmVhbURlcGVuZGFudHMoIHZpZXdtb2RlbCwgYmluZGluZ3MsIGtleXBhdGgsIGdyb3VwTmFtZSApIHtcblx0XHRcdHZhciBkZXBlbmRhbnRzLCB2YWx1ZTtcblx0XHRcdGlmICggZGVwZW5kYW50cyA9IGZpbmREZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSApICkge1xuXHRcdFx0XHR2YWx1ZSA9IHZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0ZGVwZW5kYW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZCApIHtcblx0XHRcdFx0XHQvLyBkb24ndCBcInNldFwiIHRoZSBwYXJlbnQgdmFsdWUsIHJlZmluZSBpdFxuXHRcdFx0XHRcdC8vIGkuZS4gbm90IGRhdGEgPSB2YWx1ZSwgYnV0IGRhdGFbZm9vXSA9IGZvb1ZhbHVlXG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5ncyAmJiBkLnJlZmluZVZhbHVlICkge1xuXHRcdFx0XHRcdFx0YmluZGluZ3MucHVzaCggZCApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkLnNldFZhbHVlKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5vdGlmeUJpbmRpbmdzKCB2aWV3bW9kZWwsIGJpbmRpbmdzLCBjaGFuZ2VzICkge1xuXHRcdFx0YmluZGluZ3MuZm9yRWFjaCggZnVuY3Rpb24oIGJpbmRpbmcgKSB7XG5cdFx0XHRcdHZhciB1c2VTZXQgPSBmYWxzZSxcblx0XHRcdFx0XHRpID0gMCxcblx0XHRcdFx0XHRsZW5ndGggPSBjaGFuZ2VzLmxlbmd0aCxcblx0XHRcdFx0XHRyZWZpbmVtZW50cyA9IFtdO1xuXHRcdFx0XHR3aGlsZSAoIGkgPCBsZW5ndGggKSB7XG5cdFx0XHRcdFx0dmFyIGtleXBhdGggPSBjaGFuZ2VzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBrZXlwYXRoID09PSBiaW5kaW5nLmtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHR1c2VTZXQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgga2V5cGF0aC5zbGljZSggMCwgYmluZGluZy5rZXlwYXRoLmxlbmd0aCApID09PSBiaW5kaW5nLmtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHRyZWZpbmVtZW50cy5wdXNoKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGkrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHVzZVNldCApIHtcblx0XHRcdFx0XHRiaW5kaW5nLnNldFZhbHVlKCB2aWV3bW9kZWwuZ2V0KCBiaW5kaW5nLmtleXBhdGggKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggcmVmaW5lbWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGJpbmRpbmcucmVmaW5lVmFsdWUoIHJlZmluZW1lbnRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBub3RpZnlBbGxEZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGtleXBhdGhzLCBncm91cE5hbWUgKSB7XG5cdFx0XHR2YXIgcXVldWUgPSBbXTtcblx0XHRcdGFkZEtleXBhdGhzKCBrZXlwYXRocyApO1xuXHRcdFx0cXVldWUuZm9yRWFjaCggZGlzcGF0Y2ggKTtcblxuXHRcdFx0ZnVuY3Rpb24gYWRkS2V5cGF0aHMoIGtleXBhdGhzICkge1xuXHRcdFx0XHRrZXlwYXRocy5mb3JFYWNoKCBhZGRLZXlwYXRoICk7XG5cdFx0XHRcdGtleXBhdGhzLmZvckVhY2goIGNhc2NhZGUgKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYWRkS2V5cGF0aCgga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGRlcHMgPSBmaW5kRGVwZW5kYW50cyggdmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUgKTtcblx0XHRcdFx0aWYgKCBkZXBzICkge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIHtcblx0XHRcdFx0XHRcdGtleXBhdGg6IGtleXBhdGgsXG5cdFx0XHRcdFx0XHRkZXBzOiBkZXBzXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNhc2NhZGUoIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBjaGlsZERlcHM7XG5cdFx0XHRcdGlmICggY2hpbGREZXBzID0gdmlld21vZGVsLmRlcHNNYXBbIGdyb3VwTmFtZSBdWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0YWRkS2V5cGF0aHMoIGNoaWxkRGVwcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGRpc3BhdGNoKCBzZXQgKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHZpZXdtb2RlbC5nZXQoIHNldC5rZXlwYXRoICk7XG5cdFx0XHRcdHNldC5kZXBzLmZvckVhY2goIGZ1bmN0aW9uKCBkICkge1xuXHRcdFx0XHRcdHJldHVybiBkLnNldFZhbHVlKCB2YWx1ZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmluZERlcGVuZGFudHMoIHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lICkge1xuXHRcdFx0dmFyIGdyb3VwID0gdmlld21vZGVsLmRlcHNbIGdyb3VwTmFtZSBdO1xuXHRcdFx0cmV0dXJuIGdyb3VwID8gZ3JvdXBbIGtleXBhdGggXSA6IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSggZ2V0VXBzdHJlYW1DaGFuZ2VzLCB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzX25vdGlmeVBhdHRlcm5PYnNlcnZlcnMgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2NhcHR1cmUuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRjYXB0dXJlID0gZnVuY3Rpb24gVmlld21vZGVsJGNhcHR1cmUoKSB7XG5cdFx0dGhpcy5jYXB0dXJlR3JvdXBzLnB1c2goIFtdICk7XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9jbGVhckNhY2hlLmpzICovXG5cdHZhciB2aWV3bW9kZWwkY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRjbGVhckNhY2hlKCBrZXlwYXRoLCBkb250VGVhcmRvd25XcmFwcGVyICkge1xuXHRcdHZhciBjYWNoZU1hcCwgd3JhcHBlcjtcblx0XHRpZiAoICFkb250VGVhcmRvd25XcmFwcGVyICkge1xuXHRcdFx0Ly8gSXMgdGhlcmUgYSB3cmFwcGVkIHByb3BlcnR5IGF0IHRoaXMga2V5cGF0aD9cblx0XHRcdGlmICggd3JhcHBlciA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHQvLyBEaWQgd2UgdW53cmFwIGl0P1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIudGVhcmRvd24oKSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Ly8gSXMgdGhpcyByaWdodD9cblx0XHRcdFx0XHQvLyBXaGF0J3MgdGhlIG1lYW5pbmcgb2YgcmV0dXJuaW5nIGZhbHNlIGZyb20gdGVhcmRvd24/XG5cdFx0XHRcdFx0Ly8gQ291bGQgdGhlcmUgYmUgYSBHQyByYW1pZmljYXRpb24gaWYgdGhpcyBpcyBhIFwicmVhbFwiIHJhY3RpdmUudGVhcmRvd24oKT9cblx0XHRcdFx0XHR0aGlzLndyYXBwZWRbIGtleXBhdGggXSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5jYWNoZVsga2V5cGF0aCBdID0gdW5kZWZpbmVkO1xuXHRcdGlmICggY2FjaGVNYXAgPSB0aGlzLmNhY2hlTWFwWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHR3aGlsZSAoIGNhY2hlTWFwLmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5jbGVhckNhY2hlKCBjYWNoZU1hcC5wb3AoKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvQ29tcHV0YXRpb24vZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUuanMgKi9cblx0dmFyIGdldENvbXB1dGF0aW9uU2lnbmF0dXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIHBhdHRlcm4gPSAvXFwkXFx7KFteXFx9XSspXFx9L2c7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiggc2lnbmF0dXJlICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc2lnbmF0dXJlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGdldDogc2lnbmF0dXJlXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBzaWduYXR1cmUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGdldDogY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKCBzaWduYXR1cmUgKVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2Ygc2lnbmF0dXJlID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2lnbmF0dXJlLmdldCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHNpZ25hdHVyZSA9IHtcblx0XHRcdFx0XHRnZXQ6IGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyggc2lnbmF0dXJlLmdldCApLFxuXHRcdFx0XHRcdHNldDogc2lnbmF0dXJlLnNldFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNpZ25hdHVyZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKCBzaWduYXR1cmUgKSB7XG5cdFx0XHR2YXIgZnVuY3Rpb25Cb2R5ID0gJ3ZhciBfX3JhY3RpdmU9dGhpcztyZXR1cm4oJyArIHNpZ25hdHVyZS5yZXBsYWNlKCBwYXR0ZXJuLCBmdW5jdGlvbiggbWF0Y2gsIGtleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybiAnX19yYWN0aXZlLmdldChcIicgKyBrZXlwYXRoICsgJ1wiKSc7XG5cdFx0XHR9ICkgKyAnKSc7XG5cdFx0XHRyZXR1cm4gbmV3IEZ1bmN0aW9uKCBmdW5jdGlvbkJvZHkgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL0NvbXB1dGF0aW9uL0NvbXB1dGF0aW9uLmpzICovXG5cdHZhciBDb21wdXRhdGlvbiA9IGZ1bmN0aW9uKCBsb2csIGlzRXF1YWwgKSB7XG5cblx0XHR2YXIgQ29tcHV0YXRpb24gPSBmdW5jdGlvbiggcmFjdGl2ZSwga2V5LCBzaWduYXR1cmUgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLnZpZXdtb2RlbCA9IHJhY3RpdmUudmlld21vZGVsO1xuXHRcdFx0dGhpcy5rZXkgPSBrZXk7XG5cdFx0XHR0aGlzLmdldHRlciA9IHNpZ25hdHVyZS5nZXQ7XG5cdFx0XHR0aGlzLnNldHRlciA9IHNpZ25hdHVyZS5zZXQ7XG5cdFx0XHR0aGlzLmhhcmREZXBzID0gc2lnbmF0dXJlLmRlcHMgfHwgW107XG5cdFx0XHR0aGlzLnNvZnREZXBzID0gW107XG5cdFx0XHR0aGlzLmRlcFZhbHVlcyA9IHt9O1xuXHRcdFx0aWYgKCB0aGlzLmhhcmREZXBzICkge1xuXHRcdFx0XHR0aGlzLmhhcmREZXBzLmZvckVhY2goIGZ1bmN0aW9uKCBkICkge1xuXHRcdFx0XHRcdHJldHVybiByYWN0aXZlLnZpZXdtb2RlbC5yZWdpc3RlciggZCwgdGhpcyQwLCAnY29tcHV0ZWQnICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2RpcnR5ID0gdGhpcy5fZmlyc3RSdW4gPSB0cnVlO1xuXHRcdH07XG5cdFx0Q29tcHV0YXRpb24ucHJvdG90eXBlID0ge1xuXHRcdFx0Y29uc3RydWN0b3I6IENvbXB1dGF0aW9uLFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbml0aWFsO1xuXHRcdFx0XHR0aGlzLmJ5cGFzcyA9IHRydWU7XG5cdFx0XHRcdGluaXRpYWwgPSB0aGlzLnJhY3RpdmUudmlld21vZGVsLmdldCggdGhpcy5rZXkgKTtcblx0XHRcdFx0dGhpcy5yYWN0aXZlLnZpZXdtb2RlbC5jbGVhckNhY2hlKCB0aGlzLmtleSApO1xuXHRcdFx0XHR0aGlzLmJ5cGFzcyA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoIHRoaXMuc2V0dGVyICYmIGluaXRpYWwgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLnNldCggaW5pdGlhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aW52YWxpZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0dmFyIHJhY3RpdmUsIG5ld0RlcHMsIGRlcGVuZGVuY2llc0NoYW5nZWQsIGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRcdGlmICggdGhpcy5nZXR0aW5nICkge1xuXHRcdFx0XHRcdC8vIHByZXZlbnQgZG91YmxlLWNvbXB1dGF0aW9uIChlLmcuIGNhdXNlZCBieSBhcnJheSBtdXRhdGlvbiBpbnNpZGUgY29tcHV0YXRpb24pXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZ2V0dGluZyA9IHRydWU7XG5cdFx0XHRcdGlmICggdGhpcy5fZGlydHkgKSB7XG5cdFx0XHRcdFx0cmFjdGl2ZSA9IHRoaXMucmFjdGl2ZTtcblx0XHRcdFx0XHQvLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgaW5wdXRzIGhhdmUgY2hhbmdlZCwgaW4gY2FzZSB0aGlzIGRlcGVuZHMgb25cblx0XHRcdFx0XHQvLyBvdGhlciBjb21wdXRlZCB2YWx1ZXNcblx0XHRcdFx0XHRpZiAoIHRoaXMuX2ZpcnN0UnVuIHx8ICF0aGlzLmhhcmREZXBzLmxlbmd0aCAmJiAhdGhpcy5zb2Z0RGVwcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0dGhpcy5oYXJkRGVwcyxcblx0XHRcdFx0XHRcdFx0dGhpcy5zb2Z0RGVwc1xuXHRcdFx0XHRcdFx0XS5mb3JFYWNoKCBmdW5jdGlvbiggZGVwcyApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGtleXBhdGgsIHZhbHVlLCBpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpID0gZGVwcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRcdGtleXBhdGggPSBkZXBzWyBpIF07XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSByYWN0aXZlLnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFpc0VxdWFsKCB2YWx1ZSwgdGhpcyQwLmRlcFZhbHVlc1sga2V5cGF0aCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzJDAuZGVwVmFsdWVzWyBrZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCApIHtcblx0XHRcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLmNhcHR1cmUoKTtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKCByYWN0aXZlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdmYWlsZWRDb21wdXRhdGlvbicsXG5cdFx0XHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0a2V5OiB0aGlzLmtleSxcblx0XHRcdFx0XHRcdFx0XHRcdGVycjogZXJyLm1lc3NhZ2UgfHwgZXJyXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2b2lkIDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRuZXdEZXBzID0gcmFjdGl2ZS52aWV3bW9kZWwucmVsZWFzZSgpO1xuXHRcdFx0XHRcdFx0ZGVwZW5kZW5jaWVzQ2hhbmdlZCA9IHRoaXMudXBkYXRlRGVwZW5kZW5jaWVzKCBuZXdEZXBzICk7XG5cdFx0XHRcdFx0XHRpZiAoIGRlcGVuZGVuY2llc0NoYW5nZWQgKSB7XG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmhhcmREZXBzLFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc29mdERlcHNcblx0XHRcdFx0XHRcdFx0XS5mb3JFYWNoKCBmdW5jdGlvbiggZGVwcyApIHtcblx0XHRcdFx0XHRcdFx0XHRkZXBzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcyQwLmRlcFZhbHVlc1sga2V5cGF0aCBdID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5nZXR0aW5nID0gdGhpcy5fZmlyc3RSdW4gPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5zZXR0aW5nICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhdGhpcy5zZXR0ZXIgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ29tcHV0ZWQgcHJvcGVydGllcyB3aXRob3V0IHNldHRlcnMgYXJlIHJlYWQtb25seS4gKFRoaXMgbWF5IGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJhY3RpdmUhKScgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnNldHRlci5jYWxsKCB0aGlzLnJhY3RpdmUsIHZhbHVlICk7XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlRGVwZW5kZW5jaWVzOiBmdW5jdGlvbiggbmV3RGVwcyApIHtcblx0XHRcdFx0dmFyIGksIG9sZERlcHMsIGtleXBhdGgsIGRlcGVuZGVuY2llc0NoYW5nZWQ7XG5cdFx0XHRcdG9sZERlcHMgPSB0aGlzLnNvZnREZXBzO1xuXHRcdFx0XHQvLyByZW1vdmUgZGVwZW5kZW5jaWVzIHRoYXQgYXJlIG5vIGxvbmdlciB1c2VkXG5cdFx0XHRcdGkgPSBvbGREZXBzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0a2V5cGF0aCA9IG9sZERlcHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIG5ld0RlcHMuaW5kZXhPZigga2V5cGF0aCApID09PSAtMSApIHtcblx0XHRcdFx0XHRcdGRlcGVuZGVuY2llc0NoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwudW5yZWdpc3Rlcigga2V5cGF0aCwgdGhpcywgJ2NvbXB1dGVkJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBjcmVhdGUgcmVmZXJlbmNlcyBmb3IgYW55IG5ldyBkZXBlbmRlbmNpZXNcblx0XHRcdFx0aSA9IG5ld0RlcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRrZXlwYXRoID0gbmV3RGVwc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggb2xkRGVwcy5pbmRleE9mKCBrZXlwYXRoICkgPT09IC0xICYmICggIXRoaXMuaGFyZERlcHMgfHwgdGhpcy5oYXJkRGVwcy5pbmRleE9mKCBrZXlwYXRoICkgPT09IC0xICkgKSB7XG5cdFx0XHRcdFx0XHRkZXBlbmRlbmNpZXNDaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnJlZ2lzdGVyKCBrZXlwYXRoLCB0aGlzLCAnY29tcHV0ZWQnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZGVwZW5kZW5jaWVzQ2hhbmdlZCApIHtcblx0XHRcdFx0XHR0aGlzLnNvZnREZXBzID0gbmV3RGVwcy5zbGljZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBkZXBlbmRlbmNpZXNDaGFuZ2VkO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIENvbXB1dGF0aW9uO1xuXHR9KCBsb2csIGlzRXF1YWwgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2NvbXB1dGUuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRjb21wdXRlID0gZnVuY3Rpb24oIGdldENvbXB1dGF0aW9uU2lnbmF0dXJlLCBDb21wdXRhdGlvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBWaWV3bW9kZWwkY29tcHV0ZSgga2V5LCBzaWduYXR1cmUgKSB7XG5cdFx0XHRzaWduYXR1cmUgPSBnZXRDb21wdXRhdGlvblNpZ25hdHVyZSggc2lnbmF0dXJlICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb21wdXRhdGlvbnNbIGtleSBdID0gbmV3IENvbXB1dGF0aW9uKCB0aGlzLnJhY3RpdmUsIGtleSwgc2lnbmF0dXJlICk7XG5cdFx0fTtcblx0fSggZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUsIENvbXB1dGF0aW9uICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQvRkFJTEVEX0xPT0tVUC5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9GQUlMRURfTE9PS1VQID0ge1xuXHRcdEZBSUxFRF9MT09LVVA6IHRydWVcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9VbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5LmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X1VucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kgPSBmdW5jdGlvbiggcmVtb3ZlRnJvbUFycmF5LCBydW5sb29wICkge1xuXG5cdFx0dmFyIGVtcHR5ID0ge307XG5cdFx0dmFyIFVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kgPSBmdW5jdGlvbiggdmlld21vZGVsLCBrZXlwYXRoICkge1xuXHRcdFx0dGhpcy52aWV3bW9kZWwgPSB2aWV3bW9kZWw7XG5cdFx0XHR0aGlzLnJvb3QgPSB2aWV3bW9kZWwucmFjdGl2ZTtcblx0XHRcdC8vIFRPRE8gZWxpbWluYXRlIHRoaXNcblx0XHRcdHRoaXMucmVmID0ga2V5cGF0aDtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBlbXB0eTtcblx0XHRcdHZpZXdtb2RlbC51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXNbIGtleXBhdGggXSA9IHRydWU7XG5cdFx0XHR2aWV3bW9kZWwudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzLnB1c2goIHRoaXMgKTtcblx0XHRcdHJ1bmxvb3AuYWRkVW5yZXNvbHZlZCggdGhpcyApO1xuXHRcdH07XG5cdFx0VW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeS5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZXNvbHZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy52aWV3bW9kZWwubWFyayggdGhpcy5yZWYgKTtcblx0XHRcdFx0dGhpcy52aWV3bW9kZWwudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzWyB0aGlzLnJlZiBdID0gZmFsc2U7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy52aWV3bW9kZWwudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzLCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRydW5sb29wLnJlbW92ZVVucmVzb2x2ZWQoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBVbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5O1xuXHR9KCByZW1vdmVGcm9tQXJyYXksIHJ1bmxvb3AgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldCA9IGZ1bmN0aW9uKCBpc051bWVyaWMsIEZBSUxFRF9MT09LVVAsIFVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIGVtcHR5ID0ge307XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkZ2V0KCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDEgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IGVtcHR5O1xuXHRcdFx0dmFyIHJhY3RpdmUgPSB0aGlzLnJhY3RpdmUsXG5cdFx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSxcblx0XHRcdFx0dmFsdWUsIGNvbXB1dGF0aW9uLCB3cmFwcGVkLCBjYXB0dXJlR3JvdXA7XG5cdFx0XHRpZiAoIGtleXBhdGhbIDAgXSA9PT0gJ0AnICkge1xuXHRcdFx0XHR2YWx1ZSA9IGtleXBhdGguc2xpY2UoIDEgKTtcblx0XHRcdFx0cmV0dXJuIGlzTnVtZXJpYyggdmFsdWUgKSA/ICt2YWx1ZSA6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBjYWNoZVsga2V5cGF0aCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIElzIHRoaXMgYSBjb21wdXRlZCBwcm9wZXJ0eT9cblx0XHRcdFx0aWYgKCAoIGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNbIGtleXBhdGggXSApICYmICFjb21wdXRhdGlvbi5ieXBhc3MgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjb21wdXRhdGlvbi5nZXQoKTtcblx0XHRcdFx0XHR0aGlzLmFkYXB0KCBrZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB3cmFwcGVkID0gdGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB3cmFwcGVkLnZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAha2V5cGF0aCApIHtcblx0XHRcdFx0XHR0aGlzLmFkYXB0KCAnJywgcmFjdGl2ZS5kYXRhICk7XG5cdFx0XHRcdFx0dmFsdWUgPSByYWN0aXZlLmRhdGE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSByZXRyaWV2ZSggdGhpcywga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhY2hlWyBrZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbHVlID0gY2FjaGVbIGtleXBhdGggXTtcblx0XHRcdH1cblx0XHRcdGlmICggb3B0aW9ucy5ldmFsdWF0ZVdyYXBwZWQgJiYgKCB3cmFwcGVkID0gdGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gKSApIHtcblx0XHRcdFx0dmFsdWUgPSB3cmFwcGVkLmdldCgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY2FwdHVyZSB0aGUga2V5cGF0aCwgaWYgd2UncmUgaW5zaWRlIGEgY29tcHV0YXRpb25cblx0XHRcdGlmICggb3B0aW9ucy5jYXB0dXJlICYmICggY2FwdHVyZUdyb3VwID0gdGhpcy5jYXB0dXJlR3JvdXBzWyB0aGlzLmNhcHR1cmVHcm91cHMubGVuZ3RoIC0gMSBdICkgKSB7XG5cdFx0XHRcdGlmICggIX5jYXB0dXJlR3JvdXAuaW5kZXhPZigga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdGNhcHR1cmVHcm91cC5wdXNoKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0Ly8gaWYgd2UgY291bGRuJ3QgcmVzb2x2ZSB0aGUga2V5cGF0aCwgd2UgbmVlZCB0byBtYWtlIGl0IGFzIGEgZmFpbGVkXG5cdFx0XHRcdFx0Ly8gbG9va3VwLCBzbyB0aGF0IHRoZSBjb21wdXRhdGlvbiB1cGRhdGVzIGNvcnJlY3RseSBvbmNlIHdlIENBTlxuXHRcdFx0XHRcdC8vIHJlc29sdmUgdGhlIGtleXBhdGhcblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBGQUlMRURfTE9PS1VQICYmIHRoaXMudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzWyBrZXlwYXRoIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRuZXcgVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSggdGhpcywga2V5cGF0aCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlID09PSBGQUlMRURfTE9PS1VQID8gdm9pZCAwIDogdmFsdWU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJldHJpZXZlKCB2aWV3bW9kZWwsIGtleXBhdGggKSB7XG5cdFx0XHR2YXIga2V5cywga2V5LCBwYXJlbnRLZXlwYXRoLCBwYXJlbnRWYWx1ZSwgY2FjaGVNYXAsIHZhbHVlLCB3cmFwcGVkO1xuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0a2V5ID0ga2V5cy5wb3AoKTtcblx0XHRcdHBhcmVudEtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0cGFyZW50VmFsdWUgPSB2aWV3bW9kZWwuZ2V0KCBwYXJlbnRLZXlwYXRoICk7XG5cdFx0XHRpZiAoIHdyYXBwZWQgPSB2aWV3bW9kZWwud3JhcHBlZFsgcGFyZW50S2V5cGF0aCBdICkge1xuXHRcdFx0XHRwYXJlbnRWYWx1ZSA9IHdyYXBwZWQuZ2V0KCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHBhcmVudFZhbHVlID09PSBudWxsIHx8IHBhcmVudFZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIHVwZGF0ZSBjYWNoZSBtYXBcblx0XHRcdGlmICggISggY2FjaGVNYXAgPSB2aWV3bW9kZWwuY2FjaGVNYXBbIHBhcmVudEtleXBhdGggXSApICkge1xuXHRcdFx0XHR2aWV3bW9kZWwuY2FjaGVNYXBbIHBhcmVudEtleXBhdGggXSA9IFsga2V5cGF0aCBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCBjYWNoZU1hcC5pbmRleE9mKCBrZXlwYXRoICkgPT09IC0xICkge1xuXHRcdFx0XHRcdGNhY2hlTWFwLnB1c2goIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgdGhpcyBwcm9wZXJ0eSBkb2Vzbid0IGV4aXN0LCB3ZSByZXR1cm4gYSBzZW50aW5lbCB2YWx1ZVxuXHRcdFx0Ly8gc28gdGhhdCB3ZSBrbm93IHRvIHF1ZXJ5IHBhcmVudCBzY29wZSAoaWYgc3VjaCB0aGVyZSBiZSlcblx0XHRcdGlmICggdHlwZW9mIHBhcmVudFZhbHVlID09PSAnb2JqZWN0JyAmJiAhKCBrZXkgaW4gcGFyZW50VmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHZpZXdtb2RlbC5jYWNoZVsga2V5cGF0aCBdID0gRkFJTEVEX0xPT0tVUDtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gcGFyZW50VmFsdWVbIGtleSBdO1xuXHRcdFx0Ly8gRG8gd2UgaGF2ZSBhbiBhZGFwdG9yIGZvciB0aGlzIHZhbHVlP1xuXHRcdFx0dmlld21vZGVsLmFkYXB0KCBrZXlwYXRoLCB2YWx1ZSwgZmFsc2UgKTtcblx0XHRcdC8vIFVwZGF0ZSBjYWNoZVxuXHRcdFx0dmlld21vZGVsLmNhY2hlWyBrZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBpc051bWVyaWMsIHZpZXdtb2RlbCRnZXRfRkFJTEVEX0xPT0tVUCwgdmlld21vZGVsJGdldF9VbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aWV3bW9kZWwkaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVmlld21vZGVsJGluaXQoKSB7XG5cdFx0XHR2YXIga2V5LCBjb21wdXRhdGlvbiwgY29tcHV0YXRpb25zID0gW107XG5cdFx0XHRmb3IgKCBrZXkgaW4gdGhpcy5yYWN0aXZlLmNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0ZSgga2V5LCB0aGlzLnJhY3RpdmUuY29tcHV0ZWRbIGtleSBdICk7XG5cdFx0XHRcdGNvbXB1dGF0aW9ucy5wdXNoKCBjb21wdXRhdGlvbiApO1xuXHRcdFx0fVxuXHRcdFx0Y29tcHV0YXRpb25zLmZvckVhY2goIGluaXQgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaW5pdCggY29tcHV0YXRpb24gKSB7XG5cdFx0XHRjb21wdXRhdGlvbi5pbml0KCk7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvbWFyay5qcyAqL1xuXHR2YXIgdmlld21vZGVsJG1hcmsgPSBmdW5jdGlvbiBWaWV3bW9kZWwkbWFyaygga2V5cGF0aCwgb3B0aW9ucyApIHtcblx0XHR2YXIgY29tcHV0YXRpb247XG5cdFx0Ly8gaW1wbGljaXQgY2hhbmdlcyAoaS5lLiBgZm9vLmxlbmd0aGAgb24gYHJhY3RpdmUucHVzaCgnZm9vJyw0MilgKVxuXHRcdC8vIHNob3VsZCBub3QgYmUgcGlja2VkIHVwIGJ5IHBhdHRlcm4gb2JzZXJ2ZXJzXG5cdFx0aWYgKCBvcHRpb25zICkge1xuXHRcdFx0aWYgKCBvcHRpb25zLmltcGxpY2l0ICkge1xuXHRcdFx0XHR0aGlzLmltcGxpY2l0Q2hhbmdlc1sga2V5cGF0aCBdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggb3B0aW9ucy5ub0Nhc2NhZGUgKSB7XG5cdFx0XHRcdHRoaXMubm9DYXNjYWRlWyBrZXlwYXRoIF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNbIGtleXBhdGggXSApIHtcblx0XHRcdGNvbXB1dGF0aW9uLmludmFsaWRhdGUoKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmNoYW5nZXMuaW5kZXhPZigga2V5cGF0aCApID09PSAtMSApIHtcblx0XHRcdHRoaXMuY2hhbmdlcy5wdXNoKCBrZXlwYXRoICk7XG5cdFx0fVxuXHRcdHRoaXMuY2xlYXJDYWNoZSgga2V5cGF0aCApO1xuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvbWVyZ2UvbWFwT2xkVG9OZXdJbmRleC5qcyAqL1xuXHR2YXIgdmlld21vZGVsJG1lcmdlX21hcE9sZFRvTmV3SW5kZXggPSBmdW5jdGlvbiggb2xkQXJyYXksIG5ld0FycmF5ICkge1xuXHRcdHZhciB1c2VkSW5kaWNlcywgZmlyc3RVbnVzZWRJbmRleCwgbmV3SW5kaWNlcywgY2hhbmdlZDtcblx0XHR1c2VkSW5kaWNlcyA9IHt9O1xuXHRcdGZpcnN0VW51c2VkSW5kZXggPSAwO1xuXHRcdG5ld0luZGljZXMgPSBvbGRBcnJheS5tYXAoIGZ1bmN0aW9uKCBpdGVtLCBpICkge1xuXHRcdFx0dmFyIGluZGV4LCBzdGFydCwgbGVuO1xuXHRcdFx0c3RhcnQgPSBmaXJzdFVudXNlZEluZGV4O1xuXHRcdFx0bGVuID0gbmV3QXJyYXkubGVuZ3RoO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRpbmRleCA9IG5ld0FycmF5LmluZGV4T2YoIGl0ZW0sIHN0YXJ0ICk7XG5cdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFydCA9IGluZGV4ICsgMTtcblx0XHRcdH0gd2hpbGUgKCB1c2VkSW5kaWNlc1sgaW5kZXggXSAmJiBzdGFydCA8IGxlbiApO1xuXHRcdFx0Ly8ga2VlcCB0cmFjayBvZiB0aGUgZmlyc3QgdW51c2VkIGluZGV4LCBzbyB3ZSBkb24ndCBzZWFyY2hcblx0XHRcdC8vIHRoZSB3aG9sZSBvZiBuZXdBcnJheSBmb3IgZWFjaCBpdGVtIGluIG9sZEFycmF5IHVubmVjZXNzYXJpbHlcblx0XHRcdGlmICggaW5kZXggPT09IGZpcnN0VW51c2VkSW5kZXggKSB7XG5cdFx0XHRcdGZpcnN0VW51c2VkSW5kZXggKz0gMTtcblx0XHRcdH1cblx0XHRcdGlmICggaW5kZXggIT09IGkgKSB7XG5cdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dXNlZEluZGljZXNbIGluZGV4IF0gPSB0cnVlO1xuXHRcdFx0cmV0dXJuIGluZGV4O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gbmV3SW5kaWNlcztcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL21lcmdlLmpzICovXG5cdHZhciB2aWV3bW9kZWwkbWVyZ2UgPSBmdW5jdGlvbiggd2FybiwgbWFwT2xkVG9OZXdJbmRleCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgY29tcGFyYXRvcnMgPSB7fTtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRtZXJnZSgga2V5cGF0aCwgY3VycmVudEFycmF5LCBhcnJheSwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBvbGRBcnJheSwgbmV3QXJyYXksIGNvbXBhcmF0b3IsIG5ld0luZGljZXM7XG5cdFx0XHR0aGlzLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmUgKSB7XG5cdFx0XHRcdGNvbXBhcmF0b3IgPSBnZXRDb21wYXJhdG9yRnVuY3Rpb24oIG9wdGlvbnMuY29tcGFyZSApO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5Lm1hcCggY29tcGFyYXRvciApO1xuXHRcdFx0XHRcdG5ld0FycmF5ID0gYXJyYXkubWFwKCBjb21wYXJhdG9yICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0Ly8gZmFsbGJhY2sgdG8gYW4gaWRlbnRpdHkgY2hlY2sgLSB3b3JzdCBjYXNlIHNjZW5hcmlvIHdlIGhhdmVcblx0XHRcdFx0XHQvLyB0byBkbyBtb3JlIERPTSBtYW5pcHVsYXRpb24gdGhhbiB3ZSB0aG91Z2h0Li4uXG5cdFx0XHRcdFx0Ly8gLi4udW5sZXNzIHdlJ3JlIGluIGRlYnVnIG1vZGUgb2YgY291cnNlXG5cdFx0XHRcdFx0aWYgKCB0aGlzLmRlYnVnICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR3YXJuKCAnTWVyZ2Ugb3BlcmF0aW9uOiBjb21wYXJpc29uIGZhaWxlZC4gRmFsbGluZyBiYWNrIHRvIGlkZW50aXR5IGNoZWNraW5nJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheTtcblx0XHRcdFx0XHRuZXdBcnJheSA9IGFycmF5O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheTtcblx0XHRcdFx0bmV3QXJyYXkgPSBhcnJheTtcblx0XHRcdH1cblx0XHRcdC8vIGZpbmQgbmV3IGluZGljZXMgZm9yIG1lbWJlcnMgb2Ygb2xkQXJyYXlcblx0XHRcdG5ld0luZGljZXMgPSBtYXBPbGRUb05ld0luZGV4KCBvbGRBcnJheSwgbmV3QXJyYXkgKTtcblx0XHRcdHRoaXMuc21hcnRVcGRhdGUoIGtleXBhdGgsIGFycmF5LCBuZXdJbmRpY2VzLCBjdXJyZW50QXJyYXkubGVuZ3RoICE9PSBhcnJheS5sZW5ndGggKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gc3RyaW5naWZ5KCBpdGVtICkge1xuXHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KCBpdGVtICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29tcGFyYXRvckZ1bmN0aW9uKCBjb21wYXJhdG9yICkge1xuXHRcdFx0Ly8gSWYgYGNvbXBhcmVgIGlzIGB0cnVlYCwgd2UgdXNlIEpTT04uc3RyaW5naWZ5IHRvIGNvbXBhcmVcblx0XHRcdC8vIG9iamVjdHMgdGhhdCBhcmUgdGhlIHNhbWUgc2hhcGUsIGJ1dCBub24taWRlbnRpY2FsIC0gaS5lLlxuXHRcdFx0Ly8geyBmb286ICdiYXInIH0gIT09IHsgZm9vOiAnYmFyJyB9XG5cdFx0XHRpZiAoIGNvbXBhcmF0b3IgPT09IHRydWUgKSB7XG5cdFx0XHRcdHJldHVybiBzdHJpbmdpZnk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBjb21wYXJhdG9yID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0aWYgKCAhY29tcGFyYXRvcnNbIGNvbXBhcmF0b3IgXSApIHtcblx0XHRcdFx0XHRjb21wYXJhdG9yc1sgY29tcGFyYXRvciBdID0gZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaXRlbVsgY29tcGFyYXRvciBdO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNvbXBhcmF0b3JzWyBjb21wYXJhdG9yIF07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBjb21wYXJhdG9yID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRyZXR1cm4gY29tcGFyYXRvcjtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RoZSBgY29tcGFyZWAgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbiwgb3IgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGlkZW50aWZ5aW5nIGZpZWxkIChvciBgdHJ1ZWAgdG8gdXNlIEpTT04uc3RyaW5naWZ5KScgKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB3YXJuLCB2aWV3bW9kZWwkbWVyZ2VfbWFwT2xkVG9OZXdJbmRleCApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvcmVnaXN0ZXIuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRyZWdpc3RlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVmlld21vZGVsJHJlZ2lzdGVyKCBrZXlwYXRoLCBkZXBlbmRhbnQgKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSBhcmd1bWVudHNbIDIgXTtcblx0XHRcdGlmICggZ3JvdXAgPT09IHZvaWQgMCApXG5cdFx0XHRcdGdyb3VwID0gJ2RlZmF1bHQnO1xuXHRcdFx0dmFyIGRlcHNCeUtleXBhdGgsIGRlcHM7XG5cdFx0XHRpZiAoIGRlcGVuZGFudC5pc1N0YXRpYyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZGVwc0J5S2V5cGF0aCA9IHRoaXMuZGVwc1sgZ3JvdXAgXSB8fCAoIHRoaXMuZGVwc1sgZ3JvdXAgXSA9IHt9ICk7XG5cdFx0XHRkZXBzID0gZGVwc0J5S2V5cGF0aFsga2V5cGF0aCBdIHx8ICggZGVwc0J5S2V5cGF0aFsga2V5cGF0aCBdID0gW10gKTtcblx0XHRcdGRlcHMucHVzaCggZGVwZW5kYW50ICk7XG5cdFx0XHRpZiAoICFrZXlwYXRoICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR1cGRhdGVEZXBlbmRhbnRzTWFwKCB0aGlzLCBrZXlwYXRoLCBncm91cCApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVEZXBlbmRhbnRzTWFwKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwICkge1xuXHRcdFx0dmFyIGtleXMsIHBhcmVudEtleXBhdGgsIG1hcCwgcGFyZW50O1xuXHRcdFx0Ly8gdXBkYXRlIGRlcGVuZGFudHMgbWFwXG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHR3aGlsZSAoIGtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHRwYXJlbnRLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0bWFwID0gdmlld21vZGVsLmRlcHNNYXBbIGdyb3VwIF0gfHwgKCB2aWV3bW9kZWwuZGVwc01hcFsgZ3JvdXAgXSA9IHt9ICk7XG5cdFx0XHRcdHBhcmVudCA9IG1hcFsgcGFyZW50S2V5cGF0aCBdIHx8ICggbWFwWyBwYXJlbnRLZXlwYXRoIF0gPSBbXSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudFsga2V5cGF0aCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cGFyZW50WyBrZXlwYXRoIF0gPSAwO1xuXHRcdFx0XHRcdHBhcmVudC5wdXNoKCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyZW50WyBrZXlwYXRoIF0gKz0gMTtcblx0XHRcdFx0a2V5cGF0aCA9IHBhcmVudEtleXBhdGg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvcmVsZWFzZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHJlbGVhc2UgPSBmdW5jdGlvbiBWaWV3bW9kZWwkcmVsZWFzZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5jYXB0dXJlR3JvdXBzLnBvcCgpO1xuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvc2V0LmpzICovXG5cdHZhciB2aWV3bW9kZWwkc2V0ID0gZnVuY3Rpb24oIGlzRXF1YWwsIGNyZWF0ZUJyYW5jaCApIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHRfX2V4cG9ydCA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRzZXQoIGtleXBhdGgsIHZhbHVlLCBzaWxlbnQgKSB7XG5cdFx0XHR2YXIgY29tcHV0YXRpb24sIHdyYXBwZXIsIGRvbnRUZWFyZG93bldyYXBwZXI7XG5cdFx0XHRjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zWyBrZXlwYXRoIF07XG5cdFx0XHRpZiAoIGNvbXB1dGF0aW9uICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGF0aW9uLnNldHRpbmcgKSB7XG5cdFx0XHRcdFx0Ly8gbGV0IHRoZSBvdGhlciBjb21wdXRhdGlvbiBzZXQoKSBoYW5kbGUgdGhpbmdzLi4uXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbXB1dGF0aW9uLnNldCggdmFsdWUgKTtcblx0XHRcdFx0dmFsdWUgPSBjb21wdXRhdGlvbi5nZXQoKTtcblx0XHRcdH1cblx0XHRcdGlmICggaXNFcXVhbCggdGhpcy5jYWNoZVsga2V5cGF0aCBdLCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR3cmFwcGVyID0gdGhpcy53cmFwcGVkWyBrZXlwYXRoIF07XG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGEgd3JhcHBlciB3aXRoIGEgYHJlc2V0KClgIG1ldGhvZCwgd2UgdHJ5IGFuZCB1c2UgaXQuIElmIHRoZVxuXHRcdFx0Ly8gYHJlc2V0KClgIG1ldGhvZCByZXR1cm5zIGZhbHNlLCB0aGUgd3JhcHBlciBzaG91bGQgYmUgdG9ybiBkb3duLCBhbmRcblx0XHRcdC8vIChtb3N0IGxpa2VseSkgYSBuZXcgb25lIHNob3VsZCBiZSBjcmVhdGVkIGxhdGVyXG5cdFx0XHRpZiAoIHdyYXBwZXIgJiYgd3JhcHBlci5yZXNldCApIHtcblx0XHRcdFx0ZG9udFRlYXJkb3duV3JhcHBlciA9IHdyYXBwZXIucmVzZXQoIHZhbHVlICkgIT09IGZhbHNlO1xuXHRcdFx0XHRpZiAoIGRvbnRUZWFyZG93bldyYXBwZXIgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFjb21wdXRhdGlvbiAmJiAhZG9udFRlYXJkb3duV3JhcHBlciApIHtcblx0XHRcdFx0cmVzb2x2ZVNldCggdGhpcywga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIXNpbGVudCApIHtcblx0XHRcdFx0dGhpcy5tYXJrKCBrZXlwYXRoICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXZSdyZSBzZXR0aW5nIGEgcGFyZW50IG9mIHRoZSBvcmlnaW5hbCB0YXJnZXQga2V5cGF0aCAoaS5lLlxuXHRcdFx0XHQvLyBjcmVhdGluZyBhIGZyZXNoIGJyYW5jaCkgLSB3ZSBuZWVkIHRvIGNsZWFyIHRoZSBjYWNoZSwgYnV0XG5cdFx0XHRcdC8vIG5vdCBtYXJrIGl0IGFzIGEgY2hhbmdlXG5cdFx0XHRcdHRoaXMuY2xlYXJDYWNoZSgga2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXNvbHZlU2V0KCB2aWV3bW9kZWwsIGtleXBhdGgsIHZhbHVlICkge1xuXHRcdFx0dmFyIGtleXMsIGxhc3RLZXksIHBhcmVudEtleXBhdGgsIHdyYXBwZXIsIHBhcmVudFZhbHVlLCB3cmFwcGVyU2V0LCB2YWx1ZVNldDtcblx0XHRcdHdyYXBwZXJTZXQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB3cmFwcGVyLnNldCApIHtcblx0XHRcdFx0XHR3cmFwcGVyLnNldCggbGFzdEtleSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJlbnRWYWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG5cdFx0XHRcdFx0dmFsdWVTZXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHZhbHVlU2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXBhcmVudFZhbHVlICkge1xuXHRcdFx0XHRcdHBhcmVudFZhbHVlID0gY3JlYXRlQnJhbmNoKCBsYXN0S2V5ICk7XG5cdFx0XHRcdFx0dmlld21vZGVsLnNldCggcGFyZW50S2V5cGF0aCwgcGFyZW50VmFsdWUsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJlbnRWYWx1ZVsgbGFzdEtleSBdID0gdmFsdWU7XG5cdFx0XHR9O1xuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0bGFzdEtleSA9IGtleXMucG9wKCk7XG5cdFx0XHRwYXJlbnRLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdHdyYXBwZXIgPSB2aWV3bW9kZWwud3JhcHBlZFsgcGFyZW50S2V5cGF0aCBdO1xuXHRcdFx0aWYgKCB3cmFwcGVyICkge1xuXHRcdFx0XHR3cmFwcGVyU2V0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXJlbnRWYWx1ZSA9IHZpZXdtb2RlbC5nZXQoIHBhcmVudEtleXBhdGggKTtcblx0XHRcdFx0Ly8gbWF5IGhhdmUgYmVlbiB3cmFwcGVkIHZpYSB0aGUgYWJvdmUgLmdldCgpXG5cdFx0XHRcdC8vIGNhbGwgb24gdmlld21vZGVsIGlmIHRoaXMgaXMgZmlyc3QgYWNjZXNzIHZpYSAuc2V0KCkhXG5cdFx0XHRcdGlmICggd3JhcHBlciA9IHZpZXdtb2RlbC53cmFwcGVkWyBwYXJlbnRLZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0d3JhcHBlclNldCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlU2V0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCBpc0VxdWFsLCBjcmVhdGVCcmFuY2ggKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3NtYXJ0VXBkYXRlLmpzICovXG5cdHZhciB2aWV3bW9kZWwkc21hcnRVcGRhdGUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfX2V4cG9ydDtcblx0XHR2YXIgaW1wbGljaXRPcHRpb24gPSB7XG5cdFx0XHRcdGltcGxpY2l0OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0bm9DYXNjYWRlT3B0aW9uID0ge1xuXHRcdFx0XHRub0Nhc2NhZGU6IHRydWVcblx0XHRcdH07XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiBWaWV3bW9kZWwkc21hcnRVcGRhdGUoIGtleXBhdGgsIGFycmF5LCBuZXdJbmRpY2VzICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgZGVwZW5kYW50cywgb2xkTGVuZ3RoO1xuXHRcdFx0b2xkTGVuZ3RoID0gbmV3SW5kaWNlcy5sZW5ndGg7XG5cdFx0XHQvLyBJbmRpY2VzIHRoYXQgYXJlIGJlaW5nIHJlbW92ZWQgc2hvdWxkIGJlIG1hcmtlZCBhcyBkaXJ0eVxuXHRcdFx0bmV3SW5kaWNlcy5mb3JFYWNoKCBmdW5jdGlvbiggbmV3SW5kZXgsIG9sZEluZGV4ICkge1xuXHRcdFx0XHRpZiAoIG5ld0luZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHR0aGlzJDAubWFyaygga2V5cGF0aCArICcuJyArIG9sZEluZGV4LCBub0Nhc2NhZGVPcHRpb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0Ly8gVXBkYXRlIHRoZSBtb2RlbFxuXHRcdFx0Ly8gVE9ETyBhbGxvdyBleGlzdGluZyBhcnJheSB0byBiZSB1cGRhdGVkIGluIHBsYWNlLCByYXRoZXIgdGhhbiByZXBsYWNlZD9cblx0XHRcdHRoaXMuc2V0KCBrZXlwYXRoLCBhcnJheSwgdHJ1ZSApO1xuXHRcdFx0aWYgKCBkZXBlbmRhbnRzID0gdGhpcy5kZXBzWyAnZGVmYXVsdCcgXVsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRkZXBlbmRhbnRzLmZpbHRlciggY2FuU2h1ZmZsZSApLmZvckVhY2goIGZ1bmN0aW9uKCBkICkge1xuXHRcdFx0XHRcdHJldHVybiBkLnNodWZmbGUoIG5ld0luZGljZXMsIGFycmF5ICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggb2xkTGVuZ3RoICE9PSBhcnJheS5sZW5ndGggKSB7XG5cdFx0XHRcdHRoaXMubWFyaygga2V5cGF0aCArICcubGVuZ3RoJywgaW1wbGljaXRPcHRpb24gKTtcblx0XHRcdFx0Zm9yICggdmFyIGkgPSBvbGRMZW5ndGg7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHR0aGlzLm1hcmsoIGtleXBhdGggKyAnLicgKyBpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gZG9uJ3QgYWxsb3cgcmVtb3ZlZCBpbmRleGVzIGJleW9uZCBlbmQgb2YgbmV3IGFycmF5IHRvIHRyaWdnZXIgcmVjb21wdXRhdGlvbnNcblx0XHRcdFx0Zm9yICggdmFyIGkkMCA9IGFycmF5Lmxlbmd0aDsgaSQwIDwgb2xkTGVuZ3RoOyBpJDAgKz0gMSApIHtcblx0XHRcdFx0XHR0aGlzLm1hcmsoIGtleXBhdGggKyAnLicgKyBpJDAsIG5vQ2FzY2FkZU9wdGlvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGNhblNodWZmbGUoIGRlcGVuZGFudCApIHtcblx0XHRcdHJldHVybiB0eXBlb2YgZGVwZW5kYW50LnNodWZmbGUgPT09ICdmdW5jdGlvbic7XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvdGVhcmRvd24uanMgKi9cblx0dmFyIHZpZXdtb2RlbCR0ZWFyZG93biA9IGZ1bmN0aW9uIFZpZXdtb2RlbCR0ZWFyZG93bigpIHtcblx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHR2YXIgdW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeTtcblx0XHQvLyBDbGVhciBlbnRpcmUgY2FjaGUgLSB0aGlzIGhhcyB0aGUgZGVzaXJlZCBzaWRlLWVmZmVjdFxuXHRcdC8vIG9mIHVud3JhcHBpbmcgYWRhcHRlZCB2YWx1ZXMgKGUuZy4gYXJyYXlzKVxuXHRcdE9iamVjdC5rZXlzKCB0aGlzLmNhY2hlICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcyQwLmNsZWFyQ2FjaGUoIGtleXBhdGggKTtcblx0XHR9ICk7XG5cdFx0Ly8gVGVhcmRvd24gYW55IGZhaWxlZCBsb29rdXBzIC0gd2UgZG9uJ3QgbmVlZCB0aGVtIHRvIHJlc29sdmUgYW55IG1vcmVcblx0XHR3aGlsZSAoIHVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kgPSB0aGlzLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcy5wb3AoKSApIHtcblx0XHRcdHVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kudGVhcmRvd24oKTtcblx0XHR9XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS91bnJlZ2lzdGVyLmpzICovXG5cdHZhciB2aWV3bW9kZWwkdW5yZWdpc3RlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gVmlld21vZGVsJHVucmVnaXN0ZXIoIGtleXBhdGgsIGRlcGVuZGFudCApIHtcblx0XHRcdHZhciBncm91cCA9IGFyZ3VtZW50c1sgMiBdO1xuXHRcdFx0aWYgKCBncm91cCA9PT0gdm9pZCAwIClcblx0XHRcdFx0Z3JvdXAgPSAnZGVmYXVsdCc7XG5cdFx0XHR2YXIgZGVwcywgaW5kZXg7XG5cdFx0XHRpZiAoIGRlcGVuZGFudC5pc1N0YXRpYyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZGVwcyA9IHRoaXMuZGVwc1sgZ3JvdXAgXVsga2V5cGF0aCBdO1xuXHRcdFx0aW5kZXggPSBkZXBzLmluZGV4T2YoIGRlcGVuZGFudCApO1xuXHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0F0dGVtcHRlZCB0byByZW1vdmUgYSBkZXBlbmRhbnQgdGhhdCB3YXMgbm8gbG9uZ2VyIHJlZ2lzdGVyZWQhIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4uIElmIHlvdSBhcmUgc2VlaW5nIHRoaXMgYnVnIGluIGRldmVsb3BtZW50IHBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vUmFjdGl2ZUpTL1JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzJyApO1xuXHRcdFx0fVxuXHRcdFx0ZGVwcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRpZiAoICFrZXlwYXRoICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR1cGRhdGVEZXBlbmRhbnRzTWFwKCB0aGlzLCBrZXlwYXRoLCBncm91cCApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVEZXBlbmRhbnRzTWFwKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwICkge1xuXHRcdFx0dmFyIGtleXMsIHBhcmVudEtleXBhdGgsIG1hcCwgcGFyZW50O1xuXHRcdFx0Ly8gdXBkYXRlIGRlcGVuZGFudHMgbWFwXG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHR3aGlsZSAoIGtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHRwYXJlbnRLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0bWFwID0gdmlld21vZGVsLmRlcHNNYXBbIGdyb3VwIF07XG5cdFx0XHRcdHBhcmVudCA9IG1hcFsgcGFyZW50S2V5cGF0aCBdO1xuXHRcdFx0XHRwYXJlbnRbIGtleXBhdGggXSAtPSAxO1xuXHRcdFx0XHRpZiAoICFwYXJlbnRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHQvLyByZW1vdmUgZnJvbSBwYXJlbnQgZGVwcyBtYXBcblx0XHRcdFx0XHRwYXJlbnQuc3BsaWNlKCBwYXJlbnQuaW5kZXhPZigga2V5cGF0aCApLCAxICk7XG5cdFx0XHRcdFx0cGFyZW50WyBrZXlwYXRoIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5cGF0aCA9IHBhcmVudEtleXBhdGg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfX2V4cG9ydDtcblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9hZGFwdENvbmZpZy5qcyAqL1xuXHR2YXIgYWRhcHRDb25maWcgPSBmdW5jdGlvbigpIHtcblxuXHRcdC8vIHNob3VsZCB0aGlzIGJlIGNvbWJpbmVkIHdpdGggcHJvdG90eXBlL2FkYXB0LmpzP1xuXHRcdHZhciBjb25maWd1cmUgPSB7XG5cdFx0XHRsb29rdXA6IGZ1bmN0aW9uKCB0YXJnZXQsIGFkYXB0b3JzICkge1xuXHRcdFx0XHR2YXIgaSwgYWRhcHQgPSB0YXJnZXQuYWRhcHQ7XG5cdFx0XHRcdGlmICggIWFkYXB0IHx8ICFhZGFwdC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFkYXB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggYWRhcHRvcnMgJiYgT2JqZWN0LmtleXMoIGFkYXB0b3JzICkubGVuZ3RoICYmICggaSA9IGFkYXB0Lmxlbmd0aCApICkge1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0dmFyIGFkYXB0b3IgPSBhZGFwdFsgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgYWRhcHRvciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRcdGFkYXB0WyBpIF0gPSBhZGFwdG9yc1sgYWRhcHRvciBdIHx8IGFkYXB0b3I7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBhZGFwdDtcblx0XHRcdH0sXG5cdFx0XHRjb21iaW5lOiBmdW5jdGlvbiggcGFyZW50LCBhZGFwdCApIHtcblx0XHRcdFx0Ly8gbm9ybWFsaXplICdGb28nIHRvIFsgJ0ZvbycgXVxuXHRcdFx0XHRwYXJlbnQgPSBhcnJheUlmU3RyaW5nKCBwYXJlbnQgKTtcblx0XHRcdFx0YWRhcHQgPSBhcnJheUlmU3RyaW5nKCBhZGFwdCApO1xuXHRcdFx0XHQvLyBubyBwYXJlbnQ/IHJldHVybiBhZGFwdFxuXHRcdFx0XHRpZiAoICFwYXJlbnQgfHwgIXBhcmVudC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFkYXB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG5vIGFkYXB0PyByZXR1cm4gJ2NvcHknIG9mIHBhcmVudFxuXHRcdFx0XHRpZiAoICFhZGFwdCB8fCAhYWRhcHQubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJlbnQuc2xpY2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBhZGQgcGFyZW50IGFkYXB0b3JzIHRvIG9wdGlvbnNcblx0XHRcdFx0cGFyZW50LmZvckVhY2goIGZ1bmN0aW9uKCBhICkge1xuXHRcdFx0XHRcdC8vIGRvbid0IHB1dCBpbiBkdXBsaWNhdGVzXG5cdFx0XHRcdFx0aWYgKCBhZGFwdC5pbmRleE9mKCBhICkgPT09IC0xICkge1xuXHRcdFx0XHRcdFx0YWRhcHQucHVzaCggYSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGFycmF5SWZTdHJpbmcoIGFkYXB0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgYWRhcHQgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRhZGFwdCA9IFsgYWRhcHQgXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhZGFwdDtcblx0XHR9XG5cdFx0cmV0dXJuIGNvbmZpZ3VyZTtcblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9WaWV3bW9kZWwuanMgKi9cblx0dmFyIFZpZXdtb2RlbCA9IGZ1bmN0aW9uKCBjcmVhdGUsIGFkYXB0LCBhcHBseUNoYW5nZXMsIGNhcHR1cmUsIGNsZWFyQ2FjaGUsIGNvbXB1dGUsIGdldCwgaW5pdCwgbWFyaywgbWVyZ2UsIHJlZ2lzdGVyLCByZWxlYXNlLCBzZXQsIHNtYXJ0VXBkYXRlLCB0ZWFyZG93biwgdW5yZWdpc3RlciwgYWRhcHRDb25maWcgKSB7XG5cblx0XHR2YXIgbm9NYWdpYztcblx0XHR0cnkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB7fSwgJ3Rlc3QnLCB7XG5cdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHR9ICk7XG5cdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdG5vTWFnaWMgPSB0cnVlO1xuXHRcdH1cblx0XHR2YXIgVmlld21vZGVsID0gZnVuY3Rpb24oIHJhY3RpdmUgKSB7XG5cdFx0XHR0aGlzLnJhY3RpdmUgPSByYWN0aXZlO1xuXHRcdFx0Ly8gVE9ETyBldmVudHVhbGx5LCB3ZSBzaG91bGRuJ3QgbmVlZCB0aGlzIHJlZmVyZW5jZVxuXHRcdFx0Vmlld21vZGVsLmV4dGVuZCggcmFjdGl2ZS5jb25zdHJ1Y3RvciwgcmFjdGl2ZSApO1xuXHRcdFx0dGhpcy5jYWNoZSA9IHt9O1xuXHRcdFx0Ly8gd2UgbmVlZCB0byBiZSBhYmxlIHRvIHVzZSBoYXNPd25Qcm9wZXJ0eSwgc28gY2FuJ3QgaW5oZXJpdCBmcm9tIG51bGxcblx0XHRcdHRoaXMuY2FjaGVNYXAgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdHRoaXMuZGVwcyA9IHtcblx0XHRcdFx0Y29tcHV0ZWQ6IHt9LFxuXHRcdFx0XHQnZGVmYXVsdCc6IHt9XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5kZXBzTWFwID0ge1xuXHRcdFx0XHRjb21wdXRlZDoge30sXG5cdFx0XHRcdCdkZWZhdWx0Jzoge31cblx0XHRcdH07XG5cdFx0XHR0aGlzLnBhdHRlcm5PYnNlcnZlcnMgPSBbXTtcblx0XHRcdHRoaXMud3JhcHBlZCA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0dGhpcy5jb21wdXRhdGlvbnMgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdHRoaXMuY2FwdHVyZUdyb3VwcyA9IFtdO1xuXHRcdFx0dGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMgPSBbXTtcblx0XHRcdHRoaXMuY2hhbmdlcyA9IFtdO1xuXHRcdFx0dGhpcy5pbXBsaWNpdENoYW5nZXMgPSB7fTtcblx0XHRcdHRoaXMubm9DYXNjYWRlID0ge307XG5cdFx0fTtcblx0XHRWaWV3bW9kZWwuZXh0ZW5kID0gZnVuY3Rpb24oIFBhcmVudCwgaW5zdGFuY2UgKSB7XG5cdFx0XHRpZiAoIGluc3RhbmNlLm1hZ2ljICYmIG5vTWFnaWMgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0dldHRlcnMgYW5kIHNldHRlcnMgKG1hZ2ljIG1vZGUpIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicgKTtcblx0XHRcdH1cblx0XHRcdGluc3RhbmNlLmFkYXB0ID0gYWRhcHRDb25maWcuY29tYmluZSggUGFyZW50LnByb3RvdHlwZS5hZGFwdCwgaW5zdGFuY2UuYWRhcHQgKSB8fCBbXTtcblx0XHRcdGluc3RhbmNlLmFkYXB0ID0gYWRhcHRDb25maWcubG9va3VwKCBpbnN0YW5jZSwgaW5zdGFuY2UuYWRhcHRvcnMgKTtcblx0XHR9O1xuXHRcdFZpZXdtb2RlbC5wcm90b3R5cGUgPSB7XG5cdFx0XHRhZGFwdDogYWRhcHQsXG5cdFx0XHRhcHBseUNoYW5nZXM6IGFwcGx5Q2hhbmdlcyxcblx0XHRcdGNhcHR1cmU6IGNhcHR1cmUsXG5cdFx0XHRjbGVhckNhY2hlOiBjbGVhckNhY2hlLFxuXHRcdFx0Y29tcHV0ZTogY29tcHV0ZSxcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdG1hcms6IG1hcmssXG5cdFx0XHRtZXJnZTogbWVyZ2UsXG5cdFx0XHRyZWdpc3RlcjogcmVnaXN0ZXIsXG5cdFx0XHRyZWxlYXNlOiByZWxlYXNlLFxuXHRcdFx0c2V0OiBzZXQsXG5cdFx0XHRzbWFydFVwZGF0ZTogc21hcnRVcGRhdGUsXG5cdFx0XHR0ZWFyZG93bjogdGVhcmRvd24sXG5cdFx0XHR1bnJlZ2lzdGVyOiB1bnJlZ2lzdGVyXG5cdFx0fTtcblx0XHRyZXR1cm4gVmlld21vZGVsO1xuXHR9KCBjcmVhdGUsIHZpZXdtb2RlbCRhZGFwdCwgdmlld21vZGVsJGFwcGx5Q2hhbmdlcywgdmlld21vZGVsJGNhcHR1cmUsIHZpZXdtb2RlbCRjbGVhckNhY2hlLCB2aWV3bW9kZWwkY29tcHV0ZSwgdmlld21vZGVsJGdldCwgdmlld21vZGVsJGluaXQsIHZpZXdtb2RlbCRtYXJrLCB2aWV3bW9kZWwkbWVyZ2UsIHZpZXdtb2RlbCRyZWdpc3Rlciwgdmlld21vZGVsJHJlbGVhc2UsIHZpZXdtb2RlbCRzZXQsIHZpZXdtb2RlbCRzbWFydFVwZGF0ZSwgdmlld21vZGVsJHRlYXJkb3duLCB2aWV3bW9kZWwkdW5yZWdpc3RlciwgYWRhcHRDb25maWcgKTtcblxuXHQvKiBSYWN0aXZlL2luaXRpYWxpc2UuanMgKi9cblx0dmFyIFJhY3RpdmVfaW5pdGlhbGlzZSA9IGZ1bmN0aW9uKCBjb25maWcsIGNyZWF0ZSwgRnJhZ21lbnQsIGdldEVsZW1lbnQsIGdldE5leHROdW1iZXIsIEhvb2ssIEhvb2tRdWV1ZSwgVmlld21vZGVsICkge1xuXG5cdFx0dmFyIF9fZXhwb3J0O1xuXHRcdHZhciBjb25zdHJ1Y3RIb29rID0gbmV3IEhvb2soICdjb25zdHJ1Y3QnICksXG5cdFx0XHRjb25maWdIb29rID0gbmV3IEhvb2soICdjb25maWcnICksXG5cdFx0XHRpbml0SG9vayA9IG5ldyBIb29rUXVldWUoICdpbml0JyApO1xuXHRcdF9fZXhwb3J0ID0gZnVuY3Rpb24gaW5pdGlhbGlzZVJhY3RpdmVJbnN0YW5jZSggcmFjdGl2ZSApIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAxIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdHZhciBlbDtcblx0XHRcdGluaXRpYWxpc2VQcm9wZXJ0aWVzKCByYWN0aXZlLCBvcHRpb25zICk7XG5cdFx0XHQvLyBtYWtlIHRoaXMgb3B0aW9uIGRvIHdoYXQgd291bGQgYmUgZXhwZWN0ZWQgaWYgc29tZW9uZVxuXHRcdFx0Ly8gZGlkIGluY2x1ZGUgaXQgb24gYSBuZXcgUmFjdGl2ZSgpIG9yIG5ldyBDb21wb25lbnQoKSBjYWxsLlxuXHRcdFx0Ly8gU2lsbHkgdG8gZG8gc28gKHB1dCBhIGhvb2sgb24gdGhlIHZlcnkgb3B0aW9ucyBiZWluZyB1c2VkKSxcblx0XHRcdC8vIGJ1dCBoYW5kbGUgaXQgY29ycmVjdGx5LCBjb25zaXN0ZW50IHdpdGggdGhlIGludGVudC5cblx0XHRcdGNvbnN0cnVjdEhvb2suZmlyZSggY29uZmlnLmdldENvbnN0cnVjdFRhcmdldCggcmFjdGl2ZSwgb3B0aW9ucyApLCBvcHRpb25zICk7XG5cdFx0XHQvLyBpbml0IGNvbmZpZyBmcm9tIFBhcmVudCBhbmQgb3B0aW9uc1xuXHRcdFx0Y29uZmlnLmluaXQoIHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUsIG9wdGlvbnMgKTtcblx0XHRcdGNvbmZpZ0hvb2suZmlyZSggcmFjdGl2ZSApO1xuXHRcdFx0Ly8gVGVhcmRvd24gYW55IGV4aXN0aW5nIGluc3RhbmNlcyAqYmVmb3JlKiB0cnlpbmcgdG8gc2V0IHVwIHRoZSBuZXcgb25lIC1cblx0XHRcdC8vIGF2b2lkcyBjZXJ0YWluIHdlaXJkIGJ1Z3Ncblx0XHRcdGlmICggZWwgPSBnZXRFbGVtZW50KCByYWN0aXZlLmVsICkgKSB7XG5cdFx0XHRcdGlmICggIXJhY3RpdmUuYXBwZW5kICkge1xuXHRcdFx0XHRcdGlmICggZWwuX19yYWN0aXZlX2luc3RhbmNlc19fICkge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0ZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLnNwbGljZSggMCwgZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLmxlbmd0aCApLmZvckVhY2goIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByLnRlYXJkb3duKCk7XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbC5pbm5lckhUTUwgPSAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aW5pdEhvb2suYmVnaW4oIHJhY3RpdmUgKTtcblx0XHRcdC8vIFRFTVBPUkFSWS4gVGhpcyBpcyBzbyB3ZSBjYW4gaW1wbGVtZW50IFZpZXdtb2RlbCBncmFkdWFsbHlcblx0XHRcdHJhY3RpdmUudmlld21vZGVsID0gbmV3IFZpZXdtb2RlbCggcmFjdGl2ZSApO1xuXHRcdFx0Ly8gaGFja3kgY2lyY3VsYXIgcHJvYmxlbSB1bnRpbCB3ZSBnZXQgdGhpcyBzb3J0ZWQgb3V0XG5cdFx0XHQvLyBpZiB2aWV3bW9kZWwgaW1tZWRpYXRlbHkgcHJvY2Vzc2VzIGNvbXB1dGVkIHByb3BlcnRpZXMsXG5cdFx0XHQvLyB0aGV5IG1heSBjYWxsIHJhY3RpdmUuZ2V0LCB3aGljaCBjYWxscyByYWN0aXZlLnZpZXdtb2RlbCxcblx0XHRcdC8vIHdoaWNoIGhhc24ndCBiZWVuIHNldCB0aWxsIGxpbmUgYWJvdmUgZmluaXNoZXMuXG5cdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5pbml0KCk7XG5cdFx0XHQvLyBSZW5kZXIgb3VyICpyb290IGZyYWdtZW50KlxuXHRcdFx0aWYgKCByYWN0aXZlLnRlbXBsYXRlICkge1xuXHRcdFx0XHRyYWN0aXZlLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IHJhY3RpdmUudGVtcGxhdGUsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogcmFjdGl2ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpbml0SG9vay5lbmQoIHJhY3RpdmUgKTtcblx0XHRcdC8vIHJlbmRlciBhdXRvbWF0aWNhbGx5ICggaWYgYGVsYCBpcyBzcGVjaWZpZWQgKVxuXHRcdFx0aWYgKCBlbCApIHtcblx0XHRcdFx0cmFjdGl2ZS5yZW5kZXIoIGVsLCByYWN0aXZlLmFwcGVuZCApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpbml0aWFsaXNlUHJvcGVydGllcyggcmFjdGl2ZSwgb3B0aW9ucyApIHtcblx0XHRcdC8vIEdlbmVyYXRlIGEgdW5pcXVlIGlkZW50aWZpZXIsIGZvciBwbGFjZXMgd2hlcmUgeW91J2QgdXNlIGEgd2VhayBtYXAgaWYgaXRcblx0XHRcdC8vIGV4aXN0ZWRcblx0XHRcdHJhY3RpdmUuX2d1aWQgPSBnZXROZXh0TnVtYmVyKCk7XG5cdFx0XHQvLyBldmVudHNcblx0XHRcdHJhY3RpdmUuX3N1YnMgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdC8vIHN0b3JhZ2UgZm9yIGl0ZW0gY29uZmlndXJhdGlvbiBmcm9tIGluc3RhbnRpYXRpb24gdG8gcmVzZXQsXG5cdFx0XHQvLyBsaWtlIGR5bmFtaWMgZnVuY3Rpb25zIG9yIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0cmFjdGl2ZS5fY29uZmlnID0ge307XG5cdFx0XHQvLyB0d28td2F5IGJpbmRpbmdzXG5cdFx0XHRyYWN0aXZlLl90d293YXlCaW5kaW5ncyA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0Ly8gYW5pbWF0aW9ucyAoc28gd2UgY2FuIHN0b3AgYW55IGluIHByb2dyZXNzIGF0IHRlYXJkb3duKVxuXHRcdFx0cmFjdGl2ZS5fYW5pbWF0aW9ucyA9IFtdO1xuXHRcdFx0Ly8gbm9kZXMgcmVnaXN0cnlcblx0XHRcdHJhY3RpdmUubm9kZXMgPSB7fTtcblx0XHRcdC8vIGxpdmUgcXVlcmllc1xuXHRcdFx0cmFjdGl2ZS5fbGl2ZVF1ZXJpZXMgPSBbXTtcblx0XHRcdHJhY3RpdmUuX2xpdmVDb21wb25lbnRRdWVyaWVzID0gW107XG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgY29tcG9uZW50LCBzdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50XG5cdFx0XHRpZiAoIG9wdGlvbnMuX3BhcmVudCAmJiBvcHRpb25zLl9jb21wb25lbnQgKSB7XG5cdFx0XHRcdHJhY3RpdmUuX3BhcmVudCA9IG9wdGlvbnMuX3BhcmVudDtcblx0XHRcdFx0cmFjdGl2ZS5jb21wb25lbnQgPSBvcHRpb25zLl9jb21wb25lbnQ7XG5cdFx0XHRcdC8vIEFuZCBzdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb24gdGhlIGNvbXBvbmVudFxuXHRcdFx0XHRvcHRpb25zLl9jb21wb25lbnQuaW5zdGFuY2UgPSByYWN0aXZlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX19leHBvcnQ7XG5cdH0oIGNvbmZpZywgY3JlYXRlLCBGcmFnbWVudCwgZ2V0RWxlbWVudCwgZ2V0TmV4dE51bWJlciwgUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9vaywgUmFjdGl2ZSRzaGFyZWRfaG9va3NfSG9va1F1ZXVlLCBWaWV3bW9kZWwgKTtcblxuXHQvKiBleHRlbmQvdW53cmFwRXh0ZW5kZWQuanMgKi9cblx0dmFyIHVud3JhcEV4dGVuZGVkID0gZnVuY3Rpb24oIHdyYXAsIGNvbmZpZywgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgX19leHBvcnQ7XG5cdFx0dmFyIFJhY3RpdmU7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRSYWN0aXZlID0gY2lyY3VsYXIuUmFjdGl2ZTtcblx0XHR9ICk7XG5cdFx0X19leHBvcnQgPSBmdW5jdGlvbiB1bndyYXBFeHRlbmRlZCggQ2hpbGQgKSB7XG5cdFx0XHRpZiAoICEoIENoaWxkLnByb3RvdHlwZSBpbnN0YW5jZW9mIFJhY3RpdmUgKSApIHtcblx0XHRcdFx0cmV0dXJuIENoaWxkO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG9wdGlvbnMgPSB7fTtcblx0XHRcdHdoaWxlICggQ2hpbGQgKSB7XG5cdFx0XHRcdGNvbmZpZy5yZWdpc3RyaWVzLmZvckVhY2goIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdGFkZFJlZ2lzdHJ5KCByLnVzZURlZmF1bHRzID8gQ2hpbGQucHJvdG90eXBlIDogQ2hpbGQsIG9wdGlvbnMsIHIubmFtZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdE9iamVjdC5rZXlzKCBDaGlsZC5wcm90b3R5cGUgKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdGlmICgga2V5ID09PSAnY29tcHV0ZWQnICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBDaGlsZC5wcm90b3R5cGVbIGtleSBdO1xuXHRcdFx0XHRcdGlmICggISgga2V5IGluIG9wdGlvbnMgKSApIHtcblx0XHRcdFx0XHRcdG9wdGlvbnNbIGtleSBdID0gdmFsdWUuX21ldGhvZCA/IHZhbHVlLl9tZXRob2QgOiB2YWx1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2Ygb3B0aW9uc1sga2V5IF0gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnNbIGtleSBdLl9tZXRob2QgKSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0LCBuZWVkc1N1cGVyID0gdmFsdWUuX21ldGhvZDtcblx0XHRcdFx0XHRcdGlmICggbmVlZHNTdXBlciApIHtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5fbWV0aG9kO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gcmV3cmFwIGJvdW5kIGRpcmVjdGx5IHRvIHBhcmVudCBmblxuXHRcdFx0XHRcdFx0cmVzdWx0ID0gd3JhcCggb3B0aW9uc1sga2V5IF0uX21ldGhvZCwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdGlmICggbmVlZHNTdXBlciApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0Ll9tZXRob2QgPSByZXN1bHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHJlc3VsdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0aWYgKCBDaGlsZC5fcGFyZW50ICE9PSBSYWN0aXZlICkge1xuXHRcdFx0XHRcdENoaWxkID0gQ2hpbGQuX3BhcmVudDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRDaGlsZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3B0aW9ucztcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gYWRkUmVnaXN0cnkoIHRhcmdldCwgb3B0aW9ucywgbmFtZSApIHtcblx0XHRcdHZhciByZWdpc3RyeSwga2V5cyA9IE9iamVjdC5rZXlzKCB0YXJnZXRbIG5hbWUgXSApO1xuXHRcdFx0aWYgKCAha2V5cy5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggISggcmVnaXN0cnkgPSBvcHRpb25zWyBuYW1lIF0gKSApIHtcblx0XHRcdFx0cmVnaXN0cnkgPSBvcHRpb25zWyBuYW1lIF0gPSB7fTtcblx0XHRcdH1cblx0XHRcdGtleXMuZmlsdGVyKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gISgga2V5IGluIHJlZ2lzdHJ5ICk7XG5cdFx0XHR9ICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0cmV0dXJuIHJlZ2lzdHJ5WyBrZXkgXSA9IHRhcmdldFsgbmFtZSBdWyBrZXkgXTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9fZXhwb3J0O1xuXHR9KCB3cmFwTWV0aG9kLCBjb25maWcsIGNpcmN1bGFyICk7XG5cblx0LyogZXh0ZW5kL19leHRlbmQuanMgKi9cblx0dmFyIFJhY3RpdmVfZXh0ZW5kID0gZnVuY3Rpb24oIGNyZWF0ZSwgZGVmaW5lUHJvcGVydGllcywgZ2V0R3VpZCwgY29uZmlnLCBpbml0aWFsaXNlLCBWaWV3bW9kZWwsIHVud3JhcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBleHRlbmQoKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sgMCBdO1xuXHRcdFx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKVxuXHRcdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHR2YXIgUGFyZW50ID0gdGhpcyxcblx0XHRcdFx0Q2hpbGQsIHByb3RvLCBzdGF0aWNQcm9wZXJ0aWVzO1xuXHRcdFx0Ly8gaWYgd2UncmUgZXh0ZW5kaW5nIHdpdGggYW5vdGhlciBSYWN0aXZlIGluc3RhbmNlLCBpbmhlcml0IGl0c1xuXHRcdFx0Ly8gcHJvdG90eXBlIG1ldGhvZHMgYW5kIGRlZmF1bHQgb3B0aW9ucyBhcyB3ZWxsXG5cdFx0XHRvcHRpb25zID0gdW53cmFwKCBvcHRpb25zICk7XG5cdFx0XHQvLyBjcmVhdGUgQ2hpbGQgY29uc3RydWN0b3Jcblx0XHRcdENoaWxkID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGluaXRpYWxpc2UoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHRcdH07XG5cdFx0XHRwcm90byA9IGNyZWF0ZSggUGFyZW50LnByb3RvdHlwZSApO1xuXHRcdFx0cHJvdG8uY29uc3RydWN0b3IgPSBDaGlsZDtcblx0XHRcdHN0YXRpY1Byb3BlcnRpZXMgPSB7XG5cdFx0XHRcdC8vIGVhY2ggY29tcG9uZW50IG5lZWRzIGEgZ3VpZCwgZm9yIG1hbmFnaW5nIENTUyBldGNcblx0XHRcdFx0X2d1aWQ6IHtcblx0XHRcdFx0XHR2YWx1ZTogZ2V0R3VpZCgpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIGFsaWFzIHByb3RvdHlwZSBhcyBkZWZhdWx0c1xuXHRcdFx0XHRkZWZhdWx0czoge1xuXHRcdFx0XHRcdHZhbHVlOiBwcm90b1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBleHRlbmRhYmxlXG5cdFx0XHRcdGV4dGVuZDoge1xuXHRcdFx0XHRcdHZhbHVlOiBleHRlbmQsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIFBhcmVudCAtIGZvciBJRTgsIGNhbid0IHVzZSBPYmplY3QuZ2V0UHJvdG90eXBlT2Zcblx0XHRcdFx0X3BhcmVudDoge1xuXHRcdFx0XHRcdHZhbHVlOiBQYXJlbnRcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRlZmluZVByb3BlcnRpZXMoIENoaWxkLCBzdGF0aWNQcm9wZXJ0aWVzICk7XG5cdFx0XHQvLyBleHRlbmQgY29uZmlndXJhdGlvblxuXHRcdFx0Y29uZmlnLmV4dGVuZCggUGFyZW50LCBwcm90bywgb3B0aW9ucyApO1xuXHRcdFx0Vmlld21vZGVsLmV4dGVuZCggUGFyZW50LCBwcm90byApO1xuXHRcdFx0Q2hpbGQucHJvdG90eXBlID0gcHJvdG87XG5cdFx0XHRyZXR1cm4gQ2hpbGQ7XG5cdFx0fTtcblx0fSggY3JlYXRlLCBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRHdWlkLCBjb25maWcsIFJhY3RpdmVfaW5pdGlhbGlzZSwgVmlld21vZGVsLCB1bndyYXBFeHRlbmRlZCApO1xuXG5cdC8qIFJhY3RpdmUuanMgKi9cblx0dmFyIFJhY3RpdmUgPSBmdW5jdGlvbiggZGVmYXVsdHMsIGVhc2luZywgaW50ZXJwb2xhdG9ycywgc3ZnLCBtYWdpYywgZGVmaW5lUHJvcGVydGllcywgcHJvdG8sIFByb21pc2UsIGV4dGVuZE9iaiwgZXh0ZW5kLCBwYXJzZSwgaW5pdGlhbGlzZSwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgUmFjdGl2ZSwgcHJvcGVydGllcztcblx0XHQvLyBNYWluIFJhY3RpdmUgcmVxdWlyZWQgb2JqZWN0XG5cdFx0UmFjdGl2ZSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0aW5pdGlhbGlzZSggdGhpcywgb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0Ly8gUmFjdGl2ZSBwcm9wZXJ0aWVzXG5cdFx0cHJvcGVydGllcyA9IHtcblx0XHRcdC8vIHN0YXRpYyBtZXRob2RzOlxuXHRcdFx0ZXh0ZW5kOiB7XG5cdFx0XHRcdHZhbHVlOiBleHRlbmRcblx0XHRcdH0sXG5cdFx0XHRwYXJzZToge1xuXHRcdFx0XHR2YWx1ZTogcGFyc2Vcblx0XHRcdH0sXG5cdFx0XHQvLyBOYW1lc3BhY2VkIGNvbnN0cnVjdG9yc1xuXHRcdFx0UHJvbWlzZToge1xuXHRcdFx0XHR2YWx1ZTogUHJvbWlzZVxuXHRcdFx0fSxcblx0XHRcdC8vIHN1cHBvcnRcblx0XHRcdHN2Zzoge1xuXHRcdFx0XHR2YWx1ZTogc3ZnXG5cdFx0XHR9LFxuXHRcdFx0bWFnaWM6IHtcblx0XHRcdFx0dmFsdWU6IG1hZ2ljXG5cdFx0XHR9LFxuXHRcdFx0Ly8gdmVyc2lvblxuXHRcdFx0VkVSU0lPTjoge1xuXHRcdFx0XHR2YWx1ZTogJzAuNi4xJ1xuXHRcdFx0fSxcblx0XHRcdC8vIFBsdWdpbnNcblx0XHRcdGFkYXB0b3JzOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZToge31cblx0XHRcdH0sXG5cdFx0XHRjb21wb25lbnRzOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZToge31cblx0XHRcdH0sXG5cdFx0XHRkZWNvcmF0b3JzOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZToge31cblx0XHRcdH0sXG5cdFx0XHRlYXNpbmc6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiBlYXNpbmdcblx0XHRcdH0sXG5cdFx0XHRldmVudHM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fSxcblx0XHRcdGludGVycG9sYXRvcnM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiBpbnRlcnBvbGF0b3JzXG5cdFx0XHR9LFxuXHRcdFx0cGFydGlhbHM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fSxcblx0XHRcdHRyYW5zaXRpb25zOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZToge31cblx0XHRcdH1cblx0XHR9O1xuXHRcdC8vIFJhY3RpdmUgcHJvcGVydGllc1xuXHRcdGRlZmluZVByb3BlcnRpZXMoIFJhY3RpdmUsIHByb3BlcnRpZXMgKTtcblx0XHRSYWN0aXZlLnByb3RvdHlwZSA9IGV4dGVuZE9iaiggcHJvdG8sIGRlZmF1bHRzICk7XG5cdFx0UmFjdGl2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYWN0aXZlO1xuXHRcdC8vIGFsaWFzIHByb3RvdHlwZSBhcyBkZWZhdWx0c1xuXHRcdFJhY3RpdmUuZGVmYXVsdHMgPSBSYWN0aXZlLnByb3RvdHlwZTtcblx0XHQvLyBDZXJ0YWluIG1vZHVsZXMgaGF2ZSBjaXJjdWxhciBkZXBlbmRlbmNpZXMuIElmIHdlIHdlcmUgYnVuZGxpbmcgYVxuXHRcdC8vIG1vZHVsZSBsb2FkZXIsIGUuZy4gYWxtb25kLmpzLCB0aGlzIHdvdWxkbid0IGJlIGEgcHJvYmxlbSwgYnV0IHdlJ3JlXG5cdFx0Ly8gbm90IC0gd2UncmUgdXNpbmcgYW1kY2xlYW4gYXMgcGFydCBvZiB0aGUgYnVpbGQgcHJvY2Vzcy4gQmVjYXVzZSBvZlxuXHRcdC8vIHRoaXMsIHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBhbGwgbW9kdWxlcyBoYXZlIGxvYWRlZCBiZWZvcmUgdGhvc2Vcblx0XHQvLyBjaXJjdWxhciBkZXBlbmRlbmNpZXMgY2FuIGJlIHJlcXVpcmVkLlxuXHRcdGNpcmN1bGFyLlJhY3RpdmUgPSBSYWN0aXZlO1xuXHRcdHdoaWxlICggY2lyY3VsYXIubGVuZ3RoICkge1xuXHRcdFx0Y2lyY3VsYXIucG9wKCkoKTtcblx0XHR9XG5cdFx0Ly8gUmFjdGl2ZS5qcyBtYWtlcyBsaWJlcmFsIHVzZSBvZiB0aGluZ3MgbGlrZSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi4gSW5cblx0XHQvLyBvbGRlciBicm93c2VycywgdGhlc2UgYXJlIG1hZGUgYXZhaWxhYmxlIHZpYSBhIHNoaW0gLSBoZXJlLCB3ZSBkbyBhIHF1aWNrXG5cdFx0Ly8gcHJlLWZsaWdodCBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCBlaXRoZXIgYSkgd2UncmUgbm90IGluIGEgc2hpdCBicm93c2VyLFxuXHRcdC8vIG9yIGIpIHdlJ3JlIHVzaW5nIGEgUmFjdGl2ZS1sZWdhY3kuanMgYnVpbGRcblx0XHR2YXIgRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuXHRcdGlmICggdHlwZW9mIERhdGUubm93ICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS50cmltICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgT2JqZWN0LmtleXMgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLm1hcCAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gRlVOQ1RJT04gKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdXNlIFJhY3RpdmUuanMgaW4gYW4gb2xkZXIgYnJvd3Nlci4gWW91XFwnbGwgbmVlZCB0byB1c2Ugb25lIG9mIHRoZSBcXCdsZWdhY3kgYnVpbGRzXFwnIGluIG9yZGVyIHRvIGNvbnRpbnVlIC0gc2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L2xlZ2FjeS1idWlsZHMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gUmFjdGl2ZTtcblx0fSggb3B0aW9ucywgZWFzaW5nLCBpbnRlcnBvbGF0b3JzLCBzdmcsIG1hZ2ljLCBkZWZpbmVQcm9wZXJ0aWVzLCBwcm90b3R5cGUsIFByb21pc2UsIGV4dGVuZCwgUmFjdGl2ZV9leHRlbmQsIHBhcnNlLCBSYWN0aXZlX2luaXRpYWxpc2UsIGNpcmN1bGFyICk7XG5cblxuXHQvLyBleHBvcnQgYXMgQ29tbW9uIEpTIG1vZHVsZS4uLlxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBSYWN0aXZlO1xuXHR9XG5cblx0Ly8gLi4uIG9yIGFzIEFNRCBtb2R1bGVcblx0ZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRcdGRlZmluZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gUmFjdGl2ZTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyAuLi4gb3IgYXMgYnJvd3NlciBnbG9iYWxcblx0Z2xvYmFsLlJhY3RpdmUgPSBSYWN0aXZlO1xuXG5cdFJhY3RpdmUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGdsb2JhbC5SYWN0aXZlID0gbm9Db25mbGljdDtcblx0XHRyZXR1cm4gUmFjdGl2ZTtcblx0fTtcblxufSggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzICkgKTtcbiJdfQ==
